// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_device_pool_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateDevicePoolOutput, crate::error::CreateDevicePoolError>
{
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateDevicePoolError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateDevicePoolError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::CreateDevicePoolError {
            meta: generic,
            kind: crate::error::CreateDevicePoolErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateDevicePoolError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceededException" => crate::error::CreateDevicePoolError {
            meta: generic,
            kind: crate::error::CreateDevicePoolErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_limit_exceeded_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateDevicePoolError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotFoundException" => crate::error::CreateDevicePoolError {
            meta: generic,
            kind: crate::error::CreateDevicePoolErrorKind::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_found_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateDevicePoolError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceAccountException" => crate::error::CreateDevicePoolError {
            meta: generic,
            kind: crate::error::CreateDevicePoolErrorKind::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_service_account_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateDevicePoolError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateDevicePoolError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_device_pool_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateDevicePoolOutput, crate::error::CreateDevicePoolError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_device_pool_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_create_device_pool(response.body().as_ref(), output)
                .map_err(crate::error::CreateDevicePoolError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_instance_profile_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateInstanceProfileOutput,
    crate::error::CreateInstanceProfileError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateInstanceProfileError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateInstanceProfileError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::CreateInstanceProfileError {
            meta: generic,
            kind: crate::error::CreateInstanceProfileErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateInstanceProfileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceededException" => crate::error::CreateInstanceProfileError {
            meta: generic,
            kind: crate::error::CreateInstanceProfileErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_limit_exceeded_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateInstanceProfileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotFoundException" => crate::error::CreateInstanceProfileError {
            meta: generic,
            kind: crate::error::CreateInstanceProfileErrorKind::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_found_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateInstanceProfileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceAccountException" => crate::error::CreateInstanceProfileError {
            meta: generic,
            kind: crate::error::CreateInstanceProfileErrorKind::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_service_account_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateInstanceProfileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateInstanceProfileError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_instance_profile_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateInstanceProfileOutput,
    crate::error::CreateInstanceProfileError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_instance_profile_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_create_instance_profile(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateInstanceProfileError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_network_profile_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateNetworkProfileOutput,
    crate::error::CreateNetworkProfileError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateNetworkProfileError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateNetworkProfileError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::CreateNetworkProfileError {
            meta: generic,
            kind: crate::error::CreateNetworkProfileErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateNetworkProfileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceededException" => crate::error::CreateNetworkProfileError {
            meta: generic,
            kind: crate::error::CreateNetworkProfileErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_limit_exceeded_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateNetworkProfileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotFoundException" => crate::error::CreateNetworkProfileError {
            meta: generic,
            kind: crate::error::CreateNetworkProfileErrorKind::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_found_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateNetworkProfileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceAccountException" => crate::error::CreateNetworkProfileError {
            meta: generic,
            kind: crate::error::CreateNetworkProfileErrorKind::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_service_account_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateNetworkProfileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateNetworkProfileError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_network_profile_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateNetworkProfileOutput,
    crate::error::CreateNetworkProfileError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_network_profile_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_create_network_profile(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateNetworkProfileError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_project_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateProjectOutput, crate::error::CreateProjectError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateProjectError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateProjectError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::CreateProjectError {
            meta: generic,
            kind: crate::error::CreateProjectErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateProjectError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceededException" => crate::error::CreateProjectError {
            meta: generic,
            kind: crate::error::CreateProjectErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_limit_exceeded_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateProjectError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotFoundException" => crate::error::CreateProjectError {
            meta: generic,
            kind: crate::error::CreateProjectErrorKind::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_found_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateProjectError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceAccountException" => crate::error::CreateProjectError {
            meta: generic,
            kind: crate::error::CreateProjectErrorKind::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_service_account_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateProjectError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "TagOperationException" => crate::error::CreateProjectError {
            meta: generic,
            kind: crate::error::CreateProjectErrorKind::TagOperationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::tag_operation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_tag_operation_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateProjectError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateProjectError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_project_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateProjectOutput, crate::error::CreateProjectError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_project_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_create_project(response.body().as_ref(), output)
                .map_err(crate::error::CreateProjectError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_remote_access_session_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateRemoteAccessSessionOutput,
    crate::error::CreateRemoteAccessSessionError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateRemoteAccessSessionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateRemoteAccessSessionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::CreateRemoteAccessSessionError {
            meta: generic,
            kind: crate::error::CreateRemoteAccessSessionErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateRemoteAccessSessionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceededException" => crate::error::CreateRemoteAccessSessionError {
            meta: generic,
            kind: crate::error::CreateRemoteAccessSessionErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_limit_exceeded_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateRemoteAccessSessionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotFoundException" => crate::error::CreateRemoteAccessSessionError {
            meta: generic,
            kind: crate::error::CreateRemoteAccessSessionErrorKind::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_found_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateRemoteAccessSessionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceAccountException" => crate::error::CreateRemoteAccessSessionError {
            meta: generic,
            kind: crate::error::CreateRemoteAccessSessionErrorKind::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_service_account_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateRemoteAccessSessionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateRemoteAccessSessionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_remote_access_session_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateRemoteAccessSessionOutput,
    crate::error::CreateRemoteAccessSessionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_remote_access_session_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_create_remote_access_session(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateRemoteAccessSessionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_test_grid_project_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateTestGridProjectOutput,
    crate::error::CreateTestGridProjectError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateTestGridProjectError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateTestGridProjectError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::CreateTestGridProjectError {
            meta: generic,
            kind: crate::error::CreateTestGridProjectErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateTestGridProjectError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InternalServiceException" => crate::error::CreateTestGridProjectError {
            meta: generic,
            kind: crate::error::CreateTestGridProjectErrorKind::InternalServiceException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_internal_service_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateTestGridProjectError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceededException" => crate::error::CreateTestGridProjectError {
            meta: generic,
            kind: crate::error::CreateTestGridProjectErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_limit_exceeded_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateTestGridProjectError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateTestGridProjectError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_test_grid_project_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateTestGridProjectOutput,
    crate::error::CreateTestGridProjectError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_test_grid_project_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_create_test_grid_project(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateTestGridProjectError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_test_grid_url_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateTestGridUrlOutput, crate::error::CreateTestGridUrlError>
{
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateTestGridUrlError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateTestGridUrlError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::CreateTestGridUrlError {
            meta: generic,
            kind: crate::error::CreateTestGridUrlErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateTestGridUrlError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InternalServiceException" => crate::error::CreateTestGridUrlError {
            meta: generic,
            kind: crate::error::CreateTestGridUrlErrorKind::InternalServiceException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_internal_service_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateTestGridUrlError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotFoundException" => crate::error::CreateTestGridUrlError {
            meta: generic,
            kind: crate::error::CreateTestGridUrlErrorKind::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_found_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateTestGridUrlError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateTestGridUrlError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_test_grid_url_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateTestGridUrlOutput, crate::error::CreateTestGridUrlError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_test_grid_url_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_create_test_grid_url(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateTestGridUrlError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_upload_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateUploadOutput, crate::error::CreateUploadError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateUploadError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateUploadError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::CreateUploadError {
            meta: generic,
            kind: crate::error::CreateUploadErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateUploadError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceededException" => crate::error::CreateUploadError {
            meta: generic,
            kind: crate::error::CreateUploadErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_limit_exceeded_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateUploadError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotFoundException" => crate::error::CreateUploadError {
            meta: generic,
            kind: crate::error::CreateUploadErrorKind::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_found_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateUploadError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceAccountException" => crate::error::CreateUploadError {
            meta: generic,
            kind: crate::error::CreateUploadErrorKind::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_service_account_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateUploadError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateUploadError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_upload_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateUploadOutput, crate::error::CreateUploadError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_upload_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_create_upload(response.body().as_ref(), output)
            .map_err(crate::error::CreateUploadError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_vpce_configuration_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateVpceConfigurationOutput,
    crate::error::CreateVPCEConfigurationError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateVPCEConfigurationError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateVPCEConfigurationError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::CreateVPCEConfigurationError {
            meta: generic,
            kind: crate::error::CreateVPCEConfigurationErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateVPCEConfigurationError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceededException" => crate::error::CreateVPCEConfigurationError {
            meta: generic,
            kind: crate::error::CreateVPCEConfigurationErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_limit_exceeded_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateVPCEConfigurationError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceAccountException" => crate::error::CreateVPCEConfigurationError {
            meta: generic,
            kind: crate::error::CreateVPCEConfigurationErrorKind::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_service_account_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateVPCEConfigurationError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateVPCEConfigurationError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_vpce_configuration_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateVpceConfigurationOutput,
    crate::error::CreateVPCEConfigurationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_vpce_configuration_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_create_vpce_configuration(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateVPCEConfigurationError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_device_pool_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteDevicePoolOutput, crate::error::DeleteDevicePoolError>
{
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteDevicePoolError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteDevicePoolError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::DeleteDevicePoolError {
            meta: generic,
            kind: crate::error::DeleteDevicePoolErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteDevicePoolError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceededException" => crate::error::DeleteDevicePoolError {
            meta: generic,
            kind: crate::error::DeleteDevicePoolErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_limit_exceeded_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteDevicePoolError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotFoundException" => crate::error::DeleteDevicePoolError {
            meta: generic,
            kind: crate::error::DeleteDevicePoolErrorKind::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_found_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteDevicePoolError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceAccountException" => crate::error::DeleteDevicePoolError {
            meta: generic,
            kind: crate::error::DeleteDevicePoolErrorKind::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_service_account_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteDevicePoolError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteDevicePoolError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_device_pool_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteDevicePoolOutput, crate::error::DeleteDevicePoolError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_device_pool_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_instance_profile_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteInstanceProfileOutput,
    crate::error::DeleteInstanceProfileError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteInstanceProfileError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteInstanceProfileError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::DeleteInstanceProfileError {
            meta: generic,
            kind: crate::error::DeleteInstanceProfileErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteInstanceProfileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceededException" => crate::error::DeleteInstanceProfileError {
            meta: generic,
            kind: crate::error::DeleteInstanceProfileErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_limit_exceeded_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteInstanceProfileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotFoundException" => crate::error::DeleteInstanceProfileError {
            meta: generic,
            kind: crate::error::DeleteInstanceProfileErrorKind::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_found_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteInstanceProfileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceAccountException" => crate::error::DeleteInstanceProfileError {
            meta: generic,
            kind: crate::error::DeleteInstanceProfileErrorKind::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_service_account_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteInstanceProfileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteInstanceProfileError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_instance_profile_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteInstanceProfileOutput,
    crate::error::DeleteInstanceProfileError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_instance_profile_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_network_profile_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteNetworkProfileOutput,
    crate::error::DeleteNetworkProfileError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteNetworkProfileError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteNetworkProfileError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::DeleteNetworkProfileError {
            meta: generic,
            kind: crate::error::DeleteNetworkProfileErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteNetworkProfileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceededException" => crate::error::DeleteNetworkProfileError {
            meta: generic,
            kind: crate::error::DeleteNetworkProfileErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_limit_exceeded_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteNetworkProfileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotFoundException" => crate::error::DeleteNetworkProfileError {
            meta: generic,
            kind: crate::error::DeleteNetworkProfileErrorKind::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_found_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteNetworkProfileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceAccountException" => crate::error::DeleteNetworkProfileError {
            meta: generic,
            kind: crate::error::DeleteNetworkProfileErrorKind::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_service_account_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteNetworkProfileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteNetworkProfileError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_network_profile_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteNetworkProfileOutput,
    crate::error::DeleteNetworkProfileError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_network_profile_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_project_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteProjectOutput, crate::error::DeleteProjectError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteProjectError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteProjectError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::DeleteProjectError {
            meta: generic,
            kind: crate::error::DeleteProjectErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteProjectError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceededException" => crate::error::DeleteProjectError {
            meta: generic,
            kind: crate::error::DeleteProjectErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_limit_exceeded_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteProjectError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotFoundException" => crate::error::DeleteProjectError {
            meta: generic,
            kind: crate::error::DeleteProjectErrorKind::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_found_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteProjectError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceAccountException" => crate::error::DeleteProjectError {
            meta: generic,
            kind: crate::error::DeleteProjectErrorKind::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_service_account_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteProjectError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteProjectError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_project_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteProjectOutput, crate::error::DeleteProjectError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_project_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_remote_access_session_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteRemoteAccessSessionOutput,
    crate::error::DeleteRemoteAccessSessionError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteRemoteAccessSessionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteRemoteAccessSessionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::DeleteRemoteAccessSessionError {
            meta: generic,
            kind: crate::error::DeleteRemoteAccessSessionErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteRemoteAccessSessionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceededException" => crate::error::DeleteRemoteAccessSessionError {
            meta: generic,
            kind: crate::error::DeleteRemoteAccessSessionErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_limit_exceeded_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteRemoteAccessSessionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotFoundException" => crate::error::DeleteRemoteAccessSessionError {
            meta: generic,
            kind: crate::error::DeleteRemoteAccessSessionErrorKind::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_found_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteRemoteAccessSessionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceAccountException" => crate::error::DeleteRemoteAccessSessionError {
            meta: generic,
            kind: crate::error::DeleteRemoteAccessSessionErrorKind::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_service_account_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteRemoteAccessSessionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteRemoteAccessSessionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_remote_access_session_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteRemoteAccessSessionOutput,
    crate::error::DeleteRemoteAccessSessionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_remote_access_session_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_run_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteRunOutput, crate::error::DeleteRunError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteRunError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteRunError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::DeleteRunError {
            meta: generic,
            kind: crate::error::DeleteRunErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteRunError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceededException" => crate::error::DeleteRunError {
            meta: generic,
            kind: crate::error::DeleteRunErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_limit_exceeded_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteRunError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotFoundException" => crate::error::DeleteRunError {
            meta: generic,
            kind: crate::error::DeleteRunErrorKind::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_found_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteRunError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceAccountException" => crate::error::DeleteRunError {
            meta: generic,
            kind: crate::error::DeleteRunErrorKind::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_service_account_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteRunError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteRunError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_run_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteRunOutput, crate::error::DeleteRunError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_run_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_test_grid_project_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteTestGridProjectOutput,
    crate::error::DeleteTestGridProjectError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteTestGridProjectError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteTestGridProjectError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::DeleteTestGridProjectError {
            meta: generic,
            kind: crate::error::DeleteTestGridProjectErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteTestGridProjectError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "CannotDeleteException" => crate::error::DeleteTestGridProjectError {
            meta: generic,
            kind: crate::error::DeleteTestGridProjectErrorKind::CannotDeleteException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::cannot_delete_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_cannot_delete_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteTestGridProjectError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InternalServiceException" => crate::error::DeleteTestGridProjectError {
            meta: generic,
            kind: crate::error::DeleteTestGridProjectErrorKind::InternalServiceException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_internal_service_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteTestGridProjectError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotFoundException" => crate::error::DeleteTestGridProjectError {
            meta: generic,
            kind: crate::error::DeleteTestGridProjectErrorKind::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_found_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteTestGridProjectError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteTestGridProjectError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_test_grid_project_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteTestGridProjectOutput,
    crate::error::DeleteTestGridProjectError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_test_grid_project_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_upload_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteUploadOutput, crate::error::DeleteUploadError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteUploadError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteUploadError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::DeleteUploadError {
            meta: generic,
            kind: crate::error::DeleteUploadErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteUploadError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceededException" => crate::error::DeleteUploadError {
            meta: generic,
            kind: crate::error::DeleteUploadErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_limit_exceeded_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteUploadError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotFoundException" => crate::error::DeleteUploadError {
            meta: generic,
            kind: crate::error::DeleteUploadErrorKind::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_found_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteUploadError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceAccountException" => crate::error::DeleteUploadError {
            meta: generic,
            kind: crate::error::DeleteUploadErrorKind::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_service_account_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteUploadError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteUploadError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_upload_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteUploadOutput, crate::error::DeleteUploadError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_upload_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_vpce_configuration_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteVpceConfigurationOutput,
    crate::error::DeleteVPCEConfigurationError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteVPCEConfigurationError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteVPCEConfigurationError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::DeleteVPCEConfigurationError {
            meta: generic,
            kind: crate::error::DeleteVPCEConfigurationErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteVPCEConfigurationError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidOperationException" => crate::error::DeleteVPCEConfigurationError {
            meta: generic,
            kind: crate::error::DeleteVPCEConfigurationErrorKind::InvalidOperationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_operation_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_invalid_operation_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::DeleteVPCEConfigurationError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotFoundException" => crate::error::DeleteVPCEConfigurationError {
            meta: generic,
            kind: crate::error::DeleteVPCEConfigurationErrorKind::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_found_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteVPCEConfigurationError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceAccountException" => crate::error::DeleteVPCEConfigurationError {
            meta: generic,
            kind: crate::error::DeleteVPCEConfigurationErrorKind::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_service_account_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteVPCEConfigurationError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteVPCEConfigurationError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_vpce_configuration_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteVpceConfigurationOutput,
    crate::error::DeleteVPCEConfigurationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_vpce_configuration_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_account_settings_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetAccountSettingsOutput,
    crate::error::GetAccountSettingsError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetAccountSettingsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetAccountSettingsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::GetAccountSettingsError {
            meta: generic,
            kind: crate::error::GetAccountSettingsErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetAccountSettingsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceededException" => crate::error::GetAccountSettingsError {
            meta: generic,
            kind: crate::error::GetAccountSettingsErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_limit_exceeded_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetAccountSettingsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotFoundException" => crate::error::GetAccountSettingsError {
            meta: generic,
            kind: crate::error::GetAccountSettingsErrorKind::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_found_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetAccountSettingsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceAccountException" => crate::error::GetAccountSettingsError {
            meta: generic,
            kind: crate::error::GetAccountSettingsErrorKind::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_service_account_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetAccountSettingsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetAccountSettingsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_account_settings_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetAccountSettingsOutput,
    crate::error::GetAccountSettingsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_account_settings_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_get_account_settings(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetAccountSettingsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_device_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetDeviceOutput, crate::error::GetDeviceError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetDeviceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetDeviceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::GetDeviceError {
            meta: generic,
            kind: crate::error::GetDeviceErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetDeviceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceededException" => crate::error::GetDeviceError {
            meta: generic,
            kind: crate::error::GetDeviceErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_limit_exceeded_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetDeviceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotFoundException" => crate::error::GetDeviceError {
            meta: generic,
            kind: crate::error::GetDeviceErrorKind::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_found_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetDeviceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceAccountException" => crate::error::GetDeviceError {
            meta: generic,
            kind: crate::error::GetDeviceErrorKind::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_service_account_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetDeviceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetDeviceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_device_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetDeviceOutput, crate::error::GetDeviceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_device_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_get_device(response.body().as_ref(), output)
            .map_err(crate::error::GetDeviceError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_device_instance_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetDeviceInstanceOutput, crate::error::GetDeviceInstanceError>
{
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetDeviceInstanceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetDeviceInstanceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::GetDeviceInstanceError {
            meta: generic,
            kind: crate::error::GetDeviceInstanceErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetDeviceInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceededException" => crate::error::GetDeviceInstanceError {
            meta: generic,
            kind: crate::error::GetDeviceInstanceErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_limit_exceeded_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetDeviceInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotFoundException" => crate::error::GetDeviceInstanceError {
            meta: generic,
            kind: crate::error::GetDeviceInstanceErrorKind::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_found_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetDeviceInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceAccountException" => crate::error::GetDeviceInstanceError {
            meta: generic,
            kind: crate::error::GetDeviceInstanceErrorKind::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_service_account_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetDeviceInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetDeviceInstanceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_device_instance_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetDeviceInstanceOutput, crate::error::GetDeviceInstanceError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_device_instance_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_get_device_instance(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetDeviceInstanceError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_device_pool_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetDevicePoolOutput, crate::error::GetDevicePoolError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetDevicePoolError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetDevicePoolError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::GetDevicePoolError {
            meta: generic,
            kind: crate::error::GetDevicePoolErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetDevicePoolError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceededException" => crate::error::GetDevicePoolError {
            meta: generic,
            kind: crate::error::GetDevicePoolErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_limit_exceeded_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetDevicePoolError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotFoundException" => crate::error::GetDevicePoolError {
            meta: generic,
            kind: crate::error::GetDevicePoolErrorKind::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_found_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetDevicePoolError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceAccountException" => crate::error::GetDevicePoolError {
            meta: generic,
            kind: crate::error::GetDevicePoolErrorKind::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_service_account_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetDevicePoolError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetDevicePoolError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_device_pool_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetDevicePoolOutput, crate::error::GetDevicePoolError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_device_pool_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_get_device_pool(response.body().as_ref(), output)
                .map_err(crate::error::GetDevicePoolError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_device_pool_compatibility_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetDevicePoolCompatibilityOutput,
    crate::error::GetDevicePoolCompatibilityError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetDevicePoolCompatibilityError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetDevicePoolCompatibilityError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::GetDevicePoolCompatibilityError {
            meta: generic,
            kind: crate::error::GetDevicePoolCompatibilityErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetDevicePoolCompatibilityError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceededException" => crate::error::GetDevicePoolCompatibilityError {
            meta: generic,
            kind: crate::error::GetDevicePoolCompatibilityErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_limit_exceeded_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetDevicePoolCompatibilityError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotFoundException" => crate::error::GetDevicePoolCompatibilityError {
            meta: generic,
            kind: crate::error::GetDevicePoolCompatibilityErrorKind::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_found_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetDevicePoolCompatibilityError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceAccountException" => crate::error::GetDevicePoolCompatibilityError {
            meta: generic,
            kind: crate::error::GetDevicePoolCompatibilityErrorKind::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_service_account_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetDevicePoolCompatibilityError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetDevicePoolCompatibilityError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_device_pool_compatibility_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetDevicePoolCompatibilityOutput,
    crate::error::GetDevicePoolCompatibilityError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_device_pool_compatibility_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_get_device_pool_compatibility(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetDevicePoolCompatibilityError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_instance_profile_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetInstanceProfileOutput,
    crate::error::GetInstanceProfileError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetInstanceProfileError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetInstanceProfileError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::GetInstanceProfileError {
            meta: generic,
            kind: crate::error::GetInstanceProfileErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetInstanceProfileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceededException" => crate::error::GetInstanceProfileError {
            meta: generic,
            kind: crate::error::GetInstanceProfileErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_limit_exceeded_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetInstanceProfileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotFoundException" => crate::error::GetInstanceProfileError {
            meta: generic,
            kind: crate::error::GetInstanceProfileErrorKind::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_found_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetInstanceProfileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceAccountException" => crate::error::GetInstanceProfileError {
            meta: generic,
            kind: crate::error::GetInstanceProfileErrorKind::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_service_account_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetInstanceProfileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetInstanceProfileError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_instance_profile_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetInstanceProfileOutput,
    crate::error::GetInstanceProfileError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_instance_profile_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_get_instance_profile(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetInstanceProfileError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_job_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetJobOutput, crate::error::GetJobError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetJobError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetJobError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::GetJobError {
            meta: generic,
            kind: crate::error::GetJobErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetJobError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceededException" => crate::error::GetJobError {
            meta: generic,
            kind: crate::error::GetJobErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_limit_exceeded_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetJobError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotFoundException" => crate::error::GetJobError {
            meta: generic,
            kind: crate::error::GetJobErrorKind::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_found_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetJobError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceAccountException" => crate::error::GetJobError {
            meta: generic,
            kind: crate::error::GetJobErrorKind::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_service_account_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetJobError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetJobError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_job_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetJobOutput, crate::error::GetJobError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_job_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_get_job(response.body().as_ref(), output)
            .map_err(crate::error::GetJobError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_network_profile_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetNetworkProfileOutput, crate::error::GetNetworkProfileError>
{
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetNetworkProfileError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetNetworkProfileError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::GetNetworkProfileError {
            meta: generic,
            kind: crate::error::GetNetworkProfileErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetNetworkProfileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceededException" => crate::error::GetNetworkProfileError {
            meta: generic,
            kind: crate::error::GetNetworkProfileErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_limit_exceeded_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetNetworkProfileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotFoundException" => crate::error::GetNetworkProfileError {
            meta: generic,
            kind: crate::error::GetNetworkProfileErrorKind::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_found_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetNetworkProfileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceAccountException" => crate::error::GetNetworkProfileError {
            meta: generic,
            kind: crate::error::GetNetworkProfileErrorKind::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_service_account_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetNetworkProfileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetNetworkProfileError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_network_profile_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetNetworkProfileOutput, crate::error::GetNetworkProfileError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_network_profile_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_get_network_profile(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetNetworkProfileError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_offering_status_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetOfferingStatusOutput, crate::error::GetOfferingStatusError>
{
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetOfferingStatusError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetOfferingStatusError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::GetOfferingStatusError {
            meta: generic,
            kind: crate::error::GetOfferingStatusErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetOfferingStatusError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceededException" => crate::error::GetOfferingStatusError {
            meta: generic,
            kind: crate::error::GetOfferingStatusErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_limit_exceeded_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetOfferingStatusError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotEligibleException" => crate::error::GetOfferingStatusError {
            meta: generic,
            kind: crate::error::GetOfferingStatusErrorKind::NotEligibleException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_eligible_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_eligible_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetOfferingStatusError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotFoundException" => crate::error::GetOfferingStatusError {
            meta: generic,
            kind: crate::error::GetOfferingStatusErrorKind::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_found_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetOfferingStatusError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceAccountException" => crate::error::GetOfferingStatusError {
            meta: generic,
            kind: crate::error::GetOfferingStatusErrorKind::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_service_account_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetOfferingStatusError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetOfferingStatusError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_offering_status_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetOfferingStatusOutput, crate::error::GetOfferingStatusError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_offering_status_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_get_offering_status(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetOfferingStatusError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_project_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetProjectOutput, crate::error::GetProjectError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetProjectError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetProjectError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::GetProjectError {
            meta: generic,
            kind: crate::error::GetProjectErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetProjectError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceededException" => crate::error::GetProjectError {
            meta: generic,
            kind: crate::error::GetProjectErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_limit_exceeded_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetProjectError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotFoundException" => crate::error::GetProjectError {
            meta: generic,
            kind: crate::error::GetProjectErrorKind::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_found_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetProjectError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceAccountException" => crate::error::GetProjectError {
            meta: generic,
            kind: crate::error::GetProjectErrorKind::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_service_account_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetProjectError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetProjectError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_project_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetProjectOutput, crate::error::GetProjectError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_project_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_get_project(response.body().as_ref(), output)
            .map_err(crate::error::GetProjectError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_remote_access_session_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetRemoteAccessSessionOutput,
    crate::error::GetRemoteAccessSessionError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetRemoteAccessSessionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetRemoteAccessSessionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::GetRemoteAccessSessionError {
            meta: generic,
            kind: crate::error::GetRemoteAccessSessionErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetRemoteAccessSessionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceededException" => crate::error::GetRemoteAccessSessionError {
            meta: generic,
            kind: crate::error::GetRemoteAccessSessionErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_limit_exceeded_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetRemoteAccessSessionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotFoundException" => crate::error::GetRemoteAccessSessionError {
            meta: generic,
            kind: crate::error::GetRemoteAccessSessionErrorKind::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_found_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetRemoteAccessSessionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceAccountException" => crate::error::GetRemoteAccessSessionError {
            meta: generic,
            kind: crate::error::GetRemoteAccessSessionErrorKind::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_service_account_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetRemoteAccessSessionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetRemoteAccessSessionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_remote_access_session_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetRemoteAccessSessionOutput,
    crate::error::GetRemoteAccessSessionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_remote_access_session_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_get_remote_access_session(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetRemoteAccessSessionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_run_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetRunOutput, crate::error::GetRunError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetRunError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetRunError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::GetRunError {
            meta: generic,
            kind: crate::error::GetRunErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetRunError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceededException" => crate::error::GetRunError {
            meta: generic,
            kind: crate::error::GetRunErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_limit_exceeded_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetRunError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotFoundException" => crate::error::GetRunError {
            meta: generic,
            kind: crate::error::GetRunErrorKind::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_found_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetRunError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceAccountException" => crate::error::GetRunError {
            meta: generic,
            kind: crate::error::GetRunErrorKind::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_service_account_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetRunError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetRunError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_run_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetRunOutput, crate::error::GetRunError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_run_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_get_run(response.body().as_ref(), output)
            .map_err(crate::error::GetRunError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_suite_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetSuiteOutput, crate::error::GetSuiteError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetSuiteError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetSuiteError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::GetSuiteError {
            meta: generic,
            kind: crate::error::GetSuiteErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetSuiteError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceededException" => crate::error::GetSuiteError {
            meta: generic,
            kind: crate::error::GetSuiteErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_limit_exceeded_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetSuiteError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotFoundException" => crate::error::GetSuiteError {
            meta: generic,
            kind: crate::error::GetSuiteErrorKind::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_found_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetSuiteError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceAccountException" => crate::error::GetSuiteError {
            meta: generic,
            kind: crate::error::GetSuiteErrorKind::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_service_account_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetSuiteError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetSuiteError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_suite_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetSuiteOutput, crate::error::GetSuiteError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_suite_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_get_suite(response.body().as_ref(), output)
            .map_err(crate::error::GetSuiteError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_test_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetTestOutput, crate::error::GetTestError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetTestError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetTestError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::GetTestError {
            meta: generic,
            kind: crate::error::GetTestErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetTestError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceededException" => crate::error::GetTestError {
            meta: generic,
            kind: crate::error::GetTestErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_limit_exceeded_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetTestError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotFoundException" => crate::error::GetTestError {
            meta: generic,
            kind: crate::error::GetTestErrorKind::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_found_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetTestError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceAccountException" => crate::error::GetTestError {
            meta: generic,
            kind: crate::error::GetTestErrorKind::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_service_account_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetTestError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetTestError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_test_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetTestOutput, crate::error::GetTestError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_test_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_get_test(response.body().as_ref(), output)
            .map_err(crate::error::GetTestError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_test_grid_project_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetTestGridProjectOutput,
    crate::error::GetTestGridProjectError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetTestGridProjectError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetTestGridProjectError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::GetTestGridProjectError {
            meta: generic,
            kind: crate::error::GetTestGridProjectErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetTestGridProjectError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InternalServiceException" => crate::error::GetTestGridProjectError {
            meta: generic,
            kind: crate::error::GetTestGridProjectErrorKind::InternalServiceException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_internal_service_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetTestGridProjectError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotFoundException" => crate::error::GetTestGridProjectError {
            meta: generic,
            kind: crate::error::GetTestGridProjectErrorKind::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_found_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetTestGridProjectError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetTestGridProjectError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_test_grid_project_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetTestGridProjectOutput,
    crate::error::GetTestGridProjectError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_test_grid_project_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_get_test_grid_project(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetTestGridProjectError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_test_grid_session_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetTestGridSessionOutput,
    crate::error::GetTestGridSessionError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetTestGridSessionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetTestGridSessionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::GetTestGridSessionError {
            meta: generic,
            kind: crate::error::GetTestGridSessionErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetTestGridSessionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InternalServiceException" => crate::error::GetTestGridSessionError {
            meta: generic,
            kind: crate::error::GetTestGridSessionErrorKind::InternalServiceException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_internal_service_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetTestGridSessionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotFoundException" => crate::error::GetTestGridSessionError {
            meta: generic,
            kind: crate::error::GetTestGridSessionErrorKind::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_found_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetTestGridSessionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetTestGridSessionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_test_grid_session_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetTestGridSessionOutput,
    crate::error::GetTestGridSessionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_test_grid_session_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_get_test_grid_session(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetTestGridSessionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_upload_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetUploadOutput, crate::error::GetUploadError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetUploadError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetUploadError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::GetUploadError {
            meta: generic,
            kind: crate::error::GetUploadErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetUploadError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceededException" => crate::error::GetUploadError {
            meta: generic,
            kind: crate::error::GetUploadErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_limit_exceeded_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetUploadError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotFoundException" => crate::error::GetUploadError {
            meta: generic,
            kind: crate::error::GetUploadErrorKind::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_found_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetUploadError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceAccountException" => crate::error::GetUploadError {
            meta: generic,
            kind: crate::error::GetUploadErrorKind::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_service_account_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetUploadError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetUploadError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_upload_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetUploadOutput, crate::error::GetUploadError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_upload_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_get_upload(response.body().as_ref(), output)
            .map_err(crate::error::GetUploadError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_vpce_configuration_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetVpceConfigurationOutput,
    crate::error::GetVPCEConfigurationError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetVPCEConfigurationError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetVPCEConfigurationError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::GetVPCEConfigurationError {
            meta: generic,
            kind: crate::error::GetVPCEConfigurationErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetVPCEConfigurationError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotFoundException" => crate::error::GetVPCEConfigurationError {
            meta: generic,
            kind: crate::error::GetVPCEConfigurationErrorKind::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_found_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetVPCEConfigurationError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceAccountException" => crate::error::GetVPCEConfigurationError {
            meta: generic,
            kind: crate::error::GetVPCEConfigurationErrorKind::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_service_account_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetVPCEConfigurationError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetVPCEConfigurationError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_vpce_configuration_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetVpceConfigurationOutput,
    crate::error::GetVPCEConfigurationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_vpce_configuration_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_get_vpce_configuration(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetVPCEConfigurationError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_install_to_remote_access_session_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::InstallToRemoteAccessSessionOutput,
    crate::error::InstallToRemoteAccessSessionError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::InstallToRemoteAccessSessionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::InstallToRemoteAccessSessionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::InstallToRemoteAccessSessionError {
            meta: generic,
            kind: crate::error::InstallToRemoteAccessSessionErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::InstallToRemoteAccessSessionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceededException" => crate::error::InstallToRemoteAccessSessionError {
            meta: generic,
            kind: crate::error::InstallToRemoteAccessSessionErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_limit_exceeded_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::InstallToRemoteAccessSessionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotFoundException" => crate::error::InstallToRemoteAccessSessionError {
            meta: generic,
            kind: crate::error::InstallToRemoteAccessSessionErrorKind::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_found_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::InstallToRemoteAccessSessionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceAccountException" => crate::error::InstallToRemoteAccessSessionError {
            meta: generic,
            kind: crate::error::InstallToRemoteAccessSessionErrorKind::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_service_account_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::InstallToRemoteAccessSessionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::InstallToRemoteAccessSessionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_install_to_remote_access_session_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::InstallToRemoteAccessSessionOutput,
    crate::error::InstallToRemoteAccessSessionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::install_to_remote_access_session_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_install_to_remote_access_session(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::InstallToRemoteAccessSessionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_artifacts_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListArtifactsOutput, crate::error::ListArtifactsError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListArtifactsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListArtifactsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::ListArtifactsError {
            meta: generic,
            kind: crate::error::ListArtifactsErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListArtifactsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceededException" => crate::error::ListArtifactsError {
            meta: generic,
            kind: crate::error::ListArtifactsErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_limit_exceeded_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListArtifactsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotFoundException" => crate::error::ListArtifactsError {
            meta: generic,
            kind: crate::error::ListArtifactsErrorKind::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_found_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListArtifactsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceAccountException" => crate::error::ListArtifactsError {
            meta: generic,
            kind: crate::error::ListArtifactsErrorKind::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_service_account_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListArtifactsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListArtifactsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_artifacts_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListArtifactsOutput, crate::error::ListArtifactsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_artifacts_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_list_artifacts(response.body().as_ref(), output)
                .map_err(crate::error::ListArtifactsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_device_instances_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListDeviceInstancesOutput,
    crate::error::ListDeviceInstancesError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListDeviceInstancesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListDeviceInstancesError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::ListDeviceInstancesError {
            meta: generic,
            kind: crate::error::ListDeviceInstancesErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListDeviceInstancesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceededException" => crate::error::ListDeviceInstancesError {
            meta: generic,
            kind: crate::error::ListDeviceInstancesErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_limit_exceeded_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListDeviceInstancesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotFoundException" => crate::error::ListDeviceInstancesError {
            meta: generic,
            kind: crate::error::ListDeviceInstancesErrorKind::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_found_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListDeviceInstancesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceAccountException" => crate::error::ListDeviceInstancesError {
            meta: generic,
            kind: crate::error::ListDeviceInstancesErrorKind::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_service_account_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListDeviceInstancesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListDeviceInstancesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_device_instances_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListDeviceInstancesOutput,
    crate::error::ListDeviceInstancesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_device_instances_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_list_device_instances(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListDeviceInstancesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_device_pools_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListDevicePoolsOutput, crate::error::ListDevicePoolsError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListDevicePoolsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListDevicePoolsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::ListDevicePoolsError {
            meta: generic,
            kind: crate::error::ListDevicePoolsErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListDevicePoolsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceededException" => crate::error::ListDevicePoolsError {
            meta: generic,
            kind: crate::error::ListDevicePoolsErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_limit_exceeded_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListDevicePoolsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotFoundException" => crate::error::ListDevicePoolsError {
            meta: generic,
            kind: crate::error::ListDevicePoolsErrorKind::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_found_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListDevicePoolsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceAccountException" => crate::error::ListDevicePoolsError {
            meta: generic,
            kind: crate::error::ListDevicePoolsErrorKind::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_service_account_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListDevicePoolsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListDevicePoolsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_device_pools_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListDevicePoolsOutput, crate::error::ListDevicePoolsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_device_pools_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_list_device_pools(response.body().as_ref(), output)
                .map_err(crate::error::ListDevicePoolsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_devices_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListDevicesOutput, crate::error::ListDevicesError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListDevicesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListDevicesError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::ListDevicesError {
            meta: generic,
            kind: crate::error::ListDevicesErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListDevicesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceededException" => crate::error::ListDevicesError {
            meta: generic,
            kind: crate::error::ListDevicesErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_limit_exceeded_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListDevicesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotFoundException" => crate::error::ListDevicesError {
            meta: generic,
            kind: crate::error::ListDevicesErrorKind::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_found_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListDevicesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceAccountException" => crate::error::ListDevicesError {
            meta: generic,
            kind: crate::error::ListDevicesErrorKind::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_service_account_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListDevicesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListDevicesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_devices_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListDevicesOutput, crate::error::ListDevicesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_devices_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_list_devices(response.body().as_ref(), output)
            .map_err(crate::error::ListDevicesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_instance_profiles_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListInstanceProfilesOutput,
    crate::error::ListInstanceProfilesError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListInstanceProfilesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListInstanceProfilesError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::ListInstanceProfilesError {
            meta: generic,
            kind: crate::error::ListInstanceProfilesErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListInstanceProfilesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceededException" => crate::error::ListInstanceProfilesError {
            meta: generic,
            kind: crate::error::ListInstanceProfilesErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_limit_exceeded_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListInstanceProfilesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotFoundException" => crate::error::ListInstanceProfilesError {
            meta: generic,
            kind: crate::error::ListInstanceProfilesErrorKind::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_found_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListInstanceProfilesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceAccountException" => crate::error::ListInstanceProfilesError {
            meta: generic,
            kind: crate::error::ListInstanceProfilesErrorKind::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_service_account_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListInstanceProfilesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListInstanceProfilesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_instance_profiles_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListInstanceProfilesOutput,
    crate::error::ListInstanceProfilesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_instance_profiles_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_list_instance_profiles(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListInstanceProfilesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_jobs_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListJobsOutput, crate::error::ListJobsError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListJobsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListJobsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::ListJobsError {
            meta: generic,
            kind: crate::error::ListJobsErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListJobsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceededException" => crate::error::ListJobsError {
            meta: generic,
            kind: crate::error::ListJobsErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_limit_exceeded_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListJobsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotFoundException" => crate::error::ListJobsError {
            meta: generic,
            kind: crate::error::ListJobsErrorKind::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_found_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListJobsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceAccountException" => crate::error::ListJobsError {
            meta: generic,
            kind: crate::error::ListJobsErrorKind::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_service_account_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListJobsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListJobsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_jobs_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListJobsOutput, crate::error::ListJobsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_jobs_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_list_jobs(response.body().as_ref(), output)
            .map_err(crate::error::ListJobsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_network_profiles_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListNetworkProfilesOutput,
    crate::error::ListNetworkProfilesError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListNetworkProfilesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListNetworkProfilesError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::ListNetworkProfilesError {
            meta: generic,
            kind: crate::error::ListNetworkProfilesErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListNetworkProfilesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceededException" => crate::error::ListNetworkProfilesError {
            meta: generic,
            kind: crate::error::ListNetworkProfilesErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_limit_exceeded_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListNetworkProfilesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotFoundException" => crate::error::ListNetworkProfilesError {
            meta: generic,
            kind: crate::error::ListNetworkProfilesErrorKind::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_found_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListNetworkProfilesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceAccountException" => crate::error::ListNetworkProfilesError {
            meta: generic,
            kind: crate::error::ListNetworkProfilesErrorKind::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_service_account_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListNetworkProfilesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListNetworkProfilesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_network_profiles_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListNetworkProfilesOutput,
    crate::error::ListNetworkProfilesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_network_profiles_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_list_network_profiles(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListNetworkProfilesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_offering_promotions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListOfferingPromotionsOutput,
    crate::error::ListOfferingPromotionsError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListOfferingPromotionsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListOfferingPromotionsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::ListOfferingPromotionsError {
            meta: generic,
            kind: crate::error::ListOfferingPromotionsErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListOfferingPromotionsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceededException" => crate::error::ListOfferingPromotionsError {
            meta: generic,
            kind: crate::error::ListOfferingPromotionsErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_limit_exceeded_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListOfferingPromotionsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotEligibleException" => crate::error::ListOfferingPromotionsError {
            meta: generic,
            kind: crate::error::ListOfferingPromotionsErrorKind::NotEligibleException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_eligible_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_eligible_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListOfferingPromotionsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotFoundException" => crate::error::ListOfferingPromotionsError {
            meta: generic,
            kind: crate::error::ListOfferingPromotionsErrorKind::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_found_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListOfferingPromotionsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceAccountException" => crate::error::ListOfferingPromotionsError {
            meta: generic,
            kind: crate::error::ListOfferingPromotionsErrorKind::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_service_account_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListOfferingPromotionsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListOfferingPromotionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_offering_promotions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListOfferingPromotionsOutput,
    crate::error::ListOfferingPromotionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_offering_promotions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_list_offering_promotions(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListOfferingPromotionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_offerings_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListOfferingsOutput, crate::error::ListOfferingsError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListOfferingsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListOfferingsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::ListOfferingsError {
            meta: generic,
            kind: crate::error::ListOfferingsErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListOfferingsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceededException" => crate::error::ListOfferingsError {
            meta: generic,
            kind: crate::error::ListOfferingsErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_limit_exceeded_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListOfferingsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotEligibleException" => crate::error::ListOfferingsError {
            meta: generic,
            kind: crate::error::ListOfferingsErrorKind::NotEligibleException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_eligible_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_eligible_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListOfferingsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotFoundException" => crate::error::ListOfferingsError {
            meta: generic,
            kind: crate::error::ListOfferingsErrorKind::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_found_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListOfferingsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceAccountException" => crate::error::ListOfferingsError {
            meta: generic,
            kind: crate::error::ListOfferingsErrorKind::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_service_account_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListOfferingsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListOfferingsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_offerings_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListOfferingsOutput, crate::error::ListOfferingsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_offerings_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_list_offerings(response.body().as_ref(), output)
                .map_err(crate::error::ListOfferingsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_offering_transactions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListOfferingTransactionsOutput,
    crate::error::ListOfferingTransactionsError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListOfferingTransactionsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListOfferingTransactionsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::ListOfferingTransactionsError {
            meta: generic,
            kind: crate::error::ListOfferingTransactionsErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListOfferingTransactionsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceededException" => crate::error::ListOfferingTransactionsError {
            meta: generic,
            kind: crate::error::ListOfferingTransactionsErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_limit_exceeded_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListOfferingTransactionsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotEligibleException" => crate::error::ListOfferingTransactionsError {
            meta: generic,
            kind: crate::error::ListOfferingTransactionsErrorKind::NotEligibleException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_eligible_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_eligible_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListOfferingTransactionsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotFoundException" => crate::error::ListOfferingTransactionsError {
            meta: generic,
            kind: crate::error::ListOfferingTransactionsErrorKind::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_found_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListOfferingTransactionsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceAccountException" => crate::error::ListOfferingTransactionsError {
            meta: generic,
            kind: crate::error::ListOfferingTransactionsErrorKind::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_service_account_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListOfferingTransactionsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListOfferingTransactionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_offering_transactions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListOfferingTransactionsOutput,
    crate::error::ListOfferingTransactionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_offering_transactions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_list_offering_transactions(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListOfferingTransactionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_projects_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListProjectsOutput, crate::error::ListProjectsError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListProjectsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListProjectsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::ListProjectsError {
            meta: generic,
            kind: crate::error::ListProjectsErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListProjectsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceededException" => crate::error::ListProjectsError {
            meta: generic,
            kind: crate::error::ListProjectsErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_limit_exceeded_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListProjectsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotFoundException" => crate::error::ListProjectsError {
            meta: generic,
            kind: crate::error::ListProjectsErrorKind::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_found_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListProjectsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceAccountException" => crate::error::ListProjectsError {
            meta: generic,
            kind: crate::error::ListProjectsErrorKind::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_service_account_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListProjectsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListProjectsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_projects_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListProjectsOutput, crate::error::ListProjectsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_projects_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_list_projects(response.body().as_ref(), output)
            .map_err(crate::error::ListProjectsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_remote_access_sessions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListRemoteAccessSessionsOutput,
    crate::error::ListRemoteAccessSessionsError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListRemoteAccessSessionsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListRemoteAccessSessionsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::ListRemoteAccessSessionsError {
            meta: generic,
            kind: crate::error::ListRemoteAccessSessionsErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListRemoteAccessSessionsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceededException" => crate::error::ListRemoteAccessSessionsError {
            meta: generic,
            kind: crate::error::ListRemoteAccessSessionsErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_limit_exceeded_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListRemoteAccessSessionsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotFoundException" => crate::error::ListRemoteAccessSessionsError {
            meta: generic,
            kind: crate::error::ListRemoteAccessSessionsErrorKind::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_found_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListRemoteAccessSessionsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceAccountException" => crate::error::ListRemoteAccessSessionsError {
            meta: generic,
            kind: crate::error::ListRemoteAccessSessionsErrorKind::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_service_account_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListRemoteAccessSessionsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListRemoteAccessSessionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_remote_access_sessions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListRemoteAccessSessionsOutput,
    crate::error::ListRemoteAccessSessionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_remote_access_sessions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_list_remote_access_sessions(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListRemoteAccessSessionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_runs_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListRunsOutput, crate::error::ListRunsError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListRunsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListRunsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::ListRunsError {
            meta: generic,
            kind: crate::error::ListRunsErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListRunsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceededException" => crate::error::ListRunsError {
            meta: generic,
            kind: crate::error::ListRunsErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_limit_exceeded_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListRunsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotFoundException" => crate::error::ListRunsError {
            meta: generic,
            kind: crate::error::ListRunsErrorKind::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_found_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListRunsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceAccountException" => crate::error::ListRunsError {
            meta: generic,
            kind: crate::error::ListRunsErrorKind::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_service_account_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListRunsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListRunsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_runs_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListRunsOutput, crate::error::ListRunsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_runs_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_list_runs(response.body().as_ref(), output)
            .map_err(crate::error::ListRunsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_samples_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListSamplesOutput, crate::error::ListSamplesError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListSamplesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListSamplesError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::ListSamplesError {
            meta: generic,
            kind: crate::error::ListSamplesErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListSamplesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceededException" => crate::error::ListSamplesError {
            meta: generic,
            kind: crate::error::ListSamplesErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_limit_exceeded_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListSamplesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotFoundException" => crate::error::ListSamplesError {
            meta: generic,
            kind: crate::error::ListSamplesErrorKind::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_found_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListSamplesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceAccountException" => crate::error::ListSamplesError {
            meta: generic,
            kind: crate::error::ListSamplesErrorKind::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_service_account_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListSamplesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListSamplesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_samples_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListSamplesOutput, crate::error::ListSamplesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_samples_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_list_samples(response.body().as_ref(), output)
            .map_err(crate::error::ListSamplesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_suites_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListSuitesOutput, crate::error::ListSuitesError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListSuitesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListSuitesError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::ListSuitesError {
            meta: generic,
            kind: crate::error::ListSuitesErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListSuitesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceededException" => crate::error::ListSuitesError {
            meta: generic,
            kind: crate::error::ListSuitesErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_limit_exceeded_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListSuitesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotFoundException" => crate::error::ListSuitesError {
            meta: generic,
            kind: crate::error::ListSuitesErrorKind::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_found_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListSuitesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceAccountException" => crate::error::ListSuitesError {
            meta: generic,
            kind: crate::error::ListSuitesErrorKind::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_service_account_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListSuitesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListSuitesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_suites_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListSuitesOutput, crate::error::ListSuitesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_suites_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_list_suites(response.body().as_ref(), output)
            .map_err(crate::error::ListSuitesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_tags_for_resource_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListTagsForResourceOutput,
    crate::error::ListTagsForResourceError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListTagsForResourceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListTagsForResourceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::ListTagsForResourceError {
            meta: generic,
            kind: crate::error::ListTagsForResourceErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListTagsForResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotFoundException" => crate::error::ListTagsForResourceError {
            meta: generic,
            kind: crate::error::ListTagsForResourceErrorKind::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_found_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListTagsForResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "TagOperationException" => crate::error::ListTagsForResourceError {
            meta: generic,
            kind: crate::error::ListTagsForResourceErrorKind::TagOperationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::tag_operation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_tag_operation_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListTagsForResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListTagsForResourceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_tags_for_resource_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListTagsForResourceOutput,
    crate::error::ListTagsForResourceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_tags_for_resource_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_list_tags_for_resource(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListTagsForResourceError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_test_grid_projects_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListTestGridProjectsOutput,
    crate::error::ListTestGridProjectsError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListTestGridProjectsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListTestGridProjectsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::ListTestGridProjectsError {
            meta: generic,
            kind: crate::error::ListTestGridProjectsErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListTestGridProjectsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InternalServiceException" => crate::error::ListTestGridProjectsError {
            meta: generic,
            kind: crate::error::ListTestGridProjectsErrorKind::InternalServiceException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_internal_service_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListTestGridProjectsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListTestGridProjectsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_test_grid_projects_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListTestGridProjectsOutput,
    crate::error::ListTestGridProjectsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_test_grid_projects_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_list_test_grid_projects(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListTestGridProjectsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_test_grid_session_actions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListTestGridSessionActionsOutput,
    crate::error::ListTestGridSessionActionsError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListTestGridSessionActionsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListTestGridSessionActionsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::ListTestGridSessionActionsError {
            meta: generic,
            kind: crate::error::ListTestGridSessionActionsErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListTestGridSessionActionsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InternalServiceException" => crate::error::ListTestGridSessionActionsError {
            meta: generic,
            kind: crate::error::ListTestGridSessionActionsErrorKind::InternalServiceException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_internal_service_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListTestGridSessionActionsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotFoundException" => crate::error::ListTestGridSessionActionsError {
            meta: generic,
            kind: crate::error::ListTestGridSessionActionsErrorKind::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_found_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListTestGridSessionActionsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListTestGridSessionActionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_test_grid_session_actions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListTestGridSessionActionsOutput,
    crate::error::ListTestGridSessionActionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_test_grid_session_actions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_list_test_grid_session_actions(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListTestGridSessionActionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_test_grid_session_artifacts_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListTestGridSessionArtifactsOutput,
    crate::error::ListTestGridSessionArtifactsError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListTestGridSessionArtifactsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListTestGridSessionArtifactsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::ListTestGridSessionArtifactsError {
            meta: generic,
            kind: crate::error::ListTestGridSessionArtifactsErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListTestGridSessionArtifactsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InternalServiceException" => crate::error::ListTestGridSessionArtifactsError {
            meta: generic,
            kind: crate::error::ListTestGridSessionArtifactsErrorKind::InternalServiceException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_internal_service_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListTestGridSessionArtifactsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotFoundException" => crate::error::ListTestGridSessionArtifactsError {
            meta: generic,
            kind: crate::error::ListTestGridSessionArtifactsErrorKind::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_found_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListTestGridSessionArtifactsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListTestGridSessionArtifactsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_test_grid_session_artifacts_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListTestGridSessionArtifactsOutput,
    crate::error::ListTestGridSessionArtifactsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_test_grid_session_artifacts_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_list_test_grid_session_artifacts(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListTestGridSessionArtifactsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_test_grid_sessions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListTestGridSessionsOutput,
    crate::error::ListTestGridSessionsError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListTestGridSessionsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListTestGridSessionsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::ListTestGridSessionsError {
            meta: generic,
            kind: crate::error::ListTestGridSessionsErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListTestGridSessionsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InternalServiceException" => crate::error::ListTestGridSessionsError {
            meta: generic,
            kind: crate::error::ListTestGridSessionsErrorKind::InternalServiceException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_internal_service_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListTestGridSessionsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotFoundException" => crate::error::ListTestGridSessionsError {
            meta: generic,
            kind: crate::error::ListTestGridSessionsErrorKind::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_found_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListTestGridSessionsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListTestGridSessionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_test_grid_sessions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListTestGridSessionsOutput,
    crate::error::ListTestGridSessionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_test_grid_sessions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_list_test_grid_sessions(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListTestGridSessionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_tests_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListTestsOutput, crate::error::ListTestsError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListTestsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListTestsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::ListTestsError {
            meta: generic,
            kind: crate::error::ListTestsErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListTestsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceededException" => crate::error::ListTestsError {
            meta: generic,
            kind: crate::error::ListTestsErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_limit_exceeded_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListTestsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotFoundException" => crate::error::ListTestsError {
            meta: generic,
            kind: crate::error::ListTestsErrorKind::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_found_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListTestsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceAccountException" => crate::error::ListTestsError {
            meta: generic,
            kind: crate::error::ListTestsErrorKind::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_service_account_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListTestsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListTestsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_tests_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListTestsOutput, crate::error::ListTestsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_tests_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_list_tests(response.body().as_ref(), output)
            .map_err(crate::error::ListTestsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_unique_problems_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListUniqueProblemsOutput,
    crate::error::ListUniqueProblemsError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListUniqueProblemsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListUniqueProblemsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::ListUniqueProblemsError {
            meta: generic,
            kind: crate::error::ListUniqueProblemsErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListUniqueProblemsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceededException" => crate::error::ListUniqueProblemsError {
            meta: generic,
            kind: crate::error::ListUniqueProblemsErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_limit_exceeded_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListUniqueProblemsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotFoundException" => crate::error::ListUniqueProblemsError {
            meta: generic,
            kind: crate::error::ListUniqueProblemsErrorKind::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_found_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListUniqueProblemsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceAccountException" => crate::error::ListUniqueProblemsError {
            meta: generic,
            kind: crate::error::ListUniqueProblemsErrorKind::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_service_account_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListUniqueProblemsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListUniqueProblemsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_unique_problems_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListUniqueProblemsOutput,
    crate::error::ListUniqueProblemsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_unique_problems_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_list_unique_problems(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListUniqueProblemsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_uploads_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListUploadsOutput, crate::error::ListUploadsError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListUploadsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListUploadsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::ListUploadsError {
            meta: generic,
            kind: crate::error::ListUploadsErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListUploadsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceededException" => crate::error::ListUploadsError {
            meta: generic,
            kind: crate::error::ListUploadsErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_limit_exceeded_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListUploadsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotFoundException" => crate::error::ListUploadsError {
            meta: generic,
            kind: crate::error::ListUploadsErrorKind::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_found_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListUploadsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceAccountException" => crate::error::ListUploadsError {
            meta: generic,
            kind: crate::error::ListUploadsErrorKind::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_service_account_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListUploadsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListUploadsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_uploads_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListUploadsOutput, crate::error::ListUploadsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_uploads_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_list_uploads(response.body().as_ref(), output)
            .map_err(crate::error::ListUploadsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_vpce_configurations_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListVpceConfigurationsOutput,
    crate::error::ListVPCEConfigurationsError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListVPCEConfigurationsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListVPCEConfigurationsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::ListVPCEConfigurationsError {
            meta: generic,
            kind: crate::error::ListVPCEConfigurationsErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListVPCEConfigurationsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceAccountException" => crate::error::ListVPCEConfigurationsError {
            meta: generic,
            kind: crate::error::ListVPCEConfigurationsErrorKind::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_service_account_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListVPCEConfigurationsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListVPCEConfigurationsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_vpce_configurations_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListVpceConfigurationsOutput,
    crate::error::ListVPCEConfigurationsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_vpce_configurations_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_list_vpce_configurations(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListVPCEConfigurationsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_purchase_offering_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::PurchaseOfferingOutput, crate::error::PurchaseOfferingError>
{
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::PurchaseOfferingError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::PurchaseOfferingError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::PurchaseOfferingError {
            meta: generic,
            kind: crate::error::PurchaseOfferingErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::PurchaseOfferingError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceededException" => crate::error::PurchaseOfferingError {
            meta: generic,
            kind: crate::error::PurchaseOfferingErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_limit_exceeded_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::PurchaseOfferingError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotEligibleException" => crate::error::PurchaseOfferingError {
            meta: generic,
            kind: crate::error::PurchaseOfferingErrorKind::NotEligibleException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_eligible_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_eligible_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::PurchaseOfferingError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotFoundException" => crate::error::PurchaseOfferingError {
            meta: generic,
            kind: crate::error::PurchaseOfferingErrorKind::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_found_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::PurchaseOfferingError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceAccountException" => crate::error::PurchaseOfferingError {
            meta: generic,
            kind: crate::error::PurchaseOfferingErrorKind::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_service_account_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::PurchaseOfferingError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::PurchaseOfferingError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_purchase_offering_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::PurchaseOfferingOutput, crate::error::PurchaseOfferingError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::purchase_offering_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_purchase_offering(response.body().as_ref(), output)
                .map_err(crate::error::PurchaseOfferingError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_renew_offering_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::RenewOfferingOutput, crate::error::RenewOfferingError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::RenewOfferingError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::RenewOfferingError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::RenewOfferingError {
            meta: generic,
            kind: crate::error::RenewOfferingErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::RenewOfferingError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceededException" => crate::error::RenewOfferingError {
            meta: generic,
            kind: crate::error::RenewOfferingErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_limit_exceeded_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::RenewOfferingError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotEligibleException" => crate::error::RenewOfferingError {
            meta: generic,
            kind: crate::error::RenewOfferingErrorKind::NotEligibleException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_eligible_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_eligible_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::RenewOfferingError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotFoundException" => crate::error::RenewOfferingError {
            meta: generic,
            kind: crate::error::RenewOfferingErrorKind::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_found_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::RenewOfferingError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceAccountException" => crate::error::RenewOfferingError {
            meta: generic,
            kind: crate::error::RenewOfferingErrorKind::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_service_account_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::RenewOfferingError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::RenewOfferingError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_renew_offering_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::RenewOfferingOutput, crate::error::RenewOfferingError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::renew_offering_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_renew_offering(response.body().as_ref(), output)
                .map_err(crate::error::RenewOfferingError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_schedule_run_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ScheduleRunOutput, crate::error::ScheduleRunError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ScheduleRunError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ScheduleRunError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::ScheduleRunError {
            meta: generic,
            kind: crate::error::ScheduleRunErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ScheduleRunError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "IdempotencyException" => crate::error::ScheduleRunError {
            meta: generic,
            kind: crate::error::ScheduleRunErrorKind::IdempotencyException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::idempotency_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_idempotency_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ScheduleRunError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceededException" => crate::error::ScheduleRunError {
            meta: generic,
            kind: crate::error::ScheduleRunErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_limit_exceeded_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ScheduleRunError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotFoundException" => crate::error::ScheduleRunError {
            meta: generic,
            kind: crate::error::ScheduleRunErrorKind::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_found_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ScheduleRunError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceAccountException" => crate::error::ScheduleRunError {
            meta: generic,
            kind: crate::error::ScheduleRunErrorKind::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_service_account_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ScheduleRunError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ScheduleRunError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_schedule_run_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ScheduleRunOutput, crate::error::ScheduleRunError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::schedule_run_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_schedule_run(response.body().as_ref(), output)
            .map_err(crate::error::ScheduleRunError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_job_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::StopJobOutput, crate::error::StopJobError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::StopJobError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::StopJobError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::StopJobError {
            meta: generic,
            kind: crate::error::StopJobErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::StopJobError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceededException" => crate::error::StopJobError {
            meta: generic,
            kind: crate::error::StopJobErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_limit_exceeded_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::StopJobError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotFoundException" => crate::error::StopJobError {
            meta: generic,
            kind: crate::error::StopJobErrorKind::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_found_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::StopJobError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceAccountException" => crate::error::StopJobError {
            meta: generic,
            kind: crate::error::StopJobErrorKind::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_service_account_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::StopJobError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::StopJobError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_job_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::StopJobOutput, crate::error::StopJobError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::stop_job_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_stop_job(response.body().as_ref(), output)
            .map_err(crate::error::StopJobError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_remote_access_session_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StopRemoteAccessSessionOutput,
    crate::error::StopRemoteAccessSessionError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::StopRemoteAccessSessionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::StopRemoteAccessSessionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::StopRemoteAccessSessionError {
            meta: generic,
            kind: crate::error::StopRemoteAccessSessionErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::StopRemoteAccessSessionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceededException" => crate::error::StopRemoteAccessSessionError {
            meta: generic,
            kind: crate::error::StopRemoteAccessSessionErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_limit_exceeded_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::StopRemoteAccessSessionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotFoundException" => crate::error::StopRemoteAccessSessionError {
            meta: generic,
            kind: crate::error::StopRemoteAccessSessionErrorKind::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_found_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::StopRemoteAccessSessionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceAccountException" => crate::error::StopRemoteAccessSessionError {
            meta: generic,
            kind: crate::error::StopRemoteAccessSessionErrorKind::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_service_account_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::StopRemoteAccessSessionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::StopRemoteAccessSessionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_remote_access_session_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StopRemoteAccessSessionOutput,
    crate::error::StopRemoteAccessSessionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::stop_remote_access_session_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_stop_remote_access_session(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::StopRemoteAccessSessionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_run_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::StopRunOutput, crate::error::StopRunError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::StopRunError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::StopRunError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::StopRunError {
            meta: generic,
            kind: crate::error::StopRunErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::StopRunError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceededException" => crate::error::StopRunError {
            meta: generic,
            kind: crate::error::StopRunErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_limit_exceeded_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::StopRunError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotFoundException" => crate::error::StopRunError {
            meta: generic,
            kind: crate::error::StopRunErrorKind::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_found_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::StopRunError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceAccountException" => crate::error::StopRunError {
            meta: generic,
            kind: crate::error::StopRunErrorKind::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_service_account_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::StopRunError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::StopRunError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_run_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::StopRunOutput, crate::error::StopRunError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::stop_run_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_stop_run(response.body().as_ref(), output)
            .map_err(crate::error::StopRunError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_tag_resource_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::TagResourceOutput, crate::error::TagResourceError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::TagResourceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::TagResourceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::TagResourceError {
            meta: generic,
            kind: crate::error::TagResourceErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::TagResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotFoundException" => crate::error::TagResourceError {
            meta: generic,
            kind: crate::error::TagResourceErrorKind::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_found_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::TagResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "TagOperationException" => crate::error::TagResourceError {
            meta: generic,
            kind: crate::error::TagResourceErrorKind::TagOperationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::tag_operation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_tag_operation_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::TagResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "TagPolicyException" => crate::error::TagResourceError {
            meta: generic,
            kind: crate::error::TagResourceErrorKind::TagPolicyException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::tag_policy_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_tag_policy_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::TagResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "TooManyTagsException" => crate::error::TagResourceError {
            meta: generic,
            kind: crate::error::TagResourceErrorKind::TooManyTagsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_tags_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_too_many_tags_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::TagResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::TagResourceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_tag_resource_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::TagResourceOutput, crate::error::TagResourceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::tag_resource_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_untag_resource_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::UntagResourceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UntagResourceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::UntagResourceError {
            meta: generic,
            kind: crate::error::UntagResourceErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UntagResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotFoundException" => crate::error::UntagResourceError {
            meta: generic,
            kind: crate::error::UntagResourceErrorKind::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_found_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UntagResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "TagOperationException" => crate::error::UntagResourceError {
            meta: generic,
            kind: crate::error::UntagResourceErrorKind::TagOperationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::tag_operation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_tag_operation_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UntagResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::UntagResourceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_untag_resource_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::untag_resource_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_device_instance_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateDeviceInstanceOutput,
    crate::error::UpdateDeviceInstanceError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateDeviceInstanceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateDeviceInstanceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::UpdateDeviceInstanceError {
            meta: generic,
            kind: crate::error::UpdateDeviceInstanceErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateDeviceInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceededException" => crate::error::UpdateDeviceInstanceError {
            meta: generic,
            kind: crate::error::UpdateDeviceInstanceErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_limit_exceeded_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateDeviceInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotFoundException" => crate::error::UpdateDeviceInstanceError {
            meta: generic,
            kind: crate::error::UpdateDeviceInstanceErrorKind::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_found_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateDeviceInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceAccountException" => crate::error::UpdateDeviceInstanceError {
            meta: generic,
            kind: crate::error::UpdateDeviceInstanceErrorKind::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_service_account_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateDeviceInstanceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::UpdateDeviceInstanceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_device_instance_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateDeviceInstanceOutput,
    crate::error::UpdateDeviceInstanceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_device_instance_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_update_device_instance(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateDeviceInstanceError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_device_pool_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateDevicePoolOutput, crate::error::UpdateDevicePoolError>
{
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateDevicePoolError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateDevicePoolError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::UpdateDevicePoolError {
            meta: generic,
            kind: crate::error::UpdateDevicePoolErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateDevicePoolError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceededException" => crate::error::UpdateDevicePoolError {
            meta: generic,
            kind: crate::error::UpdateDevicePoolErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_limit_exceeded_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateDevicePoolError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotFoundException" => crate::error::UpdateDevicePoolError {
            meta: generic,
            kind: crate::error::UpdateDevicePoolErrorKind::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_found_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateDevicePoolError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceAccountException" => crate::error::UpdateDevicePoolError {
            meta: generic,
            kind: crate::error::UpdateDevicePoolErrorKind::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_service_account_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateDevicePoolError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::UpdateDevicePoolError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_device_pool_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateDevicePoolOutput, crate::error::UpdateDevicePoolError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_device_pool_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_update_device_pool(response.body().as_ref(), output)
                .map_err(crate::error::UpdateDevicePoolError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_instance_profile_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateInstanceProfileOutput,
    crate::error::UpdateInstanceProfileError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateInstanceProfileError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateInstanceProfileError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::UpdateInstanceProfileError {
            meta: generic,
            kind: crate::error::UpdateInstanceProfileErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateInstanceProfileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceededException" => crate::error::UpdateInstanceProfileError {
            meta: generic,
            kind: crate::error::UpdateInstanceProfileErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_limit_exceeded_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateInstanceProfileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotFoundException" => crate::error::UpdateInstanceProfileError {
            meta: generic,
            kind: crate::error::UpdateInstanceProfileErrorKind::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_found_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateInstanceProfileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceAccountException" => crate::error::UpdateInstanceProfileError {
            meta: generic,
            kind: crate::error::UpdateInstanceProfileErrorKind::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_service_account_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateInstanceProfileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::UpdateInstanceProfileError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_instance_profile_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateInstanceProfileOutput,
    crate::error::UpdateInstanceProfileError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_instance_profile_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_update_instance_profile(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateInstanceProfileError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_network_profile_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateNetworkProfileOutput,
    crate::error::UpdateNetworkProfileError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateNetworkProfileError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateNetworkProfileError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::UpdateNetworkProfileError {
            meta: generic,
            kind: crate::error::UpdateNetworkProfileErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateNetworkProfileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceededException" => crate::error::UpdateNetworkProfileError {
            meta: generic,
            kind: crate::error::UpdateNetworkProfileErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_limit_exceeded_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateNetworkProfileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotFoundException" => crate::error::UpdateNetworkProfileError {
            meta: generic,
            kind: crate::error::UpdateNetworkProfileErrorKind::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_found_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateNetworkProfileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceAccountException" => crate::error::UpdateNetworkProfileError {
            meta: generic,
            kind: crate::error::UpdateNetworkProfileErrorKind::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_service_account_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateNetworkProfileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::UpdateNetworkProfileError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_network_profile_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateNetworkProfileOutput,
    crate::error::UpdateNetworkProfileError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_network_profile_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_update_network_profile(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateNetworkProfileError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_project_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateProjectOutput, crate::error::UpdateProjectError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateProjectError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateProjectError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::UpdateProjectError {
            meta: generic,
            kind: crate::error::UpdateProjectErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateProjectError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceededException" => crate::error::UpdateProjectError {
            meta: generic,
            kind: crate::error::UpdateProjectErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_limit_exceeded_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateProjectError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotFoundException" => crate::error::UpdateProjectError {
            meta: generic,
            kind: crate::error::UpdateProjectErrorKind::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_found_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateProjectError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceAccountException" => crate::error::UpdateProjectError {
            meta: generic,
            kind: crate::error::UpdateProjectErrorKind::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_service_account_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateProjectError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::UpdateProjectError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_project_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateProjectOutput, crate::error::UpdateProjectError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_project_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_update_project(response.body().as_ref(), output)
                .map_err(crate::error::UpdateProjectError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_test_grid_project_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateTestGridProjectOutput,
    crate::error::UpdateTestGridProjectError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateTestGridProjectError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateTestGridProjectError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::UpdateTestGridProjectError {
            meta: generic,
            kind: crate::error::UpdateTestGridProjectErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateTestGridProjectError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InternalServiceException" => crate::error::UpdateTestGridProjectError {
            meta: generic,
            kind: crate::error::UpdateTestGridProjectErrorKind::InternalServiceException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_service_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_internal_service_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateTestGridProjectError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceededException" => crate::error::UpdateTestGridProjectError {
            meta: generic,
            kind: crate::error::UpdateTestGridProjectErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_limit_exceeded_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateTestGridProjectError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotFoundException" => crate::error::UpdateTestGridProjectError {
            meta: generic,
            kind: crate::error::UpdateTestGridProjectErrorKind::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_found_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateTestGridProjectError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::UpdateTestGridProjectError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_test_grid_project_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateTestGridProjectOutput,
    crate::error::UpdateTestGridProjectError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_test_grid_project_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_update_test_grid_project(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateTestGridProjectError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_upload_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateUploadOutput, crate::error::UpdateUploadError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateUploadError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateUploadError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::UpdateUploadError {
            meta: generic,
            kind: crate::error::UpdateUploadErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateUploadError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceededException" => crate::error::UpdateUploadError {
            meta: generic,
            kind: crate::error::UpdateUploadErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_limit_exceeded_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateUploadError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotFoundException" => crate::error::UpdateUploadError {
            meta: generic,
            kind: crate::error::UpdateUploadErrorKind::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_found_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateUploadError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceAccountException" => crate::error::UpdateUploadError {
            meta: generic,
            kind: crate::error::UpdateUploadErrorKind::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_service_account_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateUploadError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::UpdateUploadError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_upload_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateUploadOutput, crate::error::UpdateUploadError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_upload_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_update_upload(response.body().as_ref(), output)
            .map_err(crate::error::UpdateUploadError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_vpce_configuration_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateVpceConfigurationOutput,
    crate::error::UpdateVPCEConfigurationError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateVPCEConfigurationError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdateVPCEConfigurationError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ArgumentException" => crate::error::UpdateVPCEConfigurationError {
            meta: generic,
            kind: crate::error::UpdateVPCEConfigurationErrorKind::ArgumentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::argument_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_argument_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateVPCEConfigurationError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidOperationException" => crate::error::UpdateVPCEConfigurationError {
            meta: generic,
            kind: crate::error::UpdateVPCEConfigurationErrorKind::InvalidOperationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_operation_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_invalid_operation_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::UpdateVPCEConfigurationError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NotFoundException" => crate::error::UpdateVPCEConfigurationError {
            meta: generic,
            kind: crate::error::UpdateVPCEConfigurationErrorKind::NotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_not_found_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateVPCEConfigurationError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ServiceAccountException" => crate::error::UpdateVPCEConfigurationError {
            meta: generic,
            kind: crate::error::UpdateVPCEConfigurationErrorKind::ServiceAccountException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::service_account_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_service_account_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateVPCEConfigurationError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::UpdateVPCEConfigurationError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_vpce_configuration_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateVpceConfigurationOutput,
    crate::error::UpdateVPCEConfigurationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_vpce_configuration_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_update_vpce_configuration(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateVPCEConfigurationError::unhandled)?;
        output.build()
    })
}
