// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateDevicePoolError {
    pub kind: CreateDevicePoolErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDevicePoolErrorKind {
    ArgumentException(crate::error::ArgumentException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    ServiceAccountException(crate::error::ServiceAccountException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateDevicePoolError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateDevicePoolErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            CreateDevicePoolErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateDevicePoolErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateDevicePoolErrorKind::ServiceAccountException(_inner) => _inner.fmt(f),
            CreateDevicePoolErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateDevicePoolError {
    fn code(&self) -> Option<&str> {
        CreateDevicePoolError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDevicePoolError {
    pub fn new(kind: CreateDevicePoolErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateDevicePoolErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateDevicePoolErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(&self.kind, CreateDevicePoolErrorKind::ArgumentException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDevicePoolErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, CreateDevicePoolErrorKind::NotFoundException(_))
    }
    pub fn is_service_account_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDevicePoolErrorKind::ServiceAccountException(_)
        )
    }
}
impl std::error::Error for CreateDevicePoolError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateDevicePoolErrorKind::ArgumentException(_inner) => Some(_inner),
            CreateDevicePoolErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateDevicePoolErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateDevicePoolErrorKind::ServiceAccountException(_inner) => Some(_inner),
            CreateDevicePoolErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateInstanceProfileError {
    pub kind: CreateInstanceProfileErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateInstanceProfileErrorKind {
    ArgumentException(crate::error::ArgumentException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    ServiceAccountException(crate::error::ServiceAccountException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateInstanceProfileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateInstanceProfileErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            CreateInstanceProfileErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateInstanceProfileErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateInstanceProfileErrorKind::ServiceAccountException(_inner) => _inner.fmt(f),
            CreateInstanceProfileErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateInstanceProfileError {
    fn code(&self) -> Option<&str> {
        CreateInstanceProfileError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateInstanceProfileError {
    pub fn new(kind: CreateInstanceProfileErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateInstanceProfileErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateInstanceProfileErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateInstanceProfileErrorKind::ArgumentException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateInstanceProfileErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateInstanceProfileErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_account_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateInstanceProfileErrorKind::ServiceAccountException(_)
        )
    }
}
impl std::error::Error for CreateInstanceProfileError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateInstanceProfileErrorKind::ArgumentException(_inner) => Some(_inner),
            CreateInstanceProfileErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateInstanceProfileErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateInstanceProfileErrorKind::ServiceAccountException(_inner) => Some(_inner),
            CreateInstanceProfileErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateNetworkProfileError {
    pub kind: CreateNetworkProfileErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateNetworkProfileErrorKind {
    ArgumentException(crate::error::ArgumentException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    ServiceAccountException(crate::error::ServiceAccountException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateNetworkProfileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateNetworkProfileErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            CreateNetworkProfileErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateNetworkProfileErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateNetworkProfileErrorKind::ServiceAccountException(_inner) => _inner.fmt(f),
            CreateNetworkProfileErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateNetworkProfileError {
    fn code(&self) -> Option<&str> {
        CreateNetworkProfileError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateNetworkProfileError {
    pub fn new(kind: CreateNetworkProfileErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateNetworkProfileErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateNetworkProfileErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateNetworkProfileErrorKind::ArgumentException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateNetworkProfileErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateNetworkProfileErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_account_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateNetworkProfileErrorKind::ServiceAccountException(_)
        )
    }
}
impl std::error::Error for CreateNetworkProfileError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateNetworkProfileErrorKind::ArgumentException(_inner) => Some(_inner),
            CreateNetworkProfileErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateNetworkProfileErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateNetworkProfileErrorKind::ServiceAccountException(_inner) => Some(_inner),
            CreateNetworkProfileErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateProjectError {
    pub kind: CreateProjectErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateProjectErrorKind {
    ArgumentException(crate::error::ArgumentException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    ServiceAccountException(crate::error::ServiceAccountException),
    TagOperationException(crate::error::TagOperationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateProjectError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateProjectErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            CreateProjectErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateProjectErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateProjectErrorKind::ServiceAccountException(_inner) => _inner.fmt(f),
            CreateProjectErrorKind::TagOperationException(_inner) => _inner.fmt(f),
            CreateProjectErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateProjectError {
    fn code(&self) -> Option<&str> {
        CreateProjectError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateProjectError {
    pub fn new(kind: CreateProjectErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateProjectErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateProjectErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(&self.kind, CreateProjectErrorKind::ArgumentException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProjectErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, CreateProjectErrorKind::NotFoundException(_))
    }
    pub fn is_service_account_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProjectErrorKind::ServiceAccountException(_)
        )
    }
    pub fn is_tag_operation_exception(&self) -> bool {
        matches!(&self.kind, CreateProjectErrorKind::TagOperationException(_))
    }
}
impl std::error::Error for CreateProjectError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateProjectErrorKind::ArgumentException(_inner) => Some(_inner),
            CreateProjectErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateProjectErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateProjectErrorKind::ServiceAccountException(_inner) => Some(_inner),
            CreateProjectErrorKind::TagOperationException(_inner) => Some(_inner),
            CreateProjectErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateRemoteAccessSessionError {
    pub kind: CreateRemoteAccessSessionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateRemoteAccessSessionErrorKind {
    ArgumentException(crate::error::ArgumentException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    ServiceAccountException(crate::error::ServiceAccountException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateRemoteAccessSessionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateRemoteAccessSessionErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            CreateRemoteAccessSessionErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateRemoteAccessSessionErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateRemoteAccessSessionErrorKind::ServiceAccountException(_inner) => _inner.fmt(f),
            CreateRemoteAccessSessionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateRemoteAccessSessionError {
    fn code(&self) -> Option<&str> {
        CreateRemoteAccessSessionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateRemoteAccessSessionError {
    pub fn new(kind: CreateRemoteAccessSessionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateRemoteAccessSessionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateRemoteAccessSessionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRemoteAccessSessionErrorKind::ArgumentException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRemoteAccessSessionErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRemoteAccessSessionErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_account_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRemoteAccessSessionErrorKind::ServiceAccountException(_)
        )
    }
}
impl std::error::Error for CreateRemoteAccessSessionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateRemoteAccessSessionErrorKind::ArgumentException(_inner) => Some(_inner),
            CreateRemoteAccessSessionErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateRemoteAccessSessionErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateRemoteAccessSessionErrorKind::ServiceAccountException(_inner) => Some(_inner),
            CreateRemoteAccessSessionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateTestGridProjectError {
    pub kind: CreateTestGridProjectErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateTestGridProjectErrorKind {
    ArgumentException(crate::error::ArgumentException),
    InternalServiceException(crate::error::InternalServiceException),
    LimitExceededException(crate::error::LimitExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateTestGridProjectError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateTestGridProjectErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            CreateTestGridProjectErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            CreateTestGridProjectErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateTestGridProjectErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateTestGridProjectError {
    fn code(&self) -> Option<&str> {
        CreateTestGridProjectError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateTestGridProjectError {
    pub fn new(kind: CreateTestGridProjectErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateTestGridProjectErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateTestGridProjectErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTestGridProjectErrorKind::ArgumentException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTestGridProjectErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTestGridProjectErrorKind::LimitExceededException(_)
        )
    }
}
impl std::error::Error for CreateTestGridProjectError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateTestGridProjectErrorKind::ArgumentException(_inner) => Some(_inner),
            CreateTestGridProjectErrorKind::InternalServiceException(_inner) => Some(_inner),
            CreateTestGridProjectErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateTestGridProjectErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateTestGridUrlError {
    pub kind: CreateTestGridUrlErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateTestGridUrlErrorKind {
    ArgumentException(crate::error::ArgumentException),
    InternalServiceException(crate::error::InternalServiceException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateTestGridUrlError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateTestGridUrlErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            CreateTestGridUrlErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            CreateTestGridUrlErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateTestGridUrlErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateTestGridUrlError {
    fn code(&self) -> Option<&str> {
        CreateTestGridUrlError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateTestGridUrlError {
    pub fn new(kind: CreateTestGridUrlErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateTestGridUrlErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateTestGridUrlErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(&self.kind, CreateTestGridUrlErrorKind::ArgumentException(_))
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTestGridUrlErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, CreateTestGridUrlErrorKind::NotFoundException(_))
    }
}
impl std::error::Error for CreateTestGridUrlError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateTestGridUrlErrorKind::ArgumentException(_inner) => Some(_inner),
            CreateTestGridUrlErrorKind::InternalServiceException(_inner) => Some(_inner),
            CreateTestGridUrlErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateTestGridUrlErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateUploadError {
    pub kind: CreateUploadErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateUploadErrorKind {
    ArgumentException(crate::error::ArgumentException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    ServiceAccountException(crate::error::ServiceAccountException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateUploadError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateUploadErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            CreateUploadErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateUploadErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateUploadErrorKind::ServiceAccountException(_inner) => _inner.fmt(f),
            CreateUploadErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateUploadError {
    fn code(&self) -> Option<&str> {
        CreateUploadError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateUploadError {
    pub fn new(kind: CreateUploadErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateUploadErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateUploadErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(&self.kind, CreateUploadErrorKind::ArgumentException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, CreateUploadErrorKind::LimitExceededException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, CreateUploadErrorKind::NotFoundException(_))
    }
    pub fn is_service_account_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUploadErrorKind::ServiceAccountException(_)
        )
    }
}
impl std::error::Error for CreateUploadError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateUploadErrorKind::ArgumentException(_inner) => Some(_inner),
            CreateUploadErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateUploadErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateUploadErrorKind::ServiceAccountException(_inner) => Some(_inner),
            CreateUploadErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateVPCEConfigurationError {
    pub kind: CreateVPCEConfigurationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateVPCEConfigurationErrorKind {
    ArgumentException(crate::error::ArgumentException),
    LimitExceededException(crate::error::LimitExceededException),
    ServiceAccountException(crate::error::ServiceAccountException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateVPCEConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateVPCEConfigurationErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            CreateVPCEConfigurationErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateVPCEConfigurationErrorKind::ServiceAccountException(_inner) => _inner.fmt(f),
            CreateVPCEConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateVPCEConfigurationError {
    fn code(&self) -> Option<&str> {
        CreateVPCEConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateVPCEConfigurationError {
    pub fn new(kind: CreateVPCEConfigurationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateVPCEConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateVPCEConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVPCEConfigurationErrorKind::ArgumentException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVPCEConfigurationErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_service_account_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVPCEConfigurationErrorKind::ServiceAccountException(_)
        )
    }
}
impl std::error::Error for CreateVPCEConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateVPCEConfigurationErrorKind::ArgumentException(_inner) => Some(_inner),
            CreateVPCEConfigurationErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateVPCEConfigurationErrorKind::ServiceAccountException(_inner) => Some(_inner),
            CreateVPCEConfigurationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteDevicePoolError {
    pub kind: DeleteDevicePoolErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDevicePoolErrorKind {
    ArgumentException(crate::error::ArgumentException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    ServiceAccountException(crate::error::ServiceAccountException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteDevicePoolError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteDevicePoolErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            DeleteDevicePoolErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            DeleteDevicePoolErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteDevicePoolErrorKind::ServiceAccountException(_inner) => _inner.fmt(f),
            DeleteDevicePoolErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteDevicePoolError {
    fn code(&self) -> Option<&str> {
        DeleteDevicePoolError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteDevicePoolError {
    pub fn new(kind: DeleteDevicePoolErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteDevicePoolErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteDevicePoolErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(&self.kind, DeleteDevicePoolErrorKind::ArgumentException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDevicePoolErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteDevicePoolErrorKind::NotFoundException(_))
    }
    pub fn is_service_account_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDevicePoolErrorKind::ServiceAccountException(_)
        )
    }
}
impl std::error::Error for DeleteDevicePoolError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteDevicePoolErrorKind::ArgumentException(_inner) => Some(_inner),
            DeleteDevicePoolErrorKind::LimitExceededException(_inner) => Some(_inner),
            DeleteDevicePoolErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteDevicePoolErrorKind::ServiceAccountException(_inner) => Some(_inner),
            DeleteDevicePoolErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteInstanceProfileError {
    pub kind: DeleteInstanceProfileErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteInstanceProfileErrorKind {
    ArgumentException(crate::error::ArgumentException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    ServiceAccountException(crate::error::ServiceAccountException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteInstanceProfileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteInstanceProfileErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            DeleteInstanceProfileErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            DeleteInstanceProfileErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteInstanceProfileErrorKind::ServiceAccountException(_inner) => _inner.fmt(f),
            DeleteInstanceProfileErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteInstanceProfileError {
    fn code(&self) -> Option<&str> {
        DeleteInstanceProfileError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteInstanceProfileError {
    pub fn new(kind: DeleteInstanceProfileErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteInstanceProfileErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteInstanceProfileErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteInstanceProfileErrorKind::ArgumentException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteInstanceProfileErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteInstanceProfileErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_account_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteInstanceProfileErrorKind::ServiceAccountException(_)
        )
    }
}
impl std::error::Error for DeleteInstanceProfileError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteInstanceProfileErrorKind::ArgumentException(_inner) => Some(_inner),
            DeleteInstanceProfileErrorKind::LimitExceededException(_inner) => Some(_inner),
            DeleteInstanceProfileErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteInstanceProfileErrorKind::ServiceAccountException(_inner) => Some(_inner),
            DeleteInstanceProfileErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteNetworkProfileError {
    pub kind: DeleteNetworkProfileErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteNetworkProfileErrorKind {
    ArgumentException(crate::error::ArgumentException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    ServiceAccountException(crate::error::ServiceAccountException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteNetworkProfileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteNetworkProfileErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            DeleteNetworkProfileErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            DeleteNetworkProfileErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteNetworkProfileErrorKind::ServiceAccountException(_inner) => _inner.fmt(f),
            DeleteNetworkProfileErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteNetworkProfileError {
    fn code(&self) -> Option<&str> {
        DeleteNetworkProfileError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteNetworkProfileError {
    pub fn new(kind: DeleteNetworkProfileErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteNetworkProfileErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteNetworkProfileErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteNetworkProfileErrorKind::ArgumentException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteNetworkProfileErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteNetworkProfileErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_account_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteNetworkProfileErrorKind::ServiceAccountException(_)
        )
    }
}
impl std::error::Error for DeleteNetworkProfileError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteNetworkProfileErrorKind::ArgumentException(_inner) => Some(_inner),
            DeleteNetworkProfileErrorKind::LimitExceededException(_inner) => Some(_inner),
            DeleteNetworkProfileErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteNetworkProfileErrorKind::ServiceAccountException(_inner) => Some(_inner),
            DeleteNetworkProfileErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteProjectError {
    pub kind: DeleteProjectErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteProjectErrorKind {
    ArgumentException(crate::error::ArgumentException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    ServiceAccountException(crate::error::ServiceAccountException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteProjectError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteProjectErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            DeleteProjectErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            DeleteProjectErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteProjectErrorKind::ServiceAccountException(_inner) => _inner.fmt(f),
            DeleteProjectErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteProjectError {
    fn code(&self) -> Option<&str> {
        DeleteProjectError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteProjectError {
    pub fn new(kind: DeleteProjectErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteProjectErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteProjectErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(&self.kind, DeleteProjectErrorKind::ArgumentException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteProjectErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteProjectErrorKind::NotFoundException(_))
    }
    pub fn is_service_account_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteProjectErrorKind::ServiceAccountException(_)
        )
    }
}
impl std::error::Error for DeleteProjectError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteProjectErrorKind::ArgumentException(_inner) => Some(_inner),
            DeleteProjectErrorKind::LimitExceededException(_inner) => Some(_inner),
            DeleteProjectErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteProjectErrorKind::ServiceAccountException(_inner) => Some(_inner),
            DeleteProjectErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteRemoteAccessSessionError {
    pub kind: DeleteRemoteAccessSessionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteRemoteAccessSessionErrorKind {
    ArgumentException(crate::error::ArgumentException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    ServiceAccountException(crate::error::ServiceAccountException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteRemoteAccessSessionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteRemoteAccessSessionErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            DeleteRemoteAccessSessionErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            DeleteRemoteAccessSessionErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteRemoteAccessSessionErrorKind::ServiceAccountException(_inner) => _inner.fmt(f),
            DeleteRemoteAccessSessionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteRemoteAccessSessionError {
    fn code(&self) -> Option<&str> {
        DeleteRemoteAccessSessionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteRemoteAccessSessionError {
    pub fn new(kind: DeleteRemoteAccessSessionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteRemoteAccessSessionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteRemoteAccessSessionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRemoteAccessSessionErrorKind::ArgumentException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRemoteAccessSessionErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRemoteAccessSessionErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_account_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRemoteAccessSessionErrorKind::ServiceAccountException(_)
        )
    }
}
impl std::error::Error for DeleteRemoteAccessSessionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteRemoteAccessSessionErrorKind::ArgumentException(_inner) => Some(_inner),
            DeleteRemoteAccessSessionErrorKind::LimitExceededException(_inner) => Some(_inner),
            DeleteRemoteAccessSessionErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteRemoteAccessSessionErrorKind::ServiceAccountException(_inner) => Some(_inner),
            DeleteRemoteAccessSessionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteRunError {
    pub kind: DeleteRunErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteRunErrorKind {
    ArgumentException(crate::error::ArgumentException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    ServiceAccountException(crate::error::ServiceAccountException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteRunError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteRunErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            DeleteRunErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            DeleteRunErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteRunErrorKind::ServiceAccountException(_inner) => _inner.fmt(f),
            DeleteRunErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteRunError {
    fn code(&self) -> Option<&str> {
        DeleteRunError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteRunError {
    pub fn new(kind: DeleteRunErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteRunErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteRunErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(&self.kind, DeleteRunErrorKind::ArgumentException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, DeleteRunErrorKind::LimitExceededException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteRunErrorKind::NotFoundException(_))
    }
    pub fn is_service_account_exception(&self) -> bool {
        matches!(&self.kind, DeleteRunErrorKind::ServiceAccountException(_))
    }
}
impl std::error::Error for DeleteRunError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteRunErrorKind::ArgumentException(_inner) => Some(_inner),
            DeleteRunErrorKind::LimitExceededException(_inner) => Some(_inner),
            DeleteRunErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteRunErrorKind::ServiceAccountException(_inner) => Some(_inner),
            DeleteRunErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteTestGridProjectError {
    pub kind: DeleteTestGridProjectErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteTestGridProjectErrorKind {
    ArgumentException(crate::error::ArgumentException),
    CannotDeleteException(crate::error::CannotDeleteException),
    InternalServiceException(crate::error::InternalServiceException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteTestGridProjectError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteTestGridProjectErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            DeleteTestGridProjectErrorKind::CannotDeleteException(_inner) => _inner.fmt(f),
            DeleteTestGridProjectErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            DeleteTestGridProjectErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteTestGridProjectErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteTestGridProjectError {
    fn code(&self) -> Option<&str> {
        DeleteTestGridProjectError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteTestGridProjectError {
    pub fn new(kind: DeleteTestGridProjectErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteTestGridProjectErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteTestGridProjectErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteTestGridProjectErrorKind::ArgumentException(_)
        )
    }
    pub fn is_cannot_delete_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteTestGridProjectErrorKind::CannotDeleteException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteTestGridProjectErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteTestGridProjectErrorKind::NotFoundException(_)
        )
    }
}
impl std::error::Error for DeleteTestGridProjectError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteTestGridProjectErrorKind::ArgumentException(_inner) => Some(_inner),
            DeleteTestGridProjectErrorKind::CannotDeleteException(_inner) => Some(_inner),
            DeleteTestGridProjectErrorKind::InternalServiceException(_inner) => Some(_inner),
            DeleteTestGridProjectErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteTestGridProjectErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteUploadError {
    pub kind: DeleteUploadErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteUploadErrorKind {
    ArgumentException(crate::error::ArgumentException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    ServiceAccountException(crate::error::ServiceAccountException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteUploadError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteUploadErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            DeleteUploadErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            DeleteUploadErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteUploadErrorKind::ServiceAccountException(_inner) => _inner.fmt(f),
            DeleteUploadErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteUploadError {
    fn code(&self) -> Option<&str> {
        DeleteUploadError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteUploadError {
    pub fn new(kind: DeleteUploadErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteUploadErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteUploadErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(&self.kind, DeleteUploadErrorKind::ArgumentException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, DeleteUploadErrorKind::LimitExceededException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteUploadErrorKind::NotFoundException(_))
    }
    pub fn is_service_account_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUploadErrorKind::ServiceAccountException(_)
        )
    }
}
impl std::error::Error for DeleteUploadError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteUploadErrorKind::ArgumentException(_inner) => Some(_inner),
            DeleteUploadErrorKind::LimitExceededException(_inner) => Some(_inner),
            DeleteUploadErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteUploadErrorKind::ServiceAccountException(_inner) => Some(_inner),
            DeleteUploadErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteVPCEConfigurationError {
    pub kind: DeleteVPCEConfigurationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteVPCEConfigurationErrorKind {
    ArgumentException(crate::error::ArgumentException),
    InvalidOperationException(crate::error::InvalidOperationException),
    NotFoundException(crate::error::NotFoundException),
    ServiceAccountException(crate::error::ServiceAccountException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteVPCEConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteVPCEConfigurationErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            DeleteVPCEConfigurationErrorKind::InvalidOperationException(_inner) => _inner.fmt(f),
            DeleteVPCEConfigurationErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteVPCEConfigurationErrorKind::ServiceAccountException(_inner) => _inner.fmt(f),
            DeleteVPCEConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteVPCEConfigurationError {
    fn code(&self) -> Option<&str> {
        DeleteVPCEConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteVPCEConfigurationError {
    pub fn new(kind: DeleteVPCEConfigurationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteVPCEConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteVPCEConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVPCEConfigurationErrorKind::ArgumentException(_)
        )
    }
    pub fn is_invalid_operation_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVPCEConfigurationErrorKind::InvalidOperationException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVPCEConfigurationErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_account_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVPCEConfigurationErrorKind::ServiceAccountException(_)
        )
    }
}
impl std::error::Error for DeleteVPCEConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteVPCEConfigurationErrorKind::ArgumentException(_inner) => Some(_inner),
            DeleteVPCEConfigurationErrorKind::InvalidOperationException(_inner) => Some(_inner),
            DeleteVPCEConfigurationErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteVPCEConfigurationErrorKind::ServiceAccountException(_inner) => Some(_inner),
            DeleteVPCEConfigurationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetAccountSettingsError {
    pub kind: GetAccountSettingsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetAccountSettingsErrorKind {
    ArgumentException(crate::error::ArgumentException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    ServiceAccountException(crate::error::ServiceAccountException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetAccountSettingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetAccountSettingsErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            GetAccountSettingsErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            GetAccountSettingsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetAccountSettingsErrorKind::ServiceAccountException(_inner) => _inner.fmt(f),
            GetAccountSettingsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetAccountSettingsError {
    fn code(&self) -> Option<&str> {
        GetAccountSettingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetAccountSettingsError {
    pub fn new(kind: GetAccountSettingsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetAccountSettingsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetAccountSettingsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAccountSettingsErrorKind::ArgumentException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAccountSettingsErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAccountSettingsErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_account_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAccountSettingsErrorKind::ServiceAccountException(_)
        )
    }
}
impl std::error::Error for GetAccountSettingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetAccountSettingsErrorKind::ArgumentException(_inner) => Some(_inner),
            GetAccountSettingsErrorKind::LimitExceededException(_inner) => Some(_inner),
            GetAccountSettingsErrorKind::NotFoundException(_inner) => Some(_inner),
            GetAccountSettingsErrorKind::ServiceAccountException(_inner) => Some(_inner),
            GetAccountSettingsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetDeviceError {
    pub kind: GetDeviceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetDeviceErrorKind {
    ArgumentException(crate::error::ArgumentException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    ServiceAccountException(crate::error::ServiceAccountException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetDeviceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetDeviceErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            GetDeviceErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            GetDeviceErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetDeviceErrorKind::ServiceAccountException(_inner) => _inner.fmt(f),
            GetDeviceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetDeviceError {
    fn code(&self) -> Option<&str> {
        GetDeviceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetDeviceError {
    pub fn new(kind: GetDeviceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetDeviceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetDeviceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(&self.kind, GetDeviceErrorKind::ArgumentException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, GetDeviceErrorKind::LimitExceededException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetDeviceErrorKind::NotFoundException(_))
    }
    pub fn is_service_account_exception(&self) -> bool {
        matches!(&self.kind, GetDeviceErrorKind::ServiceAccountException(_))
    }
}
impl std::error::Error for GetDeviceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetDeviceErrorKind::ArgumentException(_inner) => Some(_inner),
            GetDeviceErrorKind::LimitExceededException(_inner) => Some(_inner),
            GetDeviceErrorKind::NotFoundException(_inner) => Some(_inner),
            GetDeviceErrorKind::ServiceAccountException(_inner) => Some(_inner),
            GetDeviceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetDeviceInstanceError {
    pub kind: GetDeviceInstanceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetDeviceInstanceErrorKind {
    ArgumentException(crate::error::ArgumentException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    ServiceAccountException(crate::error::ServiceAccountException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetDeviceInstanceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetDeviceInstanceErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            GetDeviceInstanceErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            GetDeviceInstanceErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetDeviceInstanceErrorKind::ServiceAccountException(_inner) => _inner.fmt(f),
            GetDeviceInstanceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetDeviceInstanceError {
    fn code(&self) -> Option<&str> {
        GetDeviceInstanceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetDeviceInstanceError {
    pub fn new(kind: GetDeviceInstanceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetDeviceInstanceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetDeviceInstanceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(&self.kind, GetDeviceInstanceErrorKind::ArgumentException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDeviceInstanceErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetDeviceInstanceErrorKind::NotFoundException(_))
    }
    pub fn is_service_account_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDeviceInstanceErrorKind::ServiceAccountException(_)
        )
    }
}
impl std::error::Error for GetDeviceInstanceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetDeviceInstanceErrorKind::ArgumentException(_inner) => Some(_inner),
            GetDeviceInstanceErrorKind::LimitExceededException(_inner) => Some(_inner),
            GetDeviceInstanceErrorKind::NotFoundException(_inner) => Some(_inner),
            GetDeviceInstanceErrorKind::ServiceAccountException(_inner) => Some(_inner),
            GetDeviceInstanceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetDevicePoolError {
    pub kind: GetDevicePoolErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetDevicePoolErrorKind {
    ArgumentException(crate::error::ArgumentException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    ServiceAccountException(crate::error::ServiceAccountException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetDevicePoolError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetDevicePoolErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            GetDevicePoolErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            GetDevicePoolErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetDevicePoolErrorKind::ServiceAccountException(_inner) => _inner.fmt(f),
            GetDevicePoolErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetDevicePoolError {
    fn code(&self) -> Option<&str> {
        GetDevicePoolError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetDevicePoolError {
    pub fn new(kind: GetDevicePoolErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetDevicePoolErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetDevicePoolErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(&self.kind, GetDevicePoolErrorKind::ArgumentException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDevicePoolErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetDevicePoolErrorKind::NotFoundException(_))
    }
    pub fn is_service_account_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDevicePoolErrorKind::ServiceAccountException(_)
        )
    }
}
impl std::error::Error for GetDevicePoolError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetDevicePoolErrorKind::ArgumentException(_inner) => Some(_inner),
            GetDevicePoolErrorKind::LimitExceededException(_inner) => Some(_inner),
            GetDevicePoolErrorKind::NotFoundException(_inner) => Some(_inner),
            GetDevicePoolErrorKind::ServiceAccountException(_inner) => Some(_inner),
            GetDevicePoolErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetDevicePoolCompatibilityError {
    pub kind: GetDevicePoolCompatibilityErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetDevicePoolCompatibilityErrorKind {
    ArgumentException(crate::error::ArgumentException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    ServiceAccountException(crate::error::ServiceAccountException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetDevicePoolCompatibilityError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetDevicePoolCompatibilityErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            GetDevicePoolCompatibilityErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            GetDevicePoolCompatibilityErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetDevicePoolCompatibilityErrorKind::ServiceAccountException(_inner) => _inner.fmt(f),
            GetDevicePoolCompatibilityErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetDevicePoolCompatibilityError {
    fn code(&self) -> Option<&str> {
        GetDevicePoolCompatibilityError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetDevicePoolCompatibilityError {
    pub fn new(kind: GetDevicePoolCompatibilityErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetDevicePoolCompatibilityErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetDevicePoolCompatibilityErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDevicePoolCompatibilityErrorKind::ArgumentException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDevicePoolCompatibilityErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDevicePoolCompatibilityErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_account_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDevicePoolCompatibilityErrorKind::ServiceAccountException(_)
        )
    }
}
impl std::error::Error for GetDevicePoolCompatibilityError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetDevicePoolCompatibilityErrorKind::ArgumentException(_inner) => Some(_inner),
            GetDevicePoolCompatibilityErrorKind::LimitExceededException(_inner) => Some(_inner),
            GetDevicePoolCompatibilityErrorKind::NotFoundException(_inner) => Some(_inner),
            GetDevicePoolCompatibilityErrorKind::ServiceAccountException(_inner) => Some(_inner),
            GetDevicePoolCompatibilityErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetInstanceProfileError {
    pub kind: GetInstanceProfileErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetInstanceProfileErrorKind {
    ArgumentException(crate::error::ArgumentException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    ServiceAccountException(crate::error::ServiceAccountException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetInstanceProfileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetInstanceProfileErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            GetInstanceProfileErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            GetInstanceProfileErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetInstanceProfileErrorKind::ServiceAccountException(_inner) => _inner.fmt(f),
            GetInstanceProfileErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetInstanceProfileError {
    fn code(&self) -> Option<&str> {
        GetInstanceProfileError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetInstanceProfileError {
    pub fn new(kind: GetInstanceProfileErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetInstanceProfileErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetInstanceProfileErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetInstanceProfileErrorKind::ArgumentException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetInstanceProfileErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetInstanceProfileErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_account_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetInstanceProfileErrorKind::ServiceAccountException(_)
        )
    }
}
impl std::error::Error for GetInstanceProfileError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetInstanceProfileErrorKind::ArgumentException(_inner) => Some(_inner),
            GetInstanceProfileErrorKind::LimitExceededException(_inner) => Some(_inner),
            GetInstanceProfileErrorKind::NotFoundException(_inner) => Some(_inner),
            GetInstanceProfileErrorKind::ServiceAccountException(_inner) => Some(_inner),
            GetInstanceProfileErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetJobError {
    pub kind: GetJobErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetJobErrorKind {
    ArgumentException(crate::error::ArgumentException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    ServiceAccountException(crate::error::ServiceAccountException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetJobErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            GetJobErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            GetJobErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetJobErrorKind::ServiceAccountException(_inner) => _inner.fmt(f),
            GetJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetJobError {
    fn code(&self) -> Option<&str> {
        GetJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetJobError {
    pub fn new(kind: GetJobErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetJobErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(&self.kind, GetJobErrorKind::ArgumentException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, GetJobErrorKind::LimitExceededException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetJobErrorKind::NotFoundException(_))
    }
    pub fn is_service_account_exception(&self) -> bool {
        matches!(&self.kind, GetJobErrorKind::ServiceAccountException(_))
    }
}
impl std::error::Error for GetJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetJobErrorKind::ArgumentException(_inner) => Some(_inner),
            GetJobErrorKind::LimitExceededException(_inner) => Some(_inner),
            GetJobErrorKind::NotFoundException(_inner) => Some(_inner),
            GetJobErrorKind::ServiceAccountException(_inner) => Some(_inner),
            GetJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetNetworkProfileError {
    pub kind: GetNetworkProfileErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetNetworkProfileErrorKind {
    ArgumentException(crate::error::ArgumentException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    ServiceAccountException(crate::error::ServiceAccountException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetNetworkProfileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetNetworkProfileErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            GetNetworkProfileErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            GetNetworkProfileErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetNetworkProfileErrorKind::ServiceAccountException(_inner) => _inner.fmt(f),
            GetNetworkProfileErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetNetworkProfileError {
    fn code(&self) -> Option<&str> {
        GetNetworkProfileError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetNetworkProfileError {
    pub fn new(kind: GetNetworkProfileErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetNetworkProfileErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetNetworkProfileErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(&self.kind, GetNetworkProfileErrorKind::ArgumentException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetNetworkProfileErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetNetworkProfileErrorKind::NotFoundException(_))
    }
    pub fn is_service_account_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetNetworkProfileErrorKind::ServiceAccountException(_)
        )
    }
}
impl std::error::Error for GetNetworkProfileError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetNetworkProfileErrorKind::ArgumentException(_inner) => Some(_inner),
            GetNetworkProfileErrorKind::LimitExceededException(_inner) => Some(_inner),
            GetNetworkProfileErrorKind::NotFoundException(_inner) => Some(_inner),
            GetNetworkProfileErrorKind::ServiceAccountException(_inner) => Some(_inner),
            GetNetworkProfileErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetOfferingStatusError {
    pub kind: GetOfferingStatusErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetOfferingStatusErrorKind {
    ArgumentException(crate::error::ArgumentException),
    LimitExceededException(crate::error::LimitExceededException),
    NotEligibleException(crate::error::NotEligibleException),
    NotFoundException(crate::error::NotFoundException),
    ServiceAccountException(crate::error::ServiceAccountException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetOfferingStatusError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetOfferingStatusErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            GetOfferingStatusErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            GetOfferingStatusErrorKind::NotEligibleException(_inner) => _inner.fmt(f),
            GetOfferingStatusErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetOfferingStatusErrorKind::ServiceAccountException(_inner) => _inner.fmt(f),
            GetOfferingStatusErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetOfferingStatusError {
    fn code(&self) -> Option<&str> {
        GetOfferingStatusError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetOfferingStatusError {
    pub fn new(kind: GetOfferingStatusErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetOfferingStatusErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetOfferingStatusErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(&self.kind, GetOfferingStatusErrorKind::ArgumentException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetOfferingStatusErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_eligible_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetOfferingStatusErrorKind::NotEligibleException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetOfferingStatusErrorKind::NotFoundException(_))
    }
    pub fn is_service_account_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetOfferingStatusErrorKind::ServiceAccountException(_)
        )
    }
}
impl std::error::Error for GetOfferingStatusError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetOfferingStatusErrorKind::ArgumentException(_inner) => Some(_inner),
            GetOfferingStatusErrorKind::LimitExceededException(_inner) => Some(_inner),
            GetOfferingStatusErrorKind::NotEligibleException(_inner) => Some(_inner),
            GetOfferingStatusErrorKind::NotFoundException(_inner) => Some(_inner),
            GetOfferingStatusErrorKind::ServiceAccountException(_inner) => Some(_inner),
            GetOfferingStatusErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetProjectError {
    pub kind: GetProjectErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetProjectErrorKind {
    ArgumentException(crate::error::ArgumentException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    ServiceAccountException(crate::error::ServiceAccountException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetProjectError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetProjectErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            GetProjectErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            GetProjectErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetProjectErrorKind::ServiceAccountException(_inner) => _inner.fmt(f),
            GetProjectErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetProjectError {
    fn code(&self) -> Option<&str> {
        GetProjectError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetProjectError {
    pub fn new(kind: GetProjectErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetProjectErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetProjectErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(&self.kind, GetProjectErrorKind::ArgumentException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, GetProjectErrorKind::LimitExceededException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetProjectErrorKind::NotFoundException(_))
    }
    pub fn is_service_account_exception(&self) -> bool {
        matches!(&self.kind, GetProjectErrorKind::ServiceAccountException(_))
    }
}
impl std::error::Error for GetProjectError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetProjectErrorKind::ArgumentException(_inner) => Some(_inner),
            GetProjectErrorKind::LimitExceededException(_inner) => Some(_inner),
            GetProjectErrorKind::NotFoundException(_inner) => Some(_inner),
            GetProjectErrorKind::ServiceAccountException(_inner) => Some(_inner),
            GetProjectErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetRemoteAccessSessionError {
    pub kind: GetRemoteAccessSessionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetRemoteAccessSessionErrorKind {
    ArgumentException(crate::error::ArgumentException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    ServiceAccountException(crate::error::ServiceAccountException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetRemoteAccessSessionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetRemoteAccessSessionErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            GetRemoteAccessSessionErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            GetRemoteAccessSessionErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetRemoteAccessSessionErrorKind::ServiceAccountException(_inner) => _inner.fmt(f),
            GetRemoteAccessSessionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetRemoteAccessSessionError {
    fn code(&self) -> Option<&str> {
        GetRemoteAccessSessionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetRemoteAccessSessionError {
    pub fn new(kind: GetRemoteAccessSessionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetRemoteAccessSessionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetRemoteAccessSessionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRemoteAccessSessionErrorKind::ArgumentException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRemoteAccessSessionErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRemoteAccessSessionErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_account_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRemoteAccessSessionErrorKind::ServiceAccountException(_)
        )
    }
}
impl std::error::Error for GetRemoteAccessSessionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetRemoteAccessSessionErrorKind::ArgumentException(_inner) => Some(_inner),
            GetRemoteAccessSessionErrorKind::LimitExceededException(_inner) => Some(_inner),
            GetRemoteAccessSessionErrorKind::NotFoundException(_inner) => Some(_inner),
            GetRemoteAccessSessionErrorKind::ServiceAccountException(_inner) => Some(_inner),
            GetRemoteAccessSessionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetRunError {
    pub kind: GetRunErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetRunErrorKind {
    ArgumentException(crate::error::ArgumentException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    ServiceAccountException(crate::error::ServiceAccountException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetRunError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetRunErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            GetRunErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            GetRunErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetRunErrorKind::ServiceAccountException(_inner) => _inner.fmt(f),
            GetRunErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetRunError {
    fn code(&self) -> Option<&str> {
        GetRunError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetRunError {
    pub fn new(kind: GetRunErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetRunErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetRunErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(&self.kind, GetRunErrorKind::ArgumentException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, GetRunErrorKind::LimitExceededException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetRunErrorKind::NotFoundException(_))
    }
    pub fn is_service_account_exception(&self) -> bool {
        matches!(&self.kind, GetRunErrorKind::ServiceAccountException(_))
    }
}
impl std::error::Error for GetRunError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetRunErrorKind::ArgumentException(_inner) => Some(_inner),
            GetRunErrorKind::LimitExceededException(_inner) => Some(_inner),
            GetRunErrorKind::NotFoundException(_inner) => Some(_inner),
            GetRunErrorKind::ServiceAccountException(_inner) => Some(_inner),
            GetRunErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetSuiteError {
    pub kind: GetSuiteErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetSuiteErrorKind {
    ArgumentException(crate::error::ArgumentException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    ServiceAccountException(crate::error::ServiceAccountException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetSuiteError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetSuiteErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            GetSuiteErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            GetSuiteErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetSuiteErrorKind::ServiceAccountException(_inner) => _inner.fmt(f),
            GetSuiteErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetSuiteError {
    fn code(&self) -> Option<&str> {
        GetSuiteError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetSuiteError {
    pub fn new(kind: GetSuiteErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetSuiteErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetSuiteErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(&self.kind, GetSuiteErrorKind::ArgumentException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, GetSuiteErrorKind::LimitExceededException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetSuiteErrorKind::NotFoundException(_))
    }
    pub fn is_service_account_exception(&self) -> bool {
        matches!(&self.kind, GetSuiteErrorKind::ServiceAccountException(_))
    }
}
impl std::error::Error for GetSuiteError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetSuiteErrorKind::ArgumentException(_inner) => Some(_inner),
            GetSuiteErrorKind::LimitExceededException(_inner) => Some(_inner),
            GetSuiteErrorKind::NotFoundException(_inner) => Some(_inner),
            GetSuiteErrorKind::ServiceAccountException(_inner) => Some(_inner),
            GetSuiteErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetTestError {
    pub kind: GetTestErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetTestErrorKind {
    ArgumentException(crate::error::ArgumentException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    ServiceAccountException(crate::error::ServiceAccountException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetTestError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetTestErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            GetTestErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            GetTestErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetTestErrorKind::ServiceAccountException(_inner) => _inner.fmt(f),
            GetTestErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetTestError {
    fn code(&self) -> Option<&str> {
        GetTestError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetTestError {
    pub fn new(kind: GetTestErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetTestErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetTestErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(&self.kind, GetTestErrorKind::ArgumentException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, GetTestErrorKind::LimitExceededException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetTestErrorKind::NotFoundException(_))
    }
    pub fn is_service_account_exception(&self) -> bool {
        matches!(&self.kind, GetTestErrorKind::ServiceAccountException(_))
    }
}
impl std::error::Error for GetTestError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetTestErrorKind::ArgumentException(_inner) => Some(_inner),
            GetTestErrorKind::LimitExceededException(_inner) => Some(_inner),
            GetTestErrorKind::NotFoundException(_inner) => Some(_inner),
            GetTestErrorKind::ServiceAccountException(_inner) => Some(_inner),
            GetTestErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetTestGridProjectError {
    pub kind: GetTestGridProjectErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetTestGridProjectErrorKind {
    ArgumentException(crate::error::ArgumentException),
    InternalServiceException(crate::error::InternalServiceException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetTestGridProjectError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetTestGridProjectErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            GetTestGridProjectErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            GetTestGridProjectErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetTestGridProjectErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetTestGridProjectError {
    fn code(&self) -> Option<&str> {
        GetTestGridProjectError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetTestGridProjectError {
    pub fn new(kind: GetTestGridProjectErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetTestGridProjectErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetTestGridProjectErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetTestGridProjectErrorKind::ArgumentException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetTestGridProjectErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetTestGridProjectErrorKind::NotFoundException(_)
        )
    }
}
impl std::error::Error for GetTestGridProjectError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetTestGridProjectErrorKind::ArgumentException(_inner) => Some(_inner),
            GetTestGridProjectErrorKind::InternalServiceException(_inner) => Some(_inner),
            GetTestGridProjectErrorKind::NotFoundException(_inner) => Some(_inner),
            GetTestGridProjectErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetTestGridSessionError {
    pub kind: GetTestGridSessionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetTestGridSessionErrorKind {
    ArgumentException(crate::error::ArgumentException),
    InternalServiceException(crate::error::InternalServiceException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetTestGridSessionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetTestGridSessionErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            GetTestGridSessionErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            GetTestGridSessionErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetTestGridSessionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetTestGridSessionError {
    fn code(&self) -> Option<&str> {
        GetTestGridSessionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetTestGridSessionError {
    pub fn new(kind: GetTestGridSessionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetTestGridSessionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetTestGridSessionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetTestGridSessionErrorKind::ArgumentException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetTestGridSessionErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetTestGridSessionErrorKind::NotFoundException(_)
        )
    }
}
impl std::error::Error for GetTestGridSessionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetTestGridSessionErrorKind::ArgumentException(_inner) => Some(_inner),
            GetTestGridSessionErrorKind::InternalServiceException(_inner) => Some(_inner),
            GetTestGridSessionErrorKind::NotFoundException(_inner) => Some(_inner),
            GetTestGridSessionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetUploadError {
    pub kind: GetUploadErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetUploadErrorKind {
    ArgumentException(crate::error::ArgumentException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    ServiceAccountException(crate::error::ServiceAccountException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetUploadError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetUploadErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            GetUploadErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            GetUploadErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetUploadErrorKind::ServiceAccountException(_inner) => _inner.fmt(f),
            GetUploadErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetUploadError {
    fn code(&self) -> Option<&str> {
        GetUploadError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetUploadError {
    pub fn new(kind: GetUploadErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetUploadErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetUploadErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(&self.kind, GetUploadErrorKind::ArgumentException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, GetUploadErrorKind::LimitExceededException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetUploadErrorKind::NotFoundException(_))
    }
    pub fn is_service_account_exception(&self) -> bool {
        matches!(&self.kind, GetUploadErrorKind::ServiceAccountException(_))
    }
}
impl std::error::Error for GetUploadError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetUploadErrorKind::ArgumentException(_inner) => Some(_inner),
            GetUploadErrorKind::LimitExceededException(_inner) => Some(_inner),
            GetUploadErrorKind::NotFoundException(_inner) => Some(_inner),
            GetUploadErrorKind::ServiceAccountException(_inner) => Some(_inner),
            GetUploadErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetVPCEConfigurationError {
    pub kind: GetVPCEConfigurationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetVPCEConfigurationErrorKind {
    ArgumentException(crate::error::ArgumentException),
    NotFoundException(crate::error::NotFoundException),
    ServiceAccountException(crate::error::ServiceAccountException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetVPCEConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetVPCEConfigurationErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            GetVPCEConfigurationErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetVPCEConfigurationErrorKind::ServiceAccountException(_inner) => _inner.fmt(f),
            GetVPCEConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetVPCEConfigurationError {
    fn code(&self) -> Option<&str> {
        GetVPCEConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetVPCEConfigurationError {
    pub fn new(kind: GetVPCEConfigurationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetVPCEConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetVPCEConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVPCEConfigurationErrorKind::ArgumentException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVPCEConfigurationErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_account_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVPCEConfigurationErrorKind::ServiceAccountException(_)
        )
    }
}
impl std::error::Error for GetVPCEConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetVPCEConfigurationErrorKind::ArgumentException(_inner) => Some(_inner),
            GetVPCEConfigurationErrorKind::NotFoundException(_inner) => Some(_inner),
            GetVPCEConfigurationErrorKind::ServiceAccountException(_inner) => Some(_inner),
            GetVPCEConfigurationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct InstallToRemoteAccessSessionError {
    pub kind: InstallToRemoteAccessSessionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum InstallToRemoteAccessSessionErrorKind {
    ArgumentException(crate::error::ArgumentException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    ServiceAccountException(crate::error::ServiceAccountException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for InstallToRemoteAccessSessionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            InstallToRemoteAccessSessionErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            InstallToRemoteAccessSessionErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            InstallToRemoteAccessSessionErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            InstallToRemoteAccessSessionErrorKind::ServiceAccountException(_inner) => _inner.fmt(f),
            InstallToRemoteAccessSessionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for InstallToRemoteAccessSessionError {
    fn code(&self) -> Option<&str> {
        InstallToRemoteAccessSessionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl InstallToRemoteAccessSessionError {
    pub fn new(kind: InstallToRemoteAccessSessionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: InstallToRemoteAccessSessionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: InstallToRemoteAccessSessionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(
            &self.kind,
            InstallToRemoteAccessSessionErrorKind::ArgumentException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            InstallToRemoteAccessSessionErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            InstallToRemoteAccessSessionErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_account_exception(&self) -> bool {
        matches!(
            &self.kind,
            InstallToRemoteAccessSessionErrorKind::ServiceAccountException(_)
        )
    }
}
impl std::error::Error for InstallToRemoteAccessSessionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            InstallToRemoteAccessSessionErrorKind::ArgumentException(_inner) => Some(_inner),
            InstallToRemoteAccessSessionErrorKind::LimitExceededException(_inner) => Some(_inner),
            InstallToRemoteAccessSessionErrorKind::NotFoundException(_inner) => Some(_inner),
            InstallToRemoteAccessSessionErrorKind::ServiceAccountException(_inner) => Some(_inner),
            InstallToRemoteAccessSessionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListArtifactsError {
    pub kind: ListArtifactsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListArtifactsErrorKind {
    ArgumentException(crate::error::ArgumentException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    ServiceAccountException(crate::error::ServiceAccountException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListArtifactsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListArtifactsErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            ListArtifactsErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            ListArtifactsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ListArtifactsErrorKind::ServiceAccountException(_inner) => _inner.fmt(f),
            ListArtifactsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListArtifactsError {
    fn code(&self) -> Option<&str> {
        ListArtifactsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListArtifactsError {
    pub fn new(kind: ListArtifactsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListArtifactsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListArtifactsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(&self.kind, ListArtifactsErrorKind::ArgumentException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListArtifactsErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListArtifactsErrorKind::NotFoundException(_))
    }
    pub fn is_service_account_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListArtifactsErrorKind::ServiceAccountException(_)
        )
    }
}
impl std::error::Error for ListArtifactsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListArtifactsErrorKind::ArgumentException(_inner) => Some(_inner),
            ListArtifactsErrorKind::LimitExceededException(_inner) => Some(_inner),
            ListArtifactsErrorKind::NotFoundException(_inner) => Some(_inner),
            ListArtifactsErrorKind::ServiceAccountException(_inner) => Some(_inner),
            ListArtifactsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListDeviceInstancesError {
    pub kind: ListDeviceInstancesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListDeviceInstancesErrorKind {
    ArgumentException(crate::error::ArgumentException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    ServiceAccountException(crate::error::ServiceAccountException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListDeviceInstancesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListDeviceInstancesErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            ListDeviceInstancesErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            ListDeviceInstancesErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ListDeviceInstancesErrorKind::ServiceAccountException(_inner) => _inner.fmt(f),
            ListDeviceInstancesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListDeviceInstancesError {
    fn code(&self) -> Option<&str> {
        ListDeviceInstancesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListDeviceInstancesError {
    pub fn new(kind: ListDeviceInstancesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListDeviceInstancesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListDeviceInstancesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDeviceInstancesErrorKind::ArgumentException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDeviceInstancesErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDeviceInstancesErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_account_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDeviceInstancesErrorKind::ServiceAccountException(_)
        )
    }
}
impl std::error::Error for ListDeviceInstancesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListDeviceInstancesErrorKind::ArgumentException(_inner) => Some(_inner),
            ListDeviceInstancesErrorKind::LimitExceededException(_inner) => Some(_inner),
            ListDeviceInstancesErrorKind::NotFoundException(_inner) => Some(_inner),
            ListDeviceInstancesErrorKind::ServiceAccountException(_inner) => Some(_inner),
            ListDeviceInstancesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListDevicePoolsError {
    pub kind: ListDevicePoolsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListDevicePoolsErrorKind {
    ArgumentException(crate::error::ArgumentException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    ServiceAccountException(crate::error::ServiceAccountException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListDevicePoolsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListDevicePoolsErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            ListDevicePoolsErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            ListDevicePoolsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ListDevicePoolsErrorKind::ServiceAccountException(_inner) => _inner.fmt(f),
            ListDevicePoolsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListDevicePoolsError {
    fn code(&self) -> Option<&str> {
        ListDevicePoolsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListDevicePoolsError {
    pub fn new(kind: ListDevicePoolsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListDevicePoolsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListDevicePoolsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(&self.kind, ListDevicePoolsErrorKind::ArgumentException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDevicePoolsErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListDevicePoolsErrorKind::NotFoundException(_))
    }
    pub fn is_service_account_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDevicePoolsErrorKind::ServiceAccountException(_)
        )
    }
}
impl std::error::Error for ListDevicePoolsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListDevicePoolsErrorKind::ArgumentException(_inner) => Some(_inner),
            ListDevicePoolsErrorKind::LimitExceededException(_inner) => Some(_inner),
            ListDevicePoolsErrorKind::NotFoundException(_inner) => Some(_inner),
            ListDevicePoolsErrorKind::ServiceAccountException(_inner) => Some(_inner),
            ListDevicePoolsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListDevicesError {
    pub kind: ListDevicesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListDevicesErrorKind {
    ArgumentException(crate::error::ArgumentException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    ServiceAccountException(crate::error::ServiceAccountException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListDevicesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListDevicesErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            ListDevicesErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            ListDevicesErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ListDevicesErrorKind::ServiceAccountException(_inner) => _inner.fmt(f),
            ListDevicesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListDevicesError {
    fn code(&self) -> Option<&str> {
        ListDevicesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListDevicesError {
    pub fn new(kind: ListDevicesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListDevicesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListDevicesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(&self.kind, ListDevicesErrorKind::ArgumentException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, ListDevicesErrorKind::LimitExceededException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListDevicesErrorKind::NotFoundException(_))
    }
    pub fn is_service_account_exception(&self) -> bool {
        matches!(&self.kind, ListDevicesErrorKind::ServiceAccountException(_))
    }
}
impl std::error::Error for ListDevicesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListDevicesErrorKind::ArgumentException(_inner) => Some(_inner),
            ListDevicesErrorKind::LimitExceededException(_inner) => Some(_inner),
            ListDevicesErrorKind::NotFoundException(_inner) => Some(_inner),
            ListDevicesErrorKind::ServiceAccountException(_inner) => Some(_inner),
            ListDevicesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListInstanceProfilesError {
    pub kind: ListInstanceProfilesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListInstanceProfilesErrorKind {
    ArgumentException(crate::error::ArgumentException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    ServiceAccountException(crate::error::ServiceAccountException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListInstanceProfilesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListInstanceProfilesErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            ListInstanceProfilesErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            ListInstanceProfilesErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ListInstanceProfilesErrorKind::ServiceAccountException(_inner) => _inner.fmt(f),
            ListInstanceProfilesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListInstanceProfilesError {
    fn code(&self) -> Option<&str> {
        ListInstanceProfilesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListInstanceProfilesError {
    pub fn new(kind: ListInstanceProfilesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListInstanceProfilesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListInstanceProfilesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListInstanceProfilesErrorKind::ArgumentException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListInstanceProfilesErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListInstanceProfilesErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_account_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListInstanceProfilesErrorKind::ServiceAccountException(_)
        )
    }
}
impl std::error::Error for ListInstanceProfilesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListInstanceProfilesErrorKind::ArgumentException(_inner) => Some(_inner),
            ListInstanceProfilesErrorKind::LimitExceededException(_inner) => Some(_inner),
            ListInstanceProfilesErrorKind::NotFoundException(_inner) => Some(_inner),
            ListInstanceProfilesErrorKind::ServiceAccountException(_inner) => Some(_inner),
            ListInstanceProfilesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListJobsError {
    pub kind: ListJobsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListJobsErrorKind {
    ArgumentException(crate::error::ArgumentException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    ServiceAccountException(crate::error::ServiceAccountException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListJobsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListJobsErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            ListJobsErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            ListJobsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ListJobsErrorKind::ServiceAccountException(_inner) => _inner.fmt(f),
            ListJobsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListJobsError {
    fn code(&self) -> Option<&str> {
        ListJobsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListJobsError {
    pub fn new(kind: ListJobsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListJobsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListJobsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(&self.kind, ListJobsErrorKind::ArgumentException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, ListJobsErrorKind::LimitExceededException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListJobsErrorKind::NotFoundException(_))
    }
    pub fn is_service_account_exception(&self) -> bool {
        matches!(&self.kind, ListJobsErrorKind::ServiceAccountException(_))
    }
}
impl std::error::Error for ListJobsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListJobsErrorKind::ArgumentException(_inner) => Some(_inner),
            ListJobsErrorKind::LimitExceededException(_inner) => Some(_inner),
            ListJobsErrorKind::NotFoundException(_inner) => Some(_inner),
            ListJobsErrorKind::ServiceAccountException(_inner) => Some(_inner),
            ListJobsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListNetworkProfilesError {
    pub kind: ListNetworkProfilesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListNetworkProfilesErrorKind {
    ArgumentException(crate::error::ArgumentException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    ServiceAccountException(crate::error::ServiceAccountException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListNetworkProfilesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListNetworkProfilesErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            ListNetworkProfilesErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            ListNetworkProfilesErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ListNetworkProfilesErrorKind::ServiceAccountException(_inner) => _inner.fmt(f),
            ListNetworkProfilesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListNetworkProfilesError {
    fn code(&self) -> Option<&str> {
        ListNetworkProfilesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListNetworkProfilesError {
    pub fn new(kind: ListNetworkProfilesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListNetworkProfilesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListNetworkProfilesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListNetworkProfilesErrorKind::ArgumentException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListNetworkProfilesErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListNetworkProfilesErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_account_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListNetworkProfilesErrorKind::ServiceAccountException(_)
        )
    }
}
impl std::error::Error for ListNetworkProfilesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListNetworkProfilesErrorKind::ArgumentException(_inner) => Some(_inner),
            ListNetworkProfilesErrorKind::LimitExceededException(_inner) => Some(_inner),
            ListNetworkProfilesErrorKind::NotFoundException(_inner) => Some(_inner),
            ListNetworkProfilesErrorKind::ServiceAccountException(_inner) => Some(_inner),
            ListNetworkProfilesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListOfferingPromotionsError {
    pub kind: ListOfferingPromotionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListOfferingPromotionsErrorKind {
    ArgumentException(crate::error::ArgumentException),
    LimitExceededException(crate::error::LimitExceededException),
    NotEligibleException(crate::error::NotEligibleException),
    NotFoundException(crate::error::NotFoundException),
    ServiceAccountException(crate::error::ServiceAccountException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListOfferingPromotionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListOfferingPromotionsErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            ListOfferingPromotionsErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            ListOfferingPromotionsErrorKind::NotEligibleException(_inner) => _inner.fmt(f),
            ListOfferingPromotionsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ListOfferingPromotionsErrorKind::ServiceAccountException(_inner) => _inner.fmt(f),
            ListOfferingPromotionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListOfferingPromotionsError {
    fn code(&self) -> Option<&str> {
        ListOfferingPromotionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListOfferingPromotionsError {
    pub fn new(kind: ListOfferingPromotionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListOfferingPromotionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListOfferingPromotionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListOfferingPromotionsErrorKind::ArgumentException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListOfferingPromotionsErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_eligible_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListOfferingPromotionsErrorKind::NotEligibleException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListOfferingPromotionsErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_account_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListOfferingPromotionsErrorKind::ServiceAccountException(_)
        )
    }
}
impl std::error::Error for ListOfferingPromotionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListOfferingPromotionsErrorKind::ArgumentException(_inner) => Some(_inner),
            ListOfferingPromotionsErrorKind::LimitExceededException(_inner) => Some(_inner),
            ListOfferingPromotionsErrorKind::NotEligibleException(_inner) => Some(_inner),
            ListOfferingPromotionsErrorKind::NotFoundException(_inner) => Some(_inner),
            ListOfferingPromotionsErrorKind::ServiceAccountException(_inner) => Some(_inner),
            ListOfferingPromotionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListOfferingsError {
    pub kind: ListOfferingsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListOfferingsErrorKind {
    ArgumentException(crate::error::ArgumentException),
    LimitExceededException(crate::error::LimitExceededException),
    NotEligibleException(crate::error::NotEligibleException),
    NotFoundException(crate::error::NotFoundException),
    ServiceAccountException(crate::error::ServiceAccountException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListOfferingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListOfferingsErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            ListOfferingsErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            ListOfferingsErrorKind::NotEligibleException(_inner) => _inner.fmt(f),
            ListOfferingsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ListOfferingsErrorKind::ServiceAccountException(_inner) => _inner.fmt(f),
            ListOfferingsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListOfferingsError {
    fn code(&self) -> Option<&str> {
        ListOfferingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListOfferingsError {
    pub fn new(kind: ListOfferingsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListOfferingsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListOfferingsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(&self.kind, ListOfferingsErrorKind::ArgumentException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListOfferingsErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_eligible_exception(&self) -> bool {
        matches!(&self.kind, ListOfferingsErrorKind::NotEligibleException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListOfferingsErrorKind::NotFoundException(_))
    }
    pub fn is_service_account_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListOfferingsErrorKind::ServiceAccountException(_)
        )
    }
}
impl std::error::Error for ListOfferingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListOfferingsErrorKind::ArgumentException(_inner) => Some(_inner),
            ListOfferingsErrorKind::LimitExceededException(_inner) => Some(_inner),
            ListOfferingsErrorKind::NotEligibleException(_inner) => Some(_inner),
            ListOfferingsErrorKind::NotFoundException(_inner) => Some(_inner),
            ListOfferingsErrorKind::ServiceAccountException(_inner) => Some(_inner),
            ListOfferingsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListOfferingTransactionsError {
    pub kind: ListOfferingTransactionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListOfferingTransactionsErrorKind {
    ArgumentException(crate::error::ArgumentException),
    LimitExceededException(crate::error::LimitExceededException),
    NotEligibleException(crate::error::NotEligibleException),
    NotFoundException(crate::error::NotFoundException),
    ServiceAccountException(crate::error::ServiceAccountException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListOfferingTransactionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListOfferingTransactionsErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            ListOfferingTransactionsErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            ListOfferingTransactionsErrorKind::NotEligibleException(_inner) => _inner.fmt(f),
            ListOfferingTransactionsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ListOfferingTransactionsErrorKind::ServiceAccountException(_inner) => _inner.fmt(f),
            ListOfferingTransactionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListOfferingTransactionsError {
    fn code(&self) -> Option<&str> {
        ListOfferingTransactionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListOfferingTransactionsError {
    pub fn new(kind: ListOfferingTransactionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListOfferingTransactionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListOfferingTransactionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListOfferingTransactionsErrorKind::ArgumentException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListOfferingTransactionsErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_eligible_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListOfferingTransactionsErrorKind::NotEligibleException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListOfferingTransactionsErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_account_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListOfferingTransactionsErrorKind::ServiceAccountException(_)
        )
    }
}
impl std::error::Error for ListOfferingTransactionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListOfferingTransactionsErrorKind::ArgumentException(_inner) => Some(_inner),
            ListOfferingTransactionsErrorKind::LimitExceededException(_inner) => Some(_inner),
            ListOfferingTransactionsErrorKind::NotEligibleException(_inner) => Some(_inner),
            ListOfferingTransactionsErrorKind::NotFoundException(_inner) => Some(_inner),
            ListOfferingTransactionsErrorKind::ServiceAccountException(_inner) => Some(_inner),
            ListOfferingTransactionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListProjectsError {
    pub kind: ListProjectsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListProjectsErrorKind {
    ArgumentException(crate::error::ArgumentException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    ServiceAccountException(crate::error::ServiceAccountException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListProjectsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListProjectsErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            ListProjectsErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            ListProjectsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ListProjectsErrorKind::ServiceAccountException(_inner) => _inner.fmt(f),
            ListProjectsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListProjectsError {
    fn code(&self) -> Option<&str> {
        ListProjectsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListProjectsError {
    pub fn new(kind: ListProjectsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListProjectsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListProjectsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(&self.kind, ListProjectsErrorKind::ArgumentException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, ListProjectsErrorKind::LimitExceededException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListProjectsErrorKind::NotFoundException(_))
    }
    pub fn is_service_account_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListProjectsErrorKind::ServiceAccountException(_)
        )
    }
}
impl std::error::Error for ListProjectsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListProjectsErrorKind::ArgumentException(_inner) => Some(_inner),
            ListProjectsErrorKind::LimitExceededException(_inner) => Some(_inner),
            ListProjectsErrorKind::NotFoundException(_inner) => Some(_inner),
            ListProjectsErrorKind::ServiceAccountException(_inner) => Some(_inner),
            ListProjectsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListRemoteAccessSessionsError {
    pub kind: ListRemoteAccessSessionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListRemoteAccessSessionsErrorKind {
    ArgumentException(crate::error::ArgumentException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    ServiceAccountException(crate::error::ServiceAccountException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListRemoteAccessSessionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListRemoteAccessSessionsErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            ListRemoteAccessSessionsErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            ListRemoteAccessSessionsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ListRemoteAccessSessionsErrorKind::ServiceAccountException(_inner) => _inner.fmt(f),
            ListRemoteAccessSessionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListRemoteAccessSessionsError {
    fn code(&self) -> Option<&str> {
        ListRemoteAccessSessionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListRemoteAccessSessionsError {
    pub fn new(kind: ListRemoteAccessSessionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListRemoteAccessSessionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListRemoteAccessSessionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRemoteAccessSessionsErrorKind::ArgumentException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRemoteAccessSessionsErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRemoteAccessSessionsErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_account_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRemoteAccessSessionsErrorKind::ServiceAccountException(_)
        )
    }
}
impl std::error::Error for ListRemoteAccessSessionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListRemoteAccessSessionsErrorKind::ArgumentException(_inner) => Some(_inner),
            ListRemoteAccessSessionsErrorKind::LimitExceededException(_inner) => Some(_inner),
            ListRemoteAccessSessionsErrorKind::NotFoundException(_inner) => Some(_inner),
            ListRemoteAccessSessionsErrorKind::ServiceAccountException(_inner) => Some(_inner),
            ListRemoteAccessSessionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListRunsError {
    pub kind: ListRunsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListRunsErrorKind {
    ArgumentException(crate::error::ArgumentException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    ServiceAccountException(crate::error::ServiceAccountException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListRunsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListRunsErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            ListRunsErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            ListRunsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ListRunsErrorKind::ServiceAccountException(_inner) => _inner.fmt(f),
            ListRunsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListRunsError {
    fn code(&self) -> Option<&str> {
        ListRunsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListRunsError {
    pub fn new(kind: ListRunsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListRunsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListRunsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(&self.kind, ListRunsErrorKind::ArgumentException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, ListRunsErrorKind::LimitExceededException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListRunsErrorKind::NotFoundException(_))
    }
    pub fn is_service_account_exception(&self) -> bool {
        matches!(&self.kind, ListRunsErrorKind::ServiceAccountException(_))
    }
}
impl std::error::Error for ListRunsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListRunsErrorKind::ArgumentException(_inner) => Some(_inner),
            ListRunsErrorKind::LimitExceededException(_inner) => Some(_inner),
            ListRunsErrorKind::NotFoundException(_inner) => Some(_inner),
            ListRunsErrorKind::ServiceAccountException(_inner) => Some(_inner),
            ListRunsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListSamplesError {
    pub kind: ListSamplesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListSamplesErrorKind {
    ArgumentException(crate::error::ArgumentException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    ServiceAccountException(crate::error::ServiceAccountException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListSamplesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListSamplesErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            ListSamplesErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            ListSamplesErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ListSamplesErrorKind::ServiceAccountException(_inner) => _inner.fmt(f),
            ListSamplesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListSamplesError {
    fn code(&self) -> Option<&str> {
        ListSamplesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListSamplesError {
    pub fn new(kind: ListSamplesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListSamplesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListSamplesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(&self.kind, ListSamplesErrorKind::ArgumentException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, ListSamplesErrorKind::LimitExceededException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListSamplesErrorKind::NotFoundException(_))
    }
    pub fn is_service_account_exception(&self) -> bool {
        matches!(&self.kind, ListSamplesErrorKind::ServiceAccountException(_))
    }
}
impl std::error::Error for ListSamplesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListSamplesErrorKind::ArgumentException(_inner) => Some(_inner),
            ListSamplesErrorKind::LimitExceededException(_inner) => Some(_inner),
            ListSamplesErrorKind::NotFoundException(_inner) => Some(_inner),
            ListSamplesErrorKind::ServiceAccountException(_inner) => Some(_inner),
            ListSamplesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListSuitesError {
    pub kind: ListSuitesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListSuitesErrorKind {
    ArgumentException(crate::error::ArgumentException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    ServiceAccountException(crate::error::ServiceAccountException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListSuitesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListSuitesErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            ListSuitesErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            ListSuitesErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ListSuitesErrorKind::ServiceAccountException(_inner) => _inner.fmt(f),
            ListSuitesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListSuitesError {
    fn code(&self) -> Option<&str> {
        ListSuitesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListSuitesError {
    pub fn new(kind: ListSuitesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListSuitesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListSuitesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(&self.kind, ListSuitesErrorKind::ArgumentException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, ListSuitesErrorKind::LimitExceededException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListSuitesErrorKind::NotFoundException(_))
    }
    pub fn is_service_account_exception(&self) -> bool {
        matches!(&self.kind, ListSuitesErrorKind::ServiceAccountException(_))
    }
}
impl std::error::Error for ListSuitesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListSuitesErrorKind::ArgumentException(_inner) => Some(_inner),
            ListSuitesErrorKind::LimitExceededException(_inner) => Some(_inner),
            ListSuitesErrorKind::NotFoundException(_inner) => Some(_inner),
            ListSuitesErrorKind::ServiceAccountException(_inner) => Some(_inner),
            ListSuitesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTagsForResourceError {
    pub kind: ListTagsForResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTagsForResourceErrorKind {
    ArgumentException(crate::error::ArgumentException),
    NotFoundException(crate::error::NotFoundException),
    TagOperationException(crate::error::TagOperationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTagsForResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTagsForResourceErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::TagOperationException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTagsForResourceError {
    fn code(&self) -> Option<&str> {
        ListTagsForResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTagsForResourceError {
    pub fn new(kind: ListTagsForResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::ArgumentException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::NotFoundException(_)
        )
    }
    pub fn is_tag_operation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::TagOperationException(_)
        )
    }
}
impl std::error::Error for ListTagsForResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTagsForResourceErrorKind::ArgumentException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::NotFoundException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::TagOperationException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTestGridProjectsError {
    pub kind: ListTestGridProjectsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTestGridProjectsErrorKind {
    ArgumentException(crate::error::ArgumentException),
    InternalServiceException(crate::error::InternalServiceException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTestGridProjectsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTestGridProjectsErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            ListTestGridProjectsErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            ListTestGridProjectsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTestGridProjectsError {
    fn code(&self) -> Option<&str> {
        ListTestGridProjectsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTestGridProjectsError {
    pub fn new(kind: ListTestGridProjectsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTestGridProjectsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTestGridProjectsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTestGridProjectsErrorKind::ArgumentException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTestGridProjectsErrorKind::InternalServiceException(_)
        )
    }
}
impl std::error::Error for ListTestGridProjectsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTestGridProjectsErrorKind::ArgumentException(_inner) => Some(_inner),
            ListTestGridProjectsErrorKind::InternalServiceException(_inner) => Some(_inner),
            ListTestGridProjectsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTestGridSessionActionsError {
    pub kind: ListTestGridSessionActionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTestGridSessionActionsErrorKind {
    ArgumentException(crate::error::ArgumentException),
    InternalServiceException(crate::error::InternalServiceException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTestGridSessionActionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTestGridSessionActionsErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            ListTestGridSessionActionsErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            ListTestGridSessionActionsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ListTestGridSessionActionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTestGridSessionActionsError {
    fn code(&self) -> Option<&str> {
        ListTestGridSessionActionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTestGridSessionActionsError {
    pub fn new(kind: ListTestGridSessionActionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTestGridSessionActionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTestGridSessionActionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTestGridSessionActionsErrorKind::ArgumentException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTestGridSessionActionsErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTestGridSessionActionsErrorKind::NotFoundException(_)
        )
    }
}
impl std::error::Error for ListTestGridSessionActionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTestGridSessionActionsErrorKind::ArgumentException(_inner) => Some(_inner),
            ListTestGridSessionActionsErrorKind::InternalServiceException(_inner) => Some(_inner),
            ListTestGridSessionActionsErrorKind::NotFoundException(_inner) => Some(_inner),
            ListTestGridSessionActionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTestGridSessionArtifactsError {
    pub kind: ListTestGridSessionArtifactsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTestGridSessionArtifactsErrorKind {
    ArgumentException(crate::error::ArgumentException),
    InternalServiceException(crate::error::InternalServiceException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTestGridSessionArtifactsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTestGridSessionArtifactsErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            ListTestGridSessionArtifactsErrorKind::InternalServiceException(_inner) => {
                _inner.fmt(f)
            }
            ListTestGridSessionArtifactsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ListTestGridSessionArtifactsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTestGridSessionArtifactsError {
    fn code(&self) -> Option<&str> {
        ListTestGridSessionArtifactsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTestGridSessionArtifactsError {
    pub fn new(kind: ListTestGridSessionArtifactsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTestGridSessionArtifactsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTestGridSessionArtifactsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTestGridSessionArtifactsErrorKind::ArgumentException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTestGridSessionArtifactsErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTestGridSessionArtifactsErrorKind::NotFoundException(_)
        )
    }
}
impl std::error::Error for ListTestGridSessionArtifactsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTestGridSessionArtifactsErrorKind::ArgumentException(_inner) => Some(_inner),
            ListTestGridSessionArtifactsErrorKind::InternalServiceException(_inner) => Some(_inner),
            ListTestGridSessionArtifactsErrorKind::NotFoundException(_inner) => Some(_inner),
            ListTestGridSessionArtifactsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTestGridSessionsError {
    pub kind: ListTestGridSessionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTestGridSessionsErrorKind {
    ArgumentException(crate::error::ArgumentException),
    InternalServiceException(crate::error::InternalServiceException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTestGridSessionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTestGridSessionsErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            ListTestGridSessionsErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            ListTestGridSessionsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ListTestGridSessionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTestGridSessionsError {
    fn code(&self) -> Option<&str> {
        ListTestGridSessionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTestGridSessionsError {
    pub fn new(kind: ListTestGridSessionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTestGridSessionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTestGridSessionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTestGridSessionsErrorKind::ArgumentException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTestGridSessionsErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTestGridSessionsErrorKind::NotFoundException(_)
        )
    }
}
impl std::error::Error for ListTestGridSessionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTestGridSessionsErrorKind::ArgumentException(_inner) => Some(_inner),
            ListTestGridSessionsErrorKind::InternalServiceException(_inner) => Some(_inner),
            ListTestGridSessionsErrorKind::NotFoundException(_inner) => Some(_inner),
            ListTestGridSessionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTestsError {
    pub kind: ListTestsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTestsErrorKind {
    ArgumentException(crate::error::ArgumentException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    ServiceAccountException(crate::error::ServiceAccountException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTestsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTestsErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            ListTestsErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            ListTestsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ListTestsErrorKind::ServiceAccountException(_inner) => _inner.fmt(f),
            ListTestsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTestsError {
    fn code(&self) -> Option<&str> {
        ListTestsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTestsError {
    pub fn new(kind: ListTestsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTestsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTestsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(&self.kind, ListTestsErrorKind::ArgumentException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, ListTestsErrorKind::LimitExceededException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListTestsErrorKind::NotFoundException(_))
    }
    pub fn is_service_account_exception(&self) -> bool {
        matches!(&self.kind, ListTestsErrorKind::ServiceAccountException(_))
    }
}
impl std::error::Error for ListTestsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTestsErrorKind::ArgumentException(_inner) => Some(_inner),
            ListTestsErrorKind::LimitExceededException(_inner) => Some(_inner),
            ListTestsErrorKind::NotFoundException(_inner) => Some(_inner),
            ListTestsErrorKind::ServiceAccountException(_inner) => Some(_inner),
            ListTestsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListUniqueProblemsError {
    pub kind: ListUniqueProblemsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListUniqueProblemsErrorKind {
    ArgumentException(crate::error::ArgumentException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    ServiceAccountException(crate::error::ServiceAccountException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListUniqueProblemsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListUniqueProblemsErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            ListUniqueProblemsErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            ListUniqueProblemsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ListUniqueProblemsErrorKind::ServiceAccountException(_inner) => _inner.fmt(f),
            ListUniqueProblemsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListUniqueProblemsError {
    fn code(&self) -> Option<&str> {
        ListUniqueProblemsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListUniqueProblemsError {
    pub fn new(kind: ListUniqueProblemsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListUniqueProblemsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListUniqueProblemsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListUniqueProblemsErrorKind::ArgumentException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListUniqueProblemsErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListUniqueProblemsErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_account_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListUniqueProblemsErrorKind::ServiceAccountException(_)
        )
    }
}
impl std::error::Error for ListUniqueProblemsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListUniqueProblemsErrorKind::ArgumentException(_inner) => Some(_inner),
            ListUniqueProblemsErrorKind::LimitExceededException(_inner) => Some(_inner),
            ListUniqueProblemsErrorKind::NotFoundException(_inner) => Some(_inner),
            ListUniqueProblemsErrorKind::ServiceAccountException(_inner) => Some(_inner),
            ListUniqueProblemsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListUploadsError {
    pub kind: ListUploadsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListUploadsErrorKind {
    ArgumentException(crate::error::ArgumentException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    ServiceAccountException(crate::error::ServiceAccountException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListUploadsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListUploadsErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            ListUploadsErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            ListUploadsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ListUploadsErrorKind::ServiceAccountException(_inner) => _inner.fmt(f),
            ListUploadsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListUploadsError {
    fn code(&self) -> Option<&str> {
        ListUploadsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListUploadsError {
    pub fn new(kind: ListUploadsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListUploadsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListUploadsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(&self.kind, ListUploadsErrorKind::ArgumentException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, ListUploadsErrorKind::LimitExceededException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListUploadsErrorKind::NotFoundException(_))
    }
    pub fn is_service_account_exception(&self) -> bool {
        matches!(&self.kind, ListUploadsErrorKind::ServiceAccountException(_))
    }
}
impl std::error::Error for ListUploadsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListUploadsErrorKind::ArgumentException(_inner) => Some(_inner),
            ListUploadsErrorKind::LimitExceededException(_inner) => Some(_inner),
            ListUploadsErrorKind::NotFoundException(_inner) => Some(_inner),
            ListUploadsErrorKind::ServiceAccountException(_inner) => Some(_inner),
            ListUploadsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListVPCEConfigurationsError {
    pub kind: ListVPCEConfigurationsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListVPCEConfigurationsErrorKind {
    ArgumentException(crate::error::ArgumentException),
    ServiceAccountException(crate::error::ServiceAccountException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListVPCEConfigurationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListVPCEConfigurationsErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            ListVPCEConfigurationsErrorKind::ServiceAccountException(_inner) => _inner.fmt(f),
            ListVPCEConfigurationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListVPCEConfigurationsError {
    fn code(&self) -> Option<&str> {
        ListVPCEConfigurationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListVPCEConfigurationsError {
    pub fn new(kind: ListVPCEConfigurationsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListVPCEConfigurationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListVPCEConfigurationsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVPCEConfigurationsErrorKind::ArgumentException(_)
        )
    }
    pub fn is_service_account_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVPCEConfigurationsErrorKind::ServiceAccountException(_)
        )
    }
}
impl std::error::Error for ListVPCEConfigurationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListVPCEConfigurationsErrorKind::ArgumentException(_inner) => Some(_inner),
            ListVPCEConfigurationsErrorKind::ServiceAccountException(_inner) => Some(_inner),
            ListVPCEConfigurationsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PurchaseOfferingError {
    pub kind: PurchaseOfferingErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PurchaseOfferingErrorKind {
    ArgumentException(crate::error::ArgumentException),
    LimitExceededException(crate::error::LimitExceededException),
    NotEligibleException(crate::error::NotEligibleException),
    NotFoundException(crate::error::NotFoundException),
    ServiceAccountException(crate::error::ServiceAccountException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PurchaseOfferingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PurchaseOfferingErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            PurchaseOfferingErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            PurchaseOfferingErrorKind::NotEligibleException(_inner) => _inner.fmt(f),
            PurchaseOfferingErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            PurchaseOfferingErrorKind::ServiceAccountException(_inner) => _inner.fmt(f),
            PurchaseOfferingErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PurchaseOfferingError {
    fn code(&self) -> Option<&str> {
        PurchaseOfferingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PurchaseOfferingError {
    pub fn new(kind: PurchaseOfferingErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PurchaseOfferingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PurchaseOfferingErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(&self.kind, PurchaseOfferingErrorKind::ArgumentException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            PurchaseOfferingErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_eligible_exception(&self) -> bool {
        matches!(
            &self.kind,
            PurchaseOfferingErrorKind::NotEligibleException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, PurchaseOfferingErrorKind::NotFoundException(_))
    }
    pub fn is_service_account_exception(&self) -> bool {
        matches!(
            &self.kind,
            PurchaseOfferingErrorKind::ServiceAccountException(_)
        )
    }
}
impl std::error::Error for PurchaseOfferingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PurchaseOfferingErrorKind::ArgumentException(_inner) => Some(_inner),
            PurchaseOfferingErrorKind::LimitExceededException(_inner) => Some(_inner),
            PurchaseOfferingErrorKind::NotEligibleException(_inner) => Some(_inner),
            PurchaseOfferingErrorKind::NotFoundException(_inner) => Some(_inner),
            PurchaseOfferingErrorKind::ServiceAccountException(_inner) => Some(_inner),
            PurchaseOfferingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RenewOfferingError {
    pub kind: RenewOfferingErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RenewOfferingErrorKind {
    ArgumentException(crate::error::ArgumentException),
    LimitExceededException(crate::error::LimitExceededException),
    NotEligibleException(crate::error::NotEligibleException),
    NotFoundException(crate::error::NotFoundException),
    ServiceAccountException(crate::error::ServiceAccountException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RenewOfferingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RenewOfferingErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            RenewOfferingErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            RenewOfferingErrorKind::NotEligibleException(_inner) => _inner.fmt(f),
            RenewOfferingErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            RenewOfferingErrorKind::ServiceAccountException(_inner) => _inner.fmt(f),
            RenewOfferingErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RenewOfferingError {
    fn code(&self) -> Option<&str> {
        RenewOfferingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RenewOfferingError {
    pub fn new(kind: RenewOfferingErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RenewOfferingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RenewOfferingErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(&self.kind, RenewOfferingErrorKind::ArgumentException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            RenewOfferingErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_eligible_exception(&self) -> bool {
        matches!(&self.kind, RenewOfferingErrorKind::NotEligibleException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, RenewOfferingErrorKind::NotFoundException(_))
    }
    pub fn is_service_account_exception(&self) -> bool {
        matches!(
            &self.kind,
            RenewOfferingErrorKind::ServiceAccountException(_)
        )
    }
}
impl std::error::Error for RenewOfferingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RenewOfferingErrorKind::ArgumentException(_inner) => Some(_inner),
            RenewOfferingErrorKind::LimitExceededException(_inner) => Some(_inner),
            RenewOfferingErrorKind::NotEligibleException(_inner) => Some(_inner),
            RenewOfferingErrorKind::NotFoundException(_inner) => Some(_inner),
            RenewOfferingErrorKind::ServiceAccountException(_inner) => Some(_inner),
            RenewOfferingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ScheduleRunError {
    pub kind: ScheduleRunErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ScheduleRunErrorKind {
    ArgumentException(crate::error::ArgumentException),
    IdempotencyException(crate::error::IdempotencyException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    ServiceAccountException(crate::error::ServiceAccountException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ScheduleRunError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ScheduleRunErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            ScheduleRunErrorKind::IdempotencyException(_inner) => _inner.fmt(f),
            ScheduleRunErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            ScheduleRunErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ScheduleRunErrorKind::ServiceAccountException(_inner) => _inner.fmt(f),
            ScheduleRunErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ScheduleRunError {
    fn code(&self) -> Option<&str> {
        ScheduleRunError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ScheduleRunError {
    pub fn new(kind: ScheduleRunErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ScheduleRunErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ScheduleRunErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(&self.kind, ScheduleRunErrorKind::ArgumentException(_))
    }
    pub fn is_idempotency_exception(&self) -> bool {
        matches!(&self.kind, ScheduleRunErrorKind::IdempotencyException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, ScheduleRunErrorKind::LimitExceededException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, ScheduleRunErrorKind::NotFoundException(_))
    }
    pub fn is_service_account_exception(&self) -> bool {
        matches!(&self.kind, ScheduleRunErrorKind::ServiceAccountException(_))
    }
}
impl std::error::Error for ScheduleRunError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ScheduleRunErrorKind::ArgumentException(_inner) => Some(_inner),
            ScheduleRunErrorKind::IdempotencyException(_inner) => Some(_inner),
            ScheduleRunErrorKind::LimitExceededException(_inner) => Some(_inner),
            ScheduleRunErrorKind::NotFoundException(_inner) => Some(_inner),
            ScheduleRunErrorKind::ServiceAccountException(_inner) => Some(_inner),
            ScheduleRunErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StopJobError {
    pub kind: StopJobErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StopJobErrorKind {
    ArgumentException(crate::error::ArgumentException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    ServiceAccountException(crate::error::ServiceAccountException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StopJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StopJobErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            StopJobErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            StopJobErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            StopJobErrorKind::ServiceAccountException(_inner) => _inner.fmt(f),
            StopJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StopJobError {
    fn code(&self) -> Option<&str> {
        StopJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StopJobError {
    pub fn new(kind: StopJobErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StopJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StopJobErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(&self.kind, StopJobErrorKind::ArgumentException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, StopJobErrorKind::LimitExceededException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, StopJobErrorKind::NotFoundException(_))
    }
    pub fn is_service_account_exception(&self) -> bool {
        matches!(&self.kind, StopJobErrorKind::ServiceAccountException(_))
    }
}
impl std::error::Error for StopJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StopJobErrorKind::ArgumentException(_inner) => Some(_inner),
            StopJobErrorKind::LimitExceededException(_inner) => Some(_inner),
            StopJobErrorKind::NotFoundException(_inner) => Some(_inner),
            StopJobErrorKind::ServiceAccountException(_inner) => Some(_inner),
            StopJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StopRemoteAccessSessionError {
    pub kind: StopRemoteAccessSessionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StopRemoteAccessSessionErrorKind {
    ArgumentException(crate::error::ArgumentException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    ServiceAccountException(crate::error::ServiceAccountException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StopRemoteAccessSessionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StopRemoteAccessSessionErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            StopRemoteAccessSessionErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            StopRemoteAccessSessionErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            StopRemoteAccessSessionErrorKind::ServiceAccountException(_inner) => _inner.fmt(f),
            StopRemoteAccessSessionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StopRemoteAccessSessionError {
    fn code(&self) -> Option<&str> {
        StopRemoteAccessSessionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StopRemoteAccessSessionError {
    pub fn new(kind: StopRemoteAccessSessionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StopRemoteAccessSessionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StopRemoteAccessSessionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopRemoteAccessSessionErrorKind::ArgumentException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopRemoteAccessSessionErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopRemoteAccessSessionErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_account_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopRemoteAccessSessionErrorKind::ServiceAccountException(_)
        )
    }
}
impl std::error::Error for StopRemoteAccessSessionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StopRemoteAccessSessionErrorKind::ArgumentException(_inner) => Some(_inner),
            StopRemoteAccessSessionErrorKind::LimitExceededException(_inner) => Some(_inner),
            StopRemoteAccessSessionErrorKind::NotFoundException(_inner) => Some(_inner),
            StopRemoteAccessSessionErrorKind::ServiceAccountException(_inner) => Some(_inner),
            StopRemoteAccessSessionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StopRunError {
    pub kind: StopRunErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StopRunErrorKind {
    ArgumentException(crate::error::ArgumentException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    ServiceAccountException(crate::error::ServiceAccountException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StopRunError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StopRunErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            StopRunErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            StopRunErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            StopRunErrorKind::ServiceAccountException(_inner) => _inner.fmt(f),
            StopRunErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StopRunError {
    fn code(&self) -> Option<&str> {
        StopRunError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StopRunError {
    pub fn new(kind: StopRunErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StopRunErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StopRunErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(&self.kind, StopRunErrorKind::ArgumentException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, StopRunErrorKind::LimitExceededException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, StopRunErrorKind::NotFoundException(_))
    }
    pub fn is_service_account_exception(&self) -> bool {
        matches!(&self.kind, StopRunErrorKind::ServiceAccountException(_))
    }
}
impl std::error::Error for StopRunError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StopRunErrorKind::ArgumentException(_inner) => Some(_inner),
            StopRunErrorKind::LimitExceededException(_inner) => Some(_inner),
            StopRunErrorKind::NotFoundException(_inner) => Some(_inner),
            StopRunErrorKind::ServiceAccountException(_inner) => Some(_inner),
            StopRunErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagResourceError {
    pub kind: TagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagResourceErrorKind {
    ArgumentException(crate::error::ArgumentException),
    NotFoundException(crate::error::NotFoundException),
    TagOperationException(crate::error::TagOperationException),
    TagPolicyException(crate::error::TagPolicyException),
    TooManyTagsException(crate::error::TooManyTagsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagResourceErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::TagOperationException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::TagPolicyException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::TooManyTagsException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TagResourceError {
    fn code(&self) -> Option<&str> {
        TagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagResourceError {
    pub fn new(kind: TagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::ArgumentException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::NotFoundException(_))
    }
    pub fn is_tag_operation_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::TagOperationException(_))
    }
    pub fn is_tag_policy_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::TagPolicyException(_))
    }
    pub fn is_too_many_tags_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::TooManyTagsException(_))
    }
}
impl std::error::Error for TagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagResourceErrorKind::ArgumentException(_inner) => Some(_inner),
            TagResourceErrorKind::NotFoundException(_inner) => Some(_inner),
            TagResourceErrorKind::TagOperationException(_inner) => Some(_inner),
            TagResourceErrorKind::TagPolicyException(_inner) => Some(_inner),
            TagResourceErrorKind::TooManyTagsException(_inner) => Some(_inner),
            TagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagResourceError {
    pub kind: UntagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagResourceErrorKind {
    ArgumentException(crate::error::ArgumentException),
    NotFoundException(crate::error::NotFoundException),
    TagOperationException(crate::error::TagOperationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UntagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagResourceErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::TagOperationException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UntagResourceError {
    fn code(&self) -> Option<&str> {
        UntagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagResourceError {
    pub fn new(kind: UntagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UntagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UntagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::ArgumentException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::NotFoundException(_))
    }
    pub fn is_tag_operation_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::TagOperationException(_))
    }
}
impl std::error::Error for UntagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagResourceErrorKind::ArgumentException(_inner) => Some(_inner),
            UntagResourceErrorKind::NotFoundException(_inner) => Some(_inner),
            UntagResourceErrorKind::TagOperationException(_inner) => Some(_inner),
            UntagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateDeviceInstanceError {
    pub kind: UpdateDeviceInstanceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateDeviceInstanceErrorKind {
    ArgumentException(crate::error::ArgumentException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    ServiceAccountException(crate::error::ServiceAccountException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateDeviceInstanceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateDeviceInstanceErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            UpdateDeviceInstanceErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UpdateDeviceInstanceErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateDeviceInstanceErrorKind::ServiceAccountException(_inner) => _inner.fmt(f),
            UpdateDeviceInstanceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateDeviceInstanceError {
    fn code(&self) -> Option<&str> {
        UpdateDeviceInstanceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateDeviceInstanceError {
    pub fn new(kind: UpdateDeviceInstanceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateDeviceInstanceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateDeviceInstanceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDeviceInstanceErrorKind::ArgumentException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDeviceInstanceErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDeviceInstanceErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_account_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDeviceInstanceErrorKind::ServiceAccountException(_)
        )
    }
}
impl std::error::Error for UpdateDeviceInstanceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateDeviceInstanceErrorKind::ArgumentException(_inner) => Some(_inner),
            UpdateDeviceInstanceErrorKind::LimitExceededException(_inner) => Some(_inner),
            UpdateDeviceInstanceErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateDeviceInstanceErrorKind::ServiceAccountException(_inner) => Some(_inner),
            UpdateDeviceInstanceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateDevicePoolError {
    pub kind: UpdateDevicePoolErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateDevicePoolErrorKind {
    ArgumentException(crate::error::ArgumentException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    ServiceAccountException(crate::error::ServiceAccountException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateDevicePoolError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateDevicePoolErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            UpdateDevicePoolErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UpdateDevicePoolErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateDevicePoolErrorKind::ServiceAccountException(_inner) => _inner.fmt(f),
            UpdateDevicePoolErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateDevicePoolError {
    fn code(&self) -> Option<&str> {
        UpdateDevicePoolError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateDevicePoolError {
    pub fn new(kind: UpdateDevicePoolErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateDevicePoolErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateDevicePoolErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(&self.kind, UpdateDevicePoolErrorKind::ArgumentException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDevicePoolErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateDevicePoolErrorKind::NotFoundException(_))
    }
    pub fn is_service_account_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDevicePoolErrorKind::ServiceAccountException(_)
        )
    }
}
impl std::error::Error for UpdateDevicePoolError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateDevicePoolErrorKind::ArgumentException(_inner) => Some(_inner),
            UpdateDevicePoolErrorKind::LimitExceededException(_inner) => Some(_inner),
            UpdateDevicePoolErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateDevicePoolErrorKind::ServiceAccountException(_inner) => Some(_inner),
            UpdateDevicePoolErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateInstanceProfileError {
    pub kind: UpdateInstanceProfileErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateInstanceProfileErrorKind {
    ArgumentException(crate::error::ArgumentException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    ServiceAccountException(crate::error::ServiceAccountException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateInstanceProfileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateInstanceProfileErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            UpdateInstanceProfileErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UpdateInstanceProfileErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateInstanceProfileErrorKind::ServiceAccountException(_inner) => _inner.fmt(f),
            UpdateInstanceProfileErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateInstanceProfileError {
    fn code(&self) -> Option<&str> {
        UpdateInstanceProfileError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateInstanceProfileError {
    pub fn new(kind: UpdateInstanceProfileErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateInstanceProfileErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateInstanceProfileErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateInstanceProfileErrorKind::ArgumentException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateInstanceProfileErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateInstanceProfileErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_account_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateInstanceProfileErrorKind::ServiceAccountException(_)
        )
    }
}
impl std::error::Error for UpdateInstanceProfileError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateInstanceProfileErrorKind::ArgumentException(_inner) => Some(_inner),
            UpdateInstanceProfileErrorKind::LimitExceededException(_inner) => Some(_inner),
            UpdateInstanceProfileErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateInstanceProfileErrorKind::ServiceAccountException(_inner) => Some(_inner),
            UpdateInstanceProfileErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateNetworkProfileError {
    pub kind: UpdateNetworkProfileErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateNetworkProfileErrorKind {
    ArgumentException(crate::error::ArgumentException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    ServiceAccountException(crate::error::ServiceAccountException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateNetworkProfileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateNetworkProfileErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            UpdateNetworkProfileErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UpdateNetworkProfileErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateNetworkProfileErrorKind::ServiceAccountException(_inner) => _inner.fmt(f),
            UpdateNetworkProfileErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateNetworkProfileError {
    fn code(&self) -> Option<&str> {
        UpdateNetworkProfileError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateNetworkProfileError {
    pub fn new(kind: UpdateNetworkProfileErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateNetworkProfileErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateNetworkProfileErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateNetworkProfileErrorKind::ArgumentException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateNetworkProfileErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateNetworkProfileErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_account_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateNetworkProfileErrorKind::ServiceAccountException(_)
        )
    }
}
impl std::error::Error for UpdateNetworkProfileError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateNetworkProfileErrorKind::ArgumentException(_inner) => Some(_inner),
            UpdateNetworkProfileErrorKind::LimitExceededException(_inner) => Some(_inner),
            UpdateNetworkProfileErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateNetworkProfileErrorKind::ServiceAccountException(_inner) => Some(_inner),
            UpdateNetworkProfileErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateProjectError {
    pub kind: UpdateProjectErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateProjectErrorKind {
    ArgumentException(crate::error::ArgumentException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    ServiceAccountException(crate::error::ServiceAccountException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateProjectError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateProjectErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            UpdateProjectErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UpdateProjectErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateProjectErrorKind::ServiceAccountException(_inner) => _inner.fmt(f),
            UpdateProjectErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateProjectError {
    fn code(&self) -> Option<&str> {
        UpdateProjectError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateProjectError {
    pub fn new(kind: UpdateProjectErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateProjectErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateProjectErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(&self.kind, UpdateProjectErrorKind::ArgumentException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateProjectErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateProjectErrorKind::NotFoundException(_))
    }
    pub fn is_service_account_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateProjectErrorKind::ServiceAccountException(_)
        )
    }
}
impl std::error::Error for UpdateProjectError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateProjectErrorKind::ArgumentException(_inner) => Some(_inner),
            UpdateProjectErrorKind::LimitExceededException(_inner) => Some(_inner),
            UpdateProjectErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateProjectErrorKind::ServiceAccountException(_inner) => Some(_inner),
            UpdateProjectErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateTestGridProjectError {
    pub kind: UpdateTestGridProjectErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateTestGridProjectErrorKind {
    ArgumentException(crate::error::ArgumentException),
    InternalServiceException(crate::error::InternalServiceException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateTestGridProjectError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateTestGridProjectErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            UpdateTestGridProjectErrorKind::InternalServiceException(_inner) => _inner.fmt(f),
            UpdateTestGridProjectErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UpdateTestGridProjectErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateTestGridProjectErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateTestGridProjectError {
    fn code(&self) -> Option<&str> {
        UpdateTestGridProjectError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateTestGridProjectError {
    pub fn new(kind: UpdateTestGridProjectErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateTestGridProjectErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateTestGridProjectErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTestGridProjectErrorKind::ArgumentException(_)
        )
    }
    pub fn is_internal_service_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTestGridProjectErrorKind::InternalServiceException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTestGridProjectErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTestGridProjectErrorKind::NotFoundException(_)
        )
    }
}
impl std::error::Error for UpdateTestGridProjectError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateTestGridProjectErrorKind::ArgumentException(_inner) => Some(_inner),
            UpdateTestGridProjectErrorKind::InternalServiceException(_inner) => Some(_inner),
            UpdateTestGridProjectErrorKind::LimitExceededException(_inner) => Some(_inner),
            UpdateTestGridProjectErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateTestGridProjectErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateUploadError {
    pub kind: UpdateUploadErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateUploadErrorKind {
    ArgumentException(crate::error::ArgumentException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    ServiceAccountException(crate::error::ServiceAccountException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateUploadError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateUploadErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            UpdateUploadErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UpdateUploadErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateUploadErrorKind::ServiceAccountException(_inner) => _inner.fmt(f),
            UpdateUploadErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateUploadError {
    fn code(&self) -> Option<&str> {
        UpdateUploadError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateUploadError {
    pub fn new(kind: UpdateUploadErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateUploadErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateUploadErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(&self.kind, UpdateUploadErrorKind::ArgumentException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, UpdateUploadErrorKind::LimitExceededException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateUploadErrorKind::NotFoundException(_))
    }
    pub fn is_service_account_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUploadErrorKind::ServiceAccountException(_)
        )
    }
}
impl std::error::Error for UpdateUploadError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateUploadErrorKind::ArgumentException(_inner) => Some(_inner),
            UpdateUploadErrorKind::LimitExceededException(_inner) => Some(_inner),
            UpdateUploadErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateUploadErrorKind::ServiceAccountException(_inner) => Some(_inner),
            UpdateUploadErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateVPCEConfigurationError {
    pub kind: UpdateVPCEConfigurationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateVPCEConfigurationErrorKind {
    ArgumentException(crate::error::ArgumentException),
    InvalidOperationException(crate::error::InvalidOperationException),
    NotFoundException(crate::error::NotFoundException),
    ServiceAccountException(crate::error::ServiceAccountException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateVPCEConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateVPCEConfigurationErrorKind::ArgumentException(_inner) => _inner.fmt(f),
            UpdateVPCEConfigurationErrorKind::InvalidOperationException(_inner) => _inner.fmt(f),
            UpdateVPCEConfigurationErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateVPCEConfigurationErrorKind::ServiceAccountException(_inner) => _inner.fmt(f),
            UpdateVPCEConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateVPCEConfigurationError {
    fn code(&self) -> Option<&str> {
        UpdateVPCEConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateVPCEConfigurationError {
    pub fn new(kind: UpdateVPCEConfigurationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateVPCEConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateVPCEConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_argument_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVPCEConfigurationErrorKind::ArgumentException(_)
        )
    }
    pub fn is_invalid_operation_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVPCEConfigurationErrorKind::InvalidOperationException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVPCEConfigurationErrorKind::NotFoundException(_)
        )
    }
    pub fn is_service_account_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVPCEConfigurationErrorKind::ServiceAccountException(_)
        )
    }
}
impl std::error::Error for UpdateVPCEConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateVPCEConfigurationErrorKind::ArgumentException(_inner) => Some(_inner),
            UpdateVPCEConfigurationErrorKind::InvalidOperationException(_inner) => Some(_inner),
            UpdateVPCEConfigurationErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateVPCEConfigurationErrorKind::ServiceAccountException(_inner) => Some(_inner),
            UpdateVPCEConfigurationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// <p>There was a problem with the service account.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ServiceAccountException {
    /// <p>Any additional information about the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ServiceAccountException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ServiceAccountException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ServiceAccountException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ServiceAccountException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ServiceAccountException")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for ServiceAccountException {}
/// See [`ServiceAccountException`](crate::error::ServiceAccountException)
pub mod service_account_exception {
    /// A builder for [`ServiceAccountException`](crate::error::ServiceAccountException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any additional information about the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ServiceAccountException`](crate::error::ServiceAccountException)
        pub fn build(self) -> crate::error::ServiceAccountException {
            crate::error::ServiceAccountException {
                message: self.message,
            }
        }
    }
}
impl ServiceAccountException {
    /// Creates a new builder-style object to manufacture [`ServiceAccountException`](crate::error::ServiceAccountException)
    pub fn builder() -> crate::error::service_account_exception::Builder {
        crate::error::service_account_exception::Builder::default()
    }
}

/// <p>The specified entity was not found.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NotFoundException {
    /// <p>Any additional information about the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NotFoundException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl NotFoundException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NotFoundException")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for NotFoundException {}
/// See [`NotFoundException`](crate::error::NotFoundException)
pub mod not_found_exception {
    /// A builder for [`NotFoundException`](crate::error::NotFoundException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any additional information about the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`NotFoundException`](crate::error::NotFoundException)
        pub fn build(self) -> crate::error::NotFoundException {
            crate::error::NotFoundException {
                message: self.message,
            }
        }
    }
}
impl NotFoundException {
    /// Creates a new builder-style object to manufacture [`NotFoundException`](crate::error::NotFoundException)
    pub fn builder() -> crate::error::not_found_exception::Builder {
        crate::error::not_found_exception::Builder::default()
    }
}

/// <p>There was an error with the update request, or you do not have sufficient permissions
/// to update this VPC endpoint configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidOperationException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidOperationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidOperationException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidOperationException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidOperationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidOperationException")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidOperationException {}
/// See [`InvalidOperationException`](crate::error::InvalidOperationException)
pub mod invalid_operation_exception {
    /// A builder for [`InvalidOperationException`](crate::error::InvalidOperationException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidOperationException`](crate::error::InvalidOperationException)
        pub fn build(self) -> crate::error::InvalidOperationException {
            crate::error::InvalidOperationException {
                message: self.message,
            }
        }
    }
}
impl InvalidOperationException {
    /// Creates a new builder-style object to manufacture [`InvalidOperationException`](crate::error::InvalidOperationException)
    pub fn builder() -> crate::error::invalid_operation_exception::Builder {
        crate::error::invalid_operation_exception::Builder::default()
    }
}

/// <p>An invalid argument was specified.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ArgumentException {
    /// <p>Any additional information about the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ArgumentException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ArgumentException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ArgumentException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ArgumentException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ArgumentException")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for ArgumentException {}
/// See [`ArgumentException`](crate::error::ArgumentException)
pub mod argument_exception {
    /// A builder for [`ArgumentException`](crate::error::ArgumentException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any additional information about the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ArgumentException`](crate::error::ArgumentException)
        pub fn build(self) -> crate::error::ArgumentException {
            crate::error::ArgumentException {
                message: self.message,
            }
        }
    }
}
impl ArgumentException {
    /// Creates a new builder-style object to manufacture [`ArgumentException`](crate::error::ArgumentException)
    pub fn builder() -> crate::error::argument_exception::Builder {
        crate::error::argument_exception::Builder::default()
    }
}

/// <p>A limit was exceeded.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LimitExceededException {
    /// <p>Any additional information about the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LimitExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl LimitExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for LimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "LimitExceededException")?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for LimitExceededException {}
/// See [`LimitExceededException`](crate::error::LimitExceededException)
pub mod limit_exceeded_exception {
    /// A builder for [`LimitExceededException`](crate::error::LimitExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any additional information about the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`LimitExceededException`](crate::error::LimitExceededException)
        pub fn build(self) -> crate::error::LimitExceededException {
            crate::error::LimitExceededException {
                message: self.message,
            }
        }
    }
}
impl LimitExceededException {
    /// Creates a new builder-style object to manufacture [`LimitExceededException`](crate::error::LimitExceededException)
    pub fn builder() -> crate::error::limit_exceeded_exception::Builder {
        crate::error::limit_exceeded_exception::Builder::default()
    }
}

/// <p>An internal exception was raised in the service. Contact <a href="mailto:aws-devicefarm-support@amazon.com">aws-devicefarm-support@amazon.com</a> if you see this
/// error. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InternalServiceException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InternalServiceException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InternalServiceException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InternalServiceException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InternalServiceException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InternalServiceException")?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl std::error::Error for InternalServiceException {}
/// See [`InternalServiceException`](crate::error::InternalServiceException)
pub mod internal_service_exception {
    /// A builder for [`InternalServiceException`](crate::error::InternalServiceException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InternalServiceException`](crate::error::InternalServiceException)
        pub fn build(self) -> crate::error::InternalServiceException {
            crate::error::InternalServiceException {
                message: self.message,
            }
        }
    }
}
impl InternalServiceException {
    /// Creates a new builder-style object to manufacture [`InternalServiceException`](crate::error::InternalServiceException)
    pub fn builder() -> crate::error::internal_service_exception::Builder {
        crate::error::internal_service_exception::Builder::default()
    }
}

/// <p>The operation was not successful. Try again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TagOperationException {
    pub message: std::option::Option<std::string::String>,
    pub resource_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TagOperationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TagOperationException");
        formatter.field("message", &self.message);
        formatter.field("resource_name", &self.resource_name);
        formatter.finish()
    }
}
impl TagOperationException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TagOperationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TagOperationException")?;
        if let Some(inner_7) = &self.message {
            write!(f, ": {}", inner_7)?;
        }
        Ok(())
    }
}
impl std::error::Error for TagOperationException {}
/// See [`TagOperationException`](crate::error::TagOperationException)
pub mod tag_operation_exception {
    /// A builder for [`TagOperationException`](crate::error::TagOperationException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) resource_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        pub fn resource_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_name = Some(input.into());
            self
        }
        pub fn set_resource_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_name = input;
            self
        }
        /// Consumes the builder and constructs a [`TagOperationException`](crate::error::TagOperationException)
        pub fn build(self) -> crate::error::TagOperationException {
            crate::error::TagOperationException {
                message: self.message,
                resource_name: self.resource_name,
            }
        }
    }
}
impl TagOperationException {
    /// Creates a new builder-style object to manufacture [`TagOperationException`](crate::error::TagOperationException)
    pub fn builder() -> crate::error::tag_operation_exception::Builder {
        crate::error::tag_operation_exception::Builder::default()
    }
}

/// <p>The list of tags on the repository is over the limit. The maximum number of tags that
/// can be applied to a repository is 50. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TooManyTagsException {
    pub message: std::option::Option<std::string::String>,
    pub resource_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TooManyTagsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TooManyTagsException");
        formatter.field("message", &self.message);
        formatter.field("resource_name", &self.resource_name);
        formatter.finish()
    }
}
impl TooManyTagsException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyTagsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyTagsException")?;
        if let Some(inner_8) = &self.message {
            write!(f, ": {}", inner_8)?;
        }
        Ok(())
    }
}
impl std::error::Error for TooManyTagsException {}
/// See [`TooManyTagsException`](crate::error::TooManyTagsException)
pub mod too_many_tags_exception {
    /// A builder for [`TooManyTagsException`](crate::error::TooManyTagsException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) resource_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        pub fn resource_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_name = Some(input.into());
            self
        }
        pub fn set_resource_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_name = input;
            self
        }
        /// Consumes the builder and constructs a [`TooManyTagsException`](crate::error::TooManyTagsException)
        pub fn build(self) -> crate::error::TooManyTagsException {
            crate::error::TooManyTagsException {
                message: self.message,
                resource_name: self.resource_name,
            }
        }
    }
}
impl TooManyTagsException {
    /// Creates a new builder-style object to manufacture [`TooManyTagsException`](crate::error::TooManyTagsException)
    pub fn builder() -> crate::error::too_many_tags_exception::Builder {
        crate::error::too_many_tags_exception::Builder::default()
    }
}

/// <p>The request doesn't comply with the AWS Identity and Access Management (IAM) tag
/// policy. Correct your request and then retry it.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TagPolicyException {
    pub message: std::option::Option<std::string::String>,
    pub resource_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TagPolicyException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TagPolicyException");
        formatter.field("message", &self.message);
        formatter.field("resource_name", &self.resource_name);
        formatter.finish()
    }
}
impl TagPolicyException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TagPolicyException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TagPolicyException")?;
        if let Some(inner_9) = &self.message {
            write!(f, ": {}", inner_9)?;
        }
        Ok(())
    }
}
impl std::error::Error for TagPolicyException {}
/// See [`TagPolicyException`](crate::error::TagPolicyException)
pub mod tag_policy_exception {
    /// A builder for [`TagPolicyException`](crate::error::TagPolicyException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) resource_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        pub fn resource_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_name = Some(input.into());
            self
        }
        pub fn set_resource_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_name = input;
            self
        }
        /// Consumes the builder and constructs a [`TagPolicyException`](crate::error::TagPolicyException)
        pub fn build(self) -> crate::error::TagPolicyException {
            crate::error::TagPolicyException {
                message: self.message,
                resource_name: self.resource_name,
            }
        }
    }
}
impl TagPolicyException {
    /// Creates a new builder-style object to manufacture [`TagPolicyException`](crate::error::TagPolicyException)
    pub fn builder() -> crate::error::tag_policy_exception::Builder {
        crate::error::tag_policy_exception::Builder::default()
    }
}

/// <p>An entity with the same name already exists.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct IdempotencyException {
    /// <p>Any additional information about the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for IdempotencyException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("IdempotencyException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl IdempotencyException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for IdempotencyException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "IdempotencyException")?;
        if let Some(inner_10) = &self.message {
            write!(f, ": {}", inner_10)?;
        }
        Ok(())
    }
}
impl std::error::Error for IdempotencyException {}
/// See [`IdempotencyException`](crate::error::IdempotencyException)
pub mod idempotency_exception {
    /// A builder for [`IdempotencyException`](crate::error::IdempotencyException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any additional information about the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`IdempotencyException`](crate::error::IdempotencyException)
        pub fn build(self) -> crate::error::IdempotencyException {
            crate::error::IdempotencyException {
                message: self.message,
            }
        }
    }
}
impl IdempotencyException {
    /// Creates a new builder-style object to manufacture [`IdempotencyException`](crate::error::IdempotencyException)
    pub fn builder() -> crate::error::idempotency_exception::Builder {
        crate::error::idempotency_exception::Builder::default()
    }
}

/// <p>Exception gets thrown when a user is not eligible to perform the specified
/// transaction.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NotEligibleException {
    /// <p>The HTTP response code of a Not Eligible exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NotEligibleException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NotEligibleException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl NotEligibleException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NotEligibleException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NotEligibleException")?;
        if let Some(inner_11) = &self.message {
            write!(f, ": {}", inner_11)?;
        }
        Ok(())
    }
}
impl std::error::Error for NotEligibleException {}
/// See [`NotEligibleException`](crate::error::NotEligibleException)
pub mod not_eligible_exception {
    /// A builder for [`NotEligibleException`](crate::error::NotEligibleException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The HTTP response code of a Not Eligible exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`NotEligibleException`](crate::error::NotEligibleException)
        pub fn build(self) -> crate::error::NotEligibleException {
            crate::error::NotEligibleException {
                message: self.message,
            }
        }
    }
}
impl NotEligibleException {
    /// Creates a new builder-style object to manufacture [`NotEligibleException`](crate::error::NotEligibleException)
    pub fn builder() -> crate::error::not_eligible_exception::Builder {
        crate::error::not_eligible_exception::Builder::default()
    }
}

/// <p>The requested object could not be deleted.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CannotDeleteException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CannotDeleteException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CannotDeleteException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CannotDeleteException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CannotDeleteException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CannotDeleteException")?;
        if let Some(inner_12) = &self.message {
            write!(f, ": {}", inner_12)?;
        }
        Ok(())
    }
}
impl std::error::Error for CannotDeleteException {}
/// See [`CannotDeleteException`](crate::error::CannotDeleteException)
pub mod cannot_delete_exception {
    /// A builder for [`CannotDeleteException`](crate::error::CannotDeleteException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CannotDeleteException`](crate::error::CannotDeleteException)
        pub fn build(self) -> crate::error::CannotDeleteException {
            crate::error::CannotDeleteException {
                message: self.message,
            }
        }
    }
}
impl CannotDeleteException {
    /// Creates a new builder-style object to manufacture [`CannotDeleteException`](crate::error::CannotDeleteException)
    pub fn builder() -> crate::error::cannot_delete_exception::Builder {
        crate::error::cannot_delete_exception::Builder::default()
    }
}
