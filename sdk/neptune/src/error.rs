// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type StopDBClusterErrorKind = StopDBClusterError;
/// Error type for the `StopDBClusterError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StopDBClusterError {
    /// <p> <i>DBClusterIdentifier</i> does not refer to an existing DB cluster.</p>
    DbClusterNotFoundFault(crate::error::DbClusterNotFoundFault),
    /// <p>The DB cluster is not in a valid state.</p>
    InvalidDbClusterStateFault(crate::error::InvalidDbClusterStateFault),
    /// <p>The specified DB instance is not in the <i>available</i> state.</p>
    InvalidDbInstanceStateFault(crate::error::InvalidDbInstanceStateFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for StopDBClusterError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for StopDBClusterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DbClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::InvalidDbClusterStateFault(_inner) => _inner.fmt(f),
            Self::InvalidDbInstanceStateFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for StopDBClusterError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DbClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDbClusterStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDbInstanceStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::StopDBClusterError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for StopDBClusterError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl StopDBClusterError {
    /// Creates the `StopDBClusterError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `StopDBClusterError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DbClusterNotFoundFault(e) => e.meta(),
            Self::InvalidDbClusterStateFault(e) => e.meta(),
            Self::InvalidDbInstanceStateFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `StopDBClusterError::DbClusterNotFoundFault`.
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::DbClusterNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `StopDBClusterError::InvalidDbClusterStateFault`.
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(self, Self::InvalidDbClusterStateFault(_))
    }
    /// Returns `true` if the error kind is `StopDBClusterError::InvalidDbInstanceStateFault`.
    pub fn is_invalid_db_instance_state_fault(&self) -> bool {
        matches!(self, Self::InvalidDbInstanceStateFault(_))
    }
}
impl std::error::Error for StopDBClusterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DbClusterNotFoundFault(_inner) => Some(_inner),
            Self::InvalidDbClusterStateFault(_inner) => Some(_inner),
            Self::InvalidDbInstanceStateFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The specified DB instance is not in the <i>available</i> state.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidDbInstanceStateFault {
    /// <p>A message describing the details of the problem.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidDbInstanceStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidDbInstanceStateFault`](crate::error::InvalidDbInstanceStateFault).
    pub fn builder() -> crate::error::invalid_db_instance_state_fault::Builder {
        crate::error::invalid_db_instance_state_fault::Builder::default()
    }
}
/// See [`InvalidDbInstanceStateFault`](crate::error::InvalidDbInstanceStateFault).
pub mod invalid_db_instance_state_fault {

    /// A builder for [`InvalidDbInstanceStateFault`](crate::error::InvalidDbInstanceStateFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A message describing the details of the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message describing the details of the problem.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidDbInstanceStateFault`](crate::error::InvalidDbInstanceStateFault).
        pub fn build(self) -> crate::error::InvalidDbInstanceStateFault {
            crate::error::InvalidDbInstanceStateFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidDbInstanceStateFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidDbInstanceStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "InvalidDbInstanceStateFault [InvalidDBInstanceStateFault]"
        )?;
        if let Some(inner_1) = &self.message {
            {
                write!(f, ": {}", inner_1)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidDbInstanceStateFault {}
impl aws_http::request_id::RequestId for crate::error::InvalidDbInstanceStateFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidDbInstanceStateFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The DB cluster is not in a valid state.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidDbClusterStateFault {
    /// <p>A message describing the details of the problem.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidDbClusterStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidDbClusterStateFault`](crate::error::InvalidDbClusterStateFault).
    pub fn builder() -> crate::error::invalid_db_cluster_state_fault::Builder {
        crate::error::invalid_db_cluster_state_fault::Builder::default()
    }
}
/// See [`InvalidDbClusterStateFault`](crate::error::InvalidDbClusterStateFault).
pub mod invalid_db_cluster_state_fault {

    /// A builder for [`InvalidDbClusterStateFault`](crate::error::InvalidDbClusterStateFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A message describing the details of the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message describing the details of the problem.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidDbClusterStateFault`](crate::error::InvalidDbClusterStateFault).
        pub fn build(self) -> crate::error::InvalidDbClusterStateFault {
            crate::error::InvalidDbClusterStateFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidDbClusterStateFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidDbClusterStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidDbClusterStateFault [InvalidDBClusterStateFault]")?;
        if let Some(inner_2) = &self.message {
            {
                write!(f, ": {}", inner_2)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidDbClusterStateFault {}
impl aws_http::request_id::RequestId for crate::error::InvalidDbClusterStateFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidDbClusterStateFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p> <i>DBClusterIdentifier</i> does not refer to an existing DB cluster.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DbClusterNotFoundFault {
    /// <p>A message describing the details of the problem.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl DbClusterNotFoundFault {
    /// Creates a new builder-style object to manufacture [`DbClusterNotFoundFault`](crate::error::DbClusterNotFoundFault).
    pub fn builder() -> crate::error::db_cluster_not_found_fault::Builder {
        crate::error::db_cluster_not_found_fault::Builder::default()
    }
}
/// See [`DbClusterNotFoundFault`](crate::error::DbClusterNotFoundFault).
pub mod db_cluster_not_found_fault {

    /// A builder for [`DbClusterNotFoundFault`](crate::error::DbClusterNotFoundFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A message describing the details of the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message describing the details of the problem.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`DbClusterNotFoundFault`](crate::error::DbClusterNotFoundFault).
        pub fn build(self) -> crate::error::DbClusterNotFoundFault {
            crate::error::DbClusterNotFoundFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl DbClusterNotFoundFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DbClusterNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DbClusterNotFoundFault [DBClusterNotFoundFault]")?;
        if let Some(inner_3) = &self.message {
            {
                write!(f, ": {}", inner_3)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DbClusterNotFoundFault {}
impl aws_http::request_id::RequestId for crate::error::DbClusterNotFoundFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DbClusterNotFoundFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type StartDBClusterErrorKind = StartDBClusterError;
/// Error type for the `StartDBClusterError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartDBClusterError {
    /// <p> <i>DBClusterIdentifier</i> does not refer to an existing DB cluster.</p>
    DbClusterNotFoundFault(crate::error::DbClusterNotFoundFault),
    /// <p>The DB cluster is not in a valid state.</p>
    InvalidDbClusterStateFault(crate::error::InvalidDbClusterStateFault),
    /// <p>The specified DB instance is not in the <i>available</i> state.</p>
    InvalidDbInstanceStateFault(crate::error::InvalidDbInstanceStateFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for StartDBClusterError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for StartDBClusterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DbClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::InvalidDbClusterStateFault(_inner) => _inner.fmt(f),
            Self::InvalidDbInstanceStateFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for StartDBClusterError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DbClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDbClusterStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDbInstanceStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::StartDBClusterError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for StartDBClusterError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartDBClusterError {
    /// Creates the `StartDBClusterError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `StartDBClusterError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DbClusterNotFoundFault(e) => e.meta(),
            Self::InvalidDbClusterStateFault(e) => e.meta(),
            Self::InvalidDbInstanceStateFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `StartDBClusterError::DbClusterNotFoundFault`.
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::DbClusterNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `StartDBClusterError::InvalidDbClusterStateFault`.
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(self, Self::InvalidDbClusterStateFault(_))
    }
    /// Returns `true` if the error kind is `StartDBClusterError::InvalidDbInstanceStateFault`.
    pub fn is_invalid_db_instance_state_fault(&self) -> bool {
        matches!(self, Self::InvalidDbInstanceStateFault(_))
    }
}
impl std::error::Error for StartDBClusterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DbClusterNotFoundFault(_inner) => Some(_inner),
            Self::InvalidDbClusterStateFault(_inner) => Some(_inner),
            Self::InvalidDbInstanceStateFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type RestoreDBClusterToPointInTimeErrorKind = RestoreDBClusterToPointInTimeError;
/// Error type for the `RestoreDBClusterToPointInTimeError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RestoreDBClusterToPointInTimeError {
    /// <p>User already has a DB cluster with the given identifier.</p>
    DbClusterAlreadyExistsFault(crate::error::DbClusterAlreadyExistsFault),
    /// <p> <i>DBClusterIdentifier</i> does not refer to an existing DB cluster.</p>
    DbClusterNotFoundFault(crate::error::DbClusterNotFoundFault),
    /// <p> <i>DBClusterParameterGroupName</i> does not refer to an existing DB Cluster parameter group.</p>
    DbClusterParameterGroupNotFoundFault(crate::error::DbClusterParameterGroupNotFoundFault),
    /// <p>User attempted to create a new DB cluster and the user has already reached the maximum allowed DB cluster quota.</p>
    DbClusterQuotaExceededFault(crate::error::DbClusterQuotaExceededFault),
    /// <p> <i>DBClusterSnapshotIdentifier</i> does not refer to an existing DB cluster snapshot.</p>
    DbClusterSnapshotNotFoundFault(crate::error::DbClusterSnapshotNotFoundFault),
    /// <p> <i>DBSubnetGroupName</i> does not refer to an existing DB subnet group.</p>
    DbSubnetGroupNotFoundFault(crate::error::DbSubnetGroupNotFoundFault),
    /// <p>The DB cluster does not have enough capacity for the current operation.</p>
    InsufficientDbClusterCapacityFault(crate::error::InsufficientDbClusterCapacityFault),
    /// <p>There is insufficient storage available for the current action. You may be able to resolve this error by updating your subnet group to use different Availability Zones that have more storage available.</p>
    InsufficientStorageClusterCapacityFault(crate::error::InsufficientStorageClusterCapacityFault),
    /// <p>The supplied value is not a valid DB cluster snapshot state.</p>
    InvalidDbClusterSnapshotStateFault(crate::error::InvalidDbClusterSnapshotStateFault),
    /// <p>The DB cluster is not in a valid state.</p>
    InvalidDbClusterStateFault(crate::error::InvalidDbClusterStateFault),
    /// <p>The state of the DB snapshot does not allow deletion.</p>
    InvalidDbSnapshotStateFault(crate::error::InvalidDbSnapshotStateFault),
    /// <p>Cannot restore from vpc backup to non-vpc DB instance.</p>
    InvalidRestoreFault(crate::error::InvalidRestoreFault),
    /// <p>The requested subnet is invalid, or multiple subnets were requested that are not all in a common VPC.</p>
    InvalidSubnet(crate::error::InvalidSubnet),
    /// <p>DB subnet group does not cover all Availability Zones after it is created because users' change.</p>
    InvalidVpcNetworkStateFault(crate::error::InvalidVpcNetworkStateFault),
    /// <p>Error accessing KMS key.</p>
    KmsKeyNotAccessibleFault(crate::error::KmsKeyNotAccessibleFault),
    /// <p>The designated option group could not be found.</p>
    OptionGroupNotFoundFault(crate::error::OptionGroupNotFoundFault),
    /// <p>Request would result in user exceeding the allowed amount of storage available across all DB instances.</p>
    StorageQuotaExceededFault(crate::error::StorageQuotaExceededFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for RestoreDBClusterToPointInTimeError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for RestoreDBClusterToPointInTimeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DbClusterAlreadyExistsFault(_inner) => _inner.fmt(f),
            Self::DbClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::DbClusterParameterGroupNotFoundFault(_inner) => _inner.fmt(f),
            Self::DbClusterQuotaExceededFault(_inner) => _inner.fmt(f),
            Self::DbClusterSnapshotNotFoundFault(_inner) => _inner.fmt(f),
            Self::DbSubnetGroupNotFoundFault(_inner) => _inner.fmt(f),
            Self::InsufficientDbClusterCapacityFault(_inner) => _inner.fmt(f),
            Self::InsufficientStorageClusterCapacityFault(_inner) => _inner.fmt(f),
            Self::InvalidDbClusterSnapshotStateFault(_inner) => _inner.fmt(f),
            Self::InvalidDbClusterStateFault(_inner) => _inner.fmt(f),
            Self::InvalidDbSnapshotStateFault(_inner) => _inner.fmt(f),
            Self::InvalidRestoreFault(_inner) => _inner.fmt(f),
            Self::InvalidSubnet(_inner) => _inner.fmt(f),
            Self::InvalidVpcNetworkStateFault(_inner) => _inner.fmt(f),
            Self::KmsKeyNotAccessibleFault(_inner) => _inner.fmt(f),
            Self::OptionGroupNotFoundFault(_inner) => _inner.fmt(f),
            Self::StorageQuotaExceededFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for RestoreDBClusterToPointInTimeError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DbClusterAlreadyExistsFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DbClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DbClusterParameterGroupNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DbClusterQuotaExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DbClusterSnapshotNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DbSubnetGroupNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InsufficientDbClusterCapacityFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InsufficientStorageClusterCapacityFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDbClusterSnapshotStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDbClusterStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDbSnapshotStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRestoreFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidSubnet(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidVpcNetworkStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::KmsKeyNotAccessibleFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::OptionGroupNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::StorageQuotaExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::RestoreDBClusterToPointInTimeError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for RestoreDBClusterToPointInTimeError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl RestoreDBClusterToPointInTimeError {
    /// Creates the `RestoreDBClusterToPointInTimeError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `RestoreDBClusterToPointInTimeError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DbClusterAlreadyExistsFault(e) => e.meta(),
            Self::DbClusterNotFoundFault(e) => e.meta(),
            Self::DbClusterParameterGroupNotFoundFault(e) => e.meta(),
            Self::DbClusterQuotaExceededFault(e) => e.meta(),
            Self::DbClusterSnapshotNotFoundFault(e) => e.meta(),
            Self::DbSubnetGroupNotFoundFault(e) => e.meta(),
            Self::InsufficientDbClusterCapacityFault(e) => e.meta(),
            Self::InsufficientStorageClusterCapacityFault(e) => e.meta(),
            Self::InvalidDbClusterSnapshotStateFault(e) => e.meta(),
            Self::InvalidDbClusterStateFault(e) => e.meta(),
            Self::InvalidDbSnapshotStateFault(e) => e.meta(),
            Self::InvalidRestoreFault(e) => e.meta(),
            Self::InvalidSubnet(e) => e.meta(),
            Self::InvalidVpcNetworkStateFault(e) => e.meta(),
            Self::KmsKeyNotAccessibleFault(e) => e.meta(),
            Self::OptionGroupNotFoundFault(e) => e.meta(),
            Self::StorageQuotaExceededFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `RestoreDBClusterToPointInTimeError::DbClusterAlreadyExistsFault`.
    pub fn is_db_cluster_already_exists_fault(&self) -> bool {
        matches!(self, Self::DbClusterAlreadyExistsFault(_))
    }
    /// Returns `true` if the error kind is `RestoreDBClusterToPointInTimeError::DbClusterNotFoundFault`.
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::DbClusterNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `RestoreDBClusterToPointInTimeError::DbClusterParameterGroupNotFoundFault`.
    pub fn is_db_cluster_parameter_group_not_found_fault(&self) -> bool {
        matches!(self, Self::DbClusterParameterGroupNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `RestoreDBClusterToPointInTimeError::DbClusterQuotaExceededFault`.
    pub fn is_db_cluster_quota_exceeded_fault(&self) -> bool {
        matches!(self, Self::DbClusterQuotaExceededFault(_))
    }
    /// Returns `true` if the error kind is `RestoreDBClusterToPointInTimeError::DbClusterSnapshotNotFoundFault`.
    pub fn is_db_cluster_snapshot_not_found_fault(&self) -> bool {
        matches!(self, Self::DbClusterSnapshotNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `RestoreDBClusterToPointInTimeError::DbSubnetGroupNotFoundFault`.
    pub fn is_db_subnet_group_not_found_fault(&self) -> bool {
        matches!(self, Self::DbSubnetGroupNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `RestoreDBClusterToPointInTimeError::InsufficientDbClusterCapacityFault`.
    pub fn is_insufficient_db_cluster_capacity_fault(&self) -> bool {
        matches!(self, Self::InsufficientDbClusterCapacityFault(_))
    }
    /// Returns `true` if the error kind is `RestoreDBClusterToPointInTimeError::InsufficientStorageClusterCapacityFault`.
    pub fn is_insufficient_storage_cluster_capacity_fault(&self) -> bool {
        matches!(self, Self::InsufficientStorageClusterCapacityFault(_))
    }
    /// Returns `true` if the error kind is `RestoreDBClusterToPointInTimeError::InvalidDbClusterSnapshotStateFault`.
    pub fn is_invalid_db_cluster_snapshot_state_fault(&self) -> bool {
        matches!(self, Self::InvalidDbClusterSnapshotStateFault(_))
    }
    /// Returns `true` if the error kind is `RestoreDBClusterToPointInTimeError::InvalidDbClusterStateFault`.
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(self, Self::InvalidDbClusterStateFault(_))
    }
    /// Returns `true` if the error kind is `RestoreDBClusterToPointInTimeError::InvalidDbSnapshotStateFault`.
    pub fn is_invalid_db_snapshot_state_fault(&self) -> bool {
        matches!(self, Self::InvalidDbSnapshotStateFault(_))
    }
    /// Returns `true` if the error kind is `RestoreDBClusterToPointInTimeError::InvalidRestoreFault`.
    pub fn is_invalid_restore_fault(&self) -> bool {
        matches!(self, Self::InvalidRestoreFault(_))
    }
    /// Returns `true` if the error kind is `RestoreDBClusterToPointInTimeError::InvalidSubnet`.
    pub fn is_invalid_subnet(&self) -> bool {
        matches!(self, Self::InvalidSubnet(_))
    }
    /// Returns `true` if the error kind is `RestoreDBClusterToPointInTimeError::InvalidVpcNetworkStateFault`.
    pub fn is_invalid_vpc_network_state_fault(&self) -> bool {
        matches!(self, Self::InvalidVpcNetworkStateFault(_))
    }
    /// Returns `true` if the error kind is `RestoreDBClusterToPointInTimeError::KmsKeyNotAccessibleFault`.
    pub fn is_kms_key_not_accessible_fault(&self) -> bool {
        matches!(self, Self::KmsKeyNotAccessibleFault(_))
    }
    /// Returns `true` if the error kind is `RestoreDBClusterToPointInTimeError::OptionGroupNotFoundFault`.
    pub fn is_option_group_not_found_fault(&self) -> bool {
        matches!(self, Self::OptionGroupNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `RestoreDBClusterToPointInTimeError::StorageQuotaExceededFault`.
    pub fn is_storage_quota_exceeded_fault(&self) -> bool {
        matches!(self, Self::StorageQuotaExceededFault(_))
    }
}
impl std::error::Error for RestoreDBClusterToPointInTimeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DbClusterAlreadyExistsFault(_inner) => Some(_inner),
            Self::DbClusterNotFoundFault(_inner) => Some(_inner),
            Self::DbClusterParameterGroupNotFoundFault(_inner) => Some(_inner),
            Self::DbClusterQuotaExceededFault(_inner) => Some(_inner),
            Self::DbClusterSnapshotNotFoundFault(_inner) => Some(_inner),
            Self::DbSubnetGroupNotFoundFault(_inner) => Some(_inner),
            Self::InsufficientDbClusterCapacityFault(_inner) => Some(_inner),
            Self::InsufficientStorageClusterCapacityFault(_inner) => Some(_inner),
            Self::InvalidDbClusterSnapshotStateFault(_inner) => Some(_inner),
            Self::InvalidDbClusterStateFault(_inner) => Some(_inner),
            Self::InvalidDbSnapshotStateFault(_inner) => Some(_inner),
            Self::InvalidRestoreFault(_inner) => Some(_inner),
            Self::InvalidSubnet(_inner) => Some(_inner),
            Self::InvalidVpcNetworkStateFault(_inner) => Some(_inner),
            Self::KmsKeyNotAccessibleFault(_inner) => Some(_inner),
            Self::OptionGroupNotFoundFault(_inner) => Some(_inner),
            Self::StorageQuotaExceededFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>Request would result in user exceeding the allowed amount of storage available across all DB instances.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StorageQuotaExceededFault {
    /// <p>A message describing the details of the problem.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl StorageQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`StorageQuotaExceededFault`](crate::error::StorageQuotaExceededFault).
    pub fn builder() -> crate::error::storage_quota_exceeded_fault::Builder {
        crate::error::storage_quota_exceeded_fault::Builder::default()
    }
}
/// See [`StorageQuotaExceededFault`](crate::error::StorageQuotaExceededFault).
pub mod storage_quota_exceeded_fault {

    /// A builder for [`StorageQuotaExceededFault`](crate::error::StorageQuotaExceededFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A message describing the details of the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message describing the details of the problem.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`StorageQuotaExceededFault`](crate::error::StorageQuotaExceededFault).
        pub fn build(self) -> crate::error::StorageQuotaExceededFault {
            crate::error::StorageQuotaExceededFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl StorageQuotaExceededFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for StorageQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "StorageQuotaExceededFault")?;
        if let Some(inner_4) = &self.message {
            {
                write!(f, ": {}", inner_4)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for StorageQuotaExceededFault {}
impl aws_http::request_id::RequestId for crate::error::StorageQuotaExceededFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for StorageQuotaExceededFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The designated option group could not be found.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct OptionGroupNotFoundFault {
    /// <p>A message describing the details of the problem.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl OptionGroupNotFoundFault {
    /// Creates a new builder-style object to manufacture [`OptionGroupNotFoundFault`](crate::error::OptionGroupNotFoundFault).
    pub fn builder() -> crate::error::option_group_not_found_fault::Builder {
        crate::error::option_group_not_found_fault::Builder::default()
    }
}
/// See [`OptionGroupNotFoundFault`](crate::error::OptionGroupNotFoundFault).
pub mod option_group_not_found_fault {

    /// A builder for [`OptionGroupNotFoundFault`](crate::error::OptionGroupNotFoundFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A message describing the details of the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message describing the details of the problem.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`OptionGroupNotFoundFault`](crate::error::OptionGroupNotFoundFault).
        pub fn build(self) -> crate::error::OptionGroupNotFoundFault {
            crate::error::OptionGroupNotFoundFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl OptionGroupNotFoundFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for OptionGroupNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "OptionGroupNotFoundFault")?;
        if let Some(inner_5) = &self.message {
            {
                write!(f, ": {}", inner_5)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for OptionGroupNotFoundFault {}
impl aws_http::request_id::RequestId for crate::error::OptionGroupNotFoundFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for OptionGroupNotFoundFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>Error accessing KMS key.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct KmsKeyNotAccessibleFault {
    /// <p>A message describing the details of the problem.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl KmsKeyNotAccessibleFault {
    /// Creates a new builder-style object to manufacture [`KmsKeyNotAccessibleFault`](crate::error::KmsKeyNotAccessibleFault).
    pub fn builder() -> crate::error::kms_key_not_accessible_fault::Builder {
        crate::error::kms_key_not_accessible_fault::Builder::default()
    }
}
/// See [`KmsKeyNotAccessibleFault`](crate::error::KmsKeyNotAccessibleFault).
pub mod kms_key_not_accessible_fault {

    /// A builder for [`KmsKeyNotAccessibleFault`](crate::error::KmsKeyNotAccessibleFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A message describing the details of the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message describing the details of the problem.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`KmsKeyNotAccessibleFault`](crate::error::KmsKeyNotAccessibleFault).
        pub fn build(self) -> crate::error::KmsKeyNotAccessibleFault {
            crate::error::KmsKeyNotAccessibleFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl KmsKeyNotAccessibleFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for KmsKeyNotAccessibleFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "KmsKeyNotAccessibleFault [KMSKeyNotAccessibleFault]")?;
        if let Some(inner_6) = &self.message {
            {
                write!(f, ": {}", inner_6)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for KmsKeyNotAccessibleFault {}
impl aws_http::request_id::RequestId for crate::error::KmsKeyNotAccessibleFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for KmsKeyNotAccessibleFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>DB subnet group does not cover all Availability Zones after it is created because users' change.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidVpcNetworkStateFault {
    /// <p>A message describing the details of the problem.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidVpcNetworkStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidVpcNetworkStateFault`](crate::error::InvalidVpcNetworkStateFault).
    pub fn builder() -> crate::error::invalid_vpc_network_state_fault::Builder {
        crate::error::invalid_vpc_network_state_fault::Builder::default()
    }
}
/// See [`InvalidVpcNetworkStateFault`](crate::error::InvalidVpcNetworkStateFault).
pub mod invalid_vpc_network_state_fault {

    /// A builder for [`InvalidVpcNetworkStateFault`](crate::error::InvalidVpcNetworkStateFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A message describing the details of the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message describing the details of the problem.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidVpcNetworkStateFault`](crate::error::InvalidVpcNetworkStateFault).
        pub fn build(self) -> crate::error::InvalidVpcNetworkStateFault {
            crate::error::InvalidVpcNetworkStateFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidVpcNetworkStateFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidVpcNetworkStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "InvalidVpcNetworkStateFault [InvalidVPCNetworkStateFault]"
        )?;
        if let Some(inner_7) = &self.message {
            {
                write!(f, ": {}", inner_7)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidVpcNetworkStateFault {}
impl aws_http::request_id::RequestId for crate::error::InvalidVpcNetworkStateFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidVpcNetworkStateFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The requested subnet is invalid, or multiple subnets were requested that are not all in a common VPC.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidSubnet {
    /// <p>A message describing the details of the problem.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidSubnet {
    /// Creates a new builder-style object to manufacture [`InvalidSubnet`](crate::error::InvalidSubnet).
    pub fn builder() -> crate::error::invalid_subnet::Builder {
        crate::error::invalid_subnet::Builder::default()
    }
}
/// See [`InvalidSubnet`](crate::error::InvalidSubnet).
pub mod invalid_subnet {

    /// A builder for [`InvalidSubnet`](crate::error::InvalidSubnet).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A message describing the details of the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message describing the details of the problem.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidSubnet`](crate::error::InvalidSubnet).
        pub fn build(self) -> crate::error::InvalidSubnet {
            crate::error::InvalidSubnet {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidSubnet {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidSubnet {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidSubnet")?;
        if let Some(inner_8) = &self.message {
            {
                write!(f, ": {}", inner_8)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidSubnet {}
impl aws_http::request_id::RequestId for crate::error::InvalidSubnet {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidSubnet {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>Cannot restore from vpc backup to non-vpc DB instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidRestoreFault {
    /// <p>A message describing the details of the problem.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidRestoreFault {
    /// Creates a new builder-style object to manufacture [`InvalidRestoreFault`](crate::error::InvalidRestoreFault).
    pub fn builder() -> crate::error::invalid_restore_fault::Builder {
        crate::error::invalid_restore_fault::Builder::default()
    }
}
/// See [`InvalidRestoreFault`](crate::error::InvalidRestoreFault).
pub mod invalid_restore_fault {

    /// A builder for [`InvalidRestoreFault`](crate::error::InvalidRestoreFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A message describing the details of the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message describing the details of the problem.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidRestoreFault`](crate::error::InvalidRestoreFault).
        pub fn build(self) -> crate::error::InvalidRestoreFault {
            crate::error::InvalidRestoreFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidRestoreFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidRestoreFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidRestoreFault")?;
        if let Some(inner_9) = &self.message {
            {
                write!(f, ": {}", inner_9)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidRestoreFault {}
impl aws_http::request_id::RequestId for crate::error::InvalidRestoreFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidRestoreFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The state of the DB snapshot does not allow deletion.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidDbSnapshotStateFault {
    /// <p>A message describing the details of the problem.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidDbSnapshotStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidDbSnapshotStateFault`](crate::error::InvalidDbSnapshotStateFault).
    pub fn builder() -> crate::error::invalid_db_snapshot_state_fault::Builder {
        crate::error::invalid_db_snapshot_state_fault::Builder::default()
    }
}
/// See [`InvalidDbSnapshotStateFault`](crate::error::InvalidDbSnapshotStateFault).
pub mod invalid_db_snapshot_state_fault {

    /// A builder for [`InvalidDbSnapshotStateFault`](crate::error::InvalidDbSnapshotStateFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A message describing the details of the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message describing the details of the problem.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidDbSnapshotStateFault`](crate::error::InvalidDbSnapshotStateFault).
        pub fn build(self) -> crate::error::InvalidDbSnapshotStateFault {
            crate::error::InvalidDbSnapshotStateFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidDbSnapshotStateFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidDbSnapshotStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "InvalidDbSnapshotStateFault [InvalidDBSnapshotStateFault]"
        )?;
        if let Some(inner_10) = &self.message {
            {
                write!(f, ": {}", inner_10)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidDbSnapshotStateFault {}
impl aws_http::request_id::RequestId for crate::error::InvalidDbSnapshotStateFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidDbSnapshotStateFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The supplied value is not a valid DB cluster snapshot state.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidDbClusterSnapshotStateFault {
    /// <p>A message describing the details of the problem.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidDbClusterSnapshotStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidDbClusterSnapshotStateFault`](crate::error::InvalidDbClusterSnapshotStateFault).
    pub fn builder() -> crate::error::invalid_db_cluster_snapshot_state_fault::Builder {
        crate::error::invalid_db_cluster_snapshot_state_fault::Builder::default()
    }
}
/// See [`InvalidDbClusterSnapshotStateFault`](crate::error::InvalidDbClusterSnapshotStateFault).
pub mod invalid_db_cluster_snapshot_state_fault {

    /// A builder for [`InvalidDbClusterSnapshotStateFault`](crate::error::InvalidDbClusterSnapshotStateFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A message describing the details of the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message describing the details of the problem.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidDbClusterSnapshotStateFault`](crate::error::InvalidDbClusterSnapshotStateFault).
        pub fn build(self) -> crate::error::InvalidDbClusterSnapshotStateFault {
            crate::error::InvalidDbClusterSnapshotStateFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidDbClusterSnapshotStateFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidDbClusterSnapshotStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "InvalidDbClusterSnapshotStateFault [InvalidDBClusterSnapshotStateFault]"
        )?;
        if let Some(inner_11) = &self.message {
            {
                write!(f, ": {}", inner_11)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidDbClusterSnapshotStateFault {}
impl aws_http::request_id::RequestId for crate::error::InvalidDbClusterSnapshotStateFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for InvalidDbClusterSnapshotStateFault
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>There is insufficient storage available for the current action. You may be able to resolve this error by updating your subnet group to use different Availability Zones that have more storage available.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InsufficientStorageClusterCapacityFault {
    /// <p>A message describing the details of the problem.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InsufficientStorageClusterCapacityFault {
    /// Creates a new builder-style object to manufacture [`InsufficientStorageClusterCapacityFault`](crate::error::InsufficientStorageClusterCapacityFault).
    pub fn builder() -> crate::error::insufficient_storage_cluster_capacity_fault::Builder {
        crate::error::insufficient_storage_cluster_capacity_fault::Builder::default()
    }
}
/// See [`InsufficientStorageClusterCapacityFault`](crate::error::InsufficientStorageClusterCapacityFault).
pub mod insufficient_storage_cluster_capacity_fault {

    /// A builder for [`InsufficientStorageClusterCapacityFault`](crate::error::InsufficientStorageClusterCapacityFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A message describing the details of the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message describing the details of the problem.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InsufficientStorageClusterCapacityFault`](crate::error::InsufficientStorageClusterCapacityFault).
        pub fn build(self) -> crate::error::InsufficientStorageClusterCapacityFault {
            crate::error::InsufficientStorageClusterCapacityFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InsufficientStorageClusterCapacityFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InsufficientStorageClusterCapacityFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InsufficientStorageClusterCapacityFault")?;
        if let Some(inner_12) = &self.message {
            {
                write!(f, ": {}", inner_12)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InsufficientStorageClusterCapacityFault {}
impl aws_http::request_id::RequestId for crate::error::InsufficientStorageClusterCapacityFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for InsufficientStorageClusterCapacityFault
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The DB cluster does not have enough capacity for the current operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InsufficientDbClusterCapacityFault {
    /// <p>A message describing the details of the problem.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InsufficientDbClusterCapacityFault {
    /// Creates a new builder-style object to manufacture [`InsufficientDbClusterCapacityFault`](crate::error::InsufficientDbClusterCapacityFault).
    pub fn builder() -> crate::error::insufficient_db_cluster_capacity_fault::Builder {
        crate::error::insufficient_db_cluster_capacity_fault::Builder::default()
    }
}
/// See [`InsufficientDbClusterCapacityFault`](crate::error::InsufficientDbClusterCapacityFault).
pub mod insufficient_db_cluster_capacity_fault {

    /// A builder for [`InsufficientDbClusterCapacityFault`](crate::error::InsufficientDbClusterCapacityFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A message describing the details of the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message describing the details of the problem.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InsufficientDbClusterCapacityFault`](crate::error::InsufficientDbClusterCapacityFault).
        pub fn build(self) -> crate::error::InsufficientDbClusterCapacityFault {
            crate::error::InsufficientDbClusterCapacityFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InsufficientDbClusterCapacityFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InsufficientDbClusterCapacityFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "InsufficientDbClusterCapacityFault [InsufficientDBClusterCapacityFault]"
        )?;
        if let Some(inner_13) = &self.message {
            {
                write!(f, ": {}", inner_13)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InsufficientDbClusterCapacityFault {}
impl aws_http::request_id::RequestId for crate::error::InsufficientDbClusterCapacityFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for InsufficientDbClusterCapacityFault
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p> <i>DBSubnetGroupName</i> does not refer to an existing DB subnet group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DbSubnetGroupNotFoundFault {
    /// <p>A message describing the details of the problem.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl DbSubnetGroupNotFoundFault {
    /// Creates a new builder-style object to manufacture [`DbSubnetGroupNotFoundFault`](crate::error::DbSubnetGroupNotFoundFault).
    pub fn builder() -> crate::error::db_subnet_group_not_found_fault::Builder {
        crate::error::db_subnet_group_not_found_fault::Builder::default()
    }
}
/// See [`DbSubnetGroupNotFoundFault`](crate::error::DbSubnetGroupNotFoundFault).
pub mod db_subnet_group_not_found_fault {

    /// A builder for [`DbSubnetGroupNotFoundFault`](crate::error::DbSubnetGroupNotFoundFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A message describing the details of the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message describing the details of the problem.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`DbSubnetGroupNotFoundFault`](crate::error::DbSubnetGroupNotFoundFault).
        pub fn build(self) -> crate::error::DbSubnetGroupNotFoundFault {
            crate::error::DbSubnetGroupNotFoundFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl DbSubnetGroupNotFoundFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DbSubnetGroupNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DbSubnetGroupNotFoundFault [DBSubnetGroupNotFoundFault]")?;
        if let Some(inner_14) = &self.message {
            {
                write!(f, ": {}", inner_14)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DbSubnetGroupNotFoundFault {}
impl aws_http::request_id::RequestId for crate::error::DbSubnetGroupNotFoundFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DbSubnetGroupNotFoundFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p> <i>DBClusterSnapshotIdentifier</i> does not refer to an existing DB cluster snapshot.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DbClusterSnapshotNotFoundFault {
    /// <p>A message describing the details of the problem.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl DbClusterSnapshotNotFoundFault {
    /// Creates a new builder-style object to manufacture [`DbClusterSnapshotNotFoundFault`](crate::error::DbClusterSnapshotNotFoundFault).
    pub fn builder() -> crate::error::db_cluster_snapshot_not_found_fault::Builder {
        crate::error::db_cluster_snapshot_not_found_fault::Builder::default()
    }
}
/// See [`DbClusterSnapshotNotFoundFault`](crate::error::DbClusterSnapshotNotFoundFault).
pub mod db_cluster_snapshot_not_found_fault {

    /// A builder for [`DbClusterSnapshotNotFoundFault`](crate::error::DbClusterSnapshotNotFoundFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A message describing the details of the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message describing the details of the problem.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`DbClusterSnapshotNotFoundFault`](crate::error::DbClusterSnapshotNotFoundFault).
        pub fn build(self) -> crate::error::DbClusterSnapshotNotFoundFault {
            crate::error::DbClusterSnapshotNotFoundFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl DbClusterSnapshotNotFoundFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DbClusterSnapshotNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "DbClusterSnapshotNotFoundFault [DBClusterSnapshotNotFoundFault]"
        )?;
        if let Some(inner_15) = &self.message {
            {
                write!(f, ": {}", inner_15)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DbClusterSnapshotNotFoundFault {}
impl aws_http::request_id::RequestId for crate::error::DbClusterSnapshotNotFoundFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DbClusterSnapshotNotFoundFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>User attempted to create a new DB cluster and the user has already reached the maximum allowed DB cluster quota.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DbClusterQuotaExceededFault {
    /// <p>A message describing the details of the problem.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl DbClusterQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`DbClusterQuotaExceededFault`](crate::error::DbClusterQuotaExceededFault).
    pub fn builder() -> crate::error::db_cluster_quota_exceeded_fault::Builder {
        crate::error::db_cluster_quota_exceeded_fault::Builder::default()
    }
}
/// See [`DbClusterQuotaExceededFault`](crate::error::DbClusterQuotaExceededFault).
pub mod db_cluster_quota_exceeded_fault {

    /// A builder for [`DbClusterQuotaExceededFault`](crate::error::DbClusterQuotaExceededFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A message describing the details of the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message describing the details of the problem.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`DbClusterQuotaExceededFault`](crate::error::DbClusterQuotaExceededFault).
        pub fn build(self) -> crate::error::DbClusterQuotaExceededFault {
            crate::error::DbClusterQuotaExceededFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl DbClusterQuotaExceededFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DbClusterQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "DbClusterQuotaExceededFault [DBClusterQuotaExceededFault]"
        )?;
        if let Some(inner_16) = &self.message {
            {
                write!(f, ": {}", inner_16)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DbClusterQuotaExceededFault {}
impl aws_http::request_id::RequestId for crate::error::DbClusterQuotaExceededFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DbClusterQuotaExceededFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p> <i>DBClusterParameterGroupName</i> does not refer to an existing DB Cluster parameter group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DbClusterParameterGroupNotFoundFault {
    /// <p>A message describing the details of the problem.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl DbClusterParameterGroupNotFoundFault {
    /// Creates a new builder-style object to manufacture [`DbClusterParameterGroupNotFoundFault`](crate::error::DbClusterParameterGroupNotFoundFault).
    pub fn builder() -> crate::error::db_cluster_parameter_group_not_found_fault::Builder {
        crate::error::db_cluster_parameter_group_not_found_fault::Builder::default()
    }
}
/// See [`DbClusterParameterGroupNotFoundFault`](crate::error::DbClusterParameterGroupNotFoundFault).
pub mod db_cluster_parameter_group_not_found_fault {

    /// A builder for [`DbClusterParameterGroupNotFoundFault`](crate::error::DbClusterParameterGroupNotFoundFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A message describing the details of the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message describing the details of the problem.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`DbClusterParameterGroupNotFoundFault`](crate::error::DbClusterParameterGroupNotFoundFault).
        pub fn build(self) -> crate::error::DbClusterParameterGroupNotFoundFault {
            crate::error::DbClusterParameterGroupNotFoundFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl DbClusterParameterGroupNotFoundFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DbClusterParameterGroupNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "DbClusterParameterGroupNotFoundFault [DBClusterParameterGroupNotFoundFault]"
        )?;
        if let Some(inner_17) = &self.message {
            {
                write!(f, ": {}", inner_17)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DbClusterParameterGroupNotFoundFault {}
impl aws_http::request_id::RequestId for crate::error::DbClusterParameterGroupNotFoundFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for DbClusterParameterGroupNotFoundFault
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>User already has a DB cluster with the given identifier.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DbClusterAlreadyExistsFault {
    /// <p>A message describing the details of the problem.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl DbClusterAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`DbClusterAlreadyExistsFault`](crate::error::DbClusterAlreadyExistsFault).
    pub fn builder() -> crate::error::db_cluster_already_exists_fault::Builder {
        crate::error::db_cluster_already_exists_fault::Builder::default()
    }
}
/// See [`DbClusterAlreadyExistsFault`](crate::error::DbClusterAlreadyExistsFault).
pub mod db_cluster_already_exists_fault {

    /// A builder for [`DbClusterAlreadyExistsFault`](crate::error::DbClusterAlreadyExistsFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A message describing the details of the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message describing the details of the problem.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`DbClusterAlreadyExistsFault`](crate::error::DbClusterAlreadyExistsFault).
        pub fn build(self) -> crate::error::DbClusterAlreadyExistsFault {
            crate::error::DbClusterAlreadyExistsFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl DbClusterAlreadyExistsFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DbClusterAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "DbClusterAlreadyExistsFault [DBClusterAlreadyExistsFault]"
        )?;
        if let Some(inner_18) = &self.message {
            {
                write!(f, ": {}", inner_18)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DbClusterAlreadyExistsFault {}
impl aws_http::request_id::RequestId for crate::error::DbClusterAlreadyExistsFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DbClusterAlreadyExistsFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type RestoreDBClusterFromSnapshotErrorKind = RestoreDBClusterFromSnapshotError;
/// Error type for the `RestoreDBClusterFromSnapshotError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RestoreDBClusterFromSnapshotError {
    /// <p>User already has a DB cluster with the given identifier.</p>
    DbClusterAlreadyExistsFault(crate::error::DbClusterAlreadyExistsFault),
    /// <p> <i>DBClusterParameterGroupName</i> does not refer to an existing DB Cluster parameter group.</p>
    DbClusterParameterGroupNotFoundFault(crate::error::DbClusterParameterGroupNotFoundFault),
    /// <p>User attempted to create a new DB cluster and the user has already reached the maximum allowed DB cluster quota.</p>
    DbClusterQuotaExceededFault(crate::error::DbClusterQuotaExceededFault),
    /// <p> <i>DBClusterSnapshotIdentifier</i> does not refer to an existing DB cluster snapshot.</p>
    DbClusterSnapshotNotFoundFault(crate::error::DbClusterSnapshotNotFoundFault),
    /// <p> <i>DBSnapshotIdentifier</i> does not refer to an existing DB snapshot.</p>
    DbSnapshotNotFoundFault(crate::error::DbSnapshotNotFoundFault),
    /// <p> <i>DBSubnetGroupName</i> does not refer to an existing DB subnet group.</p>
    DbSubnetGroupNotFoundFault(crate::error::DbSubnetGroupNotFoundFault),
    /// <p>The DB cluster does not have enough capacity for the current operation.</p>
    InsufficientDbClusterCapacityFault(crate::error::InsufficientDbClusterCapacityFault),
    /// <p>There is insufficient storage available for the current action. You may be able to resolve this error by updating your subnet group to use different Availability Zones that have more storage available.</p>
    InsufficientStorageClusterCapacityFault(crate::error::InsufficientStorageClusterCapacityFault),
    /// <p>The supplied value is not a valid DB cluster snapshot state.</p>
    InvalidDbClusterSnapshotStateFault(crate::error::InvalidDbClusterSnapshotStateFault),
    /// <p>The state of the DB snapshot does not allow deletion.</p>
    InvalidDbSnapshotStateFault(crate::error::InvalidDbSnapshotStateFault),
    /// <p>Cannot restore from vpc backup to non-vpc DB instance.</p>
    InvalidRestoreFault(crate::error::InvalidRestoreFault),
    /// <p>The requested subnet is invalid, or multiple subnets were requested that are not all in a common VPC.</p>
    InvalidSubnet(crate::error::InvalidSubnet),
    /// <p>DB subnet group does not cover all Availability Zones after it is created because users' change.</p>
    InvalidVpcNetworkStateFault(crate::error::InvalidVpcNetworkStateFault),
    /// <p>Error accessing KMS key.</p>
    KmsKeyNotAccessibleFault(crate::error::KmsKeyNotAccessibleFault),
    /// <p>The designated option group could not be found.</p>
    OptionGroupNotFoundFault(crate::error::OptionGroupNotFoundFault),
    /// <p>Request would result in user exceeding the allowed amount of storage available across all DB instances.</p>
    StorageQuotaExceededFault(crate::error::StorageQuotaExceededFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for RestoreDBClusterFromSnapshotError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for RestoreDBClusterFromSnapshotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DbClusterAlreadyExistsFault(_inner) => _inner.fmt(f),
            Self::DbClusterParameterGroupNotFoundFault(_inner) => _inner.fmt(f),
            Self::DbClusterQuotaExceededFault(_inner) => _inner.fmt(f),
            Self::DbClusterSnapshotNotFoundFault(_inner) => _inner.fmt(f),
            Self::DbSnapshotNotFoundFault(_inner) => _inner.fmt(f),
            Self::DbSubnetGroupNotFoundFault(_inner) => _inner.fmt(f),
            Self::InsufficientDbClusterCapacityFault(_inner) => _inner.fmt(f),
            Self::InsufficientStorageClusterCapacityFault(_inner) => _inner.fmt(f),
            Self::InvalidDbClusterSnapshotStateFault(_inner) => _inner.fmt(f),
            Self::InvalidDbSnapshotStateFault(_inner) => _inner.fmt(f),
            Self::InvalidRestoreFault(_inner) => _inner.fmt(f),
            Self::InvalidSubnet(_inner) => _inner.fmt(f),
            Self::InvalidVpcNetworkStateFault(_inner) => _inner.fmt(f),
            Self::KmsKeyNotAccessibleFault(_inner) => _inner.fmt(f),
            Self::OptionGroupNotFoundFault(_inner) => _inner.fmt(f),
            Self::StorageQuotaExceededFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for RestoreDBClusterFromSnapshotError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DbClusterAlreadyExistsFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DbClusterParameterGroupNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DbClusterQuotaExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DbClusterSnapshotNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DbSnapshotNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DbSubnetGroupNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InsufficientDbClusterCapacityFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InsufficientStorageClusterCapacityFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDbClusterSnapshotStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDbSnapshotStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRestoreFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidSubnet(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidVpcNetworkStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::KmsKeyNotAccessibleFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::OptionGroupNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::StorageQuotaExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::RestoreDBClusterFromSnapshotError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for RestoreDBClusterFromSnapshotError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl RestoreDBClusterFromSnapshotError {
    /// Creates the `RestoreDBClusterFromSnapshotError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `RestoreDBClusterFromSnapshotError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DbClusterAlreadyExistsFault(e) => e.meta(),
            Self::DbClusterParameterGroupNotFoundFault(e) => e.meta(),
            Self::DbClusterQuotaExceededFault(e) => e.meta(),
            Self::DbClusterSnapshotNotFoundFault(e) => e.meta(),
            Self::DbSnapshotNotFoundFault(e) => e.meta(),
            Self::DbSubnetGroupNotFoundFault(e) => e.meta(),
            Self::InsufficientDbClusterCapacityFault(e) => e.meta(),
            Self::InsufficientStorageClusterCapacityFault(e) => e.meta(),
            Self::InvalidDbClusterSnapshotStateFault(e) => e.meta(),
            Self::InvalidDbSnapshotStateFault(e) => e.meta(),
            Self::InvalidRestoreFault(e) => e.meta(),
            Self::InvalidSubnet(e) => e.meta(),
            Self::InvalidVpcNetworkStateFault(e) => e.meta(),
            Self::KmsKeyNotAccessibleFault(e) => e.meta(),
            Self::OptionGroupNotFoundFault(e) => e.meta(),
            Self::StorageQuotaExceededFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `RestoreDBClusterFromSnapshotError::DbClusterAlreadyExistsFault`.
    pub fn is_db_cluster_already_exists_fault(&self) -> bool {
        matches!(self, Self::DbClusterAlreadyExistsFault(_))
    }
    /// Returns `true` if the error kind is `RestoreDBClusterFromSnapshotError::DbClusterParameterGroupNotFoundFault`.
    pub fn is_db_cluster_parameter_group_not_found_fault(&self) -> bool {
        matches!(self, Self::DbClusterParameterGroupNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `RestoreDBClusterFromSnapshotError::DbClusterQuotaExceededFault`.
    pub fn is_db_cluster_quota_exceeded_fault(&self) -> bool {
        matches!(self, Self::DbClusterQuotaExceededFault(_))
    }
    /// Returns `true` if the error kind is `RestoreDBClusterFromSnapshotError::DbClusterSnapshotNotFoundFault`.
    pub fn is_db_cluster_snapshot_not_found_fault(&self) -> bool {
        matches!(self, Self::DbClusterSnapshotNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `RestoreDBClusterFromSnapshotError::DbSnapshotNotFoundFault`.
    pub fn is_db_snapshot_not_found_fault(&self) -> bool {
        matches!(self, Self::DbSnapshotNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `RestoreDBClusterFromSnapshotError::DbSubnetGroupNotFoundFault`.
    pub fn is_db_subnet_group_not_found_fault(&self) -> bool {
        matches!(self, Self::DbSubnetGroupNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `RestoreDBClusterFromSnapshotError::InsufficientDbClusterCapacityFault`.
    pub fn is_insufficient_db_cluster_capacity_fault(&self) -> bool {
        matches!(self, Self::InsufficientDbClusterCapacityFault(_))
    }
    /// Returns `true` if the error kind is `RestoreDBClusterFromSnapshotError::InsufficientStorageClusterCapacityFault`.
    pub fn is_insufficient_storage_cluster_capacity_fault(&self) -> bool {
        matches!(self, Self::InsufficientStorageClusterCapacityFault(_))
    }
    /// Returns `true` if the error kind is `RestoreDBClusterFromSnapshotError::InvalidDbClusterSnapshotStateFault`.
    pub fn is_invalid_db_cluster_snapshot_state_fault(&self) -> bool {
        matches!(self, Self::InvalidDbClusterSnapshotStateFault(_))
    }
    /// Returns `true` if the error kind is `RestoreDBClusterFromSnapshotError::InvalidDbSnapshotStateFault`.
    pub fn is_invalid_db_snapshot_state_fault(&self) -> bool {
        matches!(self, Self::InvalidDbSnapshotStateFault(_))
    }
    /// Returns `true` if the error kind is `RestoreDBClusterFromSnapshotError::InvalidRestoreFault`.
    pub fn is_invalid_restore_fault(&self) -> bool {
        matches!(self, Self::InvalidRestoreFault(_))
    }
    /// Returns `true` if the error kind is `RestoreDBClusterFromSnapshotError::InvalidSubnet`.
    pub fn is_invalid_subnet(&self) -> bool {
        matches!(self, Self::InvalidSubnet(_))
    }
    /// Returns `true` if the error kind is `RestoreDBClusterFromSnapshotError::InvalidVpcNetworkStateFault`.
    pub fn is_invalid_vpc_network_state_fault(&self) -> bool {
        matches!(self, Self::InvalidVpcNetworkStateFault(_))
    }
    /// Returns `true` if the error kind is `RestoreDBClusterFromSnapshotError::KmsKeyNotAccessibleFault`.
    pub fn is_kms_key_not_accessible_fault(&self) -> bool {
        matches!(self, Self::KmsKeyNotAccessibleFault(_))
    }
    /// Returns `true` if the error kind is `RestoreDBClusterFromSnapshotError::OptionGroupNotFoundFault`.
    pub fn is_option_group_not_found_fault(&self) -> bool {
        matches!(self, Self::OptionGroupNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `RestoreDBClusterFromSnapshotError::StorageQuotaExceededFault`.
    pub fn is_storage_quota_exceeded_fault(&self) -> bool {
        matches!(self, Self::StorageQuotaExceededFault(_))
    }
}
impl std::error::Error for RestoreDBClusterFromSnapshotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DbClusterAlreadyExistsFault(_inner) => Some(_inner),
            Self::DbClusterParameterGroupNotFoundFault(_inner) => Some(_inner),
            Self::DbClusterQuotaExceededFault(_inner) => Some(_inner),
            Self::DbClusterSnapshotNotFoundFault(_inner) => Some(_inner),
            Self::DbSnapshotNotFoundFault(_inner) => Some(_inner),
            Self::DbSubnetGroupNotFoundFault(_inner) => Some(_inner),
            Self::InsufficientDbClusterCapacityFault(_inner) => Some(_inner),
            Self::InsufficientStorageClusterCapacityFault(_inner) => Some(_inner),
            Self::InvalidDbClusterSnapshotStateFault(_inner) => Some(_inner),
            Self::InvalidDbSnapshotStateFault(_inner) => Some(_inner),
            Self::InvalidRestoreFault(_inner) => Some(_inner),
            Self::InvalidSubnet(_inner) => Some(_inner),
            Self::InvalidVpcNetworkStateFault(_inner) => Some(_inner),
            Self::KmsKeyNotAccessibleFault(_inner) => Some(_inner),
            Self::OptionGroupNotFoundFault(_inner) => Some(_inner),
            Self::StorageQuotaExceededFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p> <i>DBSnapshotIdentifier</i> does not refer to an existing DB snapshot.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DbSnapshotNotFoundFault {
    /// <p>A message describing the details of the problem.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl DbSnapshotNotFoundFault {
    /// Creates a new builder-style object to manufacture [`DbSnapshotNotFoundFault`](crate::error::DbSnapshotNotFoundFault).
    pub fn builder() -> crate::error::db_snapshot_not_found_fault::Builder {
        crate::error::db_snapshot_not_found_fault::Builder::default()
    }
}
/// See [`DbSnapshotNotFoundFault`](crate::error::DbSnapshotNotFoundFault).
pub mod db_snapshot_not_found_fault {

    /// A builder for [`DbSnapshotNotFoundFault`](crate::error::DbSnapshotNotFoundFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A message describing the details of the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message describing the details of the problem.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`DbSnapshotNotFoundFault`](crate::error::DbSnapshotNotFoundFault).
        pub fn build(self) -> crate::error::DbSnapshotNotFoundFault {
            crate::error::DbSnapshotNotFoundFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl DbSnapshotNotFoundFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DbSnapshotNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DbSnapshotNotFoundFault [DBSnapshotNotFoundFault]")?;
        if let Some(inner_19) = &self.message {
            {
                write!(f, ": {}", inner_19)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DbSnapshotNotFoundFault {}
impl aws_http::request_id::RequestId for crate::error::DbSnapshotNotFoundFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DbSnapshotNotFoundFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ResetDBParameterGroupErrorKind = ResetDBParameterGroupError;
/// Error type for the `ResetDBParameterGroupError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ResetDBParameterGroupError {
    /// <p> <i>DBParameterGroupName</i> does not refer to an existing DB parameter group.</p>
    DbParameterGroupNotFoundFault(crate::error::DbParameterGroupNotFoundFault),
    /// <p>The DB parameter group is in use or is in an invalid state. If you are attempting to delete the parameter group, you cannot delete it when the parameter group is in this state.</p>
    InvalidDbParameterGroupStateFault(crate::error::InvalidDbParameterGroupStateFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ResetDBParameterGroupError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ResetDBParameterGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DbParameterGroupNotFoundFault(_inner) => _inner.fmt(f),
            Self::InvalidDbParameterGroupStateFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ResetDBParameterGroupError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DbParameterGroupNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDbParameterGroupStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ResetDBParameterGroupError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ResetDBParameterGroupError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ResetDBParameterGroupError {
    /// Creates the `ResetDBParameterGroupError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ResetDBParameterGroupError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DbParameterGroupNotFoundFault(e) => e.meta(),
            Self::InvalidDbParameterGroupStateFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ResetDBParameterGroupError::DbParameterGroupNotFoundFault`.
    pub fn is_db_parameter_group_not_found_fault(&self) -> bool {
        matches!(self, Self::DbParameterGroupNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `ResetDBParameterGroupError::InvalidDbParameterGroupStateFault`.
    pub fn is_invalid_db_parameter_group_state_fault(&self) -> bool {
        matches!(self, Self::InvalidDbParameterGroupStateFault(_))
    }
}
impl std::error::Error for ResetDBParameterGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DbParameterGroupNotFoundFault(_inner) => Some(_inner),
            Self::InvalidDbParameterGroupStateFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The DB parameter group is in use or is in an invalid state. If you are attempting to delete the parameter group, you cannot delete it when the parameter group is in this state.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidDbParameterGroupStateFault {
    /// <p>A message describing the details of the problem.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidDbParameterGroupStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidDbParameterGroupStateFault`](crate::error::InvalidDbParameterGroupStateFault).
    pub fn builder() -> crate::error::invalid_db_parameter_group_state_fault::Builder {
        crate::error::invalid_db_parameter_group_state_fault::Builder::default()
    }
}
/// See [`InvalidDbParameterGroupStateFault`](crate::error::InvalidDbParameterGroupStateFault).
pub mod invalid_db_parameter_group_state_fault {

    /// A builder for [`InvalidDbParameterGroupStateFault`](crate::error::InvalidDbParameterGroupStateFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A message describing the details of the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message describing the details of the problem.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidDbParameterGroupStateFault`](crate::error::InvalidDbParameterGroupStateFault).
        pub fn build(self) -> crate::error::InvalidDbParameterGroupStateFault {
            crate::error::InvalidDbParameterGroupStateFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidDbParameterGroupStateFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidDbParameterGroupStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "InvalidDbParameterGroupStateFault [InvalidDBParameterGroupStateFault]"
        )?;
        if let Some(inner_20) = &self.message {
            {
                write!(f, ": {}", inner_20)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidDbParameterGroupStateFault {}
impl aws_http::request_id::RequestId for crate::error::InvalidDbParameterGroupStateFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidDbParameterGroupStateFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p> <i>DBParameterGroupName</i> does not refer to an existing DB parameter group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DbParameterGroupNotFoundFault {
    /// <p>A message describing the details of the problem.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl DbParameterGroupNotFoundFault {
    /// Creates a new builder-style object to manufacture [`DbParameterGroupNotFoundFault`](crate::error::DbParameterGroupNotFoundFault).
    pub fn builder() -> crate::error::db_parameter_group_not_found_fault::Builder {
        crate::error::db_parameter_group_not_found_fault::Builder::default()
    }
}
/// See [`DbParameterGroupNotFoundFault`](crate::error::DbParameterGroupNotFoundFault).
pub mod db_parameter_group_not_found_fault {

    /// A builder for [`DbParameterGroupNotFoundFault`](crate::error::DbParameterGroupNotFoundFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A message describing the details of the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message describing the details of the problem.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`DbParameterGroupNotFoundFault`](crate::error::DbParameterGroupNotFoundFault).
        pub fn build(self) -> crate::error::DbParameterGroupNotFoundFault {
            crate::error::DbParameterGroupNotFoundFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl DbParameterGroupNotFoundFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DbParameterGroupNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "DbParameterGroupNotFoundFault [DBParameterGroupNotFoundFault]"
        )?;
        if let Some(inner_21) = &self.message {
            {
                write!(f, ": {}", inner_21)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DbParameterGroupNotFoundFault {}
impl aws_http::request_id::RequestId for crate::error::DbParameterGroupNotFoundFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DbParameterGroupNotFoundFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ResetDBClusterParameterGroupErrorKind = ResetDBClusterParameterGroupError;
/// Error type for the `ResetDBClusterParameterGroupError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ResetDBClusterParameterGroupError {
    /// <p> <i>DBParameterGroupName</i> does not refer to an existing DB parameter group.</p>
    DbParameterGroupNotFoundFault(crate::error::DbParameterGroupNotFoundFault),
    /// <p>The DB parameter group is in use or is in an invalid state. If you are attempting to delete the parameter group, you cannot delete it when the parameter group is in this state.</p>
    InvalidDbParameterGroupStateFault(crate::error::InvalidDbParameterGroupStateFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ResetDBClusterParameterGroupError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ResetDBClusterParameterGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DbParameterGroupNotFoundFault(_inner) => _inner.fmt(f),
            Self::InvalidDbParameterGroupStateFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ResetDBClusterParameterGroupError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DbParameterGroupNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDbParameterGroupStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ResetDBClusterParameterGroupError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ResetDBClusterParameterGroupError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ResetDBClusterParameterGroupError {
    /// Creates the `ResetDBClusterParameterGroupError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ResetDBClusterParameterGroupError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DbParameterGroupNotFoundFault(e) => e.meta(),
            Self::InvalidDbParameterGroupStateFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ResetDBClusterParameterGroupError::DbParameterGroupNotFoundFault`.
    pub fn is_db_parameter_group_not_found_fault(&self) -> bool {
        matches!(self, Self::DbParameterGroupNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `ResetDBClusterParameterGroupError::InvalidDbParameterGroupStateFault`.
    pub fn is_invalid_db_parameter_group_state_fault(&self) -> bool {
        matches!(self, Self::InvalidDbParameterGroupStateFault(_))
    }
}
impl std::error::Error for ResetDBClusterParameterGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DbParameterGroupNotFoundFault(_inner) => Some(_inner),
            Self::InvalidDbParameterGroupStateFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type RemoveTagsFromResourceErrorKind = RemoveTagsFromResourceError;
/// Error type for the `RemoveTagsFromResourceError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RemoveTagsFromResourceError {
    /// <p> <i>DBClusterIdentifier</i> does not refer to an existing DB cluster.</p>
    DbClusterNotFoundFault(crate::error::DbClusterNotFoundFault),
    /// <p> <i>DBInstanceIdentifier</i> does not refer to an existing DB instance.</p>
    DbInstanceNotFoundFault(crate::error::DbInstanceNotFoundFault),
    /// <p> <i>DBSnapshotIdentifier</i> does not refer to an existing DB snapshot.</p>
    DbSnapshotNotFoundFault(crate::error::DbSnapshotNotFoundFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for RemoveTagsFromResourceError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for RemoveTagsFromResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DbClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::DbInstanceNotFoundFault(_inner) => _inner.fmt(f),
            Self::DbSnapshotNotFoundFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for RemoveTagsFromResourceError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DbClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DbInstanceNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DbSnapshotNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::RemoveTagsFromResourceError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for RemoveTagsFromResourceError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl RemoveTagsFromResourceError {
    /// Creates the `RemoveTagsFromResourceError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `RemoveTagsFromResourceError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DbClusterNotFoundFault(e) => e.meta(),
            Self::DbInstanceNotFoundFault(e) => e.meta(),
            Self::DbSnapshotNotFoundFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `RemoveTagsFromResourceError::DbClusterNotFoundFault`.
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::DbClusterNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `RemoveTagsFromResourceError::DbInstanceNotFoundFault`.
    pub fn is_db_instance_not_found_fault(&self) -> bool {
        matches!(self, Self::DbInstanceNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `RemoveTagsFromResourceError::DbSnapshotNotFoundFault`.
    pub fn is_db_snapshot_not_found_fault(&self) -> bool {
        matches!(self, Self::DbSnapshotNotFoundFault(_))
    }
}
impl std::error::Error for RemoveTagsFromResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DbClusterNotFoundFault(_inner) => Some(_inner),
            Self::DbInstanceNotFoundFault(_inner) => Some(_inner),
            Self::DbSnapshotNotFoundFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p> <i>DBInstanceIdentifier</i> does not refer to an existing DB instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DbInstanceNotFoundFault {
    /// <p>A message describing the details of the problem.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl DbInstanceNotFoundFault {
    /// Creates a new builder-style object to manufacture [`DbInstanceNotFoundFault`](crate::error::DbInstanceNotFoundFault).
    pub fn builder() -> crate::error::db_instance_not_found_fault::Builder {
        crate::error::db_instance_not_found_fault::Builder::default()
    }
}
/// See [`DbInstanceNotFoundFault`](crate::error::DbInstanceNotFoundFault).
pub mod db_instance_not_found_fault {

    /// A builder for [`DbInstanceNotFoundFault`](crate::error::DbInstanceNotFoundFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A message describing the details of the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message describing the details of the problem.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`DbInstanceNotFoundFault`](crate::error::DbInstanceNotFoundFault).
        pub fn build(self) -> crate::error::DbInstanceNotFoundFault {
            crate::error::DbInstanceNotFoundFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl DbInstanceNotFoundFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DbInstanceNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DbInstanceNotFoundFault [DBInstanceNotFoundFault]")?;
        if let Some(inner_22) = &self.message {
            {
                write!(f, ": {}", inner_22)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DbInstanceNotFoundFault {}
impl aws_http::request_id::RequestId for crate::error::DbInstanceNotFoundFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DbInstanceNotFoundFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type RemoveSourceIdentifierFromSubscriptionErrorKind =
    RemoveSourceIdentifierFromSubscriptionError;
/// Error type for the `RemoveSourceIdentifierFromSubscriptionError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RemoveSourceIdentifierFromSubscriptionError {
    /// <p>The source could not be found.</p>
    SourceNotFoundFault(crate::error::SourceNotFoundFault),
    /// <p>The designated subscription could not be found.</p>
    SubscriptionNotFoundFault(crate::error::SubscriptionNotFoundFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for RemoveSourceIdentifierFromSubscriptionError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for RemoveSourceIdentifierFromSubscriptionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::SourceNotFoundFault(_inner) => _inner.fmt(f),
            Self::SubscriptionNotFoundFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for RemoveSourceIdentifierFromSubscriptionError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::SourceNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SubscriptionNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::RemoveSourceIdentifierFromSubscriptionError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for RemoveSourceIdentifierFromSubscriptionError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl RemoveSourceIdentifierFromSubscriptionError {
    /// Creates the `RemoveSourceIdentifierFromSubscriptionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `RemoveSourceIdentifierFromSubscriptionError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::SourceNotFoundFault(e) => e.meta(),
            Self::SubscriptionNotFoundFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `RemoveSourceIdentifierFromSubscriptionError::SourceNotFoundFault`.
    pub fn is_source_not_found_fault(&self) -> bool {
        matches!(self, Self::SourceNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `RemoveSourceIdentifierFromSubscriptionError::SubscriptionNotFoundFault`.
    pub fn is_subscription_not_found_fault(&self) -> bool {
        matches!(self, Self::SubscriptionNotFoundFault(_))
    }
}
impl std::error::Error for RemoveSourceIdentifierFromSubscriptionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::SourceNotFoundFault(_inner) => Some(_inner),
            Self::SubscriptionNotFoundFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The designated subscription could not be found.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SubscriptionNotFoundFault {
    /// <p>A message describing the details of the problem.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl SubscriptionNotFoundFault {
    /// Creates a new builder-style object to manufacture [`SubscriptionNotFoundFault`](crate::error::SubscriptionNotFoundFault).
    pub fn builder() -> crate::error::subscription_not_found_fault::Builder {
        crate::error::subscription_not_found_fault::Builder::default()
    }
}
/// See [`SubscriptionNotFoundFault`](crate::error::SubscriptionNotFoundFault).
pub mod subscription_not_found_fault {

    /// A builder for [`SubscriptionNotFoundFault`](crate::error::SubscriptionNotFoundFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A message describing the details of the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message describing the details of the problem.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`SubscriptionNotFoundFault`](crate::error::SubscriptionNotFoundFault).
        pub fn build(self) -> crate::error::SubscriptionNotFoundFault {
            crate::error::SubscriptionNotFoundFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl SubscriptionNotFoundFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SubscriptionNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SubscriptionNotFoundFault")?;
        if let Some(inner_23) = &self.message {
            {
                write!(f, ": {}", inner_23)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for SubscriptionNotFoundFault {}
impl aws_http::request_id::RequestId for crate::error::SubscriptionNotFoundFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for SubscriptionNotFoundFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The source could not be found.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SourceNotFoundFault {
    /// <p>A message describing the details of the problem.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl SourceNotFoundFault {
    /// Creates a new builder-style object to manufacture [`SourceNotFoundFault`](crate::error::SourceNotFoundFault).
    pub fn builder() -> crate::error::source_not_found_fault::Builder {
        crate::error::source_not_found_fault::Builder::default()
    }
}
/// See [`SourceNotFoundFault`](crate::error::SourceNotFoundFault).
pub mod source_not_found_fault {

    /// A builder for [`SourceNotFoundFault`](crate::error::SourceNotFoundFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A message describing the details of the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message describing the details of the problem.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`SourceNotFoundFault`](crate::error::SourceNotFoundFault).
        pub fn build(self) -> crate::error::SourceNotFoundFault {
            crate::error::SourceNotFoundFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl SourceNotFoundFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SourceNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SourceNotFoundFault")?;
        if let Some(inner_24) = &self.message {
            {
                write!(f, ": {}", inner_24)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for SourceNotFoundFault {}
impl aws_http::request_id::RequestId for crate::error::SourceNotFoundFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for SourceNotFoundFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type RemoveRoleFromDBClusterErrorKind = RemoveRoleFromDBClusterError;
/// Error type for the `RemoveRoleFromDBClusterError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RemoveRoleFromDBClusterError {
    /// <p> <i>DBClusterIdentifier</i> does not refer to an existing DB cluster.</p>
    DbClusterNotFoundFault(crate::error::DbClusterNotFoundFault),
    /// <p>The specified IAM role Amazon Resource Name (ARN) is not associated with the specified DB cluster.</p>
    DbClusterRoleNotFoundFault(crate::error::DbClusterRoleNotFoundFault),
    /// <p>The DB cluster is not in a valid state.</p>
    InvalidDbClusterStateFault(crate::error::InvalidDbClusterStateFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for RemoveRoleFromDBClusterError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for RemoveRoleFromDBClusterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DbClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::DbClusterRoleNotFoundFault(_inner) => _inner.fmt(f),
            Self::InvalidDbClusterStateFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for RemoveRoleFromDBClusterError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DbClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DbClusterRoleNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDbClusterStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::RemoveRoleFromDBClusterError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for RemoveRoleFromDBClusterError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl RemoveRoleFromDBClusterError {
    /// Creates the `RemoveRoleFromDBClusterError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `RemoveRoleFromDBClusterError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DbClusterNotFoundFault(e) => e.meta(),
            Self::DbClusterRoleNotFoundFault(e) => e.meta(),
            Self::InvalidDbClusterStateFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `RemoveRoleFromDBClusterError::DbClusterNotFoundFault`.
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::DbClusterNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `RemoveRoleFromDBClusterError::DbClusterRoleNotFoundFault`.
    pub fn is_db_cluster_role_not_found_fault(&self) -> bool {
        matches!(self, Self::DbClusterRoleNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `RemoveRoleFromDBClusterError::InvalidDbClusterStateFault`.
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(self, Self::InvalidDbClusterStateFault(_))
    }
}
impl std::error::Error for RemoveRoleFromDBClusterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DbClusterNotFoundFault(_inner) => Some(_inner),
            Self::DbClusterRoleNotFoundFault(_inner) => Some(_inner),
            Self::InvalidDbClusterStateFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The specified IAM role Amazon Resource Name (ARN) is not associated with the specified DB cluster.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DbClusterRoleNotFoundFault {
    /// <p>A message describing the details of the problem.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl DbClusterRoleNotFoundFault {
    /// Creates a new builder-style object to manufacture [`DbClusterRoleNotFoundFault`](crate::error::DbClusterRoleNotFoundFault).
    pub fn builder() -> crate::error::db_cluster_role_not_found_fault::Builder {
        crate::error::db_cluster_role_not_found_fault::Builder::default()
    }
}
/// See [`DbClusterRoleNotFoundFault`](crate::error::DbClusterRoleNotFoundFault).
pub mod db_cluster_role_not_found_fault {

    /// A builder for [`DbClusterRoleNotFoundFault`](crate::error::DbClusterRoleNotFoundFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A message describing the details of the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message describing the details of the problem.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`DbClusterRoleNotFoundFault`](crate::error::DbClusterRoleNotFoundFault).
        pub fn build(self) -> crate::error::DbClusterRoleNotFoundFault {
            crate::error::DbClusterRoleNotFoundFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl DbClusterRoleNotFoundFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DbClusterRoleNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DbClusterRoleNotFoundFault [DBClusterRoleNotFoundFault]")?;
        if let Some(inner_25) = &self.message {
            {
                write!(f, ": {}", inner_25)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DbClusterRoleNotFoundFault {}
impl aws_http::request_id::RequestId for crate::error::DbClusterRoleNotFoundFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DbClusterRoleNotFoundFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type RemoveFromGlobalClusterErrorKind = RemoveFromGlobalClusterError;
/// Error type for the `RemoveFromGlobalClusterError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RemoveFromGlobalClusterError {
    /// <p> <i>DBClusterIdentifier</i> does not refer to an existing DB cluster.</p>
    DbClusterNotFoundFault(crate::error::DbClusterNotFoundFault),
    /// <p>The <code>GlobalClusterIdentifier</code> doesn't refer to an existing global database cluster. </p>
    GlobalClusterNotFoundFault(crate::error::GlobalClusterNotFoundFault),
    /// <p>The global cluster is in an invalid state and can't perform the requested operation. </p>
    InvalidGlobalClusterStateFault(crate::error::InvalidGlobalClusterStateFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for RemoveFromGlobalClusterError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for RemoveFromGlobalClusterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DbClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::GlobalClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::InvalidGlobalClusterStateFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for RemoveFromGlobalClusterError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DbClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::GlobalClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidGlobalClusterStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::RemoveFromGlobalClusterError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for RemoveFromGlobalClusterError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl RemoveFromGlobalClusterError {
    /// Creates the `RemoveFromGlobalClusterError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `RemoveFromGlobalClusterError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DbClusterNotFoundFault(e) => e.meta(),
            Self::GlobalClusterNotFoundFault(e) => e.meta(),
            Self::InvalidGlobalClusterStateFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `RemoveFromGlobalClusterError::DbClusterNotFoundFault`.
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::DbClusterNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `RemoveFromGlobalClusterError::GlobalClusterNotFoundFault`.
    pub fn is_global_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::GlobalClusterNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `RemoveFromGlobalClusterError::InvalidGlobalClusterStateFault`.
    pub fn is_invalid_global_cluster_state_fault(&self) -> bool {
        matches!(self, Self::InvalidGlobalClusterStateFault(_))
    }
}
impl std::error::Error for RemoveFromGlobalClusterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DbClusterNotFoundFault(_inner) => Some(_inner),
            Self::GlobalClusterNotFoundFault(_inner) => Some(_inner),
            Self::InvalidGlobalClusterStateFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The global cluster is in an invalid state and can't perform the requested operation. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidGlobalClusterStateFault {
    /// <p>A message describing the details of the problem.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidGlobalClusterStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidGlobalClusterStateFault`](crate::error::InvalidGlobalClusterStateFault).
    pub fn builder() -> crate::error::invalid_global_cluster_state_fault::Builder {
        crate::error::invalid_global_cluster_state_fault::Builder::default()
    }
}
/// See [`InvalidGlobalClusterStateFault`](crate::error::InvalidGlobalClusterStateFault).
pub mod invalid_global_cluster_state_fault {

    /// A builder for [`InvalidGlobalClusterStateFault`](crate::error::InvalidGlobalClusterStateFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A message describing the details of the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message describing the details of the problem.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidGlobalClusterStateFault`](crate::error::InvalidGlobalClusterStateFault).
        pub fn build(self) -> crate::error::InvalidGlobalClusterStateFault {
            crate::error::InvalidGlobalClusterStateFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidGlobalClusterStateFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidGlobalClusterStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidGlobalClusterStateFault")?;
        if let Some(inner_26) = &self.message {
            {
                write!(f, ": {}", inner_26)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidGlobalClusterStateFault {}
impl aws_http::request_id::RequestId for crate::error::InvalidGlobalClusterStateFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidGlobalClusterStateFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The <code>GlobalClusterIdentifier</code> doesn't refer to an existing global database cluster. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GlobalClusterNotFoundFault {
    /// <p>A message describing the details of the problem.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl GlobalClusterNotFoundFault {
    /// Creates a new builder-style object to manufacture [`GlobalClusterNotFoundFault`](crate::error::GlobalClusterNotFoundFault).
    pub fn builder() -> crate::error::global_cluster_not_found_fault::Builder {
        crate::error::global_cluster_not_found_fault::Builder::default()
    }
}
/// See [`GlobalClusterNotFoundFault`](crate::error::GlobalClusterNotFoundFault).
pub mod global_cluster_not_found_fault {

    /// A builder for [`GlobalClusterNotFoundFault`](crate::error::GlobalClusterNotFoundFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A message describing the details of the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message describing the details of the problem.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`GlobalClusterNotFoundFault`](crate::error::GlobalClusterNotFoundFault).
        pub fn build(self) -> crate::error::GlobalClusterNotFoundFault {
            crate::error::GlobalClusterNotFoundFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl GlobalClusterNotFoundFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for GlobalClusterNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "GlobalClusterNotFoundFault")?;
        if let Some(inner_27) = &self.message {
            {
                write!(f, ": {}", inner_27)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for GlobalClusterNotFoundFault {}
impl aws_http::request_id::RequestId for crate::error::GlobalClusterNotFoundFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GlobalClusterNotFoundFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type RebootDBInstanceErrorKind = RebootDBInstanceError;
/// Error type for the `RebootDBInstanceError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RebootDBInstanceError {
    /// <p> <i>DBInstanceIdentifier</i> does not refer to an existing DB instance.</p>
    DbInstanceNotFoundFault(crate::error::DbInstanceNotFoundFault),
    /// <p>The specified DB instance is not in the <i>available</i> state.</p>
    InvalidDbInstanceStateFault(crate::error::InvalidDbInstanceStateFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for RebootDBInstanceError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for RebootDBInstanceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DbInstanceNotFoundFault(_inner) => _inner.fmt(f),
            Self::InvalidDbInstanceStateFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for RebootDBInstanceError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DbInstanceNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDbInstanceStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::RebootDBInstanceError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for RebootDBInstanceError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl RebootDBInstanceError {
    /// Creates the `RebootDBInstanceError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `RebootDBInstanceError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DbInstanceNotFoundFault(e) => e.meta(),
            Self::InvalidDbInstanceStateFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `RebootDBInstanceError::DbInstanceNotFoundFault`.
    pub fn is_db_instance_not_found_fault(&self) -> bool {
        matches!(self, Self::DbInstanceNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `RebootDBInstanceError::InvalidDbInstanceStateFault`.
    pub fn is_invalid_db_instance_state_fault(&self) -> bool {
        matches!(self, Self::InvalidDbInstanceStateFault(_))
    }
}
impl std::error::Error for RebootDBInstanceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DbInstanceNotFoundFault(_inner) => Some(_inner),
            Self::InvalidDbInstanceStateFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type PromoteReadReplicaDBClusterErrorKind = PromoteReadReplicaDBClusterError;
/// Error type for the `PromoteReadReplicaDBClusterError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PromoteReadReplicaDBClusterError {
    /// <p> <i>DBClusterIdentifier</i> does not refer to an existing DB cluster.</p>
    DbClusterNotFoundFault(crate::error::DbClusterNotFoundFault),
    /// <p>The DB cluster is not in a valid state.</p>
    InvalidDbClusterStateFault(crate::error::InvalidDbClusterStateFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for PromoteReadReplicaDBClusterError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for PromoteReadReplicaDBClusterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DbClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::InvalidDbClusterStateFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for PromoteReadReplicaDBClusterError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DbClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDbClusterStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::PromoteReadReplicaDBClusterError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for PromoteReadReplicaDBClusterError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl PromoteReadReplicaDBClusterError {
    /// Creates the `PromoteReadReplicaDBClusterError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `PromoteReadReplicaDBClusterError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DbClusterNotFoundFault(e) => e.meta(),
            Self::InvalidDbClusterStateFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `PromoteReadReplicaDBClusterError::DbClusterNotFoundFault`.
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::DbClusterNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `PromoteReadReplicaDBClusterError::InvalidDbClusterStateFault`.
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(self, Self::InvalidDbClusterStateFault(_))
    }
}
impl std::error::Error for PromoteReadReplicaDBClusterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DbClusterNotFoundFault(_inner) => Some(_inner),
            Self::InvalidDbClusterStateFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ModifyGlobalClusterErrorKind = ModifyGlobalClusterError;
/// Error type for the `ModifyGlobalClusterError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ModifyGlobalClusterError {
    /// <p>The <code>GlobalClusterIdentifier</code> doesn't refer to an existing global database cluster. </p>
    GlobalClusterNotFoundFault(crate::error::GlobalClusterNotFoundFault),
    /// <p>The global cluster is in an invalid state and can't perform the requested operation. </p>
    InvalidGlobalClusterStateFault(crate::error::InvalidGlobalClusterStateFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ModifyGlobalClusterError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ModifyGlobalClusterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::GlobalClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::InvalidGlobalClusterStateFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ModifyGlobalClusterError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::GlobalClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidGlobalClusterStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ModifyGlobalClusterError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ModifyGlobalClusterError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ModifyGlobalClusterError {
    /// Creates the `ModifyGlobalClusterError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ModifyGlobalClusterError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::GlobalClusterNotFoundFault(e) => e.meta(),
            Self::InvalidGlobalClusterStateFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ModifyGlobalClusterError::GlobalClusterNotFoundFault`.
    pub fn is_global_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::GlobalClusterNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `ModifyGlobalClusterError::InvalidGlobalClusterStateFault`.
    pub fn is_invalid_global_cluster_state_fault(&self) -> bool {
        matches!(self, Self::InvalidGlobalClusterStateFault(_))
    }
}
impl std::error::Error for ModifyGlobalClusterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::GlobalClusterNotFoundFault(_inner) => Some(_inner),
            Self::InvalidGlobalClusterStateFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ModifyEventSubscriptionErrorKind = ModifyEventSubscriptionError;
/// Error type for the `ModifyEventSubscriptionError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ModifyEventSubscriptionError {
    /// <p>You have exceeded the number of events you can subscribe to.</p>
    EventSubscriptionQuotaExceededFault(crate::error::EventSubscriptionQuotaExceededFault),
    /// <p>The SNS topic is invalid.</p>
    SnsInvalidTopicFault(crate::error::SnsInvalidTopicFault),
    /// <p>There is no SNS authorization.</p>
    SnsNoAuthorizationFault(crate::error::SnsNoAuthorizationFault),
    /// <p>The ARN of the SNS topic could not be found.</p>
    SnsTopicArnNotFoundFault(crate::error::SnsTopicArnNotFoundFault),
    /// <p>The designated subscription category could not be found.</p>
    SubscriptionCategoryNotFoundFault(crate::error::SubscriptionCategoryNotFoundFault),
    /// <p>The designated subscription could not be found.</p>
    SubscriptionNotFoundFault(crate::error::SubscriptionNotFoundFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ModifyEventSubscriptionError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ModifyEventSubscriptionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::EventSubscriptionQuotaExceededFault(_inner) => _inner.fmt(f),
            Self::SnsInvalidTopicFault(_inner) => _inner.fmt(f),
            Self::SnsNoAuthorizationFault(_inner) => _inner.fmt(f),
            Self::SnsTopicArnNotFoundFault(_inner) => _inner.fmt(f),
            Self::SubscriptionCategoryNotFoundFault(_inner) => _inner.fmt(f),
            Self::SubscriptionNotFoundFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ModifyEventSubscriptionError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::EventSubscriptionQuotaExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SnsInvalidTopicFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SnsNoAuthorizationFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SnsTopicArnNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SubscriptionCategoryNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SubscriptionNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ModifyEventSubscriptionError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ModifyEventSubscriptionError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ModifyEventSubscriptionError {
    /// Creates the `ModifyEventSubscriptionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ModifyEventSubscriptionError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::EventSubscriptionQuotaExceededFault(e) => e.meta(),
            Self::SnsInvalidTopicFault(e) => e.meta(),
            Self::SnsNoAuthorizationFault(e) => e.meta(),
            Self::SnsTopicArnNotFoundFault(e) => e.meta(),
            Self::SubscriptionCategoryNotFoundFault(e) => e.meta(),
            Self::SubscriptionNotFoundFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ModifyEventSubscriptionError::EventSubscriptionQuotaExceededFault`.
    pub fn is_event_subscription_quota_exceeded_fault(&self) -> bool {
        matches!(self, Self::EventSubscriptionQuotaExceededFault(_))
    }
    /// Returns `true` if the error kind is `ModifyEventSubscriptionError::SnsInvalidTopicFault`.
    pub fn is_sns_invalid_topic_fault(&self) -> bool {
        matches!(self, Self::SnsInvalidTopicFault(_))
    }
    /// Returns `true` if the error kind is `ModifyEventSubscriptionError::SnsNoAuthorizationFault`.
    pub fn is_sns_no_authorization_fault(&self) -> bool {
        matches!(self, Self::SnsNoAuthorizationFault(_))
    }
    /// Returns `true` if the error kind is `ModifyEventSubscriptionError::SnsTopicArnNotFoundFault`.
    pub fn is_sns_topic_arn_not_found_fault(&self) -> bool {
        matches!(self, Self::SnsTopicArnNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `ModifyEventSubscriptionError::SubscriptionCategoryNotFoundFault`.
    pub fn is_subscription_category_not_found_fault(&self) -> bool {
        matches!(self, Self::SubscriptionCategoryNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `ModifyEventSubscriptionError::SubscriptionNotFoundFault`.
    pub fn is_subscription_not_found_fault(&self) -> bool {
        matches!(self, Self::SubscriptionNotFoundFault(_))
    }
}
impl std::error::Error for ModifyEventSubscriptionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::EventSubscriptionQuotaExceededFault(_inner) => Some(_inner),
            Self::SnsInvalidTopicFault(_inner) => Some(_inner),
            Self::SnsNoAuthorizationFault(_inner) => Some(_inner),
            Self::SnsTopicArnNotFoundFault(_inner) => Some(_inner),
            Self::SubscriptionCategoryNotFoundFault(_inner) => Some(_inner),
            Self::SubscriptionNotFoundFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The designated subscription category could not be found.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SubscriptionCategoryNotFoundFault {
    /// <p>A message describing the details of the problem.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl SubscriptionCategoryNotFoundFault {
    /// Creates a new builder-style object to manufacture [`SubscriptionCategoryNotFoundFault`](crate::error::SubscriptionCategoryNotFoundFault).
    pub fn builder() -> crate::error::subscription_category_not_found_fault::Builder {
        crate::error::subscription_category_not_found_fault::Builder::default()
    }
}
/// See [`SubscriptionCategoryNotFoundFault`](crate::error::SubscriptionCategoryNotFoundFault).
pub mod subscription_category_not_found_fault {

    /// A builder for [`SubscriptionCategoryNotFoundFault`](crate::error::SubscriptionCategoryNotFoundFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A message describing the details of the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message describing the details of the problem.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`SubscriptionCategoryNotFoundFault`](crate::error::SubscriptionCategoryNotFoundFault).
        pub fn build(self) -> crate::error::SubscriptionCategoryNotFoundFault {
            crate::error::SubscriptionCategoryNotFoundFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl SubscriptionCategoryNotFoundFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SubscriptionCategoryNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SubscriptionCategoryNotFoundFault")?;
        if let Some(inner_28) = &self.message {
            {
                write!(f, ": {}", inner_28)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for SubscriptionCategoryNotFoundFault {}
impl aws_http::request_id::RequestId for crate::error::SubscriptionCategoryNotFoundFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for SubscriptionCategoryNotFoundFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The ARN of the SNS topic could not be found.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SnsTopicArnNotFoundFault {
    /// <p>A message describing the details of the problem.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl SnsTopicArnNotFoundFault {
    /// Creates a new builder-style object to manufacture [`SnsTopicArnNotFoundFault`](crate::error::SnsTopicArnNotFoundFault).
    pub fn builder() -> crate::error::sns_topic_arn_not_found_fault::Builder {
        crate::error::sns_topic_arn_not_found_fault::Builder::default()
    }
}
/// See [`SnsTopicArnNotFoundFault`](crate::error::SnsTopicArnNotFoundFault).
pub mod sns_topic_arn_not_found_fault {

    /// A builder for [`SnsTopicArnNotFoundFault`](crate::error::SnsTopicArnNotFoundFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A message describing the details of the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message describing the details of the problem.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`SnsTopicArnNotFoundFault`](crate::error::SnsTopicArnNotFoundFault).
        pub fn build(self) -> crate::error::SnsTopicArnNotFoundFault {
            crate::error::SnsTopicArnNotFoundFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl SnsTopicArnNotFoundFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SnsTopicArnNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SnsTopicArnNotFoundFault [SNSTopicArnNotFoundFault]")?;
        if let Some(inner_29) = &self.message {
            {
                write!(f, ": {}", inner_29)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for SnsTopicArnNotFoundFault {}
impl aws_http::request_id::RequestId for crate::error::SnsTopicArnNotFoundFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for SnsTopicArnNotFoundFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>There is no SNS authorization.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SnsNoAuthorizationFault {
    /// <p>A message describing the details of the problem.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl SnsNoAuthorizationFault {
    /// Creates a new builder-style object to manufacture [`SnsNoAuthorizationFault`](crate::error::SnsNoAuthorizationFault).
    pub fn builder() -> crate::error::sns_no_authorization_fault::Builder {
        crate::error::sns_no_authorization_fault::Builder::default()
    }
}
/// See [`SnsNoAuthorizationFault`](crate::error::SnsNoAuthorizationFault).
pub mod sns_no_authorization_fault {

    /// A builder for [`SnsNoAuthorizationFault`](crate::error::SnsNoAuthorizationFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A message describing the details of the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message describing the details of the problem.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`SnsNoAuthorizationFault`](crate::error::SnsNoAuthorizationFault).
        pub fn build(self) -> crate::error::SnsNoAuthorizationFault {
            crate::error::SnsNoAuthorizationFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl SnsNoAuthorizationFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SnsNoAuthorizationFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SnsNoAuthorizationFault [SNSNoAuthorizationFault]")?;
        if let Some(inner_30) = &self.message {
            {
                write!(f, ": {}", inner_30)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for SnsNoAuthorizationFault {}
impl aws_http::request_id::RequestId for crate::error::SnsNoAuthorizationFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for SnsNoAuthorizationFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The SNS topic is invalid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SnsInvalidTopicFault {
    /// <p>A message describing the details of the problem.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl SnsInvalidTopicFault {
    /// Creates a new builder-style object to manufacture [`SnsInvalidTopicFault`](crate::error::SnsInvalidTopicFault).
    pub fn builder() -> crate::error::sns_invalid_topic_fault::Builder {
        crate::error::sns_invalid_topic_fault::Builder::default()
    }
}
/// See [`SnsInvalidTopicFault`](crate::error::SnsInvalidTopicFault).
pub mod sns_invalid_topic_fault {

    /// A builder for [`SnsInvalidTopicFault`](crate::error::SnsInvalidTopicFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A message describing the details of the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message describing the details of the problem.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`SnsInvalidTopicFault`](crate::error::SnsInvalidTopicFault).
        pub fn build(self) -> crate::error::SnsInvalidTopicFault {
            crate::error::SnsInvalidTopicFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl SnsInvalidTopicFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SnsInvalidTopicFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SnsInvalidTopicFault [SNSInvalidTopicFault]")?;
        if let Some(inner_31) = &self.message {
            {
                write!(f, ": {}", inner_31)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for SnsInvalidTopicFault {}
impl aws_http::request_id::RequestId for crate::error::SnsInvalidTopicFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for SnsInvalidTopicFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>You have exceeded the number of events you can subscribe to.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EventSubscriptionQuotaExceededFault {
    /// <p>A message describing the details of the problem.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl EventSubscriptionQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`EventSubscriptionQuotaExceededFault`](crate::error::EventSubscriptionQuotaExceededFault).
    pub fn builder() -> crate::error::event_subscription_quota_exceeded_fault::Builder {
        crate::error::event_subscription_quota_exceeded_fault::Builder::default()
    }
}
/// See [`EventSubscriptionQuotaExceededFault`](crate::error::EventSubscriptionQuotaExceededFault).
pub mod event_subscription_quota_exceeded_fault {

    /// A builder for [`EventSubscriptionQuotaExceededFault`](crate::error::EventSubscriptionQuotaExceededFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A message describing the details of the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message describing the details of the problem.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`EventSubscriptionQuotaExceededFault`](crate::error::EventSubscriptionQuotaExceededFault).
        pub fn build(self) -> crate::error::EventSubscriptionQuotaExceededFault {
            crate::error::EventSubscriptionQuotaExceededFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl EventSubscriptionQuotaExceededFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for EventSubscriptionQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "EventSubscriptionQuotaExceededFault")?;
        if let Some(inner_32) = &self.message {
            {
                write!(f, ": {}", inner_32)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for EventSubscriptionQuotaExceededFault {}
impl aws_http::request_id::RequestId for crate::error::EventSubscriptionQuotaExceededFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for EventSubscriptionQuotaExceededFault
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ModifyDBSubnetGroupErrorKind = ModifyDBSubnetGroupError;
/// Error type for the `ModifyDBSubnetGroupError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ModifyDBSubnetGroupError {
    /// <p>Subnets in the DB subnet group should cover at least two Availability Zones unless there is only one Availability Zone.</p>
    DbSubnetGroupDoesNotCoverEnoughAZs(crate::error::DbSubnetGroupDoesNotCoverEnoughAZs),
    /// <p> <i>DBSubnetGroupName</i> does not refer to an existing DB subnet group.</p>
    DbSubnetGroupNotFoundFault(crate::error::DbSubnetGroupNotFoundFault),
    /// <p>Request would result in user exceeding the allowed number of subnets in a DB subnet groups.</p>
    DbSubnetQuotaExceededFault(crate::error::DbSubnetQuotaExceededFault),
    /// <p>The requested subnet is invalid, or multiple subnets were requested that are not all in a common VPC.</p>
    InvalidSubnet(crate::error::InvalidSubnet),
    /// <p>The DB subnet is already in use in the Availability Zone.</p>
    SubnetAlreadyInUse(crate::error::SubnetAlreadyInUse),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ModifyDBSubnetGroupError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ModifyDBSubnetGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DbSubnetGroupDoesNotCoverEnoughAZs(_inner) => _inner.fmt(f),
            Self::DbSubnetGroupNotFoundFault(_inner) => _inner.fmt(f),
            Self::DbSubnetQuotaExceededFault(_inner) => _inner.fmt(f),
            Self::InvalidSubnet(_inner) => _inner.fmt(f),
            Self::SubnetAlreadyInUse(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ModifyDBSubnetGroupError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DbSubnetGroupDoesNotCoverEnoughAZs(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DbSubnetGroupNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DbSubnetQuotaExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidSubnet(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SubnetAlreadyInUse(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ModifyDBSubnetGroupError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ModifyDBSubnetGroupError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ModifyDBSubnetGroupError {
    /// Creates the `ModifyDBSubnetGroupError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ModifyDBSubnetGroupError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DbSubnetGroupDoesNotCoverEnoughAZs(e) => e.meta(),
            Self::DbSubnetGroupNotFoundFault(e) => e.meta(),
            Self::DbSubnetQuotaExceededFault(e) => e.meta(),
            Self::InvalidSubnet(e) => e.meta(),
            Self::SubnetAlreadyInUse(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ModifyDBSubnetGroupError::DbSubnetGroupDoesNotCoverEnoughAZs`.
    pub fn is_db_subnet_group_does_not_cover_enough_a_zs(&self) -> bool {
        matches!(self, Self::DbSubnetGroupDoesNotCoverEnoughAZs(_))
    }
    /// Returns `true` if the error kind is `ModifyDBSubnetGroupError::DbSubnetGroupNotFoundFault`.
    pub fn is_db_subnet_group_not_found_fault(&self) -> bool {
        matches!(self, Self::DbSubnetGroupNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `ModifyDBSubnetGroupError::DbSubnetQuotaExceededFault`.
    pub fn is_db_subnet_quota_exceeded_fault(&self) -> bool {
        matches!(self, Self::DbSubnetQuotaExceededFault(_))
    }
    /// Returns `true` if the error kind is `ModifyDBSubnetGroupError::InvalidSubnet`.
    pub fn is_invalid_subnet(&self) -> bool {
        matches!(self, Self::InvalidSubnet(_))
    }
    /// Returns `true` if the error kind is `ModifyDBSubnetGroupError::SubnetAlreadyInUse`.
    pub fn is_subnet_already_in_use(&self) -> bool {
        matches!(self, Self::SubnetAlreadyInUse(_))
    }
}
impl std::error::Error for ModifyDBSubnetGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DbSubnetGroupDoesNotCoverEnoughAZs(_inner) => Some(_inner),
            Self::DbSubnetGroupNotFoundFault(_inner) => Some(_inner),
            Self::DbSubnetQuotaExceededFault(_inner) => Some(_inner),
            Self::InvalidSubnet(_inner) => Some(_inner),
            Self::SubnetAlreadyInUse(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The DB subnet is already in use in the Availability Zone.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SubnetAlreadyInUse {
    /// <p>A message describing the details of the problem.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl SubnetAlreadyInUse {
    /// Creates a new builder-style object to manufacture [`SubnetAlreadyInUse`](crate::error::SubnetAlreadyInUse).
    pub fn builder() -> crate::error::subnet_already_in_use::Builder {
        crate::error::subnet_already_in_use::Builder::default()
    }
}
/// See [`SubnetAlreadyInUse`](crate::error::SubnetAlreadyInUse).
pub mod subnet_already_in_use {

    /// A builder for [`SubnetAlreadyInUse`](crate::error::SubnetAlreadyInUse).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A message describing the details of the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message describing the details of the problem.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`SubnetAlreadyInUse`](crate::error::SubnetAlreadyInUse).
        pub fn build(self) -> crate::error::SubnetAlreadyInUse {
            crate::error::SubnetAlreadyInUse {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl SubnetAlreadyInUse {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SubnetAlreadyInUse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SubnetAlreadyInUse")?;
        if let Some(inner_33) = &self.message {
            {
                write!(f, ": {}", inner_33)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for SubnetAlreadyInUse {}
impl aws_http::request_id::RequestId for crate::error::SubnetAlreadyInUse {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for SubnetAlreadyInUse {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>Request would result in user exceeding the allowed number of subnets in a DB subnet groups.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DbSubnetQuotaExceededFault {
    /// <p>A message describing the details of the problem.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl DbSubnetQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`DbSubnetQuotaExceededFault`](crate::error::DbSubnetQuotaExceededFault).
    pub fn builder() -> crate::error::db_subnet_quota_exceeded_fault::Builder {
        crate::error::db_subnet_quota_exceeded_fault::Builder::default()
    }
}
/// See [`DbSubnetQuotaExceededFault`](crate::error::DbSubnetQuotaExceededFault).
pub mod db_subnet_quota_exceeded_fault {

    /// A builder for [`DbSubnetQuotaExceededFault`](crate::error::DbSubnetQuotaExceededFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A message describing the details of the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message describing the details of the problem.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`DbSubnetQuotaExceededFault`](crate::error::DbSubnetQuotaExceededFault).
        pub fn build(self) -> crate::error::DbSubnetQuotaExceededFault {
            crate::error::DbSubnetQuotaExceededFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl DbSubnetQuotaExceededFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DbSubnetQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DbSubnetQuotaExceededFault [DBSubnetQuotaExceededFault]")?;
        if let Some(inner_34) = &self.message {
            {
                write!(f, ": {}", inner_34)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DbSubnetQuotaExceededFault {}
impl aws_http::request_id::RequestId for crate::error::DbSubnetQuotaExceededFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DbSubnetQuotaExceededFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>Subnets in the DB subnet group should cover at least two Availability Zones unless there is only one Availability Zone.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DbSubnetGroupDoesNotCoverEnoughAZs {
    /// <p>A message describing the details of the problem.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl DbSubnetGroupDoesNotCoverEnoughAZs {
    /// Creates a new builder-style object to manufacture [`DbSubnetGroupDoesNotCoverEnoughAZs`](crate::error::DbSubnetGroupDoesNotCoverEnoughAZs).
    pub fn builder() -> crate::error::db_subnet_group_does_not_cover_enough_a_zs::Builder {
        crate::error::db_subnet_group_does_not_cover_enough_a_zs::Builder::default()
    }
}
/// See [`DbSubnetGroupDoesNotCoverEnoughAZs`](crate::error::DbSubnetGroupDoesNotCoverEnoughAZs).
pub mod db_subnet_group_does_not_cover_enough_a_zs {

    /// A builder for [`DbSubnetGroupDoesNotCoverEnoughAZs`](crate::error::DbSubnetGroupDoesNotCoverEnoughAZs).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A message describing the details of the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message describing the details of the problem.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`DbSubnetGroupDoesNotCoverEnoughAZs`](crate::error::DbSubnetGroupDoesNotCoverEnoughAZs).
        pub fn build(self) -> crate::error::DbSubnetGroupDoesNotCoverEnoughAZs {
            crate::error::DbSubnetGroupDoesNotCoverEnoughAZs {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl DbSubnetGroupDoesNotCoverEnoughAZs {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DbSubnetGroupDoesNotCoverEnoughAZs {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "DbSubnetGroupDoesNotCoverEnoughAZs [DBSubnetGroupDoesNotCoverEnoughAZs]"
        )?;
        if let Some(inner_35) = &self.message {
            {
                write!(f, ": {}", inner_35)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DbSubnetGroupDoesNotCoverEnoughAZs {}
impl aws_http::request_id::RequestId for crate::error::DbSubnetGroupDoesNotCoverEnoughAZs {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for DbSubnetGroupDoesNotCoverEnoughAZs
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ModifyDBParameterGroupErrorKind = ModifyDBParameterGroupError;
/// Error type for the `ModifyDBParameterGroupError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ModifyDBParameterGroupError {
    /// <p> <i>DBParameterGroupName</i> does not refer to an existing DB parameter group.</p>
    DbParameterGroupNotFoundFault(crate::error::DbParameterGroupNotFoundFault),
    /// <p>The DB parameter group is in use or is in an invalid state. If you are attempting to delete the parameter group, you cannot delete it when the parameter group is in this state.</p>
    InvalidDbParameterGroupStateFault(crate::error::InvalidDbParameterGroupStateFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ModifyDBParameterGroupError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ModifyDBParameterGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DbParameterGroupNotFoundFault(_inner) => _inner.fmt(f),
            Self::InvalidDbParameterGroupStateFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ModifyDBParameterGroupError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DbParameterGroupNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDbParameterGroupStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ModifyDBParameterGroupError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ModifyDBParameterGroupError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ModifyDBParameterGroupError {
    /// Creates the `ModifyDBParameterGroupError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ModifyDBParameterGroupError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DbParameterGroupNotFoundFault(e) => e.meta(),
            Self::InvalidDbParameterGroupStateFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ModifyDBParameterGroupError::DbParameterGroupNotFoundFault`.
    pub fn is_db_parameter_group_not_found_fault(&self) -> bool {
        matches!(self, Self::DbParameterGroupNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `ModifyDBParameterGroupError::InvalidDbParameterGroupStateFault`.
    pub fn is_invalid_db_parameter_group_state_fault(&self) -> bool {
        matches!(self, Self::InvalidDbParameterGroupStateFault(_))
    }
}
impl std::error::Error for ModifyDBParameterGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DbParameterGroupNotFoundFault(_inner) => Some(_inner),
            Self::InvalidDbParameterGroupStateFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ModifyDBInstanceErrorKind = ModifyDBInstanceError;
/// Error type for the `ModifyDBInstanceError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ModifyDBInstanceError {
    /// <p>Specified CIDRIP or EC2 security group is not authorized for the specified DB security group.</p>
    /// <p>Neptune may not also be authorized via IAM to perform necessary actions on your behalf.</p>
    AuthorizationNotFoundFault(crate::error::AuthorizationNotFoundFault),
    /// <p> <i>CertificateIdentifier</i> does not refer to an existing certificate.</p>
    CertificateNotFoundFault(crate::error::CertificateNotFoundFault),
    /// <p>User already has a DB instance with the given identifier.</p>
    DbInstanceAlreadyExistsFault(crate::error::DbInstanceAlreadyExistsFault),
    /// <p> <i>DBInstanceIdentifier</i> does not refer to an existing DB instance.</p>
    DbInstanceNotFoundFault(crate::error::DbInstanceNotFoundFault),
    /// <p> <i>DBParameterGroupName</i> does not refer to an existing DB parameter group.</p>
    DbParameterGroupNotFoundFault(crate::error::DbParameterGroupNotFoundFault),
    /// <p> <i>DBSecurityGroupName</i> does not refer to an existing DB security group.</p>
    DbSecurityGroupNotFoundFault(crate::error::DbSecurityGroupNotFoundFault),
    /// <p>The DB upgrade failed because a resource the DB depends on could not be modified.</p>
    DbUpgradeDependencyFailureFault(crate::error::DbUpgradeDependencyFailureFault),
    /// <p> <i>Domain</i> does not refer to an existing Active Directory Domain.</p>
    DomainNotFoundFault(crate::error::DomainNotFoundFault),
    /// <p>Specified DB instance class is not available in the specified Availability Zone.</p>
    InsufficientDbInstanceCapacityFault(crate::error::InsufficientDbInstanceCapacityFault),
    /// <p>The specified DB instance is not in the <i>available</i> state.</p>
    InvalidDbInstanceStateFault(crate::error::InvalidDbInstanceStateFault),
    /// <p>The state of the DB security group does not allow deletion.</p>
    InvalidDbSecurityGroupStateFault(crate::error::InvalidDbSecurityGroupStateFault),
    /// <p>DB subnet group does not cover all Availability Zones after it is created because users' change.</p>
    InvalidVpcNetworkStateFault(crate::error::InvalidVpcNetworkStateFault),
    /// <p>The designated option group could not be found.</p>
    OptionGroupNotFoundFault(crate::error::OptionGroupNotFoundFault),
    /// <p>Provisioned IOPS not available in the specified Availability Zone.</p>
    ProvisionedIopsNotAvailableInAzFault(crate::error::ProvisionedIopsNotAvailableInAzFault),
    /// <p>Request would result in user exceeding the allowed amount of storage available across all DB instances.</p>
    StorageQuotaExceededFault(crate::error::StorageQuotaExceededFault),
    /// <p> <i>StorageType</i> specified cannot be associated with the DB Instance.</p>
    StorageTypeNotSupportedFault(crate::error::StorageTypeNotSupportedFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ModifyDBInstanceError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ModifyDBInstanceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AuthorizationNotFoundFault(_inner) => _inner.fmt(f),
            Self::CertificateNotFoundFault(_inner) => _inner.fmt(f),
            Self::DbInstanceAlreadyExistsFault(_inner) => _inner.fmt(f),
            Self::DbInstanceNotFoundFault(_inner) => _inner.fmt(f),
            Self::DbParameterGroupNotFoundFault(_inner) => _inner.fmt(f),
            Self::DbSecurityGroupNotFoundFault(_inner) => _inner.fmt(f),
            Self::DbUpgradeDependencyFailureFault(_inner) => _inner.fmt(f),
            Self::DomainNotFoundFault(_inner) => _inner.fmt(f),
            Self::InsufficientDbInstanceCapacityFault(_inner) => _inner.fmt(f),
            Self::InvalidDbInstanceStateFault(_inner) => _inner.fmt(f),
            Self::InvalidDbSecurityGroupStateFault(_inner) => _inner.fmt(f),
            Self::InvalidVpcNetworkStateFault(_inner) => _inner.fmt(f),
            Self::OptionGroupNotFoundFault(_inner) => _inner.fmt(f),
            Self::ProvisionedIopsNotAvailableInAzFault(_inner) => _inner.fmt(f),
            Self::StorageQuotaExceededFault(_inner) => _inner.fmt(f),
            Self::StorageTypeNotSupportedFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ModifyDBInstanceError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AuthorizationNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::CertificateNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DbInstanceAlreadyExistsFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DbInstanceNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DbParameterGroupNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DbSecurityGroupNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DbUpgradeDependencyFailureFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DomainNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InsufficientDbInstanceCapacityFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDbInstanceStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDbSecurityGroupStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidVpcNetworkStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::OptionGroupNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ProvisionedIopsNotAvailableInAzFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::StorageQuotaExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::StorageTypeNotSupportedFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ModifyDBInstanceError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ModifyDBInstanceError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ModifyDBInstanceError {
    /// Creates the `ModifyDBInstanceError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ModifyDBInstanceError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AuthorizationNotFoundFault(e) => e.meta(),
            Self::CertificateNotFoundFault(e) => e.meta(),
            Self::DbInstanceAlreadyExistsFault(e) => e.meta(),
            Self::DbInstanceNotFoundFault(e) => e.meta(),
            Self::DbParameterGroupNotFoundFault(e) => e.meta(),
            Self::DbSecurityGroupNotFoundFault(e) => e.meta(),
            Self::DbUpgradeDependencyFailureFault(e) => e.meta(),
            Self::DomainNotFoundFault(e) => e.meta(),
            Self::InsufficientDbInstanceCapacityFault(e) => e.meta(),
            Self::InvalidDbInstanceStateFault(e) => e.meta(),
            Self::InvalidDbSecurityGroupStateFault(e) => e.meta(),
            Self::InvalidVpcNetworkStateFault(e) => e.meta(),
            Self::OptionGroupNotFoundFault(e) => e.meta(),
            Self::ProvisionedIopsNotAvailableInAzFault(e) => e.meta(),
            Self::StorageQuotaExceededFault(e) => e.meta(),
            Self::StorageTypeNotSupportedFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ModifyDBInstanceError::AuthorizationNotFoundFault`.
    pub fn is_authorization_not_found_fault(&self) -> bool {
        matches!(self, Self::AuthorizationNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `ModifyDBInstanceError::CertificateNotFoundFault`.
    pub fn is_certificate_not_found_fault(&self) -> bool {
        matches!(self, Self::CertificateNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `ModifyDBInstanceError::DbInstanceAlreadyExistsFault`.
    pub fn is_db_instance_already_exists_fault(&self) -> bool {
        matches!(self, Self::DbInstanceAlreadyExistsFault(_))
    }
    /// Returns `true` if the error kind is `ModifyDBInstanceError::DbInstanceNotFoundFault`.
    pub fn is_db_instance_not_found_fault(&self) -> bool {
        matches!(self, Self::DbInstanceNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `ModifyDBInstanceError::DbParameterGroupNotFoundFault`.
    pub fn is_db_parameter_group_not_found_fault(&self) -> bool {
        matches!(self, Self::DbParameterGroupNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `ModifyDBInstanceError::DbSecurityGroupNotFoundFault`.
    pub fn is_db_security_group_not_found_fault(&self) -> bool {
        matches!(self, Self::DbSecurityGroupNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `ModifyDBInstanceError::DbUpgradeDependencyFailureFault`.
    pub fn is_db_upgrade_dependency_failure_fault(&self) -> bool {
        matches!(self, Self::DbUpgradeDependencyFailureFault(_))
    }
    /// Returns `true` if the error kind is `ModifyDBInstanceError::DomainNotFoundFault`.
    pub fn is_domain_not_found_fault(&self) -> bool {
        matches!(self, Self::DomainNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `ModifyDBInstanceError::InsufficientDbInstanceCapacityFault`.
    pub fn is_insufficient_db_instance_capacity_fault(&self) -> bool {
        matches!(self, Self::InsufficientDbInstanceCapacityFault(_))
    }
    /// Returns `true` if the error kind is `ModifyDBInstanceError::InvalidDbInstanceStateFault`.
    pub fn is_invalid_db_instance_state_fault(&self) -> bool {
        matches!(self, Self::InvalidDbInstanceStateFault(_))
    }
    /// Returns `true` if the error kind is `ModifyDBInstanceError::InvalidDbSecurityGroupStateFault`.
    pub fn is_invalid_db_security_group_state_fault(&self) -> bool {
        matches!(self, Self::InvalidDbSecurityGroupStateFault(_))
    }
    /// Returns `true` if the error kind is `ModifyDBInstanceError::InvalidVpcNetworkStateFault`.
    pub fn is_invalid_vpc_network_state_fault(&self) -> bool {
        matches!(self, Self::InvalidVpcNetworkStateFault(_))
    }
    /// Returns `true` if the error kind is `ModifyDBInstanceError::OptionGroupNotFoundFault`.
    pub fn is_option_group_not_found_fault(&self) -> bool {
        matches!(self, Self::OptionGroupNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `ModifyDBInstanceError::ProvisionedIopsNotAvailableInAzFault`.
    pub fn is_provisioned_iops_not_available_in_az_fault(&self) -> bool {
        matches!(self, Self::ProvisionedIopsNotAvailableInAzFault(_))
    }
    /// Returns `true` if the error kind is `ModifyDBInstanceError::StorageQuotaExceededFault`.
    pub fn is_storage_quota_exceeded_fault(&self) -> bool {
        matches!(self, Self::StorageQuotaExceededFault(_))
    }
    /// Returns `true` if the error kind is `ModifyDBInstanceError::StorageTypeNotSupportedFault`.
    pub fn is_storage_type_not_supported_fault(&self) -> bool {
        matches!(self, Self::StorageTypeNotSupportedFault(_))
    }
}
impl std::error::Error for ModifyDBInstanceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AuthorizationNotFoundFault(_inner) => Some(_inner),
            Self::CertificateNotFoundFault(_inner) => Some(_inner),
            Self::DbInstanceAlreadyExistsFault(_inner) => Some(_inner),
            Self::DbInstanceNotFoundFault(_inner) => Some(_inner),
            Self::DbParameterGroupNotFoundFault(_inner) => Some(_inner),
            Self::DbSecurityGroupNotFoundFault(_inner) => Some(_inner),
            Self::DbUpgradeDependencyFailureFault(_inner) => Some(_inner),
            Self::DomainNotFoundFault(_inner) => Some(_inner),
            Self::InsufficientDbInstanceCapacityFault(_inner) => Some(_inner),
            Self::InvalidDbInstanceStateFault(_inner) => Some(_inner),
            Self::InvalidDbSecurityGroupStateFault(_inner) => Some(_inner),
            Self::InvalidVpcNetworkStateFault(_inner) => Some(_inner),
            Self::OptionGroupNotFoundFault(_inner) => Some(_inner),
            Self::ProvisionedIopsNotAvailableInAzFault(_inner) => Some(_inner),
            Self::StorageQuotaExceededFault(_inner) => Some(_inner),
            Self::StorageTypeNotSupportedFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p> <i>StorageType</i> specified cannot be associated with the DB Instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StorageTypeNotSupportedFault {
    /// <p>A message describing the details of the problem.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl StorageTypeNotSupportedFault {
    /// Creates a new builder-style object to manufacture [`StorageTypeNotSupportedFault`](crate::error::StorageTypeNotSupportedFault).
    pub fn builder() -> crate::error::storage_type_not_supported_fault::Builder {
        crate::error::storage_type_not_supported_fault::Builder::default()
    }
}
/// See [`StorageTypeNotSupportedFault`](crate::error::StorageTypeNotSupportedFault).
pub mod storage_type_not_supported_fault {

    /// A builder for [`StorageTypeNotSupportedFault`](crate::error::StorageTypeNotSupportedFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A message describing the details of the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message describing the details of the problem.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`StorageTypeNotSupportedFault`](crate::error::StorageTypeNotSupportedFault).
        pub fn build(self) -> crate::error::StorageTypeNotSupportedFault {
            crate::error::StorageTypeNotSupportedFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl StorageTypeNotSupportedFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for StorageTypeNotSupportedFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "StorageTypeNotSupportedFault")?;
        if let Some(inner_36) = &self.message {
            {
                write!(f, ": {}", inner_36)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for StorageTypeNotSupportedFault {}
impl aws_http::request_id::RequestId for crate::error::StorageTypeNotSupportedFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for StorageTypeNotSupportedFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>Provisioned IOPS not available in the specified Availability Zone.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ProvisionedIopsNotAvailableInAzFault {
    /// <p>A message describing the details of the problem.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ProvisionedIopsNotAvailableInAzFault {
    /// Creates a new builder-style object to manufacture [`ProvisionedIopsNotAvailableInAzFault`](crate::error::ProvisionedIopsNotAvailableInAzFault).
    pub fn builder() -> crate::error::provisioned_iops_not_available_in_az_fault::Builder {
        crate::error::provisioned_iops_not_available_in_az_fault::Builder::default()
    }
}
/// See [`ProvisionedIopsNotAvailableInAzFault`](crate::error::ProvisionedIopsNotAvailableInAzFault).
pub mod provisioned_iops_not_available_in_az_fault {

    /// A builder for [`ProvisionedIopsNotAvailableInAzFault`](crate::error::ProvisionedIopsNotAvailableInAzFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A message describing the details of the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message describing the details of the problem.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ProvisionedIopsNotAvailableInAzFault`](crate::error::ProvisionedIopsNotAvailableInAzFault).
        pub fn build(self) -> crate::error::ProvisionedIopsNotAvailableInAzFault {
            crate::error::ProvisionedIopsNotAvailableInAzFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl ProvisionedIopsNotAvailableInAzFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ProvisionedIopsNotAvailableInAzFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "ProvisionedIopsNotAvailableInAzFault [ProvisionedIopsNotAvailableInAZFault]"
        )?;
        if let Some(inner_37) = &self.message {
            {
                write!(f, ": {}", inner_37)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ProvisionedIopsNotAvailableInAzFault {}
impl aws_http::request_id::RequestId for crate::error::ProvisionedIopsNotAvailableInAzFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for ProvisionedIopsNotAvailableInAzFault
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The state of the DB security group does not allow deletion.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidDbSecurityGroupStateFault {
    /// <p>A message describing the details of the problem.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidDbSecurityGroupStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidDbSecurityGroupStateFault`](crate::error::InvalidDbSecurityGroupStateFault).
    pub fn builder() -> crate::error::invalid_db_security_group_state_fault::Builder {
        crate::error::invalid_db_security_group_state_fault::Builder::default()
    }
}
/// See [`InvalidDbSecurityGroupStateFault`](crate::error::InvalidDbSecurityGroupStateFault).
pub mod invalid_db_security_group_state_fault {

    /// A builder for [`InvalidDbSecurityGroupStateFault`](crate::error::InvalidDbSecurityGroupStateFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A message describing the details of the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message describing the details of the problem.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidDbSecurityGroupStateFault`](crate::error::InvalidDbSecurityGroupStateFault).
        pub fn build(self) -> crate::error::InvalidDbSecurityGroupStateFault {
            crate::error::InvalidDbSecurityGroupStateFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidDbSecurityGroupStateFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidDbSecurityGroupStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "InvalidDbSecurityGroupStateFault [InvalidDBSecurityGroupStateFault]"
        )?;
        if let Some(inner_38) = &self.message {
            {
                write!(f, ": {}", inner_38)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidDbSecurityGroupStateFault {}
impl aws_http::request_id::RequestId for crate::error::InvalidDbSecurityGroupStateFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidDbSecurityGroupStateFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>Specified DB instance class is not available in the specified Availability Zone.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InsufficientDbInstanceCapacityFault {
    /// <p>A message describing the details of the problem.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InsufficientDbInstanceCapacityFault {
    /// Creates a new builder-style object to manufacture [`InsufficientDbInstanceCapacityFault`](crate::error::InsufficientDbInstanceCapacityFault).
    pub fn builder() -> crate::error::insufficient_db_instance_capacity_fault::Builder {
        crate::error::insufficient_db_instance_capacity_fault::Builder::default()
    }
}
/// See [`InsufficientDbInstanceCapacityFault`](crate::error::InsufficientDbInstanceCapacityFault).
pub mod insufficient_db_instance_capacity_fault {

    /// A builder for [`InsufficientDbInstanceCapacityFault`](crate::error::InsufficientDbInstanceCapacityFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A message describing the details of the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message describing the details of the problem.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InsufficientDbInstanceCapacityFault`](crate::error::InsufficientDbInstanceCapacityFault).
        pub fn build(self) -> crate::error::InsufficientDbInstanceCapacityFault {
            crate::error::InsufficientDbInstanceCapacityFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InsufficientDbInstanceCapacityFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InsufficientDbInstanceCapacityFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "InsufficientDbInstanceCapacityFault [InsufficientDBInstanceCapacityFault]"
        )?;
        if let Some(inner_39) = &self.message {
            {
                write!(f, ": {}", inner_39)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InsufficientDbInstanceCapacityFault {}
impl aws_http::request_id::RequestId for crate::error::InsufficientDbInstanceCapacityFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for InsufficientDbInstanceCapacityFault
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p> <i>Domain</i> does not refer to an existing Active Directory Domain.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DomainNotFoundFault {
    /// <p>A message describing the details of the problem.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl DomainNotFoundFault {
    /// Creates a new builder-style object to manufacture [`DomainNotFoundFault`](crate::error::DomainNotFoundFault).
    pub fn builder() -> crate::error::domain_not_found_fault::Builder {
        crate::error::domain_not_found_fault::Builder::default()
    }
}
/// See [`DomainNotFoundFault`](crate::error::DomainNotFoundFault).
pub mod domain_not_found_fault {

    /// A builder for [`DomainNotFoundFault`](crate::error::DomainNotFoundFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A message describing the details of the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message describing the details of the problem.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`DomainNotFoundFault`](crate::error::DomainNotFoundFault).
        pub fn build(self) -> crate::error::DomainNotFoundFault {
            crate::error::DomainNotFoundFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl DomainNotFoundFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DomainNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DomainNotFoundFault")?;
        if let Some(inner_40) = &self.message {
            {
                write!(f, ": {}", inner_40)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DomainNotFoundFault {}
impl aws_http::request_id::RequestId for crate::error::DomainNotFoundFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DomainNotFoundFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The DB upgrade failed because a resource the DB depends on could not be modified.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DbUpgradeDependencyFailureFault {
    /// <p>A message describing the details of the problem.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl DbUpgradeDependencyFailureFault {
    /// Creates a new builder-style object to manufacture [`DbUpgradeDependencyFailureFault`](crate::error::DbUpgradeDependencyFailureFault).
    pub fn builder() -> crate::error::db_upgrade_dependency_failure_fault::Builder {
        crate::error::db_upgrade_dependency_failure_fault::Builder::default()
    }
}
/// See [`DbUpgradeDependencyFailureFault`](crate::error::DbUpgradeDependencyFailureFault).
pub mod db_upgrade_dependency_failure_fault {

    /// A builder for [`DbUpgradeDependencyFailureFault`](crate::error::DbUpgradeDependencyFailureFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A message describing the details of the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message describing the details of the problem.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`DbUpgradeDependencyFailureFault`](crate::error::DbUpgradeDependencyFailureFault).
        pub fn build(self) -> crate::error::DbUpgradeDependencyFailureFault {
            crate::error::DbUpgradeDependencyFailureFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl DbUpgradeDependencyFailureFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DbUpgradeDependencyFailureFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "DbUpgradeDependencyFailureFault [DBUpgradeDependencyFailureFault]"
        )?;
        if let Some(inner_41) = &self.message {
            {
                write!(f, ": {}", inner_41)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DbUpgradeDependencyFailureFault {}
impl aws_http::request_id::RequestId for crate::error::DbUpgradeDependencyFailureFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DbUpgradeDependencyFailureFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p> <i>DBSecurityGroupName</i> does not refer to an existing DB security group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DbSecurityGroupNotFoundFault {
    /// <p>A message describing the details of the problem.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl DbSecurityGroupNotFoundFault {
    /// Creates a new builder-style object to manufacture [`DbSecurityGroupNotFoundFault`](crate::error::DbSecurityGroupNotFoundFault).
    pub fn builder() -> crate::error::db_security_group_not_found_fault::Builder {
        crate::error::db_security_group_not_found_fault::Builder::default()
    }
}
/// See [`DbSecurityGroupNotFoundFault`](crate::error::DbSecurityGroupNotFoundFault).
pub mod db_security_group_not_found_fault {

    /// A builder for [`DbSecurityGroupNotFoundFault`](crate::error::DbSecurityGroupNotFoundFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A message describing the details of the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message describing the details of the problem.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`DbSecurityGroupNotFoundFault`](crate::error::DbSecurityGroupNotFoundFault).
        pub fn build(self) -> crate::error::DbSecurityGroupNotFoundFault {
            crate::error::DbSecurityGroupNotFoundFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl DbSecurityGroupNotFoundFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DbSecurityGroupNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "DbSecurityGroupNotFoundFault [DBSecurityGroupNotFoundFault]"
        )?;
        if let Some(inner_42) = &self.message {
            {
                write!(f, ": {}", inner_42)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DbSecurityGroupNotFoundFault {}
impl aws_http::request_id::RequestId for crate::error::DbSecurityGroupNotFoundFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DbSecurityGroupNotFoundFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>User already has a DB instance with the given identifier.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DbInstanceAlreadyExistsFault {
    /// <p>A message describing the details of the problem.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl DbInstanceAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`DbInstanceAlreadyExistsFault`](crate::error::DbInstanceAlreadyExistsFault).
    pub fn builder() -> crate::error::db_instance_already_exists_fault::Builder {
        crate::error::db_instance_already_exists_fault::Builder::default()
    }
}
/// See [`DbInstanceAlreadyExistsFault`](crate::error::DbInstanceAlreadyExistsFault).
pub mod db_instance_already_exists_fault {

    /// A builder for [`DbInstanceAlreadyExistsFault`](crate::error::DbInstanceAlreadyExistsFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A message describing the details of the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message describing the details of the problem.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`DbInstanceAlreadyExistsFault`](crate::error::DbInstanceAlreadyExistsFault).
        pub fn build(self) -> crate::error::DbInstanceAlreadyExistsFault {
            crate::error::DbInstanceAlreadyExistsFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl DbInstanceAlreadyExistsFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DbInstanceAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "DbInstanceAlreadyExistsFault [DBInstanceAlreadyExistsFault]"
        )?;
        if let Some(inner_43) = &self.message {
            {
                write!(f, ": {}", inner_43)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DbInstanceAlreadyExistsFault {}
impl aws_http::request_id::RequestId for crate::error::DbInstanceAlreadyExistsFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DbInstanceAlreadyExistsFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p> <i>CertificateIdentifier</i> does not refer to an existing certificate.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CertificateNotFoundFault {
    /// <p>A message describing the details of the problem.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl CertificateNotFoundFault {
    /// Creates a new builder-style object to manufacture [`CertificateNotFoundFault`](crate::error::CertificateNotFoundFault).
    pub fn builder() -> crate::error::certificate_not_found_fault::Builder {
        crate::error::certificate_not_found_fault::Builder::default()
    }
}
/// See [`CertificateNotFoundFault`](crate::error::CertificateNotFoundFault).
pub mod certificate_not_found_fault {

    /// A builder for [`CertificateNotFoundFault`](crate::error::CertificateNotFoundFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A message describing the details of the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message describing the details of the problem.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`CertificateNotFoundFault`](crate::error::CertificateNotFoundFault).
        pub fn build(self) -> crate::error::CertificateNotFoundFault {
            crate::error::CertificateNotFoundFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl CertificateNotFoundFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CertificateNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CertificateNotFoundFault")?;
        if let Some(inner_44) = &self.message {
            {
                write!(f, ": {}", inner_44)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for CertificateNotFoundFault {}
impl aws_http::request_id::RequestId for crate::error::CertificateNotFoundFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CertificateNotFoundFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>Specified CIDRIP or EC2 security group is not authorized for the specified DB security group.</p>
/// <p>Neptune may not also be authorized via IAM to perform necessary actions on your behalf.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AuthorizationNotFoundFault {
    /// <p>A message describing the details of the problem.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl AuthorizationNotFoundFault {
    /// Creates a new builder-style object to manufacture [`AuthorizationNotFoundFault`](crate::error::AuthorizationNotFoundFault).
    pub fn builder() -> crate::error::authorization_not_found_fault::Builder {
        crate::error::authorization_not_found_fault::Builder::default()
    }
}
/// See [`AuthorizationNotFoundFault`](crate::error::AuthorizationNotFoundFault).
pub mod authorization_not_found_fault {

    /// A builder for [`AuthorizationNotFoundFault`](crate::error::AuthorizationNotFoundFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A message describing the details of the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message describing the details of the problem.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`AuthorizationNotFoundFault`](crate::error::AuthorizationNotFoundFault).
        pub fn build(self) -> crate::error::AuthorizationNotFoundFault {
            crate::error::AuthorizationNotFoundFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl AuthorizationNotFoundFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AuthorizationNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AuthorizationNotFoundFault")?;
        if let Some(inner_45) = &self.message {
            {
                write!(f, ": {}", inner_45)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for AuthorizationNotFoundFault {}
impl aws_http::request_id::RequestId for crate::error::AuthorizationNotFoundFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for AuthorizationNotFoundFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ModifyDBClusterSnapshotAttributeErrorKind = ModifyDBClusterSnapshotAttributeError;
/// Error type for the `ModifyDBClusterSnapshotAttributeError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ModifyDBClusterSnapshotAttributeError {
    /// <p> <i>DBClusterSnapshotIdentifier</i> does not refer to an existing DB cluster snapshot.</p>
    DbClusterSnapshotNotFoundFault(crate::error::DbClusterSnapshotNotFoundFault),
    /// <p>The supplied value is not a valid DB cluster snapshot state.</p>
    InvalidDbClusterSnapshotStateFault(crate::error::InvalidDbClusterSnapshotStateFault),
    /// <p>You have exceeded the maximum number of accounts that you can share a manual DB snapshot with.</p>
    SharedSnapshotQuotaExceededFault(crate::error::SharedSnapshotQuotaExceededFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ModifyDBClusterSnapshotAttributeError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ModifyDBClusterSnapshotAttributeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DbClusterSnapshotNotFoundFault(_inner) => _inner.fmt(f),
            Self::InvalidDbClusterSnapshotStateFault(_inner) => _inner.fmt(f),
            Self::SharedSnapshotQuotaExceededFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for ModifyDBClusterSnapshotAttributeError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DbClusterSnapshotNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDbClusterSnapshotStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SharedSnapshotQuotaExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ModifyDBClusterSnapshotAttributeError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ModifyDBClusterSnapshotAttributeError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ModifyDBClusterSnapshotAttributeError {
    /// Creates the `ModifyDBClusterSnapshotAttributeError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ModifyDBClusterSnapshotAttributeError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DbClusterSnapshotNotFoundFault(e) => e.meta(),
            Self::InvalidDbClusterSnapshotStateFault(e) => e.meta(),
            Self::SharedSnapshotQuotaExceededFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ModifyDBClusterSnapshotAttributeError::DbClusterSnapshotNotFoundFault`.
    pub fn is_db_cluster_snapshot_not_found_fault(&self) -> bool {
        matches!(self, Self::DbClusterSnapshotNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `ModifyDBClusterSnapshotAttributeError::InvalidDbClusterSnapshotStateFault`.
    pub fn is_invalid_db_cluster_snapshot_state_fault(&self) -> bool {
        matches!(self, Self::InvalidDbClusterSnapshotStateFault(_))
    }
    /// Returns `true` if the error kind is `ModifyDBClusterSnapshotAttributeError::SharedSnapshotQuotaExceededFault`.
    pub fn is_shared_snapshot_quota_exceeded_fault(&self) -> bool {
        matches!(self, Self::SharedSnapshotQuotaExceededFault(_))
    }
}
impl std::error::Error for ModifyDBClusterSnapshotAttributeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DbClusterSnapshotNotFoundFault(_inner) => Some(_inner),
            Self::InvalidDbClusterSnapshotStateFault(_inner) => Some(_inner),
            Self::SharedSnapshotQuotaExceededFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>You have exceeded the maximum number of accounts that you can share a manual DB snapshot with.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SharedSnapshotQuotaExceededFault {
    /// <p>A message describing the details of the problem.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl SharedSnapshotQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`SharedSnapshotQuotaExceededFault`](crate::error::SharedSnapshotQuotaExceededFault).
    pub fn builder() -> crate::error::shared_snapshot_quota_exceeded_fault::Builder {
        crate::error::shared_snapshot_quota_exceeded_fault::Builder::default()
    }
}
/// See [`SharedSnapshotQuotaExceededFault`](crate::error::SharedSnapshotQuotaExceededFault).
pub mod shared_snapshot_quota_exceeded_fault {

    /// A builder for [`SharedSnapshotQuotaExceededFault`](crate::error::SharedSnapshotQuotaExceededFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A message describing the details of the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message describing the details of the problem.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`SharedSnapshotQuotaExceededFault`](crate::error::SharedSnapshotQuotaExceededFault).
        pub fn build(self) -> crate::error::SharedSnapshotQuotaExceededFault {
            crate::error::SharedSnapshotQuotaExceededFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl SharedSnapshotQuotaExceededFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SharedSnapshotQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SharedSnapshotQuotaExceededFault")?;
        if let Some(inner_46) = &self.message {
            {
                write!(f, ": {}", inner_46)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for SharedSnapshotQuotaExceededFault {}
impl aws_http::request_id::RequestId for crate::error::SharedSnapshotQuotaExceededFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for SharedSnapshotQuotaExceededFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ModifyDBClusterParameterGroupErrorKind = ModifyDBClusterParameterGroupError;
/// Error type for the `ModifyDBClusterParameterGroupError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ModifyDBClusterParameterGroupError {
    /// <p> <i>DBParameterGroupName</i> does not refer to an existing DB parameter group.</p>
    DbParameterGroupNotFoundFault(crate::error::DbParameterGroupNotFoundFault),
    /// <p>The DB parameter group is in use or is in an invalid state. If you are attempting to delete the parameter group, you cannot delete it when the parameter group is in this state.</p>
    InvalidDbParameterGroupStateFault(crate::error::InvalidDbParameterGroupStateFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ModifyDBClusterParameterGroupError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ModifyDBClusterParameterGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DbParameterGroupNotFoundFault(_inner) => _inner.fmt(f),
            Self::InvalidDbParameterGroupStateFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for ModifyDBClusterParameterGroupError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DbParameterGroupNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDbParameterGroupStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ModifyDBClusterParameterGroupError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ModifyDBClusterParameterGroupError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ModifyDBClusterParameterGroupError {
    /// Creates the `ModifyDBClusterParameterGroupError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ModifyDBClusterParameterGroupError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DbParameterGroupNotFoundFault(e) => e.meta(),
            Self::InvalidDbParameterGroupStateFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ModifyDBClusterParameterGroupError::DbParameterGroupNotFoundFault`.
    pub fn is_db_parameter_group_not_found_fault(&self) -> bool {
        matches!(self, Self::DbParameterGroupNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `ModifyDBClusterParameterGroupError::InvalidDbParameterGroupStateFault`.
    pub fn is_invalid_db_parameter_group_state_fault(&self) -> bool {
        matches!(self, Self::InvalidDbParameterGroupStateFault(_))
    }
}
impl std::error::Error for ModifyDBClusterParameterGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DbParameterGroupNotFoundFault(_inner) => Some(_inner),
            Self::InvalidDbParameterGroupStateFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ModifyDBClusterEndpointErrorKind = ModifyDBClusterEndpointError;
/// Error type for the `ModifyDBClusterEndpointError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ModifyDBClusterEndpointError {
    /// <p>The specified custom endpoint doesn't exist.</p>
    DbClusterEndpointNotFoundFault(crate::error::DbClusterEndpointNotFoundFault),
    /// <p> <i>DBInstanceIdentifier</i> does not refer to an existing DB instance.</p>
    DbInstanceNotFoundFault(crate::error::DbInstanceNotFoundFault),
    /// <p>The requested operation cannot be performed on the endpoint while the endpoint is in this state.</p>
    InvalidDbClusterEndpointStateFault(crate::error::InvalidDbClusterEndpointStateFault),
    /// <p>The DB cluster is not in a valid state.</p>
    InvalidDbClusterStateFault(crate::error::InvalidDbClusterStateFault),
    /// <p>The specified DB instance is not in the <i>available</i> state.</p>
    InvalidDbInstanceStateFault(crate::error::InvalidDbInstanceStateFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ModifyDBClusterEndpointError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ModifyDBClusterEndpointError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DbClusterEndpointNotFoundFault(_inner) => _inner.fmt(f),
            Self::DbInstanceNotFoundFault(_inner) => _inner.fmt(f),
            Self::InvalidDbClusterEndpointStateFault(_inner) => _inner.fmt(f),
            Self::InvalidDbClusterStateFault(_inner) => _inner.fmt(f),
            Self::InvalidDbInstanceStateFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ModifyDBClusterEndpointError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DbClusterEndpointNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DbInstanceNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDbClusterEndpointStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDbClusterStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDbInstanceStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ModifyDBClusterEndpointError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ModifyDBClusterEndpointError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ModifyDBClusterEndpointError {
    /// Creates the `ModifyDBClusterEndpointError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ModifyDBClusterEndpointError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DbClusterEndpointNotFoundFault(e) => e.meta(),
            Self::DbInstanceNotFoundFault(e) => e.meta(),
            Self::InvalidDbClusterEndpointStateFault(e) => e.meta(),
            Self::InvalidDbClusterStateFault(e) => e.meta(),
            Self::InvalidDbInstanceStateFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ModifyDBClusterEndpointError::DbClusterEndpointNotFoundFault`.
    pub fn is_db_cluster_endpoint_not_found_fault(&self) -> bool {
        matches!(self, Self::DbClusterEndpointNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `ModifyDBClusterEndpointError::DbInstanceNotFoundFault`.
    pub fn is_db_instance_not_found_fault(&self) -> bool {
        matches!(self, Self::DbInstanceNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `ModifyDBClusterEndpointError::InvalidDbClusterEndpointStateFault`.
    pub fn is_invalid_db_cluster_endpoint_state_fault(&self) -> bool {
        matches!(self, Self::InvalidDbClusterEndpointStateFault(_))
    }
    /// Returns `true` if the error kind is `ModifyDBClusterEndpointError::InvalidDbClusterStateFault`.
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(self, Self::InvalidDbClusterStateFault(_))
    }
    /// Returns `true` if the error kind is `ModifyDBClusterEndpointError::InvalidDbInstanceStateFault`.
    pub fn is_invalid_db_instance_state_fault(&self) -> bool {
        matches!(self, Self::InvalidDbInstanceStateFault(_))
    }
}
impl std::error::Error for ModifyDBClusterEndpointError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DbClusterEndpointNotFoundFault(_inner) => Some(_inner),
            Self::DbInstanceNotFoundFault(_inner) => Some(_inner),
            Self::InvalidDbClusterEndpointStateFault(_inner) => Some(_inner),
            Self::InvalidDbClusterStateFault(_inner) => Some(_inner),
            Self::InvalidDbInstanceStateFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The requested operation cannot be performed on the endpoint while the endpoint is in this state.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidDbClusterEndpointStateFault {
    /// <p>A message describing the details of the problem.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidDbClusterEndpointStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidDbClusterEndpointStateFault`](crate::error::InvalidDbClusterEndpointStateFault).
    pub fn builder() -> crate::error::invalid_db_cluster_endpoint_state_fault::Builder {
        crate::error::invalid_db_cluster_endpoint_state_fault::Builder::default()
    }
}
/// See [`InvalidDbClusterEndpointStateFault`](crate::error::InvalidDbClusterEndpointStateFault).
pub mod invalid_db_cluster_endpoint_state_fault {

    /// A builder for [`InvalidDbClusterEndpointStateFault`](crate::error::InvalidDbClusterEndpointStateFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A message describing the details of the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message describing the details of the problem.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidDbClusterEndpointStateFault`](crate::error::InvalidDbClusterEndpointStateFault).
        pub fn build(self) -> crate::error::InvalidDbClusterEndpointStateFault {
            crate::error::InvalidDbClusterEndpointStateFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidDbClusterEndpointStateFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidDbClusterEndpointStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "InvalidDbClusterEndpointStateFault [InvalidDBClusterEndpointStateFault]"
        )?;
        if let Some(inner_47) = &self.message {
            {
                write!(f, ": {}", inner_47)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidDbClusterEndpointStateFault {}
impl aws_http::request_id::RequestId for crate::error::InvalidDbClusterEndpointStateFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for InvalidDbClusterEndpointStateFault
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The specified custom endpoint doesn't exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DbClusterEndpointNotFoundFault {
    /// <p>A message describing the details of the problem.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl DbClusterEndpointNotFoundFault {
    /// Creates a new builder-style object to manufacture [`DbClusterEndpointNotFoundFault`](crate::error::DbClusterEndpointNotFoundFault).
    pub fn builder() -> crate::error::db_cluster_endpoint_not_found_fault::Builder {
        crate::error::db_cluster_endpoint_not_found_fault::Builder::default()
    }
}
/// See [`DbClusterEndpointNotFoundFault`](crate::error::DbClusterEndpointNotFoundFault).
pub mod db_cluster_endpoint_not_found_fault {

    /// A builder for [`DbClusterEndpointNotFoundFault`](crate::error::DbClusterEndpointNotFoundFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A message describing the details of the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message describing the details of the problem.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`DbClusterEndpointNotFoundFault`](crate::error::DbClusterEndpointNotFoundFault).
        pub fn build(self) -> crate::error::DbClusterEndpointNotFoundFault {
            crate::error::DbClusterEndpointNotFoundFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl DbClusterEndpointNotFoundFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DbClusterEndpointNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "DbClusterEndpointNotFoundFault [DBClusterEndpointNotFoundFault]"
        )?;
        if let Some(inner_48) = &self.message {
            {
                write!(f, ": {}", inner_48)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DbClusterEndpointNotFoundFault {}
impl aws_http::request_id::RequestId for crate::error::DbClusterEndpointNotFoundFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DbClusterEndpointNotFoundFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ModifyDBClusterErrorKind = ModifyDBClusterError;
/// Error type for the `ModifyDBClusterError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ModifyDBClusterError {
    /// <p>User already has a DB cluster with the given identifier.</p>
    DbClusterAlreadyExistsFault(crate::error::DbClusterAlreadyExistsFault),
    /// <p> <i>DBClusterIdentifier</i> does not refer to an existing DB cluster.</p>
    DbClusterNotFoundFault(crate::error::DbClusterNotFoundFault),
    /// <p> <i>DBClusterParameterGroupName</i> does not refer to an existing DB Cluster parameter group.</p>
    DbClusterParameterGroupNotFoundFault(crate::error::DbClusterParameterGroupNotFoundFault),
    /// <p> <i>DBSubnetGroupName</i> does not refer to an existing DB subnet group.</p>
    DbSubnetGroupNotFoundFault(crate::error::DbSubnetGroupNotFoundFault),
    /// <p>The DB cluster is not in a valid state.</p>
    InvalidDbClusterStateFault(crate::error::InvalidDbClusterStateFault),
    /// <p>The specified DB instance is not in the <i>available</i> state.</p>
    InvalidDbInstanceStateFault(crate::error::InvalidDbInstanceStateFault),
    /// <p>The state of the DB security group does not allow deletion.</p>
    InvalidDbSecurityGroupStateFault(crate::error::InvalidDbSecurityGroupStateFault),
    /// <p>The DB subnet group cannot be deleted because it is in use.</p>
    InvalidDbSubnetGroupStateFault(crate::error::InvalidDbSubnetGroupStateFault),
    /// <p>The requested subnet is invalid, or multiple subnets were requested that are not all in a common VPC.</p>
    InvalidSubnet(crate::error::InvalidSubnet),
    /// <p>DB subnet group does not cover all Availability Zones after it is created because users' change.</p>
    InvalidVpcNetworkStateFault(crate::error::InvalidVpcNetworkStateFault),
    /// <p>Request would result in user exceeding the allowed amount of storage available across all DB instances.</p>
    StorageQuotaExceededFault(crate::error::StorageQuotaExceededFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ModifyDBClusterError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ModifyDBClusterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DbClusterAlreadyExistsFault(_inner) => _inner.fmt(f),
            Self::DbClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::DbClusterParameterGroupNotFoundFault(_inner) => _inner.fmt(f),
            Self::DbSubnetGroupNotFoundFault(_inner) => _inner.fmt(f),
            Self::InvalidDbClusterStateFault(_inner) => _inner.fmt(f),
            Self::InvalidDbInstanceStateFault(_inner) => _inner.fmt(f),
            Self::InvalidDbSecurityGroupStateFault(_inner) => _inner.fmt(f),
            Self::InvalidDbSubnetGroupStateFault(_inner) => _inner.fmt(f),
            Self::InvalidSubnet(_inner) => _inner.fmt(f),
            Self::InvalidVpcNetworkStateFault(_inner) => _inner.fmt(f),
            Self::StorageQuotaExceededFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ModifyDBClusterError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DbClusterAlreadyExistsFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DbClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DbClusterParameterGroupNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DbSubnetGroupNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDbClusterStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDbInstanceStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDbSecurityGroupStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDbSubnetGroupStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidSubnet(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidVpcNetworkStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::StorageQuotaExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ModifyDBClusterError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ModifyDBClusterError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ModifyDBClusterError {
    /// Creates the `ModifyDBClusterError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ModifyDBClusterError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DbClusterAlreadyExistsFault(e) => e.meta(),
            Self::DbClusterNotFoundFault(e) => e.meta(),
            Self::DbClusterParameterGroupNotFoundFault(e) => e.meta(),
            Self::DbSubnetGroupNotFoundFault(e) => e.meta(),
            Self::InvalidDbClusterStateFault(e) => e.meta(),
            Self::InvalidDbInstanceStateFault(e) => e.meta(),
            Self::InvalidDbSecurityGroupStateFault(e) => e.meta(),
            Self::InvalidDbSubnetGroupStateFault(e) => e.meta(),
            Self::InvalidSubnet(e) => e.meta(),
            Self::InvalidVpcNetworkStateFault(e) => e.meta(),
            Self::StorageQuotaExceededFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ModifyDBClusterError::DbClusterAlreadyExistsFault`.
    pub fn is_db_cluster_already_exists_fault(&self) -> bool {
        matches!(self, Self::DbClusterAlreadyExistsFault(_))
    }
    /// Returns `true` if the error kind is `ModifyDBClusterError::DbClusterNotFoundFault`.
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::DbClusterNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `ModifyDBClusterError::DbClusterParameterGroupNotFoundFault`.
    pub fn is_db_cluster_parameter_group_not_found_fault(&self) -> bool {
        matches!(self, Self::DbClusterParameterGroupNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `ModifyDBClusterError::DbSubnetGroupNotFoundFault`.
    pub fn is_db_subnet_group_not_found_fault(&self) -> bool {
        matches!(self, Self::DbSubnetGroupNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `ModifyDBClusterError::InvalidDbClusterStateFault`.
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(self, Self::InvalidDbClusterStateFault(_))
    }
    /// Returns `true` if the error kind is `ModifyDBClusterError::InvalidDbInstanceStateFault`.
    pub fn is_invalid_db_instance_state_fault(&self) -> bool {
        matches!(self, Self::InvalidDbInstanceStateFault(_))
    }
    /// Returns `true` if the error kind is `ModifyDBClusterError::InvalidDbSecurityGroupStateFault`.
    pub fn is_invalid_db_security_group_state_fault(&self) -> bool {
        matches!(self, Self::InvalidDbSecurityGroupStateFault(_))
    }
    /// Returns `true` if the error kind is `ModifyDBClusterError::InvalidDbSubnetGroupStateFault`.
    pub fn is_invalid_db_subnet_group_state_fault(&self) -> bool {
        matches!(self, Self::InvalidDbSubnetGroupStateFault(_))
    }
    /// Returns `true` if the error kind is `ModifyDBClusterError::InvalidSubnet`.
    pub fn is_invalid_subnet(&self) -> bool {
        matches!(self, Self::InvalidSubnet(_))
    }
    /// Returns `true` if the error kind is `ModifyDBClusterError::InvalidVpcNetworkStateFault`.
    pub fn is_invalid_vpc_network_state_fault(&self) -> bool {
        matches!(self, Self::InvalidVpcNetworkStateFault(_))
    }
    /// Returns `true` if the error kind is `ModifyDBClusterError::StorageQuotaExceededFault`.
    pub fn is_storage_quota_exceeded_fault(&self) -> bool {
        matches!(self, Self::StorageQuotaExceededFault(_))
    }
}
impl std::error::Error for ModifyDBClusterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DbClusterAlreadyExistsFault(_inner) => Some(_inner),
            Self::DbClusterNotFoundFault(_inner) => Some(_inner),
            Self::DbClusterParameterGroupNotFoundFault(_inner) => Some(_inner),
            Self::DbSubnetGroupNotFoundFault(_inner) => Some(_inner),
            Self::InvalidDbClusterStateFault(_inner) => Some(_inner),
            Self::InvalidDbInstanceStateFault(_inner) => Some(_inner),
            Self::InvalidDbSecurityGroupStateFault(_inner) => Some(_inner),
            Self::InvalidDbSubnetGroupStateFault(_inner) => Some(_inner),
            Self::InvalidSubnet(_inner) => Some(_inner),
            Self::InvalidVpcNetworkStateFault(_inner) => Some(_inner),
            Self::StorageQuotaExceededFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The DB subnet group cannot be deleted because it is in use.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidDbSubnetGroupStateFault {
    /// <p>A message describing the details of the problem.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidDbSubnetGroupStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidDbSubnetGroupStateFault`](crate::error::InvalidDbSubnetGroupStateFault).
    pub fn builder() -> crate::error::invalid_db_subnet_group_state_fault::Builder {
        crate::error::invalid_db_subnet_group_state_fault::Builder::default()
    }
}
/// See [`InvalidDbSubnetGroupStateFault`](crate::error::InvalidDbSubnetGroupStateFault).
pub mod invalid_db_subnet_group_state_fault {

    /// A builder for [`InvalidDbSubnetGroupStateFault`](crate::error::InvalidDbSubnetGroupStateFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A message describing the details of the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message describing the details of the problem.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidDbSubnetGroupStateFault`](crate::error::InvalidDbSubnetGroupStateFault).
        pub fn build(self) -> crate::error::InvalidDbSubnetGroupStateFault {
            crate::error::InvalidDbSubnetGroupStateFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidDbSubnetGroupStateFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidDbSubnetGroupStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "InvalidDbSubnetGroupStateFault [InvalidDBSubnetGroupStateFault]"
        )?;
        if let Some(inner_49) = &self.message {
            {
                write!(f, ": {}", inner_49)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidDbSubnetGroupStateFault {}
impl aws_http::request_id::RequestId for crate::error::InvalidDbSubnetGroupStateFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidDbSubnetGroupStateFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ListTagsForResourceErrorKind = ListTagsForResourceError;
/// Error type for the `ListTagsForResourceError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTagsForResourceError {
    /// <p> <i>DBClusterIdentifier</i> does not refer to an existing DB cluster.</p>
    DbClusterNotFoundFault(crate::error::DbClusterNotFoundFault),
    /// <p> <i>DBInstanceIdentifier</i> does not refer to an existing DB instance.</p>
    DbInstanceNotFoundFault(crate::error::DbInstanceNotFoundFault),
    /// <p> <i>DBSnapshotIdentifier</i> does not refer to an existing DB snapshot.</p>
    DbSnapshotNotFoundFault(crate::error::DbSnapshotNotFoundFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListTagsForResourceError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ListTagsForResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DbClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::DbInstanceNotFoundFault(_inner) => _inner.fmt(f),
            Self::DbSnapshotNotFoundFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListTagsForResourceError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DbClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DbInstanceNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DbSnapshotNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListTagsForResourceError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListTagsForResourceError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTagsForResourceError {
    /// Creates the `ListTagsForResourceError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ListTagsForResourceError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DbClusterNotFoundFault(e) => e.meta(),
            Self::DbInstanceNotFoundFault(e) => e.meta(),
            Self::DbSnapshotNotFoundFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListTagsForResourceError::DbClusterNotFoundFault`.
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::DbClusterNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `ListTagsForResourceError::DbInstanceNotFoundFault`.
    pub fn is_db_instance_not_found_fault(&self) -> bool {
        matches!(self, Self::DbInstanceNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `ListTagsForResourceError::DbSnapshotNotFoundFault`.
    pub fn is_db_snapshot_not_found_fault(&self) -> bool {
        matches!(self, Self::DbSnapshotNotFoundFault(_))
    }
}
impl std::error::Error for ListTagsForResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DbClusterNotFoundFault(_inner) => Some(_inner),
            Self::DbInstanceNotFoundFault(_inner) => Some(_inner),
            Self::DbSnapshotNotFoundFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type FailoverGlobalClusterErrorKind = FailoverGlobalClusterError;
/// Error type for the `FailoverGlobalClusterError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum FailoverGlobalClusterError {
    /// <p> <i>DBClusterIdentifier</i> does not refer to an existing DB cluster.</p>
    DbClusterNotFoundFault(crate::error::DbClusterNotFoundFault),
    /// <p>The <code>GlobalClusterIdentifier</code> doesn't refer to an existing global database cluster. </p>
    GlobalClusterNotFoundFault(crate::error::GlobalClusterNotFoundFault),
    /// <p>The DB cluster is not in a valid state.</p>
    InvalidDbClusterStateFault(crate::error::InvalidDbClusterStateFault),
    /// <p>The global cluster is in an invalid state and can't perform the requested operation. </p>
    InvalidGlobalClusterStateFault(crate::error::InvalidGlobalClusterStateFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for FailoverGlobalClusterError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for FailoverGlobalClusterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DbClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::GlobalClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::InvalidDbClusterStateFault(_inner) => _inner.fmt(f),
            Self::InvalidGlobalClusterStateFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for FailoverGlobalClusterError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DbClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::GlobalClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDbClusterStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidGlobalClusterStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::FailoverGlobalClusterError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for FailoverGlobalClusterError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl FailoverGlobalClusterError {
    /// Creates the `FailoverGlobalClusterError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `FailoverGlobalClusterError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DbClusterNotFoundFault(e) => e.meta(),
            Self::GlobalClusterNotFoundFault(e) => e.meta(),
            Self::InvalidDbClusterStateFault(e) => e.meta(),
            Self::InvalidGlobalClusterStateFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `FailoverGlobalClusterError::DbClusterNotFoundFault`.
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::DbClusterNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `FailoverGlobalClusterError::GlobalClusterNotFoundFault`.
    pub fn is_global_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::GlobalClusterNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `FailoverGlobalClusterError::InvalidDbClusterStateFault`.
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(self, Self::InvalidDbClusterStateFault(_))
    }
    /// Returns `true` if the error kind is `FailoverGlobalClusterError::InvalidGlobalClusterStateFault`.
    pub fn is_invalid_global_cluster_state_fault(&self) -> bool {
        matches!(self, Self::InvalidGlobalClusterStateFault(_))
    }
}
impl std::error::Error for FailoverGlobalClusterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DbClusterNotFoundFault(_inner) => Some(_inner),
            Self::GlobalClusterNotFoundFault(_inner) => Some(_inner),
            Self::InvalidDbClusterStateFault(_inner) => Some(_inner),
            Self::InvalidGlobalClusterStateFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type FailoverDBClusterErrorKind = FailoverDBClusterError;
/// Error type for the `FailoverDBClusterError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum FailoverDBClusterError {
    /// <p> <i>DBClusterIdentifier</i> does not refer to an existing DB cluster.</p>
    DbClusterNotFoundFault(crate::error::DbClusterNotFoundFault),
    /// <p>The DB cluster is not in a valid state.</p>
    InvalidDbClusterStateFault(crate::error::InvalidDbClusterStateFault),
    /// <p>The specified DB instance is not in the <i>available</i> state.</p>
    InvalidDbInstanceStateFault(crate::error::InvalidDbInstanceStateFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for FailoverDBClusterError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for FailoverDBClusterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DbClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::InvalidDbClusterStateFault(_inner) => _inner.fmt(f),
            Self::InvalidDbInstanceStateFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for FailoverDBClusterError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DbClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDbClusterStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDbInstanceStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::FailoverDBClusterError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for FailoverDBClusterError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl FailoverDBClusterError {
    /// Creates the `FailoverDBClusterError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `FailoverDBClusterError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DbClusterNotFoundFault(e) => e.meta(),
            Self::InvalidDbClusterStateFault(e) => e.meta(),
            Self::InvalidDbInstanceStateFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `FailoverDBClusterError::DbClusterNotFoundFault`.
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::DbClusterNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `FailoverDBClusterError::InvalidDbClusterStateFault`.
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(self, Self::InvalidDbClusterStateFault(_))
    }
    /// Returns `true` if the error kind is `FailoverDBClusterError::InvalidDbInstanceStateFault`.
    pub fn is_invalid_db_instance_state_fault(&self) -> bool {
        matches!(self, Self::InvalidDbInstanceStateFault(_))
    }
}
impl std::error::Error for FailoverDBClusterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DbClusterNotFoundFault(_inner) => Some(_inner),
            Self::InvalidDbClusterStateFault(_inner) => Some(_inner),
            Self::InvalidDbInstanceStateFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeValidDBInstanceModificationsErrorKind = DescribeValidDBInstanceModificationsError;
/// Error type for the `DescribeValidDBInstanceModificationsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeValidDBInstanceModificationsError {
    /// <p> <i>DBInstanceIdentifier</i> does not refer to an existing DB instance.</p>
    DbInstanceNotFoundFault(crate::error::DbInstanceNotFoundFault),
    /// <p>The specified DB instance is not in the <i>available</i> state.</p>
    InvalidDbInstanceStateFault(crate::error::InvalidDbInstanceStateFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeValidDBInstanceModificationsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeValidDBInstanceModificationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DbInstanceNotFoundFault(_inner) => _inner.fmt(f),
            Self::InvalidDbInstanceStateFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for DescribeValidDBInstanceModificationsError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DbInstanceNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDbInstanceStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeValidDBInstanceModificationsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeValidDBInstanceModificationsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeValidDBInstanceModificationsError {
    /// Creates the `DescribeValidDBInstanceModificationsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeValidDBInstanceModificationsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DbInstanceNotFoundFault(e) => e.meta(),
            Self::InvalidDbInstanceStateFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeValidDBInstanceModificationsError::DbInstanceNotFoundFault`.
    pub fn is_db_instance_not_found_fault(&self) -> bool {
        matches!(self, Self::DbInstanceNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `DescribeValidDBInstanceModificationsError::InvalidDbInstanceStateFault`.
    pub fn is_invalid_db_instance_state_fault(&self) -> bool {
        matches!(self, Self::InvalidDbInstanceStateFault(_))
    }
}
impl std::error::Error for DescribeValidDBInstanceModificationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DbInstanceNotFoundFault(_inner) => Some(_inner),
            Self::InvalidDbInstanceStateFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribePendingMaintenanceActionsErrorKind = DescribePendingMaintenanceActionsError;
/// Error type for the `DescribePendingMaintenanceActionsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribePendingMaintenanceActionsError {
    /// <p>The specified resource ID was not found.</p>
    ResourceNotFoundFault(crate::error::ResourceNotFoundFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribePendingMaintenanceActionsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribePendingMaintenanceActionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ResourceNotFoundFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for DescribePendingMaintenanceActionsError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ResourceNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribePendingMaintenanceActionsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribePendingMaintenanceActionsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribePendingMaintenanceActionsError {
    /// Creates the `DescribePendingMaintenanceActionsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribePendingMaintenanceActionsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ResourceNotFoundFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribePendingMaintenanceActionsError::ResourceNotFoundFault`.
    pub fn is_resource_not_found_fault(&self) -> bool {
        matches!(self, Self::ResourceNotFoundFault(_))
    }
}
impl std::error::Error for DescribePendingMaintenanceActionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ResourceNotFoundFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The specified resource ID was not found.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ResourceNotFoundFault {
    /// <p>A message describing the details of the problem.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ResourceNotFoundFault {
    /// Creates a new builder-style object to manufacture [`ResourceNotFoundFault`](crate::error::ResourceNotFoundFault).
    pub fn builder() -> crate::error::resource_not_found_fault::Builder {
        crate::error::resource_not_found_fault::Builder::default()
    }
}
/// See [`ResourceNotFoundFault`](crate::error::ResourceNotFoundFault).
pub mod resource_not_found_fault {

    /// A builder for [`ResourceNotFoundFault`](crate::error::ResourceNotFoundFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A message describing the details of the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message describing the details of the problem.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ResourceNotFoundFault`](crate::error::ResourceNotFoundFault).
        pub fn build(self) -> crate::error::ResourceNotFoundFault {
            crate::error::ResourceNotFoundFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl ResourceNotFoundFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceNotFoundFault")?;
        if let Some(inner_50) = &self.message {
            {
                write!(f, ": {}", inner_50)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ResourceNotFoundFault {}
impl aws_http::request_id::RequestId for crate::error::ResourceNotFoundFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ResourceNotFoundFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeOrderableDBInstanceOptionsErrorKind = DescribeOrderableDBInstanceOptionsError;
/// Error type for the `DescribeOrderableDBInstanceOptionsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeOrderableDBInstanceOptionsError {
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeOrderableDBInstanceOptionsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeOrderableDBInstanceOptionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for DescribeOrderableDBInstanceOptionsError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeOrderableDBInstanceOptionsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeOrderableDBInstanceOptionsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeOrderableDBInstanceOptionsError {
    /// Creates the `DescribeOrderableDBInstanceOptionsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeOrderableDBInstanceOptionsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::Unhandled(e) => e.meta(),
        }
    }
}
impl std::error::Error for DescribeOrderableDBInstanceOptionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeGlobalClustersErrorKind = DescribeGlobalClustersError;
/// Error type for the `DescribeGlobalClustersError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeGlobalClustersError {
    /// <p>The <code>GlobalClusterIdentifier</code> doesn't refer to an existing global database cluster. </p>
    GlobalClusterNotFoundFault(crate::error::GlobalClusterNotFoundFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeGlobalClustersError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeGlobalClustersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::GlobalClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeGlobalClustersError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::GlobalClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeGlobalClustersError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeGlobalClustersError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeGlobalClustersError {
    /// Creates the `DescribeGlobalClustersError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeGlobalClustersError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::GlobalClusterNotFoundFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeGlobalClustersError::GlobalClusterNotFoundFault`.
    pub fn is_global_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::GlobalClusterNotFoundFault(_))
    }
}
impl std::error::Error for DescribeGlobalClustersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::GlobalClusterNotFoundFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeEventSubscriptionsErrorKind = DescribeEventSubscriptionsError;
/// Error type for the `DescribeEventSubscriptionsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeEventSubscriptionsError {
    /// <p>The designated subscription could not be found.</p>
    SubscriptionNotFoundFault(crate::error::SubscriptionNotFoundFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeEventSubscriptionsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeEventSubscriptionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::SubscriptionNotFoundFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeEventSubscriptionsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::SubscriptionNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeEventSubscriptionsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeEventSubscriptionsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeEventSubscriptionsError {
    /// Creates the `DescribeEventSubscriptionsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeEventSubscriptionsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::SubscriptionNotFoundFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeEventSubscriptionsError::SubscriptionNotFoundFault`.
    pub fn is_subscription_not_found_fault(&self) -> bool {
        matches!(self, Self::SubscriptionNotFoundFault(_))
    }
}
impl std::error::Error for DescribeEventSubscriptionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::SubscriptionNotFoundFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeEventsErrorKind = DescribeEventsError;
/// Error type for the `DescribeEventsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeEventsError {
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeEventsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeEventsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeEventsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeEventsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeEventsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeEventsError {
    /// Creates the `DescribeEventsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeEventsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::Unhandled(e) => e.meta(),
        }
    }
}
impl std::error::Error for DescribeEventsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeEventCategoriesErrorKind = DescribeEventCategoriesError;
/// Error type for the `DescribeEventCategoriesError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeEventCategoriesError {
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeEventCategoriesError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeEventCategoriesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeEventCategoriesError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeEventCategoriesError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeEventCategoriesError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeEventCategoriesError {
    /// Creates the `DescribeEventCategoriesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeEventCategoriesError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::Unhandled(e) => e.meta(),
        }
    }
}
impl std::error::Error for DescribeEventCategoriesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeEngineDefaultParametersErrorKind = DescribeEngineDefaultParametersError;
/// Error type for the `DescribeEngineDefaultParametersError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeEngineDefaultParametersError {
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeEngineDefaultParametersError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeEngineDefaultParametersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for DescribeEngineDefaultParametersError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeEngineDefaultParametersError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeEngineDefaultParametersError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeEngineDefaultParametersError {
    /// Creates the `DescribeEngineDefaultParametersError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeEngineDefaultParametersError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::Unhandled(e) => e.meta(),
        }
    }
}
impl std::error::Error for DescribeEngineDefaultParametersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeEngineDefaultClusterParametersErrorKind =
    DescribeEngineDefaultClusterParametersError;
/// Error type for the `DescribeEngineDefaultClusterParametersError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeEngineDefaultClusterParametersError {
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeEngineDefaultClusterParametersError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeEngineDefaultClusterParametersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for DescribeEngineDefaultClusterParametersError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeEngineDefaultClusterParametersError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeEngineDefaultClusterParametersError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeEngineDefaultClusterParametersError {
    /// Creates the `DescribeEngineDefaultClusterParametersError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeEngineDefaultClusterParametersError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::Unhandled(e) => e.meta(),
        }
    }
}
impl std::error::Error for DescribeEngineDefaultClusterParametersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeDBSubnetGroupsErrorKind = DescribeDBSubnetGroupsError;
/// Error type for the `DescribeDBSubnetGroupsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDBSubnetGroupsError {
    /// <p> <i>DBSubnetGroupName</i> does not refer to an existing DB subnet group.</p>
    DbSubnetGroupNotFoundFault(crate::error::DbSubnetGroupNotFoundFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeDBSubnetGroupsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeDBSubnetGroupsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DbSubnetGroupNotFoundFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeDBSubnetGroupsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DbSubnetGroupNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeDBSubnetGroupsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeDBSubnetGroupsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDBSubnetGroupsError {
    /// Creates the `DescribeDBSubnetGroupsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeDBSubnetGroupsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DbSubnetGroupNotFoundFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeDBSubnetGroupsError::DbSubnetGroupNotFoundFault`.
    pub fn is_db_subnet_group_not_found_fault(&self) -> bool {
        matches!(self, Self::DbSubnetGroupNotFoundFault(_))
    }
}
impl std::error::Error for DescribeDBSubnetGroupsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DbSubnetGroupNotFoundFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeDBParametersErrorKind = DescribeDBParametersError;
/// Error type for the `DescribeDBParametersError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDBParametersError {
    /// <p> <i>DBParameterGroupName</i> does not refer to an existing DB parameter group.</p>
    DbParameterGroupNotFoundFault(crate::error::DbParameterGroupNotFoundFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeDBParametersError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeDBParametersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DbParameterGroupNotFoundFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeDBParametersError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DbParameterGroupNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeDBParametersError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeDBParametersError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDBParametersError {
    /// Creates the `DescribeDBParametersError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeDBParametersError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DbParameterGroupNotFoundFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeDBParametersError::DbParameterGroupNotFoundFault`.
    pub fn is_db_parameter_group_not_found_fault(&self) -> bool {
        matches!(self, Self::DbParameterGroupNotFoundFault(_))
    }
}
impl std::error::Error for DescribeDBParametersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DbParameterGroupNotFoundFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeDBParameterGroupsErrorKind = DescribeDBParameterGroupsError;
/// Error type for the `DescribeDBParameterGroupsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDBParameterGroupsError {
    /// <p> <i>DBParameterGroupName</i> does not refer to an existing DB parameter group.</p>
    DbParameterGroupNotFoundFault(crate::error::DbParameterGroupNotFoundFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeDBParameterGroupsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeDBParameterGroupsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DbParameterGroupNotFoundFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeDBParameterGroupsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DbParameterGroupNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeDBParameterGroupsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeDBParameterGroupsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDBParameterGroupsError {
    /// Creates the `DescribeDBParameterGroupsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeDBParameterGroupsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DbParameterGroupNotFoundFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeDBParameterGroupsError::DbParameterGroupNotFoundFault`.
    pub fn is_db_parameter_group_not_found_fault(&self) -> bool {
        matches!(self, Self::DbParameterGroupNotFoundFault(_))
    }
}
impl std::error::Error for DescribeDBParameterGroupsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DbParameterGroupNotFoundFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeDBInstancesErrorKind = DescribeDBInstancesError;
/// Error type for the `DescribeDBInstancesError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDBInstancesError {
    /// <p> <i>DBInstanceIdentifier</i> does not refer to an existing DB instance.</p>
    DbInstanceNotFoundFault(crate::error::DbInstanceNotFoundFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeDBInstancesError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeDBInstancesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DbInstanceNotFoundFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeDBInstancesError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DbInstanceNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeDBInstancesError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeDBInstancesError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDBInstancesError {
    /// Creates the `DescribeDBInstancesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeDBInstancesError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DbInstanceNotFoundFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeDBInstancesError::DbInstanceNotFoundFault`.
    pub fn is_db_instance_not_found_fault(&self) -> bool {
        matches!(self, Self::DbInstanceNotFoundFault(_))
    }
}
impl std::error::Error for DescribeDBInstancesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DbInstanceNotFoundFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeDBEngineVersionsErrorKind = DescribeDBEngineVersionsError;
/// Error type for the `DescribeDBEngineVersionsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDBEngineVersionsError {
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeDBEngineVersionsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeDBEngineVersionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeDBEngineVersionsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeDBEngineVersionsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeDBEngineVersionsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDBEngineVersionsError {
    /// Creates the `DescribeDBEngineVersionsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeDBEngineVersionsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::Unhandled(e) => e.meta(),
        }
    }
}
impl std::error::Error for DescribeDBEngineVersionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeDBClusterSnapshotsErrorKind = DescribeDBClusterSnapshotsError;
/// Error type for the `DescribeDBClusterSnapshotsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDBClusterSnapshotsError {
    /// <p> <i>DBClusterSnapshotIdentifier</i> does not refer to an existing DB cluster snapshot.</p>
    DbClusterSnapshotNotFoundFault(crate::error::DbClusterSnapshotNotFoundFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeDBClusterSnapshotsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeDBClusterSnapshotsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DbClusterSnapshotNotFoundFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeDBClusterSnapshotsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DbClusterSnapshotNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeDBClusterSnapshotsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeDBClusterSnapshotsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDBClusterSnapshotsError {
    /// Creates the `DescribeDBClusterSnapshotsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeDBClusterSnapshotsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DbClusterSnapshotNotFoundFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeDBClusterSnapshotsError::DbClusterSnapshotNotFoundFault`.
    pub fn is_db_cluster_snapshot_not_found_fault(&self) -> bool {
        matches!(self, Self::DbClusterSnapshotNotFoundFault(_))
    }
}
impl std::error::Error for DescribeDBClusterSnapshotsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DbClusterSnapshotNotFoundFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeDBClusterSnapshotAttributesErrorKind = DescribeDBClusterSnapshotAttributesError;
/// Error type for the `DescribeDBClusterSnapshotAttributesError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDBClusterSnapshotAttributesError {
    /// <p> <i>DBClusterSnapshotIdentifier</i> does not refer to an existing DB cluster snapshot.</p>
    DbClusterSnapshotNotFoundFault(crate::error::DbClusterSnapshotNotFoundFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeDBClusterSnapshotAttributesError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeDBClusterSnapshotAttributesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DbClusterSnapshotNotFoundFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for DescribeDBClusterSnapshotAttributesError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DbClusterSnapshotNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeDBClusterSnapshotAttributesError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeDBClusterSnapshotAttributesError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDBClusterSnapshotAttributesError {
    /// Creates the `DescribeDBClusterSnapshotAttributesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeDBClusterSnapshotAttributesError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DbClusterSnapshotNotFoundFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeDBClusterSnapshotAttributesError::DbClusterSnapshotNotFoundFault`.
    pub fn is_db_cluster_snapshot_not_found_fault(&self) -> bool {
        matches!(self, Self::DbClusterSnapshotNotFoundFault(_))
    }
}
impl std::error::Error for DescribeDBClusterSnapshotAttributesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DbClusterSnapshotNotFoundFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeDBClustersErrorKind = DescribeDBClustersError;
/// Error type for the `DescribeDBClustersError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDBClustersError {
    /// <p> <i>DBClusterIdentifier</i> does not refer to an existing DB cluster.</p>
    DbClusterNotFoundFault(crate::error::DbClusterNotFoundFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeDBClustersError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeDBClustersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DbClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeDBClustersError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DbClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeDBClustersError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeDBClustersError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDBClustersError {
    /// Creates the `DescribeDBClustersError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeDBClustersError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DbClusterNotFoundFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeDBClustersError::DbClusterNotFoundFault`.
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::DbClusterNotFoundFault(_))
    }
}
impl std::error::Error for DescribeDBClustersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DbClusterNotFoundFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeDBClusterParametersErrorKind = DescribeDBClusterParametersError;
/// Error type for the `DescribeDBClusterParametersError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDBClusterParametersError {
    /// <p> <i>DBParameterGroupName</i> does not refer to an existing DB parameter group.</p>
    DbParameterGroupNotFoundFault(crate::error::DbParameterGroupNotFoundFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeDBClusterParametersError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeDBClusterParametersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DbParameterGroupNotFoundFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeDBClusterParametersError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DbParameterGroupNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeDBClusterParametersError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeDBClusterParametersError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDBClusterParametersError {
    /// Creates the `DescribeDBClusterParametersError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeDBClusterParametersError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DbParameterGroupNotFoundFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeDBClusterParametersError::DbParameterGroupNotFoundFault`.
    pub fn is_db_parameter_group_not_found_fault(&self) -> bool {
        matches!(self, Self::DbParameterGroupNotFoundFault(_))
    }
}
impl std::error::Error for DescribeDBClusterParametersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DbParameterGroupNotFoundFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeDBClusterParameterGroupsErrorKind = DescribeDBClusterParameterGroupsError;
/// Error type for the `DescribeDBClusterParameterGroupsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDBClusterParameterGroupsError {
    /// <p> <i>DBParameterGroupName</i> does not refer to an existing DB parameter group.</p>
    DbParameterGroupNotFoundFault(crate::error::DbParameterGroupNotFoundFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeDBClusterParameterGroupsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeDBClusterParameterGroupsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DbParameterGroupNotFoundFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for DescribeDBClusterParameterGroupsError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DbParameterGroupNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeDBClusterParameterGroupsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeDBClusterParameterGroupsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDBClusterParameterGroupsError {
    /// Creates the `DescribeDBClusterParameterGroupsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeDBClusterParameterGroupsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DbParameterGroupNotFoundFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeDBClusterParameterGroupsError::DbParameterGroupNotFoundFault`.
    pub fn is_db_parameter_group_not_found_fault(&self) -> bool {
        matches!(self, Self::DbParameterGroupNotFoundFault(_))
    }
}
impl std::error::Error for DescribeDBClusterParameterGroupsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DbParameterGroupNotFoundFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeDBClusterEndpointsErrorKind = DescribeDBClusterEndpointsError;
/// Error type for the `DescribeDBClusterEndpointsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDBClusterEndpointsError {
    /// <p> <i>DBClusterIdentifier</i> does not refer to an existing DB cluster.</p>
    DbClusterNotFoundFault(crate::error::DbClusterNotFoundFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeDBClusterEndpointsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeDBClusterEndpointsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DbClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeDBClusterEndpointsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DbClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeDBClusterEndpointsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeDBClusterEndpointsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDBClusterEndpointsError {
    /// Creates the `DescribeDBClusterEndpointsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeDBClusterEndpointsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DbClusterNotFoundFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeDBClusterEndpointsError::DbClusterNotFoundFault`.
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::DbClusterNotFoundFault(_))
    }
}
impl std::error::Error for DescribeDBClusterEndpointsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DbClusterNotFoundFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteGlobalClusterErrorKind = DeleteGlobalClusterError;
/// Error type for the `DeleteGlobalClusterError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteGlobalClusterError {
    /// <p>The <code>GlobalClusterIdentifier</code> doesn't refer to an existing global database cluster. </p>
    GlobalClusterNotFoundFault(crate::error::GlobalClusterNotFoundFault),
    /// <p>The global cluster is in an invalid state and can't perform the requested operation. </p>
    InvalidGlobalClusterStateFault(crate::error::InvalidGlobalClusterStateFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteGlobalClusterError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteGlobalClusterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::GlobalClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::InvalidGlobalClusterStateFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteGlobalClusterError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::GlobalClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidGlobalClusterStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteGlobalClusterError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteGlobalClusterError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteGlobalClusterError {
    /// Creates the `DeleteGlobalClusterError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteGlobalClusterError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::GlobalClusterNotFoundFault(e) => e.meta(),
            Self::InvalidGlobalClusterStateFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteGlobalClusterError::GlobalClusterNotFoundFault`.
    pub fn is_global_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::GlobalClusterNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `DeleteGlobalClusterError::InvalidGlobalClusterStateFault`.
    pub fn is_invalid_global_cluster_state_fault(&self) -> bool {
        matches!(self, Self::InvalidGlobalClusterStateFault(_))
    }
}
impl std::error::Error for DeleteGlobalClusterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::GlobalClusterNotFoundFault(_inner) => Some(_inner),
            Self::InvalidGlobalClusterStateFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteEventSubscriptionErrorKind = DeleteEventSubscriptionError;
/// Error type for the `DeleteEventSubscriptionError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteEventSubscriptionError {
    /// <p>The event subscription is in an invalid state.</p>
    InvalidEventSubscriptionStateFault(crate::error::InvalidEventSubscriptionStateFault),
    /// <p>The designated subscription could not be found.</p>
    SubscriptionNotFoundFault(crate::error::SubscriptionNotFoundFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteEventSubscriptionError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteEventSubscriptionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidEventSubscriptionStateFault(_inner) => _inner.fmt(f),
            Self::SubscriptionNotFoundFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteEventSubscriptionError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidEventSubscriptionStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SubscriptionNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteEventSubscriptionError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteEventSubscriptionError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteEventSubscriptionError {
    /// Creates the `DeleteEventSubscriptionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteEventSubscriptionError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidEventSubscriptionStateFault(e) => e.meta(),
            Self::SubscriptionNotFoundFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteEventSubscriptionError::InvalidEventSubscriptionStateFault`.
    pub fn is_invalid_event_subscription_state_fault(&self) -> bool {
        matches!(self, Self::InvalidEventSubscriptionStateFault(_))
    }
    /// Returns `true` if the error kind is `DeleteEventSubscriptionError::SubscriptionNotFoundFault`.
    pub fn is_subscription_not_found_fault(&self) -> bool {
        matches!(self, Self::SubscriptionNotFoundFault(_))
    }
}
impl std::error::Error for DeleteEventSubscriptionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidEventSubscriptionStateFault(_inner) => Some(_inner),
            Self::SubscriptionNotFoundFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The event subscription is in an invalid state.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidEventSubscriptionStateFault {
    /// <p>A message describing the details of the problem.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidEventSubscriptionStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidEventSubscriptionStateFault`](crate::error::InvalidEventSubscriptionStateFault).
    pub fn builder() -> crate::error::invalid_event_subscription_state_fault::Builder {
        crate::error::invalid_event_subscription_state_fault::Builder::default()
    }
}
/// See [`InvalidEventSubscriptionStateFault`](crate::error::InvalidEventSubscriptionStateFault).
pub mod invalid_event_subscription_state_fault {

    /// A builder for [`InvalidEventSubscriptionStateFault`](crate::error::InvalidEventSubscriptionStateFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A message describing the details of the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message describing the details of the problem.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidEventSubscriptionStateFault`](crate::error::InvalidEventSubscriptionStateFault).
        pub fn build(self) -> crate::error::InvalidEventSubscriptionStateFault {
            crate::error::InvalidEventSubscriptionStateFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidEventSubscriptionStateFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidEventSubscriptionStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidEventSubscriptionStateFault")?;
        if let Some(inner_51) = &self.message {
            {
                write!(f, ": {}", inner_51)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidEventSubscriptionStateFault {}
impl aws_http::request_id::RequestId for crate::error::InvalidEventSubscriptionStateFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for InvalidEventSubscriptionStateFault
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteDBSubnetGroupErrorKind = DeleteDBSubnetGroupError;
/// Error type for the `DeleteDBSubnetGroupError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDBSubnetGroupError {
    /// <p> <i>DBSubnetGroupName</i> does not refer to an existing DB subnet group.</p>
    DbSubnetGroupNotFoundFault(crate::error::DbSubnetGroupNotFoundFault),
    /// <p>The DB subnet group cannot be deleted because it is in use.</p>
    InvalidDbSubnetGroupStateFault(crate::error::InvalidDbSubnetGroupStateFault),
    /// <p>The DB subnet is not in the <i>available</i> state.</p>
    InvalidDbSubnetStateFault(crate::error::InvalidDbSubnetStateFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteDBSubnetGroupError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteDBSubnetGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DbSubnetGroupNotFoundFault(_inner) => _inner.fmt(f),
            Self::InvalidDbSubnetGroupStateFault(_inner) => _inner.fmt(f),
            Self::InvalidDbSubnetStateFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteDBSubnetGroupError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DbSubnetGroupNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDbSubnetGroupStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDbSubnetStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteDBSubnetGroupError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteDBSubnetGroupError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteDBSubnetGroupError {
    /// Creates the `DeleteDBSubnetGroupError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteDBSubnetGroupError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DbSubnetGroupNotFoundFault(e) => e.meta(),
            Self::InvalidDbSubnetGroupStateFault(e) => e.meta(),
            Self::InvalidDbSubnetStateFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteDBSubnetGroupError::DbSubnetGroupNotFoundFault`.
    pub fn is_db_subnet_group_not_found_fault(&self) -> bool {
        matches!(self, Self::DbSubnetGroupNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `DeleteDBSubnetGroupError::InvalidDbSubnetGroupStateFault`.
    pub fn is_invalid_db_subnet_group_state_fault(&self) -> bool {
        matches!(self, Self::InvalidDbSubnetGroupStateFault(_))
    }
    /// Returns `true` if the error kind is `DeleteDBSubnetGroupError::InvalidDbSubnetStateFault`.
    pub fn is_invalid_db_subnet_state_fault(&self) -> bool {
        matches!(self, Self::InvalidDbSubnetStateFault(_))
    }
}
impl std::error::Error for DeleteDBSubnetGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DbSubnetGroupNotFoundFault(_inner) => Some(_inner),
            Self::InvalidDbSubnetGroupStateFault(_inner) => Some(_inner),
            Self::InvalidDbSubnetStateFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The DB subnet is not in the <i>available</i> state.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidDbSubnetStateFault {
    /// <p>A message describing the details of the problem.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidDbSubnetStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidDbSubnetStateFault`](crate::error::InvalidDbSubnetStateFault).
    pub fn builder() -> crate::error::invalid_db_subnet_state_fault::Builder {
        crate::error::invalid_db_subnet_state_fault::Builder::default()
    }
}
/// See [`InvalidDbSubnetStateFault`](crate::error::InvalidDbSubnetStateFault).
pub mod invalid_db_subnet_state_fault {

    /// A builder for [`InvalidDbSubnetStateFault`](crate::error::InvalidDbSubnetStateFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A message describing the details of the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message describing the details of the problem.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidDbSubnetStateFault`](crate::error::InvalidDbSubnetStateFault).
        pub fn build(self) -> crate::error::InvalidDbSubnetStateFault {
            crate::error::InvalidDbSubnetStateFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidDbSubnetStateFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidDbSubnetStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidDbSubnetStateFault [InvalidDBSubnetStateFault]")?;
        if let Some(inner_52) = &self.message {
            {
                write!(f, ": {}", inner_52)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidDbSubnetStateFault {}
impl aws_http::request_id::RequestId for crate::error::InvalidDbSubnetStateFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidDbSubnetStateFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteDBParameterGroupErrorKind = DeleteDBParameterGroupError;
/// Error type for the `DeleteDBParameterGroupError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDBParameterGroupError {
    /// <p> <i>DBParameterGroupName</i> does not refer to an existing DB parameter group.</p>
    DbParameterGroupNotFoundFault(crate::error::DbParameterGroupNotFoundFault),
    /// <p>The DB parameter group is in use or is in an invalid state. If you are attempting to delete the parameter group, you cannot delete it when the parameter group is in this state.</p>
    InvalidDbParameterGroupStateFault(crate::error::InvalidDbParameterGroupStateFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteDBParameterGroupError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteDBParameterGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DbParameterGroupNotFoundFault(_inner) => _inner.fmt(f),
            Self::InvalidDbParameterGroupStateFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteDBParameterGroupError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DbParameterGroupNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDbParameterGroupStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteDBParameterGroupError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteDBParameterGroupError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteDBParameterGroupError {
    /// Creates the `DeleteDBParameterGroupError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteDBParameterGroupError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DbParameterGroupNotFoundFault(e) => e.meta(),
            Self::InvalidDbParameterGroupStateFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteDBParameterGroupError::DbParameterGroupNotFoundFault`.
    pub fn is_db_parameter_group_not_found_fault(&self) -> bool {
        matches!(self, Self::DbParameterGroupNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `DeleteDBParameterGroupError::InvalidDbParameterGroupStateFault`.
    pub fn is_invalid_db_parameter_group_state_fault(&self) -> bool {
        matches!(self, Self::InvalidDbParameterGroupStateFault(_))
    }
}
impl std::error::Error for DeleteDBParameterGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DbParameterGroupNotFoundFault(_inner) => Some(_inner),
            Self::InvalidDbParameterGroupStateFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteDBInstanceErrorKind = DeleteDBInstanceError;
/// Error type for the `DeleteDBInstanceError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDBInstanceError {
    /// <p> <i>DBInstanceIdentifier</i> does not refer to an existing DB instance.</p>
    DbInstanceNotFoundFault(crate::error::DbInstanceNotFoundFault),
    /// <p> <i>DBSnapshotIdentifier</i> is already used by an existing snapshot.</p>
    DbSnapshotAlreadyExistsFault(crate::error::DbSnapshotAlreadyExistsFault),
    /// <p>The DB cluster is not in a valid state.</p>
    InvalidDbClusterStateFault(crate::error::InvalidDbClusterStateFault),
    /// <p>The specified DB instance is not in the <i>available</i> state.</p>
    InvalidDbInstanceStateFault(crate::error::InvalidDbInstanceStateFault),
    /// <p>Request would result in user exceeding the allowed number of DB snapshots.</p>
    SnapshotQuotaExceededFault(crate::error::SnapshotQuotaExceededFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteDBInstanceError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteDBInstanceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DbInstanceNotFoundFault(_inner) => _inner.fmt(f),
            Self::DbSnapshotAlreadyExistsFault(_inner) => _inner.fmt(f),
            Self::InvalidDbClusterStateFault(_inner) => _inner.fmt(f),
            Self::InvalidDbInstanceStateFault(_inner) => _inner.fmt(f),
            Self::SnapshotQuotaExceededFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteDBInstanceError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DbInstanceNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DbSnapshotAlreadyExistsFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDbClusterStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDbInstanceStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SnapshotQuotaExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteDBInstanceError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteDBInstanceError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteDBInstanceError {
    /// Creates the `DeleteDBInstanceError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteDBInstanceError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DbInstanceNotFoundFault(e) => e.meta(),
            Self::DbSnapshotAlreadyExistsFault(e) => e.meta(),
            Self::InvalidDbClusterStateFault(e) => e.meta(),
            Self::InvalidDbInstanceStateFault(e) => e.meta(),
            Self::SnapshotQuotaExceededFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteDBInstanceError::DbInstanceNotFoundFault`.
    pub fn is_db_instance_not_found_fault(&self) -> bool {
        matches!(self, Self::DbInstanceNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `DeleteDBInstanceError::DbSnapshotAlreadyExistsFault`.
    pub fn is_db_snapshot_already_exists_fault(&self) -> bool {
        matches!(self, Self::DbSnapshotAlreadyExistsFault(_))
    }
    /// Returns `true` if the error kind is `DeleteDBInstanceError::InvalidDbClusterStateFault`.
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(self, Self::InvalidDbClusterStateFault(_))
    }
    /// Returns `true` if the error kind is `DeleteDBInstanceError::InvalidDbInstanceStateFault`.
    pub fn is_invalid_db_instance_state_fault(&self) -> bool {
        matches!(self, Self::InvalidDbInstanceStateFault(_))
    }
    /// Returns `true` if the error kind is `DeleteDBInstanceError::SnapshotQuotaExceededFault`.
    pub fn is_snapshot_quota_exceeded_fault(&self) -> bool {
        matches!(self, Self::SnapshotQuotaExceededFault(_))
    }
}
impl std::error::Error for DeleteDBInstanceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DbInstanceNotFoundFault(_inner) => Some(_inner),
            Self::DbSnapshotAlreadyExistsFault(_inner) => Some(_inner),
            Self::InvalidDbClusterStateFault(_inner) => Some(_inner),
            Self::InvalidDbInstanceStateFault(_inner) => Some(_inner),
            Self::SnapshotQuotaExceededFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>Request would result in user exceeding the allowed number of DB snapshots.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SnapshotQuotaExceededFault {
    /// <p>A message describing the details of the problem.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl SnapshotQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`SnapshotQuotaExceededFault`](crate::error::SnapshotQuotaExceededFault).
    pub fn builder() -> crate::error::snapshot_quota_exceeded_fault::Builder {
        crate::error::snapshot_quota_exceeded_fault::Builder::default()
    }
}
/// See [`SnapshotQuotaExceededFault`](crate::error::SnapshotQuotaExceededFault).
pub mod snapshot_quota_exceeded_fault {

    /// A builder for [`SnapshotQuotaExceededFault`](crate::error::SnapshotQuotaExceededFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A message describing the details of the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message describing the details of the problem.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`SnapshotQuotaExceededFault`](crate::error::SnapshotQuotaExceededFault).
        pub fn build(self) -> crate::error::SnapshotQuotaExceededFault {
            crate::error::SnapshotQuotaExceededFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl SnapshotQuotaExceededFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SnapshotQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SnapshotQuotaExceededFault")?;
        if let Some(inner_53) = &self.message {
            {
                write!(f, ": {}", inner_53)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for SnapshotQuotaExceededFault {}
impl aws_http::request_id::RequestId for crate::error::SnapshotQuotaExceededFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for SnapshotQuotaExceededFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p> <i>DBSnapshotIdentifier</i> is already used by an existing snapshot.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DbSnapshotAlreadyExistsFault {
    /// <p>A message describing the details of the problem.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl DbSnapshotAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`DbSnapshotAlreadyExistsFault`](crate::error::DbSnapshotAlreadyExistsFault).
    pub fn builder() -> crate::error::db_snapshot_already_exists_fault::Builder {
        crate::error::db_snapshot_already_exists_fault::Builder::default()
    }
}
/// See [`DbSnapshotAlreadyExistsFault`](crate::error::DbSnapshotAlreadyExistsFault).
pub mod db_snapshot_already_exists_fault {

    /// A builder for [`DbSnapshotAlreadyExistsFault`](crate::error::DbSnapshotAlreadyExistsFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A message describing the details of the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message describing the details of the problem.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`DbSnapshotAlreadyExistsFault`](crate::error::DbSnapshotAlreadyExistsFault).
        pub fn build(self) -> crate::error::DbSnapshotAlreadyExistsFault {
            crate::error::DbSnapshotAlreadyExistsFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl DbSnapshotAlreadyExistsFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DbSnapshotAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "DbSnapshotAlreadyExistsFault [DBSnapshotAlreadyExistsFault]"
        )?;
        if let Some(inner_54) = &self.message {
            {
                write!(f, ": {}", inner_54)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DbSnapshotAlreadyExistsFault {}
impl aws_http::request_id::RequestId for crate::error::DbSnapshotAlreadyExistsFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DbSnapshotAlreadyExistsFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteDBClusterSnapshotErrorKind = DeleteDBClusterSnapshotError;
/// Error type for the `DeleteDBClusterSnapshotError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDBClusterSnapshotError {
    /// <p> <i>DBClusterSnapshotIdentifier</i> does not refer to an existing DB cluster snapshot.</p>
    DbClusterSnapshotNotFoundFault(crate::error::DbClusterSnapshotNotFoundFault),
    /// <p>The supplied value is not a valid DB cluster snapshot state.</p>
    InvalidDbClusterSnapshotStateFault(crate::error::InvalidDbClusterSnapshotStateFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteDBClusterSnapshotError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteDBClusterSnapshotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DbClusterSnapshotNotFoundFault(_inner) => _inner.fmt(f),
            Self::InvalidDbClusterSnapshotStateFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteDBClusterSnapshotError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DbClusterSnapshotNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDbClusterSnapshotStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteDBClusterSnapshotError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteDBClusterSnapshotError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteDBClusterSnapshotError {
    /// Creates the `DeleteDBClusterSnapshotError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteDBClusterSnapshotError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DbClusterSnapshotNotFoundFault(e) => e.meta(),
            Self::InvalidDbClusterSnapshotStateFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteDBClusterSnapshotError::DbClusterSnapshotNotFoundFault`.
    pub fn is_db_cluster_snapshot_not_found_fault(&self) -> bool {
        matches!(self, Self::DbClusterSnapshotNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `DeleteDBClusterSnapshotError::InvalidDbClusterSnapshotStateFault`.
    pub fn is_invalid_db_cluster_snapshot_state_fault(&self) -> bool {
        matches!(self, Self::InvalidDbClusterSnapshotStateFault(_))
    }
}
impl std::error::Error for DeleteDBClusterSnapshotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DbClusterSnapshotNotFoundFault(_inner) => Some(_inner),
            Self::InvalidDbClusterSnapshotStateFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteDBClusterParameterGroupErrorKind = DeleteDBClusterParameterGroupError;
/// Error type for the `DeleteDBClusterParameterGroupError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDBClusterParameterGroupError {
    /// <p> <i>DBParameterGroupName</i> does not refer to an existing DB parameter group.</p>
    DbParameterGroupNotFoundFault(crate::error::DbParameterGroupNotFoundFault),
    /// <p>The DB parameter group is in use or is in an invalid state. If you are attempting to delete the parameter group, you cannot delete it when the parameter group is in this state.</p>
    InvalidDbParameterGroupStateFault(crate::error::InvalidDbParameterGroupStateFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteDBClusterParameterGroupError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteDBClusterParameterGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DbParameterGroupNotFoundFault(_inner) => _inner.fmt(f),
            Self::InvalidDbParameterGroupStateFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for DeleteDBClusterParameterGroupError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DbParameterGroupNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDbParameterGroupStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteDBClusterParameterGroupError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteDBClusterParameterGroupError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteDBClusterParameterGroupError {
    /// Creates the `DeleteDBClusterParameterGroupError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteDBClusterParameterGroupError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DbParameterGroupNotFoundFault(e) => e.meta(),
            Self::InvalidDbParameterGroupStateFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteDBClusterParameterGroupError::DbParameterGroupNotFoundFault`.
    pub fn is_db_parameter_group_not_found_fault(&self) -> bool {
        matches!(self, Self::DbParameterGroupNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `DeleteDBClusterParameterGroupError::InvalidDbParameterGroupStateFault`.
    pub fn is_invalid_db_parameter_group_state_fault(&self) -> bool {
        matches!(self, Self::InvalidDbParameterGroupStateFault(_))
    }
}
impl std::error::Error for DeleteDBClusterParameterGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DbParameterGroupNotFoundFault(_inner) => Some(_inner),
            Self::InvalidDbParameterGroupStateFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteDBClusterEndpointErrorKind = DeleteDBClusterEndpointError;
/// Error type for the `DeleteDBClusterEndpointError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDBClusterEndpointError {
    /// <p>The specified custom endpoint doesn't exist.</p>
    DbClusterEndpointNotFoundFault(crate::error::DbClusterEndpointNotFoundFault),
    /// <p>The requested operation cannot be performed on the endpoint while the endpoint is in this state.</p>
    InvalidDbClusterEndpointStateFault(crate::error::InvalidDbClusterEndpointStateFault),
    /// <p>The DB cluster is not in a valid state.</p>
    InvalidDbClusterStateFault(crate::error::InvalidDbClusterStateFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteDBClusterEndpointError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteDBClusterEndpointError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DbClusterEndpointNotFoundFault(_inner) => _inner.fmt(f),
            Self::InvalidDbClusterEndpointStateFault(_inner) => _inner.fmt(f),
            Self::InvalidDbClusterStateFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteDBClusterEndpointError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DbClusterEndpointNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDbClusterEndpointStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDbClusterStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteDBClusterEndpointError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteDBClusterEndpointError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteDBClusterEndpointError {
    /// Creates the `DeleteDBClusterEndpointError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteDBClusterEndpointError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DbClusterEndpointNotFoundFault(e) => e.meta(),
            Self::InvalidDbClusterEndpointStateFault(e) => e.meta(),
            Self::InvalidDbClusterStateFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteDBClusterEndpointError::DbClusterEndpointNotFoundFault`.
    pub fn is_db_cluster_endpoint_not_found_fault(&self) -> bool {
        matches!(self, Self::DbClusterEndpointNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `DeleteDBClusterEndpointError::InvalidDbClusterEndpointStateFault`.
    pub fn is_invalid_db_cluster_endpoint_state_fault(&self) -> bool {
        matches!(self, Self::InvalidDbClusterEndpointStateFault(_))
    }
    /// Returns `true` if the error kind is `DeleteDBClusterEndpointError::InvalidDbClusterStateFault`.
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(self, Self::InvalidDbClusterStateFault(_))
    }
}
impl std::error::Error for DeleteDBClusterEndpointError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DbClusterEndpointNotFoundFault(_inner) => Some(_inner),
            Self::InvalidDbClusterEndpointStateFault(_inner) => Some(_inner),
            Self::InvalidDbClusterStateFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteDBClusterErrorKind = DeleteDBClusterError;
/// Error type for the `DeleteDBClusterError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDBClusterError {
    /// <p> <i>DBClusterIdentifier</i> does not refer to an existing DB cluster.</p>
    DbClusterNotFoundFault(crate::error::DbClusterNotFoundFault),
    /// <p>User already has a DB cluster snapshot with the given identifier.</p>
    DbClusterSnapshotAlreadyExistsFault(crate::error::DbClusterSnapshotAlreadyExistsFault),
    /// <p>The supplied value is not a valid DB cluster snapshot state.</p>
    InvalidDbClusterSnapshotStateFault(crate::error::InvalidDbClusterSnapshotStateFault),
    /// <p>The DB cluster is not in a valid state.</p>
    InvalidDbClusterStateFault(crate::error::InvalidDbClusterStateFault),
    /// <p>Request would result in user exceeding the allowed number of DB snapshots.</p>
    SnapshotQuotaExceededFault(crate::error::SnapshotQuotaExceededFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteDBClusterError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteDBClusterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DbClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::DbClusterSnapshotAlreadyExistsFault(_inner) => _inner.fmt(f),
            Self::InvalidDbClusterSnapshotStateFault(_inner) => _inner.fmt(f),
            Self::InvalidDbClusterStateFault(_inner) => _inner.fmt(f),
            Self::SnapshotQuotaExceededFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteDBClusterError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DbClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DbClusterSnapshotAlreadyExistsFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDbClusterSnapshotStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDbClusterStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SnapshotQuotaExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteDBClusterError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteDBClusterError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteDBClusterError {
    /// Creates the `DeleteDBClusterError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteDBClusterError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DbClusterNotFoundFault(e) => e.meta(),
            Self::DbClusterSnapshotAlreadyExistsFault(e) => e.meta(),
            Self::InvalidDbClusterSnapshotStateFault(e) => e.meta(),
            Self::InvalidDbClusterStateFault(e) => e.meta(),
            Self::SnapshotQuotaExceededFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteDBClusterError::DbClusterNotFoundFault`.
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::DbClusterNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `DeleteDBClusterError::DbClusterSnapshotAlreadyExistsFault`.
    pub fn is_db_cluster_snapshot_already_exists_fault(&self) -> bool {
        matches!(self, Self::DbClusterSnapshotAlreadyExistsFault(_))
    }
    /// Returns `true` if the error kind is `DeleteDBClusterError::InvalidDbClusterSnapshotStateFault`.
    pub fn is_invalid_db_cluster_snapshot_state_fault(&self) -> bool {
        matches!(self, Self::InvalidDbClusterSnapshotStateFault(_))
    }
    /// Returns `true` if the error kind is `DeleteDBClusterError::InvalidDbClusterStateFault`.
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(self, Self::InvalidDbClusterStateFault(_))
    }
    /// Returns `true` if the error kind is `DeleteDBClusterError::SnapshotQuotaExceededFault`.
    pub fn is_snapshot_quota_exceeded_fault(&self) -> bool {
        matches!(self, Self::SnapshotQuotaExceededFault(_))
    }
}
impl std::error::Error for DeleteDBClusterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DbClusterNotFoundFault(_inner) => Some(_inner),
            Self::DbClusterSnapshotAlreadyExistsFault(_inner) => Some(_inner),
            Self::InvalidDbClusterSnapshotStateFault(_inner) => Some(_inner),
            Self::InvalidDbClusterStateFault(_inner) => Some(_inner),
            Self::SnapshotQuotaExceededFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>User already has a DB cluster snapshot with the given identifier.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DbClusterSnapshotAlreadyExistsFault {
    /// <p>A message describing the details of the problem.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl DbClusterSnapshotAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`DbClusterSnapshotAlreadyExistsFault`](crate::error::DbClusterSnapshotAlreadyExistsFault).
    pub fn builder() -> crate::error::db_cluster_snapshot_already_exists_fault::Builder {
        crate::error::db_cluster_snapshot_already_exists_fault::Builder::default()
    }
}
/// See [`DbClusterSnapshotAlreadyExistsFault`](crate::error::DbClusterSnapshotAlreadyExistsFault).
pub mod db_cluster_snapshot_already_exists_fault {

    /// A builder for [`DbClusterSnapshotAlreadyExistsFault`](crate::error::DbClusterSnapshotAlreadyExistsFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A message describing the details of the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message describing the details of the problem.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`DbClusterSnapshotAlreadyExistsFault`](crate::error::DbClusterSnapshotAlreadyExistsFault).
        pub fn build(self) -> crate::error::DbClusterSnapshotAlreadyExistsFault {
            crate::error::DbClusterSnapshotAlreadyExistsFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl DbClusterSnapshotAlreadyExistsFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DbClusterSnapshotAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "DbClusterSnapshotAlreadyExistsFault [DBClusterSnapshotAlreadyExistsFault]"
        )?;
        if let Some(inner_55) = &self.message {
            {
                write!(f, ": {}", inner_55)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DbClusterSnapshotAlreadyExistsFault {}
impl aws_http::request_id::RequestId for crate::error::DbClusterSnapshotAlreadyExistsFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for DbClusterSnapshotAlreadyExistsFault
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateGlobalClusterErrorKind = CreateGlobalClusterError;
/// Error type for the `CreateGlobalClusterError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateGlobalClusterError {
    /// <p> <i>DBClusterIdentifier</i> does not refer to an existing DB cluster.</p>
    DbClusterNotFoundFault(crate::error::DbClusterNotFoundFault),
    /// <p>The <code>GlobalClusterIdentifier</code> already exists. Choose a new global database identifier (unique name) to create a new global database cluster.</p>
    GlobalClusterAlreadyExistsFault(crate::error::GlobalClusterAlreadyExistsFault),
    /// <p>The number of global database clusters for this account is already at the maximum allowed.</p>
    GlobalClusterQuotaExceededFault(crate::error::GlobalClusterQuotaExceededFault),
    /// <p>The DB cluster is not in a valid state.</p>
    InvalidDbClusterStateFault(crate::error::InvalidDbClusterStateFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateGlobalClusterError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateGlobalClusterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DbClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::GlobalClusterAlreadyExistsFault(_inner) => _inner.fmt(f),
            Self::GlobalClusterQuotaExceededFault(_inner) => _inner.fmt(f),
            Self::InvalidDbClusterStateFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateGlobalClusterError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DbClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::GlobalClusterAlreadyExistsFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::GlobalClusterQuotaExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDbClusterStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateGlobalClusterError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateGlobalClusterError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateGlobalClusterError {
    /// Creates the `CreateGlobalClusterError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateGlobalClusterError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DbClusterNotFoundFault(e) => e.meta(),
            Self::GlobalClusterAlreadyExistsFault(e) => e.meta(),
            Self::GlobalClusterQuotaExceededFault(e) => e.meta(),
            Self::InvalidDbClusterStateFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateGlobalClusterError::DbClusterNotFoundFault`.
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::DbClusterNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `CreateGlobalClusterError::GlobalClusterAlreadyExistsFault`.
    pub fn is_global_cluster_already_exists_fault(&self) -> bool {
        matches!(self, Self::GlobalClusterAlreadyExistsFault(_))
    }
    /// Returns `true` if the error kind is `CreateGlobalClusterError::GlobalClusterQuotaExceededFault`.
    pub fn is_global_cluster_quota_exceeded_fault(&self) -> bool {
        matches!(self, Self::GlobalClusterQuotaExceededFault(_))
    }
    /// Returns `true` if the error kind is `CreateGlobalClusterError::InvalidDbClusterStateFault`.
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(self, Self::InvalidDbClusterStateFault(_))
    }
}
impl std::error::Error for CreateGlobalClusterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DbClusterNotFoundFault(_inner) => Some(_inner),
            Self::GlobalClusterAlreadyExistsFault(_inner) => Some(_inner),
            Self::GlobalClusterQuotaExceededFault(_inner) => Some(_inner),
            Self::InvalidDbClusterStateFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The number of global database clusters for this account is already at the maximum allowed.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GlobalClusterQuotaExceededFault {
    /// <p>A message describing the details of the problem.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl GlobalClusterQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`GlobalClusterQuotaExceededFault`](crate::error::GlobalClusterQuotaExceededFault).
    pub fn builder() -> crate::error::global_cluster_quota_exceeded_fault::Builder {
        crate::error::global_cluster_quota_exceeded_fault::Builder::default()
    }
}
/// See [`GlobalClusterQuotaExceededFault`](crate::error::GlobalClusterQuotaExceededFault).
pub mod global_cluster_quota_exceeded_fault {

    /// A builder for [`GlobalClusterQuotaExceededFault`](crate::error::GlobalClusterQuotaExceededFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A message describing the details of the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message describing the details of the problem.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`GlobalClusterQuotaExceededFault`](crate::error::GlobalClusterQuotaExceededFault).
        pub fn build(self) -> crate::error::GlobalClusterQuotaExceededFault {
            crate::error::GlobalClusterQuotaExceededFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl GlobalClusterQuotaExceededFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for GlobalClusterQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "GlobalClusterQuotaExceededFault")?;
        if let Some(inner_56) = &self.message {
            {
                write!(f, ": {}", inner_56)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for GlobalClusterQuotaExceededFault {}
impl aws_http::request_id::RequestId for crate::error::GlobalClusterQuotaExceededFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GlobalClusterQuotaExceededFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The <code>GlobalClusterIdentifier</code> already exists. Choose a new global database identifier (unique name) to create a new global database cluster.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GlobalClusterAlreadyExistsFault {
    /// <p>A message describing the details of the problem.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl GlobalClusterAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`GlobalClusterAlreadyExistsFault`](crate::error::GlobalClusterAlreadyExistsFault).
    pub fn builder() -> crate::error::global_cluster_already_exists_fault::Builder {
        crate::error::global_cluster_already_exists_fault::Builder::default()
    }
}
/// See [`GlobalClusterAlreadyExistsFault`](crate::error::GlobalClusterAlreadyExistsFault).
pub mod global_cluster_already_exists_fault {

    /// A builder for [`GlobalClusterAlreadyExistsFault`](crate::error::GlobalClusterAlreadyExistsFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A message describing the details of the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message describing the details of the problem.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`GlobalClusterAlreadyExistsFault`](crate::error::GlobalClusterAlreadyExistsFault).
        pub fn build(self) -> crate::error::GlobalClusterAlreadyExistsFault {
            crate::error::GlobalClusterAlreadyExistsFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl GlobalClusterAlreadyExistsFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for GlobalClusterAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "GlobalClusterAlreadyExistsFault")?;
        if let Some(inner_57) = &self.message {
            {
                write!(f, ": {}", inner_57)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for GlobalClusterAlreadyExistsFault {}
impl aws_http::request_id::RequestId for crate::error::GlobalClusterAlreadyExistsFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GlobalClusterAlreadyExistsFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateEventSubscriptionErrorKind = CreateEventSubscriptionError;
/// Error type for the `CreateEventSubscriptionError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateEventSubscriptionError {
    /// <p>You have exceeded the number of events you can subscribe to.</p>
    EventSubscriptionQuotaExceededFault(crate::error::EventSubscriptionQuotaExceededFault),
    /// <p>The SNS topic is invalid.</p>
    SnsInvalidTopicFault(crate::error::SnsInvalidTopicFault),
    /// <p>There is no SNS authorization.</p>
    SnsNoAuthorizationFault(crate::error::SnsNoAuthorizationFault),
    /// <p>The ARN of the SNS topic could not be found.</p>
    SnsTopicArnNotFoundFault(crate::error::SnsTopicArnNotFoundFault),
    /// <p>The source could not be found.</p>
    SourceNotFoundFault(crate::error::SourceNotFoundFault),
    /// <p>This subscription already exists.</p>
    SubscriptionAlreadyExistFault(crate::error::SubscriptionAlreadyExistFault),
    /// <p>The designated subscription category could not be found.</p>
    SubscriptionCategoryNotFoundFault(crate::error::SubscriptionCategoryNotFoundFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateEventSubscriptionError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateEventSubscriptionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::EventSubscriptionQuotaExceededFault(_inner) => _inner.fmt(f),
            Self::SnsInvalidTopicFault(_inner) => _inner.fmt(f),
            Self::SnsNoAuthorizationFault(_inner) => _inner.fmt(f),
            Self::SnsTopicArnNotFoundFault(_inner) => _inner.fmt(f),
            Self::SourceNotFoundFault(_inner) => _inner.fmt(f),
            Self::SubscriptionAlreadyExistFault(_inner) => _inner.fmt(f),
            Self::SubscriptionCategoryNotFoundFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateEventSubscriptionError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::EventSubscriptionQuotaExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SnsInvalidTopicFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SnsNoAuthorizationFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SnsTopicArnNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SourceNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SubscriptionAlreadyExistFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SubscriptionCategoryNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateEventSubscriptionError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateEventSubscriptionError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateEventSubscriptionError {
    /// Creates the `CreateEventSubscriptionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateEventSubscriptionError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::EventSubscriptionQuotaExceededFault(e) => e.meta(),
            Self::SnsInvalidTopicFault(e) => e.meta(),
            Self::SnsNoAuthorizationFault(e) => e.meta(),
            Self::SnsTopicArnNotFoundFault(e) => e.meta(),
            Self::SourceNotFoundFault(e) => e.meta(),
            Self::SubscriptionAlreadyExistFault(e) => e.meta(),
            Self::SubscriptionCategoryNotFoundFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateEventSubscriptionError::EventSubscriptionQuotaExceededFault`.
    pub fn is_event_subscription_quota_exceeded_fault(&self) -> bool {
        matches!(self, Self::EventSubscriptionQuotaExceededFault(_))
    }
    /// Returns `true` if the error kind is `CreateEventSubscriptionError::SnsInvalidTopicFault`.
    pub fn is_sns_invalid_topic_fault(&self) -> bool {
        matches!(self, Self::SnsInvalidTopicFault(_))
    }
    /// Returns `true` if the error kind is `CreateEventSubscriptionError::SnsNoAuthorizationFault`.
    pub fn is_sns_no_authorization_fault(&self) -> bool {
        matches!(self, Self::SnsNoAuthorizationFault(_))
    }
    /// Returns `true` if the error kind is `CreateEventSubscriptionError::SnsTopicArnNotFoundFault`.
    pub fn is_sns_topic_arn_not_found_fault(&self) -> bool {
        matches!(self, Self::SnsTopicArnNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `CreateEventSubscriptionError::SourceNotFoundFault`.
    pub fn is_source_not_found_fault(&self) -> bool {
        matches!(self, Self::SourceNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `CreateEventSubscriptionError::SubscriptionAlreadyExistFault`.
    pub fn is_subscription_already_exist_fault(&self) -> bool {
        matches!(self, Self::SubscriptionAlreadyExistFault(_))
    }
    /// Returns `true` if the error kind is `CreateEventSubscriptionError::SubscriptionCategoryNotFoundFault`.
    pub fn is_subscription_category_not_found_fault(&self) -> bool {
        matches!(self, Self::SubscriptionCategoryNotFoundFault(_))
    }
}
impl std::error::Error for CreateEventSubscriptionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::EventSubscriptionQuotaExceededFault(_inner) => Some(_inner),
            Self::SnsInvalidTopicFault(_inner) => Some(_inner),
            Self::SnsNoAuthorizationFault(_inner) => Some(_inner),
            Self::SnsTopicArnNotFoundFault(_inner) => Some(_inner),
            Self::SourceNotFoundFault(_inner) => Some(_inner),
            Self::SubscriptionAlreadyExistFault(_inner) => Some(_inner),
            Self::SubscriptionCategoryNotFoundFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>This subscription already exists.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SubscriptionAlreadyExistFault {
    /// <p>A message describing the details of the problem.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl SubscriptionAlreadyExistFault {
    /// Creates a new builder-style object to manufacture [`SubscriptionAlreadyExistFault`](crate::error::SubscriptionAlreadyExistFault).
    pub fn builder() -> crate::error::subscription_already_exist_fault::Builder {
        crate::error::subscription_already_exist_fault::Builder::default()
    }
}
/// See [`SubscriptionAlreadyExistFault`](crate::error::SubscriptionAlreadyExistFault).
pub mod subscription_already_exist_fault {

    /// A builder for [`SubscriptionAlreadyExistFault`](crate::error::SubscriptionAlreadyExistFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A message describing the details of the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message describing the details of the problem.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`SubscriptionAlreadyExistFault`](crate::error::SubscriptionAlreadyExistFault).
        pub fn build(self) -> crate::error::SubscriptionAlreadyExistFault {
            crate::error::SubscriptionAlreadyExistFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl SubscriptionAlreadyExistFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SubscriptionAlreadyExistFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SubscriptionAlreadyExistFault")?;
        if let Some(inner_58) = &self.message {
            {
                write!(f, ": {}", inner_58)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for SubscriptionAlreadyExistFault {}
impl aws_http::request_id::RequestId for crate::error::SubscriptionAlreadyExistFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for SubscriptionAlreadyExistFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateDBSubnetGroupErrorKind = CreateDBSubnetGroupError;
/// Error type for the `CreateDBSubnetGroupError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDBSubnetGroupError {
    /// <p> <i>DBSubnetGroupName</i> is already used by an existing DB subnet group.</p>
    DbSubnetGroupAlreadyExistsFault(crate::error::DbSubnetGroupAlreadyExistsFault),
    /// <p>Subnets in the DB subnet group should cover at least two Availability Zones unless there is only one Availability Zone.</p>
    DbSubnetGroupDoesNotCoverEnoughAZs(crate::error::DbSubnetGroupDoesNotCoverEnoughAZs),
    /// <p>Request would result in user exceeding the allowed number of DB subnet groups.</p>
    DbSubnetGroupQuotaExceededFault(crate::error::DbSubnetGroupQuotaExceededFault),
    /// <p>Request would result in user exceeding the allowed number of subnets in a DB subnet groups.</p>
    DbSubnetQuotaExceededFault(crate::error::DbSubnetQuotaExceededFault),
    /// <p>The requested subnet is invalid, or multiple subnets were requested that are not all in a common VPC.</p>
    InvalidSubnet(crate::error::InvalidSubnet),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateDBSubnetGroupError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateDBSubnetGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DbSubnetGroupAlreadyExistsFault(_inner) => _inner.fmt(f),
            Self::DbSubnetGroupDoesNotCoverEnoughAZs(_inner) => _inner.fmt(f),
            Self::DbSubnetGroupQuotaExceededFault(_inner) => _inner.fmt(f),
            Self::DbSubnetQuotaExceededFault(_inner) => _inner.fmt(f),
            Self::InvalidSubnet(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateDBSubnetGroupError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DbSubnetGroupAlreadyExistsFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DbSubnetGroupDoesNotCoverEnoughAZs(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DbSubnetGroupQuotaExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DbSubnetQuotaExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidSubnet(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateDBSubnetGroupError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateDBSubnetGroupError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDBSubnetGroupError {
    /// Creates the `CreateDBSubnetGroupError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateDBSubnetGroupError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DbSubnetGroupAlreadyExistsFault(e) => e.meta(),
            Self::DbSubnetGroupDoesNotCoverEnoughAZs(e) => e.meta(),
            Self::DbSubnetGroupQuotaExceededFault(e) => e.meta(),
            Self::DbSubnetQuotaExceededFault(e) => e.meta(),
            Self::InvalidSubnet(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateDBSubnetGroupError::DbSubnetGroupAlreadyExistsFault`.
    pub fn is_db_subnet_group_already_exists_fault(&self) -> bool {
        matches!(self, Self::DbSubnetGroupAlreadyExistsFault(_))
    }
    /// Returns `true` if the error kind is `CreateDBSubnetGroupError::DbSubnetGroupDoesNotCoverEnoughAZs`.
    pub fn is_db_subnet_group_does_not_cover_enough_a_zs(&self) -> bool {
        matches!(self, Self::DbSubnetGroupDoesNotCoverEnoughAZs(_))
    }
    /// Returns `true` if the error kind is `CreateDBSubnetGroupError::DbSubnetGroupQuotaExceededFault`.
    pub fn is_db_subnet_group_quota_exceeded_fault(&self) -> bool {
        matches!(self, Self::DbSubnetGroupQuotaExceededFault(_))
    }
    /// Returns `true` if the error kind is `CreateDBSubnetGroupError::DbSubnetQuotaExceededFault`.
    pub fn is_db_subnet_quota_exceeded_fault(&self) -> bool {
        matches!(self, Self::DbSubnetQuotaExceededFault(_))
    }
    /// Returns `true` if the error kind is `CreateDBSubnetGroupError::InvalidSubnet`.
    pub fn is_invalid_subnet(&self) -> bool {
        matches!(self, Self::InvalidSubnet(_))
    }
}
impl std::error::Error for CreateDBSubnetGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DbSubnetGroupAlreadyExistsFault(_inner) => Some(_inner),
            Self::DbSubnetGroupDoesNotCoverEnoughAZs(_inner) => Some(_inner),
            Self::DbSubnetGroupQuotaExceededFault(_inner) => Some(_inner),
            Self::DbSubnetQuotaExceededFault(_inner) => Some(_inner),
            Self::InvalidSubnet(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>Request would result in user exceeding the allowed number of DB subnet groups.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DbSubnetGroupQuotaExceededFault {
    /// <p>A message describing the details of the problem.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl DbSubnetGroupQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`DbSubnetGroupQuotaExceededFault`](crate::error::DbSubnetGroupQuotaExceededFault).
    pub fn builder() -> crate::error::db_subnet_group_quota_exceeded_fault::Builder {
        crate::error::db_subnet_group_quota_exceeded_fault::Builder::default()
    }
}
/// See [`DbSubnetGroupQuotaExceededFault`](crate::error::DbSubnetGroupQuotaExceededFault).
pub mod db_subnet_group_quota_exceeded_fault {

    /// A builder for [`DbSubnetGroupQuotaExceededFault`](crate::error::DbSubnetGroupQuotaExceededFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A message describing the details of the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message describing the details of the problem.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`DbSubnetGroupQuotaExceededFault`](crate::error::DbSubnetGroupQuotaExceededFault).
        pub fn build(self) -> crate::error::DbSubnetGroupQuotaExceededFault {
            crate::error::DbSubnetGroupQuotaExceededFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl DbSubnetGroupQuotaExceededFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DbSubnetGroupQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "DbSubnetGroupQuotaExceededFault [DBSubnetGroupQuotaExceededFault]"
        )?;
        if let Some(inner_59) = &self.message {
            {
                write!(f, ": {}", inner_59)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DbSubnetGroupQuotaExceededFault {}
impl aws_http::request_id::RequestId for crate::error::DbSubnetGroupQuotaExceededFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DbSubnetGroupQuotaExceededFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p> <i>DBSubnetGroupName</i> is already used by an existing DB subnet group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DbSubnetGroupAlreadyExistsFault {
    /// <p>A message describing the details of the problem.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl DbSubnetGroupAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`DbSubnetGroupAlreadyExistsFault`](crate::error::DbSubnetGroupAlreadyExistsFault).
    pub fn builder() -> crate::error::db_subnet_group_already_exists_fault::Builder {
        crate::error::db_subnet_group_already_exists_fault::Builder::default()
    }
}
/// See [`DbSubnetGroupAlreadyExistsFault`](crate::error::DbSubnetGroupAlreadyExistsFault).
pub mod db_subnet_group_already_exists_fault {

    /// A builder for [`DbSubnetGroupAlreadyExistsFault`](crate::error::DbSubnetGroupAlreadyExistsFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A message describing the details of the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message describing the details of the problem.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`DbSubnetGroupAlreadyExistsFault`](crate::error::DbSubnetGroupAlreadyExistsFault).
        pub fn build(self) -> crate::error::DbSubnetGroupAlreadyExistsFault {
            crate::error::DbSubnetGroupAlreadyExistsFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl DbSubnetGroupAlreadyExistsFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DbSubnetGroupAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "DbSubnetGroupAlreadyExistsFault [DBSubnetGroupAlreadyExistsFault]"
        )?;
        if let Some(inner_60) = &self.message {
            {
                write!(f, ": {}", inner_60)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DbSubnetGroupAlreadyExistsFault {}
impl aws_http::request_id::RequestId for crate::error::DbSubnetGroupAlreadyExistsFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DbSubnetGroupAlreadyExistsFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateDBParameterGroupErrorKind = CreateDBParameterGroupError;
/// Error type for the `CreateDBParameterGroupError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDBParameterGroupError {
    /// <p>A DB parameter group with the same name exists.</p>
    DbParameterGroupAlreadyExistsFault(crate::error::DbParameterGroupAlreadyExistsFault),
    /// <p>Request would result in user exceeding the allowed number of DB parameter groups.</p>
    DbParameterGroupQuotaExceededFault(crate::error::DbParameterGroupQuotaExceededFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateDBParameterGroupError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateDBParameterGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DbParameterGroupAlreadyExistsFault(_inner) => _inner.fmt(f),
            Self::DbParameterGroupQuotaExceededFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateDBParameterGroupError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DbParameterGroupAlreadyExistsFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DbParameterGroupQuotaExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateDBParameterGroupError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateDBParameterGroupError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDBParameterGroupError {
    /// Creates the `CreateDBParameterGroupError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateDBParameterGroupError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DbParameterGroupAlreadyExistsFault(e) => e.meta(),
            Self::DbParameterGroupQuotaExceededFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateDBParameterGroupError::DbParameterGroupAlreadyExistsFault`.
    pub fn is_db_parameter_group_already_exists_fault(&self) -> bool {
        matches!(self, Self::DbParameterGroupAlreadyExistsFault(_))
    }
    /// Returns `true` if the error kind is `CreateDBParameterGroupError::DbParameterGroupQuotaExceededFault`.
    pub fn is_db_parameter_group_quota_exceeded_fault(&self) -> bool {
        matches!(self, Self::DbParameterGroupQuotaExceededFault(_))
    }
}
impl std::error::Error for CreateDBParameterGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DbParameterGroupAlreadyExistsFault(_inner) => Some(_inner),
            Self::DbParameterGroupQuotaExceededFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>Request would result in user exceeding the allowed number of DB parameter groups.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DbParameterGroupQuotaExceededFault {
    /// <p>A message describing the details of the problem.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl DbParameterGroupQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`DbParameterGroupQuotaExceededFault`](crate::error::DbParameterGroupQuotaExceededFault).
    pub fn builder() -> crate::error::db_parameter_group_quota_exceeded_fault::Builder {
        crate::error::db_parameter_group_quota_exceeded_fault::Builder::default()
    }
}
/// See [`DbParameterGroupQuotaExceededFault`](crate::error::DbParameterGroupQuotaExceededFault).
pub mod db_parameter_group_quota_exceeded_fault {

    /// A builder for [`DbParameterGroupQuotaExceededFault`](crate::error::DbParameterGroupQuotaExceededFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A message describing the details of the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message describing the details of the problem.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`DbParameterGroupQuotaExceededFault`](crate::error::DbParameterGroupQuotaExceededFault).
        pub fn build(self) -> crate::error::DbParameterGroupQuotaExceededFault {
            crate::error::DbParameterGroupQuotaExceededFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl DbParameterGroupQuotaExceededFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DbParameterGroupQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "DbParameterGroupQuotaExceededFault [DBParameterGroupQuotaExceededFault]"
        )?;
        if let Some(inner_61) = &self.message {
            {
                write!(f, ": {}", inner_61)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DbParameterGroupQuotaExceededFault {}
impl aws_http::request_id::RequestId for crate::error::DbParameterGroupQuotaExceededFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for DbParameterGroupQuotaExceededFault
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>A DB parameter group with the same name exists.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DbParameterGroupAlreadyExistsFault {
    /// <p>A message describing the details of the problem.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl DbParameterGroupAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`DbParameterGroupAlreadyExistsFault`](crate::error::DbParameterGroupAlreadyExistsFault).
    pub fn builder() -> crate::error::db_parameter_group_already_exists_fault::Builder {
        crate::error::db_parameter_group_already_exists_fault::Builder::default()
    }
}
/// See [`DbParameterGroupAlreadyExistsFault`](crate::error::DbParameterGroupAlreadyExistsFault).
pub mod db_parameter_group_already_exists_fault {

    /// A builder for [`DbParameterGroupAlreadyExistsFault`](crate::error::DbParameterGroupAlreadyExistsFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A message describing the details of the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message describing the details of the problem.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`DbParameterGroupAlreadyExistsFault`](crate::error::DbParameterGroupAlreadyExistsFault).
        pub fn build(self) -> crate::error::DbParameterGroupAlreadyExistsFault {
            crate::error::DbParameterGroupAlreadyExistsFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl DbParameterGroupAlreadyExistsFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DbParameterGroupAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "DbParameterGroupAlreadyExistsFault [DBParameterGroupAlreadyExistsFault]"
        )?;
        if let Some(inner_62) = &self.message {
            {
                write!(f, ": {}", inner_62)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DbParameterGroupAlreadyExistsFault {}
impl aws_http::request_id::RequestId for crate::error::DbParameterGroupAlreadyExistsFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for DbParameterGroupAlreadyExistsFault
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateDBInstanceErrorKind = CreateDBInstanceError;
/// Error type for the `CreateDBInstanceError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDBInstanceError {
    /// <p>Specified CIDRIP or EC2 security group is not authorized for the specified DB security group.</p>
    /// <p>Neptune may not also be authorized via IAM to perform necessary actions on your behalf.</p>
    AuthorizationNotFoundFault(crate::error::AuthorizationNotFoundFault),
    /// <p> <i>DBClusterIdentifier</i> does not refer to an existing DB cluster.</p>
    DbClusterNotFoundFault(crate::error::DbClusterNotFoundFault),
    /// <p>User already has a DB instance with the given identifier.</p>
    DbInstanceAlreadyExistsFault(crate::error::DbInstanceAlreadyExistsFault),
    /// <p> <i>DBParameterGroupName</i> does not refer to an existing DB parameter group.</p>
    DbParameterGroupNotFoundFault(crate::error::DbParameterGroupNotFoundFault),
    /// <p> <i>DBSecurityGroupName</i> does not refer to an existing DB security group.</p>
    DbSecurityGroupNotFoundFault(crate::error::DbSecurityGroupNotFoundFault),
    /// <p>Subnets in the DB subnet group should cover at least two Availability Zones unless there is only one Availability Zone.</p>
    DbSubnetGroupDoesNotCoverEnoughAZs(crate::error::DbSubnetGroupDoesNotCoverEnoughAZs),
    /// <p> <i>DBSubnetGroupName</i> does not refer to an existing DB subnet group.</p>
    DbSubnetGroupNotFoundFault(crate::error::DbSubnetGroupNotFoundFault),
    /// <p> <i>Domain</i> does not refer to an existing Active Directory Domain.</p>
    DomainNotFoundFault(crate::error::DomainNotFoundFault),
    /// <p>Request would result in user exceeding the allowed number of DB instances.</p>
    InstanceQuotaExceededFault(crate::error::InstanceQuotaExceededFault),
    /// <p>Specified DB instance class is not available in the specified Availability Zone.</p>
    InsufficientDbInstanceCapacityFault(crate::error::InsufficientDbInstanceCapacityFault),
    /// <p>The DB cluster is not in a valid state.</p>
    InvalidDbClusterStateFault(crate::error::InvalidDbClusterStateFault),
    /// <p>The requested subnet is invalid, or multiple subnets were requested that are not all in a common VPC.</p>
    InvalidSubnet(crate::error::InvalidSubnet),
    /// <p>DB subnet group does not cover all Availability Zones after it is created because users' change.</p>
    InvalidVpcNetworkStateFault(crate::error::InvalidVpcNetworkStateFault),
    /// <p>Error accessing KMS key.</p>
    KmsKeyNotAccessibleFault(crate::error::KmsKeyNotAccessibleFault),
    /// <p>The designated option group could not be found.</p>
    OptionGroupNotFoundFault(crate::error::OptionGroupNotFoundFault),
    /// <p>Provisioned IOPS not available in the specified Availability Zone.</p>
    ProvisionedIopsNotAvailableInAzFault(crate::error::ProvisionedIopsNotAvailableInAzFault),
    /// <p>Request would result in user exceeding the allowed amount of storage available across all DB instances.</p>
    StorageQuotaExceededFault(crate::error::StorageQuotaExceededFault),
    /// <p> <i>StorageType</i> specified cannot be associated with the DB Instance.</p>
    StorageTypeNotSupportedFault(crate::error::StorageTypeNotSupportedFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateDBInstanceError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateDBInstanceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AuthorizationNotFoundFault(_inner) => _inner.fmt(f),
            Self::DbClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::DbInstanceAlreadyExistsFault(_inner) => _inner.fmt(f),
            Self::DbParameterGroupNotFoundFault(_inner) => _inner.fmt(f),
            Self::DbSecurityGroupNotFoundFault(_inner) => _inner.fmt(f),
            Self::DbSubnetGroupDoesNotCoverEnoughAZs(_inner) => _inner.fmt(f),
            Self::DbSubnetGroupNotFoundFault(_inner) => _inner.fmt(f),
            Self::DomainNotFoundFault(_inner) => _inner.fmt(f),
            Self::InstanceQuotaExceededFault(_inner) => _inner.fmt(f),
            Self::InsufficientDbInstanceCapacityFault(_inner) => _inner.fmt(f),
            Self::InvalidDbClusterStateFault(_inner) => _inner.fmt(f),
            Self::InvalidSubnet(_inner) => _inner.fmt(f),
            Self::InvalidVpcNetworkStateFault(_inner) => _inner.fmt(f),
            Self::KmsKeyNotAccessibleFault(_inner) => _inner.fmt(f),
            Self::OptionGroupNotFoundFault(_inner) => _inner.fmt(f),
            Self::ProvisionedIopsNotAvailableInAzFault(_inner) => _inner.fmt(f),
            Self::StorageQuotaExceededFault(_inner) => _inner.fmt(f),
            Self::StorageTypeNotSupportedFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateDBInstanceError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AuthorizationNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DbClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DbInstanceAlreadyExistsFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DbParameterGroupNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DbSecurityGroupNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DbSubnetGroupDoesNotCoverEnoughAZs(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DbSubnetGroupNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DomainNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InstanceQuotaExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InsufficientDbInstanceCapacityFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDbClusterStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidSubnet(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidVpcNetworkStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::KmsKeyNotAccessibleFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::OptionGroupNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ProvisionedIopsNotAvailableInAzFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::StorageQuotaExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::StorageTypeNotSupportedFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateDBInstanceError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateDBInstanceError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDBInstanceError {
    /// Creates the `CreateDBInstanceError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateDBInstanceError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AuthorizationNotFoundFault(e) => e.meta(),
            Self::DbClusterNotFoundFault(e) => e.meta(),
            Self::DbInstanceAlreadyExistsFault(e) => e.meta(),
            Self::DbParameterGroupNotFoundFault(e) => e.meta(),
            Self::DbSecurityGroupNotFoundFault(e) => e.meta(),
            Self::DbSubnetGroupDoesNotCoverEnoughAZs(e) => e.meta(),
            Self::DbSubnetGroupNotFoundFault(e) => e.meta(),
            Self::DomainNotFoundFault(e) => e.meta(),
            Self::InstanceQuotaExceededFault(e) => e.meta(),
            Self::InsufficientDbInstanceCapacityFault(e) => e.meta(),
            Self::InvalidDbClusterStateFault(e) => e.meta(),
            Self::InvalidSubnet(e) => e.meta(),
            Self::InvalidVpcNetworkStateFault(e) => e.meta(),
            Self::KmsKeyNotAccessibleFault(e) => e.meta(),
            Self::OptionGroupNotFoundFault(e) => e.meta(),
            Self::ProvisionedIopsNotAvailableInAzFault(e) => e.meta(),
            Self::StorageQuotaExceededFault(e) => e.meta(),
            Self::StorageTypeNotSupportedFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateDBInstanceError::AuthorizationNotFoundFault`.
    pub fn is_authorization_not_found_fault(&self) -> bool {
        matches!(self, Self::AuthorizationNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `CreateDBInstanceError::DbClusterNotFoundFault`.
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::DbClusterNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `CreateDBInstanceError::DbInstanceAlreadyExistsFault`.
    pub fn is_db_instance_already_exists_fault(&self) -> bool {
        matches!(self, Self::DbInstanceAlreadyExistsFault(_))
    }
    /// Returns `true` if the error kind is `CreateDBInstanceError::DbParameterGroupNotFoundFault`.
    pub fn is_db_parameter_group_not_found_fault(&self) -> bool {
        matches!(self, Self::DbParameterGroupNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `CreateDBInstanceError::DbSecurityGroupNotFoundFault`.
    pub fn is_db_security_group_not_found_fault(&self) -> bool {
        matches!(self, Self::DbSecurityGroupNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `CreateDBInstanceError::DbSubnetGroupDoesNotCoverEnoughAZs`.
    pub fn is_db_subnet_group_does_not_cover_enough_a_zs(&self) -> bool {
        matches!(self, Self::DbSubnetGroupDoesNotCoverEnoughAZs(_))
    }
    /// Returns `true` if the error kind is `CreateDBInstanceError::DbSubnetGroupNotFoundFault`.
    pub fn is_db_subnet_group_not_found_fault(&self) -> bool {
        matches!(self, Self::DbSubnetGroupNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `CreateDBInstanceError::DomainNotFoundFault`.
    pub fn is_domain_not_found_fault(&self) -> bool {
        matches!(self, Self::DomainNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `CreateDBInstanceError::InstanceQuotaExceededFault`.
    pub fn is_instance_quota_exceeded_fault(&self) -> bool {
        matches!(self, Self::InstanceQuotaExceededFault(_))
    }
    /// Returns `true` if the error kind is `CreateDBInstanceError::InsufficientDbInstanceCapacityFault`.
    pub fn is_insufficient_db_instance_capacity_fault(&self) -> bool {
        matches!(self, Self::InsufficientDbInstanceCapacityFault(_))
    }
    /// Returns `true` if the error kind is `CreateDBInstanceError::InvalidDbClusterStateFault`.
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(self, Self::InvalidDbClusterStateFault(_))
    }
    /// Returns `true` if the error kind is `CreateDBInstanceError::InvalidSubnet`.
    pub fn is_invalid_subnet(&self) -> bool {
        matches!(self, Self::InvalidSubnet(_))
    }
    /// Returns `true` if the error kind is `CreateDBInstanceError::InvalidVpcNetworkStateFault`.
    pub fn is_invalid_vpc_network_state_fault(&self) -> bool {
        matches!(self, Self::InvalidVpcNetworkStateFault(_))
    }
    /// Returns `true` if the error kind is `CreateDBInstanceError::KmsKeyNotAccessibleFault`.
    pub fn is_kms_key_not_accessible_fault(&self) -> bool {
        matches!(self, Self::KmsKeyNotAccessibleFault(_))
    }
    /// Returns `true` if the error kind is `CreateDBInstanceError::OptionGroupNotFoundFault`.
    pub fn is_option_group_not_found_fault(&self) -> bool {
        matches!(self, Self::OptionGroupNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `CreateDBInstanceError::ProvisionedIopsNotAvailableInAzFault`.
    pub fn is_provisioned_iops_not_available_in_az_fault(&self) -> bool {
        matches!(self, Self::ProvisionedIopsNotAvailableInAzFault(_))
    }
    /// Returns `true` if the error kind is `CreateDBInstanceError::StorageQuotaExceededFault`.
    pub fn is_storage_quota_exceeded_fault(&self) -> bool {
        matches!(self, Self::StorageQuotaExceededFault(_))
    }
    /// Returns `true` if the error kind is `CreateDBInstanceError::StorageTypeNotSupportedFault`.
    pub fn is_storage_type_not_supported_fault(&self) -> bool {
        matches!(self, Self::StorageTypeNotSupportedFault(_))
    }
}
impl std::error::Error for CreateDBInstanceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AuthorizationNotFoundFault(_inner) => Some(_inner),
            Self::DbClusterNotFoundFault(_inner) => Some(_inner),
            Self::DbInstanceAlreadyExistsFault(_inner) => Some(_inner),
            Self::DbParameterGroupNotFoundFault(_inner) => Some(_inner),
            Self::DbSecurityGroupNotFoundFault(_inner) => Some(_inner),
            Self::DbSubnetGroupDoesNotCoverEnoughAZs(_inner) => Some(_inner),
            Self::DbSubnetGroupNotFoundFault(_inner) => Some(_inner),
            Self::DomainNotFoundFault(_inner) => Some(_inner),
            Self::InstanceQuotaExceededFault(_inner) => Some(_inner),
            Self::InsufficientDbInstanceCapacityFault(_inner) => Some(_inner),
            Self::InvalidDbClusterStateFault(_inner) => Some(_inner),
            Self::InvalidSubnet(_inner) => Some(_inner),
            Self::InvalidVpcNetworkStateFault(_inner) => Some(_inner),
            Self::KmsKeyNotAccessibleFault(_inner) => Some(_inner),
            Self::OptionGroupNotFoundFault(_inner) => Some(_inner),
            Self::ProvisionedIopsNotAvailableInAzFault(_inner) => Some(_inner),
            Self::StorageQuotaExceededFault(_inner) => Some(_inner),
            Self::StorageTypeNotSupportedFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>Request would result in user exceeding the allowed number of DB instances.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InstanceQuotaExceededFault {
    /// <p>A message describing the details of the problem.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InstanceQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`InstanceQuotaExceededFault`](crate::error::InstanceQuotaExceededFault).
    pub fn builder() -> crate::error::instance_quota_exceeded_fault::Builder {
        crate::error::instance_quota_exceeded_fault::Builder::default()
    }
}
/// See [`InstanceQuotaExceededFault`](crate::error::InstanceQuotaExceededFault).
pub mod instance_quota_exceeded_fault {

    /// A builder for [`InstanceQuotaExceededFault`](crate::error::InstanceQuotaExceededFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A message describing the details of the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message describing the details of the problem.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InstanceQuotaExceededFault`](crate::error::InstanceQuotaExceededFault).
        pub fn build(self) -> crate::error::InstanceQuotaExceededFault {
            crate::error::InstanceQuotaExceededFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InstanceQuotaExceededFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InstanceQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InstanceQuotaExceededFault")?;
        if let Some(inner_63) = &self.message {
            {
                write!(f, ": {}", inner_63)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InstanceQuotaExceededFault {}
impl aws_http::request_id::RequestId for crate::error::InstanceQuotaExceededFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InstanceQuotaExceededFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateDBClusterSnapshotErrorKind = CreateDBClusterSnapshotError;
/// Error type for the `CreateDBClusterSnapshotError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDBClusterSnapshotError {
    /// <p> <i>DBClusterIdentifier</i> does not refer to an existing DB cluster.</p>
    DbClusterNotFoundFault(crate::error::DbClusterNotFoundFault),
    /// <p>User already has a DB cluster snapshot with the given identifier.</p>
    DbClusterSnapshotAlreadyExistsFault(crate::error::DbClusterSnapshotAlreadyExistsFault),
    /// <p>The supplied value is not a valid DB cluster snapshot state.</p>
    InvalidDbClusterSnapshotStateFault(crate::error::InvalidDbClusterSnapshotStateFault),
    /// <p>The DB cluster is not in a valid state.</p>
    InvalidDbClusterStateFault(crate::error::InvalidDbClusterStateFault),
    /// <p>Request would result in user exceeding the allowed number of DB snapshots.</p>
    SnapshotQuotaExceededFault(crate::error::SnapshotQuotaExceededFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateDBClusterSnapshotError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateDBClusterSnapshotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DbClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::DbClusterSnapshotAlreadyExistsFault(_inner) => _inner.fmt(f),
            Self::InvalidDbClusterSnapshotStateFault(_inner) => _inner.fmt(f),
            Self::InvalidDbClusterStateFault(_inner) => _inner.fmt(f),
            Self::SnapshotQuotaExceededFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateDBClusterSnapshotError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DbClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DbClusterSnapshotAlreadyExistsFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDbClusterSnapshotStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDbClusterStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SnapshotQuotaExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateDBClusterSnapshotError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateDBClusterSnapshotError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDBClusterSnapshotError {
    /// Creates the `CreateDBClusterSnapshotError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateDBClusterSnapshotError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DbClusterNotFoundFault(e) => e.meta(),
            Self::DbClusterSnapshotAlreadyExistsFault(e) => e.meta(),
            Self::InvalidDbClusterSnapshotStateFault(e) => e.meta(),
            Self::InvalidDbClusterStateFault(e) => e.meta(),
            Self::SnapshotQuotaExceededFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateDBClusterSnapshotError::DbClusterNotFoundFault`.
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::DbClusterNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `CreateDBClusterSnapshotError::DbClusterSnapshotAlreadyExistsFault`.
    pub fn is_db_cluster_snapshot_already_exists_fault(&self) -> bool {
        matches!(self, Self::DbClusterSnapshotAlreadyExistsFault(_))
    }
    /// Returns `true` if the error kind is `CreateDBClusterSnapshotError::InvalidDbClusterSnapshotStateFault`.
    pub fn is_invalid_db_cluster_snapshot_state_fault(&self) -> bool {
        matches!(self, Self::InvalidDbClusterSnapshotStateFault(_))
    }
    /// Returns `true` if the error kind is `CreateDBClusterSnapshotError::InvalidDbClusterStateFault`.
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(self, Self::InvalidDbClusterStateFault(_))
    }
    /// Returns `true` if the error kind is `CreateDBClusterSnapshotError::SnapshotQuotaExceededFault`.
    pub fn is_snapshot_quota_exceeded_fault(&self) -> bool {
        matches!(self, Self::SnapshotQuotaExceededFault(_))
    }
}
impl std::error::Error for CreateDBClusterSnapshotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DbClusterNotFoundFault(_inner) => Some(_inner),
            Self::DbClusterSnapshotAlreadyExistsFault(_inner) => Some(_inner),
            Self::InvalidDbClusterSnapshotStateFault(_inner) => Some(_inner),
            Self::InvalidDbClusterStateFault(_inner) => Some(_inner),
            Self::SnapshotQuotaExceededFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateDBClusterParameterGroupErrorKind = CreateDBClusterParameterGroupError;
/// Error type for the `CreateDBClusterParameterGroupError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDBClusterParameterGroupError {
    /// <p>A DB parameter group with the same name exists.</p>
    DbParameterGroupAlreadyExistsFault(crate::error::DbParameterGroupAlreadyExistsFault),
    /// <p>Request would result in user exceeding the allowed number of DB parameter groups.</p>
    DbParameterGroupQuotaExceededFault(crate::error::DbParameterGroupQuotaExceededFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateDBClusterParameterGroupError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateDBClusterParameterGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DbParameterGroupAlreadyExistsFault(_inner) => _inner.fmt(f),
            Self::DbParameterGroupQuotaExceededFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for CreateDBClusterParameterGroupError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DbParameterGroupAlreadyExistsFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DbParameterGroupQuotaExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateDBClusterParameterGroupError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateDBClusterParameterGroupError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDBClusterParameterGroupError {
    /// Creates the `CreateDBClusterParameterGroupError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateDBClusterParameterGroupError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DbParameterGroupAlreadyExistsFault(e) => e.meta(),
            Self::DbParameterGroupQuotaExceededFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateDBClusterParameterGroupError::DbParameterGroupAlreadyExistsFault`.
    pub fn is_db_parameter_group_already_exists_fault(&self) -> bool {
        matches!(self, Self::DbParameterGroupAlreadyExistsFault(_))
    }
    /// Returns `true` if the error kind is `CreateDBClusterParameterGroupError::DbParameterGroupQuotaExceededFault`.
    pub fn is_db_parameter_group_quota_exceeded_fault(&self) -> bool {
        matches!(self, Self::DbParameterGroupQuotaExceededFault(_))
    }
}
impl std::error::Error for CreateDBClusterParameterGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DbParameterGroupAlreadyExistsFault(_inner) => Some(_inner),
            Self::DbParameterGroupQuotaExceededFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateDBClusterEndpointErrorKind = CreateDBClusterEndpointError;
/// Error type for the `CreateDBClusterEndpointError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDBClusterEndpointError {
    /// <p>The specified custom endpoint cannot be created because it already exists.</p>
    DbClusterEndpointAlreadyExistsFault(crate::error::DbClusterEndpointAlreadyExistsFault),
    /// <p>The cluster already has the maximum number of custom endpoints.</p>
    DbClusterEndpointQuotaExceededFault(crate::error::DbClusterEndpointQuotaExceededFault),
    /// <p> <i>DBClusterIdentifier</i> does not refer to an existing DB cluster.</p>
    DbClusterNotFoundFault(crate::error::DbClusterNotFoundFault),
    /// <p> <i>DBInstanceIdentifier</i> does not refer to an existing DB instance.</p>
    DbInstanceNotFoundFault(crate::error::DbInstanceNotFoundFault),
    /// <p>The DB cluster is not in a valid state.</p>
    InvalidDbClusterStateFault(crate::error::InvalidDbClusterStateFault),
    /// <p>The specified DB instance is not in the <i>available</i> state.</p>
    InvalidDbInstanceStateFault(crate::error::InvalidDbInstanceStateFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateDBClusterEndpointError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateDBClusterEndpointError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DbClusterEndpointAlreadyExistsFault(_inner) => _inner.fmt(f),
            Self::DbClusterEndpointQuotaExceededFault(_inner) => _inner.fmt(f),
            Self::DbClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::DbInstanceNotFoundFault(_inner) => _inner.fmt(f),
            Self::InvalidDbClusterStateFault(_inner) => _inner.fmt(f),
            Self::InvalidDbInstanceStateFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateDBClusterEndpointError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DbClusterEndpointAlreadyExistsFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DbClusterEndpointQuotaExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DbClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DbInstanceNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDbClusterStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDbInstanceStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateDBClusterEndpointError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateDBClusterEndpointError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDBClusterEndpointError {
    /// Creates the `CreateDBClusterEndpointError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateDBClusterEndpointError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DbClusterEndpointAlreadyExistsFault(e) => e.meta(),
            Self::DbClusterEndpointQuotaExceededFault(e) => e.meta(),
            Self::DbClusterNotFoundFault(e) => e.meta(),
            Self::DbInstanceNotFoundFault(e) => e.meta(),
            Self::InvalidDbClusterStateFault(e) => e.meta(),
            Self::InvalidDbInstanceStateFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateDBClusterEndpointError::DbClusterEndpointAlreadyExistsFault`.
    pub fn is_db_cluster_endpoint_already_exists_fault(&self) -> bool {
        matches!(self, Self::DbClusterEndpointAlreadyExistsFault(_))
    }
    /// Returns `true` if the error kind is `CreateDBClusterEndpointError::DbClusterEndpointQuotaExceededFault`.
    pub fn is_db_cluster_endpoint_quota_exceeded_fault(&self) -> bool {
        matches!(self, Self::DbClusterEndpointQuotaExceededFault(_))
    }
    /// Returns `true` if the error kind is `CreateDBClusterEndpointError::DbClusterNotFoundFault`.
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::DbClusterNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `CreateDBClusterEndpointError::DbInstanceNotFoundFault`.
    pub fn is_db_instance_not_found_fault(&self) -> bool {
        matches!(self, Self::DbInstanceNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `CreateDBClusterEndpointError::InvalidDbClusterStateFault`.
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(self, Self::InvalidDbClusterStateFault(_))
    }
    /// Returns `true` if the error kind is `CreateDBClusterEndpointError::InvalidDbInstanceStateFault`.
    pub fn is_invalid_db_instance_state_fault(&self) -> bool {
        matches!(self, Self::InvalidDbInstanceStateFault(_))
    }
}
impl std::error::Error for CreateDBClusterEndpointError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DbClusterEndpointAlreadyExistsFault(_inner) => Some(_inner),
            Self::DbClusterEndpointQuotaExceededFault(_inner) => Some(_inner),
            Self::DbClusterNotFoundFault(_inner) => Some(_inner),
            Self::DbInstanceNotFoundFault(_inner) => Some(_inner),
            Self::InvalidDbClusterStateFault(_inner) => Some(_inner),
            Self::InvalidDbInstanceStateFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The cluster already has the maximum number of custom endpoints.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DbClusterEndpointQuotaExceededFault {
    /// <p>A message describing the details of the problem.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl DbClusterEndpointQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`DbClusterEndpointQuotaExceededFault`](crate::error::DbClusterEndpointQuotaExceededFault).
    pub fn builder() -> crate::error::db_cluster_endpoint_quota_exceeded_fault::Builder {
        crate::error::db_cluster_endpoint_quota_exceeded_fault::Builder::default()
    }
}
/// See [`DbClusterEndpointQuotaExceededFault`](crate::error::DbClusterEndpointQuotaExceededFault).
pub mod db_cluster_endpoint_quota_exceeded_fault {

    /// A builder for [`DbClusterEndpointQuotaExceededFault`](crate::error::DbClusterEndpointQuotaExceededFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A message describing the details of the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message describing the details of the problem.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`DbClusterEndpointQuotaExceededFault`](crate::error::DbClusterEndpointQuotaExceededFault).
        pub fn build(self) -> crate::error::DbClusterEndpointQuotaExceededFault {
            crate::error::DbClusterEndpointQuotaExceededFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl DbClusterEndpointQuotaExceededFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DbClusterEndpointQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "DbClusterEndpointQuotaExceededFault [DBClusterEndpointQuotaExceededFault]"
        )?;
        if let Some(inner_64) = &self.message {
            {
                write!(f, ": {}", inner_64)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DbClusterEndpointQuotaExceededFault {}
impl aws_http::request_id::RequestId for crate::error::DbClusterEndpointQuotaExceededFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for DbClusterEndpointQuotaExceededFault
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The specified custom endpoint cannot be created because it already exists.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DbClusterEndpointAlreadyExistsFault {
    /// <p>A message describing the details of the problem.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl DbClusterEndpointAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`DbClusterEndpointAlreadyExistsFault`](crate::error::DbClusterEndpointAlreadyExistsFault).
    pub fn builder() -> crate::error::db_cluster_endpoint_already_exists_fault::Builder {
        crate::error::db_cluster_endpoint_already_exists_fault::Builder::default()
    }
}
/// See [`DbClusterEndpointAlreadyExistsFault`](crate::error::DbClusterEndpointAlreadyExistsFault).
pub mod db_cluster_endpoint_already_exists_fault {

    /// A builder for [`DbClusterEndpointAlreadyExistsFault`](crate::error::DbClusterEndpointAlreadyExistsFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A message describing the details of the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message describing the details of the problem.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`DbClusterEndpointAlreadyExistsFault`](crate::error::DbClusterEndpointAlreadyExistsFault).
        pub fn build(self) -> crate::error::DbClusterEndpointAlreadyExistsFault {
            crate::error::DbClusterEndpointAlreadyExistsFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl DbClusterEndpointAlreadyExistsFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DbClusterEndpointAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "DbClusterEndpointAlreadyExistsFault [DBClusterEndpointAlreadyExistsFault]"
        )?;
        if let Some(inner_65) = &self.message {
            {
                write!(f, ": {}", inner_65)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DbClusterEndpointAlreadyExistsFault {}
impl aws_http::request_id::RequestId for crate::error::DbClusterEndpointAlreadyExistsFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for DbClusterEndpointAlreadyExistsFault
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateDBClusterErrorKind = CreateDBClusterError;
/// Error type for the `CreateDBClusterError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDBClusterError {
    /// <p>User already has a DB cluster with the given identifier.</p>
    DbClusterAlreadyExistsFault(crate::error::DbClusterAlreadyExistsFault),
    /// <p> <i>DBClusterIdentifier</i> does not refer to an existing DB cluster.</p>
    DbClusterNotFoundFault(crate::error::DbClusterNotFoundFault),
    /// <p> <i>DBClusterParameterGroupName</i> does not refer to an existing DB Cluster parameter group.</p>
    DbClusterParameterGroupNotFoundFault(crate::error::DbClusterParameterGroupNotFoundFault),
    /// <p>User attempted to create a new DB cluster and the user has already reached the maximum allowed DB cluster quota.</p>
    DbClusterQuotaExceededFault(crate::error::DbClusterQuotaExceededFault),
    /// <p> <i>DBInstanceIdentifier</i> does not refer to an existing DB instance.</p>
    DbInstanceNotFoundFault(crate::error::DbInstanceNotFoundFault),
    /// <p>Subnets in the DB subnet group should cover at least two Availability Zones unless there is only one Availability Zone.</p>
    DbSubnetGroupDoesNotCoverEnoughAZs(crate::error::DbSubnetGroupDoesNotCoverEnoughAZs),
    /// <p> <i>DBSubnetGroupName</i> does not refer to an existing DB subnet group.</p>
    DbSubnetGroupNotFoundFault(crate::error::DbSubnetGroupNotFoundFault),
    /// <p>The <code>GlobalClusterIdentifier</code> doesn't refer to an existing global database cluster. </p>
    GlobalClusterNotFoundFault(crate::error::GlobalClusterNotFoundFault),
    /// <p>There is insufficient storage available for the current action. You may be able to resolve this error by updating your subnet group to use different Availability Zones that have more storage available.</p>
    InsufficientStorageClusterCapacityFault(crate::error::InsufficientStorageClusterCapacityFault),
    /// <p>The DB cluster is not in a valid state.</p>
    InvalidDbClusterStateFault(crate::error::InvalidDbClusterStateFault),
    /// <p>The specified DB instance is not in the <i>available</i> state.</p>
    InvalidDbInstanceStateFault(crate::error::InvalidDbInstanceStateFault),
    /// <p>The DB subnet group cannot be deleted because it is in use.</p>
    InvalidDbSubnetGroupStateFault(crate::error::InvalidDbSubnetGroupStateFault),
    /// <p>The global cluster is in an invalid state and can't perform the requested operation. </p>
    InvalidGlobalClusterStateFault(crate::error::InvalidGlobalClusterStateFault),
    /// <p>The requested subnet is invalid, or multiple subnets were requested that are not all in a common VPC.</p>
    InvalidSubnet(crate::error::InvalidSubnet),
    /// <p>DB subnet group does not cover all Availability Zones after it is created because users' change.</p>
    InvalidVpcNetworkStateFault(crate::error::InvalidVpcNetworkStateFault),
    /// <p>Error accessing KMS key.</p>
    KmsKeyNotAccessibleFault(crate::error::KmsKeyNotAccessibleFault),
    /// <p>Request would result in user exceeding the allowed amount of storage available across all DB instances.</p>
    StorageQuotaExceededFault(crate::error::StorageQuotaExceededFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateDBClusterError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateDBClusterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DbClusterAlreadyExistsFault(_inner) => _inner.fmt(f),
            Self::DbClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::DbClusterParameterGroupNotFoundFault(_inner) => _inner.fmt(f),
            Self::DbClusterQuotaExceededFault(_inner) => _inner.fmt(f),
            Self::DbInstanceNotFoundFault(_inner) => _inner.fmt(f),
            Self::DbSubnetGroupDoesNotCoverEnoughAZs(_inner) => _inner.fmt(f),
            Self::DbSubnetGroupNotFoundFault(_inner) => _inner.fmt(f),
            Self::GlobalClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::InsufficientStorageClusterCapacityFault(_inner) => _inner.fmt(f),
            Self::InvalidDbClusterStateFault(_inner) => _inner.fmt(f),
            Self::InvalidDbInstanceStateFault(_inner) => _inner.fmt(f),
            Self::InvalidDbSubnetGroupStateFault(_inner) => _inner.fmt(f),
            Self::InvalidGlobalClusterStateFault(_inner) => _inner.fmt(f),
            Self::InvalidSubnet(_inner) => _inner.fmt(f),
            Self::InvalidVpcNetworkStateFault(_inner) => _inner.fmt(f),
            Self::KmsKeyNotAccessibleFault(_inner) => _inner.fmt(f),
            Self::StorageQuotaExceededFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateDBClusterError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DbClusterAlreadyExistsFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DbClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DbClusterParameterGroupNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DbClusterQuotaExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DbInstanceNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DbSubnetGroupDoesNotCoverEnoughAZs(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DbSubnetGroupNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::GlobalClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InsufficientStorageClusterCapacityFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDbClusterStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDbInstanceStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDbSubnetGroupStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidGlobalClusterStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidSubnet(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidVpcNetworkStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::KmsKeyNotAccessibleFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::StorageQuotaExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateDBClusterError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateDBClusterError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDBClusterError {
    /// Creates the `CreateDBClusterError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateDBClusterError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DbClusterAlreadyExistsFault(e) => e.meta(),
            Self::DbClusterNotFoundFault(e) => e.meta(),
            Self::DbClusterParameterGroupNotFoundFault(e) => e.meta(),
            Self::DbClusterQuotaExceededFault(e) => e.meta(),
            Self::DbInstanceNotFoundFault(e) => e.meta(),
            Self::DbSubnetGroupDoesNotCoverEnoughAZs(e) => e.meta(),
            Self::DbSubnetGroupNotFoundFault(e) => e.meta(),
            Self::GlobalClusterNotFoundFault(e) => e.meta(),
            Self::InsufficientStorageClusterCapacityFault(e) => e.meta(),
            Self::InvalidDbClusterStateFault(e) => e.meta(),
            Self::InvalidDbInstanceStateFault(e) => e.meta(),
            Self::InvalidDbSubnetGroupStateFault(e) => e.meta(),
            Self::InvalidGlobalClusterStateFault(e) => e.meta(),
            Self::InvalidSubnet(e) => e.meta(),
            Self::InvalidVpcNetworkStateFault(e) => e.meta(),
            Self::KmsKeyNotAccessibleFault(e) => e.meta(),
            Self::StorageQuotaExceededFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateDBClusterError::DbClusterAlreadyExistsFault`.
    pub fn is_db_cluster_already_exists_fault(&self) -> bool {
        matches!(self, Self::DbClusterAlreadyExistsFault(_))
    }
    /// Returns `true` if the error kind is `CreateDBClusterError::DbClusterNotFoundFault`.
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::DbClusterNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `CreateDBClusterError::DbClusterParameterGroupNotFoundFault`.
    pub fn is_db_cluster_parameter_group_not_found_fault(&self) -> bool {
        matches!(self, Self::DbClusterParameterGroupNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `CreateDBClusterError::DbClusterQuotaExceededFault`.
    pub fn is_db_cluster_quota_exceeded_fault(&self) -> bool {
        matches!(self, Self::DbClusterQuotaExceededFault(_))
    }
    /// Returns `true` if the error kind is `CreateDBClusterError::DbInstanceNotFoundFault`.
    pub fn is_db_instance_not_found_fault(&self) -> bool {
        matches!(self, Self::DbInstanceNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `CreateDBClusterError::DbSubnetGroupDoesNotCoverEnoughAZs`.
    pub fn is_db_subnet_group_does_not_cover_enough_a_zs(&self) -> bool {
        matches!(self, Self::DbSubnetGroupDoesNotCoverEnoughAZs(_))
    }
    /// Returns `true` if the error kind is `CreateDBClusterError::DbSubnetGroupNotFoundFault`.
    pub fn is_db_subnet_group_not_found_fault(&self) -> bool {
        matches!(self, Self::DbSubnetGroupNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `CreateDBClusterError::GlobalClusterNotFoundFault`.
    pub fn is_global_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::GlobalClusterNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `CreateDBClusterError::InsufficientStorageClusterCapacityFault`.
    pub fn is_insufficient_storage_cluster_capacity_fault(&self) -> bool {
        matches!(self, Self::InsufficientStorageClusterCapacityFault(_))
    }
    /// Returns `true` if the error kind is `CreateDBClusterError::InvalidDbClusterStateFault`.
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(self, Self::InvalidDbClusterStateFault(_))
    }
    /// Returns `true` if the error kind is `CreateDBClusterError::InvalidDbInstanceStateFault`.
    pub fn is_invalid_db_instance_state_fault(&self) -> bool {
        matches!(self, Self::InvalidDbInstanceStateFault(_))
    }
    /// Returns `true` if the error kind is `CreateDBClusterError::InvalidDbSubnetGroupStateFault`.
    pub fn is_invalid_db_subnet_group_state_fault(&self) -> bool {
        matches!(self, Self::InvalidDbSubnetGroupStateFault(_))
    }
    /// Returns `true` if the error kind is `CreateDBClusterError::InvalidGlobalClusterStateFault`.
    pub fn is_invalid_global_cluster_state_fault(&self) -> bool {
        matches!(self, Self::InvalidGlobalClusterStateFault(_))
    }
    /// Returns `true` if the error kind is `CreateDBClusterError::InvalidSubnet`.
    pub fn is_invalid_subnet(&self) -> bool {
        matches!(self, Self::InvalidSubnet(_))
    }
    /// Returns `true` if the error kind is `CreateDBClusterError::InvalidVpcNetworkStateFault`.
    pub fn is_invalid_vpc_network_state_fault(&self) -> bool {
        matches!(self, Self::InvalidVpcNetworkStateFault(_))
    }
    /// Returns `true` if the error kind is `CreateDBClusterError::KmsKeyNotAccessibleFault`.
    pub fn is_kms_key_not_accessible_fault(&self) -> bool {
        matches!(self, Self::KmsKeyNotAccessibleFault(_))
    }
    /// Returns `true` if the error kind is `CreateDBClusterError::StorageQuotaExceededFault`.
    pub fn is_storage_quota_exceeded_fault(&self) -> bool {
        matches!(self, Self::StorageQuotaExceededFault(_))
    }
}
impl std::error::Error for CreateDBClusterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DbClusterAlreadyExistsFault(_inner) => Some(_inner),
            Self::DbClusterNotFoundFault(_inner) => Some(_inner),
            Self::DbClusterParameterGroupNotFoundFault(_inner) => Some(_inner),
            Self::DbClusterQuotaExceededFault(_inner) => Some(_inner),
            Self::DbInstanceNotFoundFault(_inner) => Some(_inner),
            Self::DbSubnetGroupDoesNotCoverEnoughAZs(_inner) => Some(_inner),
            Self::DbSubnetGroupNotFoundFault(_inner) => Some(_inner),
            Self::GlobalClusterNotFoundFault(_inner) => Some(_inner),
            Self::InsufficientStorageClusterCapacityFault(_inner) => Some(_inner),
            Self::InvalidDbClusterStateFault(_inner) => Some(_inner),
            Self::InvalidDbInstanceStateFault(_inner) => Some(_inner),
            Self::InvalidDbSubnetGroupStateFault(_inner) => Some(_inner),
            Self::InvalidGlobalClusterStateFault(_inner) => Some(_inner),
            Self::InvalidSubnet(_inner) => Some(_inner),
            Self::InvalidVpcNetworkStateFault(_inner) => Some(_inner),
            Self::KmsKeyNotAccessibleFault(_inner) => Some(_inner),
            Self::StorageQuotaExceededFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CopyDBParameterGroupErrorKind = CopyDBParameterGroupError;
/// Error type for the `CopyDBParameterGroupError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CopyDBParameterGroupError {
    /// <p>A DB parameter group with the same name exists.</p>
    DbParameterGroupAlreadyExistsFault(crate::error::DbParameterGroupAlreadyExistsFault),
    /// <p> <i>DBParameterGroupName</i> does not refer to an existing DB parameter group.</p>
    DbParameterGroupNotFoundFault(crate::error::DbParameterGroupNotFoundFault),
    /// <p>Request would result in user exceeding the allowed number of DB parameter groups.</p>
    DbParameterGroupQuotaExceededFault(crate::error::DbParameterGroupQuotaExceededFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CopyDBParameterGroupError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CopyDBParameterGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DbParameterGroupAlreadyExistsFault(_inner) => _inner.fmt(f),
            Self::DbParameterGroupNotFoundFault(_inner) => _inner.fmt(f),
            Self::DbParameterGroupQuotaExceededFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CopyDBParameterGroupError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DbParameterGroupAlreadyExistsFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DbParameterGroupNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DbParameterGroupQuotaExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CopyDBParameterGroupError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CopyDBParameterGroupError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CopyDBParameterGroupError {
    /// Creates the `CopyDBParameterGroupError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CopyDBParameterGroupError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DbParameterGroupAlreadyExistsFault(e) => e.meta(),
            Self::DbParameterGroupNotFoundFault(e) => e.meta(),
            Self::DbParameterGroupQuotaExceededFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CopyDBParameterGroupError::DbParameterGroupAlreadyExistsFault`.
    pub fn is_db_parameter_group_already_exists_fault(&self) -> bool {
        matches!(self, Self::DbParameterGroupAlreadyExistsFault(_))
    }
    /// Returns `true` if the error kind is `CopyDBParameterGroupError::DbParameterGroupNotFoundFault`.
    pub fn is_db_parameter_group_not_found_fault(&self) -> bool {
        matches!(self, Self::DbParameterGroupNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `CopyDBParameterGroupError::DbParameterGroupQuotaExceededFault`.
    pub fn is_db_parameter_group_quota_exceeded_fault(&self) -> bool {
        matches!(self, Self::DbParameterGroupQuotaExceededFault(_))
    }
}
impl std::error::Error for CopyDBParameterGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DbParameterGroupAlreadyExistsFault(_inner) => Some(_inner),
            Self::DbParameterGroupNotFoundFault(_inner) => Some(_inner),
            Self::DbParameterGroupQuotaExceededFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CopyDBClusterSnapshotErrorKind = CopyDBClusterSnapshotError;
/// Error type for the `CopyDBClusterSnapshotError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CopyDBClusterSnapshotError {
    /// <p>User already has a DB cluster snapshot with the given identifier.</p>
    DbClusterSnapshotAlreadyExistsFault(crate::error::DbClusterSnapshotAlreadyExistsFault),
    /// <p> <i>DBClusterSnapshotIdentifier</i> does not refer to an existing DB cluster snapshot.</p>
    DbClusterSnapshotNotFoundFault(crate::error::DbClusterSnapshotNotFoundFault),
    /// <p>The supplied value is not a valid DB cluster snapshot state.</p>
    InvalidDbClusterSnapshotStateFault(crate::error::InvalidDbClusterSnapshotStateFault),
    /// <p>The DB cluster is not in a valid state.</p>
    InvalidDbClusterStateFault(crate::error::InvalidDbClusterStateFault),
    /// <p>Error accessing KMS key.</p>
    KmsKeyNotAccessibleFault(crate::error::KmsKeyNotAccessibleFault),
    /// <p>Request would result in user exceeding the allowed number of DB snapshots.</p>
    SnapshotQuotaExceededFault(crate::error::SnapshotQuotaExceededFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CopyDBClusterSnapshotError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CopyDBClusterSnapshotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DbClusterSnapshotAlreadyExistsFault(_inner) => _inner.fmt(f),
            Self::DbClusterSnapshotNotFoundFault(_inner) => _inner.fmt(f),
            Self::InvalidDbClusterSnapshotStateFault(_inner) => _inner.fmt(f),
            Self::InvalidDbClusterStateFault(_inner) => _inner.fmt(f),
            Self::KmsKeyNotAccessibleFault(_inner) => _inner.fmt(f),
            Self::SnapshotQuotaExceededFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CopyDBClusterSnapshotError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DbClusterSnapshotAlreadyExistsFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DbClusterSnapshotNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDbClusterSnapshotStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDbClusterStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::KmsKeyNotAccessibleFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SnapshotQuotaExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CopyDBClusterSnapshotError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CopyDBClusterSnapshotError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CopyDBClusterSnapshotError {
    /// Creates the `CopyDBClusterSnapshotError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CopyDBClusterSnapshotError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DbClusterSnapshotAlreadyExistsFault(e) => e.meta(),
            Self::DbClusterSnapshotNotFoundFault(e) => e.meta(),
            Self::InvalidDbClusterSnapshotStateFault(e) => e.meta(),
            Self::InvalidDbClusterStateFault(e) => e.meta(),
            Self::KmsKeyNotAccessibleFault(e) => e.meta(),
            Self::SnapshotQuotaExceededFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CopyDBClusterSnapshotError::DbClusterSnapshotAlreadyExistsFault`.
    pub fn is_db_cluster_snapshot_already_exists_fault(&self) -> bool {
        matches!(self, Self::DbClusterSnapshotAlreadyExistsFault(_))
    }
    /// Returns `true` if the error kind is `CopyDBClusterSnapshotError::DbClusterSnapshotNotFoundFault`.
    pub fn is_db_cluster_snapshot_not_found_fault(&self) -> bool {
        matches!(self, Self::DbClusterSnapshotNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `CopyDBClusterSnapshotError::InvalidDbClusterSnapshotStateFault`.
    pub fn is_invalid_db_cluster_snapshot_state_fault(&self) -> bool {
        matches!(self, Self::InvalidDbClusterSnapshotStateFault(_))
    }
    /// Returns `true` if the error kind is `CopyDBClusterSnapshotError::InvalidDbClusterStateFault`.
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(self, Self::InvalidDbClusterStateFault(_))
    }
    /// Returns `true` if the error kind is `CopyDBClusterSnapshotError::KmsKeyNotAccessibleFault`.
    pub fn is_kms_key_not_accessible_fault(&self) -> bool {
        matches!(self, Self::KmsKeyNotAccessibleFault(_))
    }
    /// Returns `true` if the error kind is `CopyDBClusterSnapshotError::SnapshotQuotaExceededFault`.
    pub fn is_snapshot_quota_exceeded_fault(&self) -> bool {
        matches!(self, Self::SnapshotQuotaExceededFault(_))
    }
}
impl std::error::Error for CopyDBClusterSnapshotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DbClusterSnapshotAlreadyExistsFault(_inner) => Some(_inner),
            Self::DbClusterSnapshotNotFoundFault(_inner) => Some(_inner),
            Self::InvalidDbClusterSnapshotStateFault(_inner) => Some(_inner),
            Self::InvalidDbClusterStateFault(_inner) => Some(_inner),
            Self::KmsKeyNotAccessibleFault(_inner) => Some(_inner),
            Self::SnapshotQuotaExceededFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CopyDBClusterParameterGroupErrorKind = CopyDBClusterParameterGroupError;
/// Error type for the `CopyDBClusterParameterGroupError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CopyDBClusterParameterGroupError {
    /// <p>A DB parameter group with the same name exists.</p>
    DbParameterGroupAlreadyExistsFault(crate::error::DbParameterGroupAlreadyExistsFault),
    /// <p> <i>DBParameterGroupName</i> does not refer to an existing DB parameter group.</p>
    DbParameterGroupNotFoundFault(crate::error::DbParameterGroupNotFoundFault),
    /// <p>Request would result in user exceeding the allowed number of DB parameter groups.</p>
    DbParameterGroupQuotaExceededFault(crate::error::DbParameterGroupQuotaExceededFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CopyDBClusterParameterGroupError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CopyDBClusterParameterGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DbParameterGroupAlreadyExistsFault(_inner) => _inner.fmt(f),
            Self::DbParameterGroupNotFoundFault(_inner) => _inner.fmt(f),
            Self::DbParameterGroupQuotaExceededFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CopyDBClusterParameterGroupError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DbParameterGroupAlreadyExistsFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DbParameterGroupNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DbParameterGroupQuotaExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CopyDBClusterParameterGroupError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CopyDBClusterParameterGroupError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CopyDBClusterParameterGroupError {
    /// Creates the `CopyDBClusterParameterGroupError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CopyDBClusterParameterGroupError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DbParameterGroupAlreadyExistsFault(e) => e.meta(),
            Self::DbParameterGroupNotFoundFault(e) => e.meta(),
            Self::DbParameterGroupQuotaExceededFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CopyDBClusterParameterGroupError::DbParameterGroupAlreadyExistsFault`.
    pub fn is_db_parameter_group_already_exists_fault(&self) -> bool {
        matches!(self, Self::DbParameterGroupAlreadyExistsFault(_))
    }
    /// Returns `true` if the error kind is `CopyDBClusterParameterGroupError::DbParameterGroupNotFoundFault`.
    pub fn is_db_parameter_group_not_found_fault(&self) -> bool {
        matches!(self, Self::DbParameterGroupNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `CopyDBClusterParameterGroupError::DbParameterGroupQuotaExceededFault`.
    pub fn is_db_parameter_group_quota_exceeded_fault(&self) -> bool {
        matches!(self, Self::DbParameterGroupQuotaExceededFault(_))
    }
}
impl std::error::Error for CopyDBClusterParameterGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DbParameterGroupAlreadyExistsFault(_inner) => Some(_inner),
            Self::DbParameterGroupNotFoundFault(_inner) => Some(_inner),
            Self::DbParameterGroupQuotaExceededFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ApplyPendingMaintenanceActionErrorKind = ApplyPendingMaintenanceActionError;
/// Error type for the `ApplyPendingMaintenanceActionError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ApplyPendingMaintenanceActionError {
    /// <p>The specified resource ID was not found.</p>
    ResourceNotFoundFault(crate::error::ResourceNotFoundFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ApplyPendingMaintenanceActionError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ApplyPendingMaintenanceActionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ResourceNotFoundFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for ApplyPendingMaintenanceActionError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ResourceNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ApplyPendingMaintenanceActionError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ApplyPendingMaintenanceActionError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ApplyPendingMaintenanceActionError {
    /// Creates the `ApplyPendingMaintenanceActionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ApplyPendingMaintenanceActionError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ResourceNotFoundFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ApplyPendingMaintenanceActionError::ResourceNotFoundFault`.
    pub fn is_resource_not_found_fault(&self) -> bool {
        matches!(self, Self::ResourceNotFoundFault(_))
    }
}
impl std::error::Error for ApplyPendingMaintenanceActionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ResourceNotFoundFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type AddTagsToResourceErrorKind = AddTagsToResourceError;
/// Error type for the `AddTagsToResourceError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AddTagsToResourceError {
    /// <p> <i>DBClusterIdentifier</i> does not refer to an existing DB cluster.</p>
    DbClusterNotFoundFault(crate::error::DbClusterNotFoundFault),
    /// <p> <i>DBInstanceIdentifier</i> does not refer to an existing DB instance.</p>
    DbInstanceNotFoundFault(crate::error::DbInstanceNotFoundFault),
    /// <p> <i>DBSnapshotIdentifier</i> does not refer to an existing DB snapshot.</p>
    DbSnapshotNotFoundFault(crate::error::DbSnapshotNotFoundFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for AddTagsToResourceError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for AddTagsToResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DbClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::DbInstanceNotFoundFault(_inner) => _inner.fmt(f),
            Self::DbSnapshotNotFoundFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for AddTagsToResourceError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DbClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DbInstanceNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DbSnapshotNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::AddTagsToResourceError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for AddTagsToResourceError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl AddTagsToResourceError {
    /// Creates the `AddTagsToResourceError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `AddTagsToResourceError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DbClusterNotFoundFault(e) => e.meta(),
            Self::DbInstanceNotFoundFault(e) => e.meta(),
            Self::DbSnapshotNotFoundFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `AddTagsToResourceError::DbClusterNotFoundFault`.
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::DbClusterNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `AddTagsToResourceError::DbInstanceNotFoundFault`.
    pub fn is_db_instance_not_found_fault(&self) -> bool {
        matches!(self, Self::DbInstanceNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `AddTagsToResourceError::DbSnapshotNotFoundFault`.
    pub fn is_db_snapshot_not_found_fault(&self) -> bool {
        matches!(self, Self::DbSnapshotNotFoundFault(_))
    }
}
impl std::error::Error for AddTagsToResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DbClusterNotFoundFault(_inner) => Some(_inner),
            Self::DbInstanceNotFoundFault(_inner) => Some(_inner),
            Self::DbSnapshotNotFoundFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type AddSourceIdentifierToSubscriptionErrorKind = AddSourceIdentifierToSubscriptionError;
/// Error type for the `AddSourceIdentifierToSubscriptionError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AddSourceIdentifierToSubscriptionError {
    /// <p>The source could not be found.</p>
    SourceNotFoundFault(crate::error::SourceNotFoundFault),
    /// <p>The designated subscription could not be found.</p>
    SubscriptionNotFoundFault(crate::error::SubscriptionNotFoundFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for AddSourceIdentifierToSubscriptionError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for AddSourceIdentifierToSubscriptionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::SourceNotFoundFault(_inner) => _inner.fmt(f),
            Self::SubscriptionNotFoundFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for AddSourceIdentifierToSubscriptionError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::SourceNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SubscriptionNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::AddSourceIdentifierToSubscriptionError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for AddSourceIdentifierToSubscriptionError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl AddSourceIdentifierToSubscriptionError {
    /// Creates the `AddSourceIdentifierToSubscriptionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `AddSourceIdentifierToSubscriptionError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::SourceNotFoundFault(e) => e.meta(),
            Self::SubscriptionNotFoundFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `AddSourceIdentifierToSubscriptionError::SourceNotFoundFault`.
    pub fn is_source_not_found_fault(&self) -> bool {
        matches!(self, Self::SourceNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `AddSourceIdentifierToSubscriptionError::SubscriptionNotFoundFault`.
    pub fn is_subscription_not_found_fault(&self) -> bool {
        matches!(self, Self::SubscriptionNotFoundFault(_))
    }
}
impl std::error::Error for AddSourceIdentifierToSubscriptionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::SourceNotFoundFault(_inner) => Some(_inner),
            Self::SubscriptionNotFoundFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type AddRoleToDBClusterErrorKind = AddRoleToDBClusterError;
/// Error type for the `AddRoleToDBClusterError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AddRoleToDBClusterError {
    /// <p> <i>DBClusterIdentifier</i> does not refer to an existing DB cluster.</p>
    DbClusterNotFoundFault(crate::error::DbClusterNotFoundFault),
    /// <p>The specified IAM role Amazon Resource Name (ARN) is already associated with the specified DB cluster.</p>
    DbClusterRoleAlreadyExistsFault(crate::error::DbClusterRoleAlreadyExistsFault),
    /// <p>You have exceeded the maximum number of IAM roles that can be associated with the specified DB cluster.</p>
    DbClusterRoleQuotaExceededFault(crate::error::DbClusterRoleQuotaExceededFault),
    /// <p>The DB cluster is not in a valid state.</p>
    InvalidDbClusterStateFault(crate::error::InvalidDbClusterStateFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for AddRoleToDBClusterError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for AddRoleToDBClusterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DbClusterNotFoundFault(_inner) => _inner.fmt(f),
            Self::DbClusterRoleAlreadyExistsFault(_inner) => _inner.fmt(f),
            Self::DbClusterRoleQuotaExceededFault(_inner) => _inner.fmt(f),
            Self::InvalidDbClusterStateFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for AddRoleToDBClusterError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DbClusterNotFoundFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DbClusterRoleAlreadyExistsFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DbClusterRoleQuotaExceededFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDbClusterStateFault(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::AddRoleToDBClusterError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for AddRoleToDBClusterError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl AddRoleToDBClusterError {
    /// Creates the `AddRoleToDBClusterError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `AddRoleToDBClusterError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DbClusterNotFoundFault(e) => e.meta(),
            Self::DbClusterRoleAlreadyExistsFault(e) => e.meta(),
            Self::DbClusterRoleQuotaExceededFault(e) => e.meta(),
            Self::InvalidDbClusterStateFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `AddRoleToDBClusterError::DbClusterNotFoundFault`.
    pub fn is_db_cluster_not_found_fault(&self) -> bool {
        matches!(self, Self::DbClusterNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `AddRoleToDBClusterError::DbClusterRoleAlreadyExistsFault`.
    pub fn is_db_cluster_role_already_exists_fault(&self) -> bool {
        matches!(self, Self::DbClusterRoleAlreadyExistsFault(_))
    }
    /// Returns `true` if the error kind is `AddRoleToDBClusterError::DbClusterRoleQuotaExceededFault`.
    pub fn is_db_cluster_role_quota_exceeded_fault(&self) -> bool {
        matches!(self, Self::DbClusterRoleQuotaExceededFault(_))
    }
    /// Returns `true` if the error kind is `AddRoleToDBClusterError::InvalidDbClusterStateFault`.
    pub fn is_invalid_db_cluster_state_fault(&self) -> bool {
        matches!(self, Self::InvalidDbClusterStateFault(_))
    }
}
impl std::error::Error for AddRoleToDBClusterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DbClusterNotFoundFault(_inner) => Some(_inner),
            Self::DbClusterRoleAlreadyExistsFault(_inner) => Some(_inner),
            Self::DbClusterRoleQuotaExceededFault(_inner) => Some(_inner),
            Self::InvalidDbClusterStateFault(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>You have exceeded the maximum number of IAM roles that can be associated with the specified DB cluster.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DbClusterRoleQuotaExceededFault {
    /// <p>A message describing the details of the problem.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl DbClusterRoleQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`DbClusterRoleQuotaExceededFault`](crate::error::DbClusterRoleQuotaExceededFault).
    pub fn builder() -> crate::error::db_cluster_role_quota_exceeded_fault::Builder {
        crate::error::db_cluster_role_quota_exceeded_fault::Builder::default()
    }
}
/// See [`DbClusterRoleQuotaExceededFault`](crate::error::DbClusterRoleQuotaExceededFault).
pub mod db_cluster_role_quota_exceeded_fault {

    /// A builder for [`DbClusterRoleQuotaExceededFault`](crate::error::DbClusterRoleQuotaExceededFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A message describing the details of the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message describing the details of the problem.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`DbClusterRoleQuotaExceededFault`](crate::error::DbClusterRoleQuotaExceededFault).
        pub fn build(self) -> crate::error::DbClusterRoleQuotaExceededFault {
            crate::error::DbClusterRoleQuotaExceededFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl DbClusterRoleQuotaExceededFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DbClusterRoleQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "DbClusterRoleQuotaExceededFault [DBClusterRoleQuotaExceededFault]"
        )?;
        if let Some(inner_66) = &self.message {
            {
                write!(f, ": {}", inner_66)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DbClusterRoleQuotaExceededFault {}
impl aws_http::request_id::RequestId for crate::error::DbClusterRoleQuotaExceededFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DbClusterRoleQuotaExceededFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The specified IAM role Amazon Resource Name (ARN) is already associated with the specified DB cluster.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DbClusterRoleAlreadyExistsFault {
    /// <p>A message describing the details of the problem.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl DbClusterRoleAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`DbClusterRoleAlreadyExistsFault`](crate::error::DbClusterRoleAlreadyExistsFault).
    pub fn builder() -> crate::error::db_cluster_role_already_exists_fault::Builder {
        crate::error::db_cluster_role_already_exists_fault::Builder::default()
    }
}
/// See [`DbClusterRoleAlreadyExistsFault`](crate::error::DbClusterRoleAlreadyExistsFault).
pub mod db_cluster_role_already_exists_fault {

    /// A builder for [`DbClusterRoleAlreadyExistsFault`](crate::error::DbClusterRoleAlreadyExistsFault).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A message describing the details of the problem.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message describing the details of the problem.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`DbClusterRoleAlreadyExistsFault`](crate::error::DbClusterRoleAlreadyExistsFault).
        pub fn build(self) -> crate::error::DbClusterRoleAlreadyExistsFault {
            crate::error::DbClusterRoleAlreadyExistsFault {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl DbClusterRoleAlreadyExistsFault {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DbClusterRoleAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "DbClusterRoleAlreadyExistsFault [DBClusterRoleAlreadyExistsFault]"
        )?;
        if let Some(inner_67) = &self.message {
            {
                write!(f, ": {}", inner_67)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DbClusterRoleAlreadyExistsFault {}
impl aws_http::request_id::RequestId for crate::error::DbClusterRoleAlreadyExistsFault {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DbClusterRoleAlreadyExistsFault {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
