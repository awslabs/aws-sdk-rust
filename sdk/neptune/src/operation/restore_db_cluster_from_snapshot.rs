// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// Orchestration and serialization glue logic for `RestoreDBClusterFromSnapshot`.
#[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
#[doc(hidden)]
pub struct RestoreDBClusterFromSnapshot;
impl RestoreDBClusterFromSnapshot {
    #[doc(hidden)]
    pub fn new() -> Self {
        Self
    }
    pub(crate) async fn orchestrate(
        runtime_plugins: &::aws_smithy_runtime_api::client::runtime_plugin::RuntimePlugins,
        input: crate::operation::restore_db_cluster_from_snapshot::RestoreDbClusterFromSnapshotInput,
    ) -> ::std::result::Result<
        crate::operation::restore_db_cluster_from_snapshot::RestoreDbClusterFromSnapshotOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::restore_db_cluster_from_snapshot::RestoreDBClusterFromSnapshotError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let map_err = |err: ::aws_smithy_runtime_api::client::result::SdkError<
            ::aws_smithy_runtime_api::client::interceptors::context::Error,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >| {
            err.map_service_error(|err| {
                err.downcast::<crate::operation::restore_db_cluster_from_snapshot::RestoreDBClusterFromSnapshotError>()
                    .expect("correct error type")
            })
        };
        let context = Self::orchestrate_with_stop_point(runtime_plugins, input, ::aws_smithy_runtime::client::orchestrator::StopPoint::None)
            .await
            .map_err(map_err)?;
        let output = context.finalize().map_err(map_err)?;
        ::std::result::Result::Ok(
            output
                .downcast::<crate::operation::restore_db_cluster_from_snapshot::RestoreDbClusterFromSnapshotOutput>()
                .expect("correct output type"),
        )
    }

    pub(crate) async fn orchestrate_with_stop_point(
        runtime_plugins: &::aws_smithy_runtime_api::client::runtime_plugin::RuntimePlugins,
        input: crate::operation::restore_db_cluster_from_snapshot::RestoreDbClusterFromSnapshotInput,
        stop_point: ::aws_smithy_runtime::client::orchestrator::StopPoint,
    ) -> ::std::result::Result<
        ::aws_smithy_runtime_api::client::interceptors::context::InterceptorContext,
        ::aws_smithy_runtime_api::client::result::SdkError<
            ::aws_smithy_runtime_api::client::interceptors::context::Error,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let input = ::aws_smithy_runtime_api::client::interceptors::context::Input::erase(input);
        ::aws_smithy_runtime::client::orchestrator::invoke_with_stop_point(
            "neptune",
            "RestoreDBClusterFromSnapshot",
            input,
            runtime_plugins,
            stop_point,
        )
        .await
    }

    pub(crate) fn operation_runtime_plugins(
        client_runtime_plugins: ::aws_smithy_runtime_api::client::runtime_plugin::RuntimePlugins,
        client_config: &crate::config::Config,
        config_override: ::std::option::Option<crate::config::Builder>,
    ) -> ::aws_smithy_runtime_api::client::runtime_plugin::RuntimePlugins {
        let mut runtime_plugins = client_runtime_plugins.with_operation_plugin(Self::new());
        runtime_plugins = runtime_plugins.with_client_plugin(crate::auth_plugin::DefaultAuthOptionsPlugin::new(vec![
            ::aws_runtime::auth::sigv4::SCHEME_ID,
        ]));
        if let ::std::option::Option::Some(config_override) = config_override {
            for plugin in config_override.runtime_plugins.iter().cloned() {
                runtime_plugins = runtime_plugins.with_operation_plugin(plugin);
            }
            runtime_plugins = runtime_plugins.with_operation_plugin(crate::config::ConfigOverrideRuntimePlugin::new(
                config_override,
                client_config.config.clone(),
                &client_config.runtime_components,
            ));
        }
        runtime_plugins
    }
}
impl ::aws_smithy_runtime_api::client::runtime_plugin::RuntimePlugin for RestoreDBClusterFromSnapshot {
    fn config(&self) -> ::std::option::Option<::aws_smithy_types::config_bag::FrozenLayer> {
        let mut cfg = ::aws_smithy_types::config_bag::Layer::new("RestoreDBClusterFromSnapshot");

        cfg.store_put(::aws_smithy_runtime_api::client::ser_de::SharedRequestSerializer::new(
            RestoreDBClusterFromSnapshotRequestSerializer,
        ));
        cfg.store_put(::aws_smithy_runtime_api::client::ser_de::SharedResponseDeserializer::new(
            RestoreDBClusterFromSnapshotResponseDeserializer,
        ));

        cfg.store_put(::aws_smithy_runtime_api::client::auth::AuthSchemeOptionResolverParams::new(
            ::aws_smithy_runtime_api::client::auth::static_resolver::StaticAuthSchemeOptionResolverParams::new(),
        ));

        cfg.store_put(::aws_smithy_http::operation::Metadata::new("RestoreDBClusterFromSnapshot", "neptune"));
        let mut signing_options = ::aws_runtime::auth::SigningOptions::default();
        signing_options.double_uri_encode = true;
        signing_options.content_sha256_header = false;
        signing_options.normalize_uri_path = true;
        signing_options.payload_override = None;

        cfg.store_put(::aws_runtime::auth::SigV4OperationSigningConfig {
            signing_options,
            ..::std::default::Default::default()
        });

        ::std::option::Option::Some(cfg.freeze())
    }

    fn runtime_components(
        &self,
        _: &::aws_smithy_runtime_api::client::runtime_components::RuntimeComponentsBuilder,
    ) -> ::std::borrow::Cow<'_, ::aws_smithy_runtime_api::client::runtime_components::RuntimeComponentsBuilder> {
        ::std::borrow::Cow::Owned(
            ::aws_smithy_runtime_api::client::runtime_components::RuntimeComponentsBuilder::new("RestoreDBClusterFromSnapshot")
                .with_interceptor(RestoreDBClusterFromSnapshotEndpointParamsInterceptor)
                .with_retry_classifier(::aws_smithy_runtime::client::retries::classifiers::TransientErrorClassifier::<
                    crate::operation::restore_db_cluster_from_snapshot::RestoreDBClusterFromSnapshotError,
                >::new())
                .with_retry_classifier(::aws_smithy_runtime::client::retries::classifiers::ModeledAsRetryableClassifier::<
                    crate::operation::restore_db_cluster_from_snapshot::RestoreDBClusterFromSnapshotError,
                >::new())
                .with_retry_classifier(::aws_runtime::retries::classifiers::AwsErrorCodeClassifier::<
                    crate::operation::restore_db_cluster_from_snapshot::RestoreDBClusterFromSnapshotError,
                >::new()),
        )
    }
}

#[derive(Debug)]
struct RestoreDBClusterFromSnapshotResponseDeserializer;
impl ::aws_smithy_runtime_api::client::ser_de::DeserializeResponse for RestoreDBClusterFromSnapshotResponseDeserializer {
    fn deserialize_nonstreaming(
        &self,
        response: &::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
    ) -> ::aws_smithy_runtime_api::client::interceptors::context::OutputOrError {
        let (success, status) = (response.status().is_success(), response.status().as_u16());
        let headers = response.headers();
        let body = response.body().bytes().expect("body loaded");
        #[allow(unused_mut)]
        let mut force_error = false;
        ::tracing::debug!(request_id = ?::aws_http::request_id::RequestId::request_id(response));
        let parse_result = if !success && status != 200 || force_error {
            crate::protocol_serde::shape_restore_db_cluster_from_snapshot::de_restore_db_cluster_from_snapshot_http_error(status, headers, body)
        } else {
            crate::protocol_serde::shape_restore_db_cluster_from_snapshot::de_restore_db_cluster_from_snapshot_http_response(status, headers, body)
        };
        crate::protocol_serde::type_erase_result(parse_result)
    }
}
#[derive(Debug)]
struct RestoreDBClusterFromSnapshotRequestSerializer;
impl ::aws_smithy_runtime_api::client::ser_de::SerializeRequest for RestoreDBClusterFromSnapshotRequestSerializer {
    #[allow(unused_mut, clippy::let_and_return, clippy::needless_borrow, clippy::useless_conversion)]
    fn serialize_input(
        &self,
        input: ::aws_smithy_runtime_api::client::interceptors::context::Input,
        _cfg: &mut ::aws_smithy_types::config_bag::ConfigBag,
    ) -> ::std::result::Result<::aws_smithy_runtime_api::client::orchestrator::HttpRequest, ::aws_smithy_runtime_api::box_error::BoxError> {
        let input = input
            .downcast::<crate::operation::restore_db_cluster_from_snapshot::RestoreDbClusterFromSnapshotInput>()
            .expect("correct type");
        let _header_serialization_settings = _cfg
            .load::<crate::serialization_settings::HeaderSerializationSettings>()
            .cloned()
            .unwrap_or_default();
        let mut request_builder = {
            fn uri_base(
                _input: &crate::operation::restore_db_cluster_from_snapshot::RestoreDbClusterFromSnapshotInput,
                output: &mut ::std::string::String,
            ) -> ::std::result::Result<(), ::aws_smithy_types::error::operation::BuildError> {
                use ::std::fmt::Write as _;
                ::std::write!(output, "/").expect("formatting should succeed");
                ::std::result::Result::Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::operation::restore_db_cluster_from_snapshot::RestoreDbClusterFromSnapshotInput,
                builder: ::http::request::Builder,
            ) -> ::std::result::Result<::http::request::Builder, ::aws_smithy_types::error::operation::BuildError> {
                let mut uri = ::std::string::String::new();
                uri_base(input, &mut uri)?;
                ::std::result::Result::Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&input, ::http::request::Builder::new())?;
            builder = _header_serialization_settings.set_default_header(builder, ::http::header::CONTENT_TYPE, "application/x-www-form-urlencoded");
            builder
        };
        let body = ::aws_smithy_types::body::SdkBody::from(
            crate::protocol_serde::shape_restore_db_cluster_from_snapshot_input::ser_restore_db_cluster_from_snapshot_input_input(&input)?,
        );
        if let Some(content_length) = body.content_length() {
            let content_length = content_length.to_string();
            request_builder = _header_serialization_settings.set_default_header(request_builder, ::http::header::CONTENT_LENGTH, &content_length);
        }
        ::std::result::Result::Ok(request_builder.body(body).expect("valid request").try_into().unwrap())
    }
}
#[derive(Debug)]
struct RestoreDBClusterFromSnapshotEndpointParamsInterceptor;

impl ::aws_smithy_runtime_api::client::interceptors::Intercept for RestoreDBClusterFromSnapshotEndpointParamsInterceptor {
    fn name(&self) -> &'static str {
        "RestoreDBClusterFromSnapshotEndpointParamsInterceptor"
    }

    fn read_before_execution(
        &self,
        context: &::aws_smithy_runtime_api::client::interceptors::context::BeforeSerializationInterceptorContextRef<
            '_,
            ::aws_smithy_runtime_api::client::interceptors::context::Input,
            ::aws_smithy_runtime_api::client::interceptors::context::Output,
            ::aws_smithy_runtime_api::client::interceptors::context::Error,
        >,
        cfg: &mut ::aws_smithy_types::config_bag::ConfigBag,
    ) -> ::std::result::Result<(), ::aws_smithy_runtime_api::box_error::BoxError> {
        let _input = context
            .input()
            .downcast_ref::<RestoreDbClusterFromSnapshotInput>()
            .ok_or("failed to downcast to RestoreDbClusterFromSnapshotInput")?;

        let params = crate::config::endpoint::Params::builder()
            .set_region(cfg.load::<::aws_types::region::Region>().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(cfg.load::<::aws_types::endpoint_config::UseDualStack>().map(|ty| ty.0))
            .set_use_fips(cfg.load::<::aws_types::endpoint_config::UseFips>().map(|ty| ty.0))
            .set_endpoint(cfg.load::<::aws_types::endpoint_config::EndpointUrl>().map(|ty| ty.0.clone()))
            .build()
            .map_err(|err| {
                ::aws_smithy_runtime_api::client::interceptors::error::ContextAttachedError::new("endpoint params could not be built", err)
            })?;
        cfg.interceptor_state()
            .store_put(::aws_smithy_runtime_api::client::endpoint::EndpointResolverParams::new(params));
        ::std::result::Result::Ok(())
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type RestoreDBClusterFromSnapshotErrorKind = RestoreDBClusterFromSnapshotError;
/// Error type for the `RestoreDBClusterFromSnapshotError` operation.
#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum RestoreDBClusterFromSnapshotError {
    /// <p>User already has a DB cluster with the given identifier.</p>
    DbClusterAlreadyExistsFault(crate::types::error::DbClusterAlreadyExistsFault),
    /// <p> <i>DBClusterParameterGroupName</i> does not refer to an existing DB Cluster parameter group.</p>
    DbClusterParameterGroupNotFoundFault(crate::types::error::DbClusterParameterGroupNotFoundFault),
    /// <p>User attempted to create a new DB cluster and the user has already reached the maximum allowed DB cluster quota.</p>
    DbClusterQuotaExceededFault(crate::types::error::DbClusterQuotaExceededFault),
    /// <p> <i>DBClusterSnapshotIdentifier</i> does not refer to an existing DB cluster snapshot.</p>
    DbClusterSnapshotNotFoundFault(crate::types::error::DbClusterSnapshotNotFoundFault),
    /// <p> <i>DBSnapshotIdentifier</i> does not refer to an existing DB snapshot.</p>
    DbSnapshotNotFoundFault(crate::types::error::DbSnapshotNotFoundFault),
    /// <p> <i>DBSubnetGroupName</i> does not refer to an existing DB subnet group.</p>
    DbSubnetGroupNotFoundFault(crate::types::error::DbSubnetGroupNotFoundFault),
    /// <p>The DB cluster does not have enough capacity for the current operation.</p>
    InsufficientDbClusterCapacityFault(crate::types::error::InsufficientDbClusterCapacityFault),
    /// <p>There is insufficient storage available for the current action. You may be able to resolve this error by updating your subnet group to use different Availability Zones that have more storage available.</p>
    InsufficientStorageClusterCapacityFault(crate::types::error::InsufficientStorageClusterCapacityFault),
    /// <p>The supplied value is not a valid DB cluster snapshot state.</p>
    InvalidDbClusterSnapshotStateFault(crate::types::error::InvalidDbClusterSnapshotStateFault),
    /// <p>The state of the DB snapshot does not allow deletion.</p>
    InvalidDbSnapshotStateFault(crate::types::error::InvalidDbSnapshotStateFault),
    /// <p>Cannot restore from vpc backup to non-vpc DB instance.</p>
    InvalidRestoreFault(crate::types::error::InvalidRestoreFault),
    /// <p>The requested subnet is invalid, or multiple subnets were requested that are not all in a common VPC.</p>
    InvalidSubnet(crate::types::error::InvalidSubnet),
    /// <p>DB subnet group does not cover all Availability Zones after it is created because users' change.</p>
    InvalidVpcNetworkStateFault(crate::types::error::InvalidVpcNetworkStateFault),
    /// <p>Error accessing KMS key.</p>
    KmsKeyNotAccessibleFault(crate::types::error::KmsKeyNotAccessibleFault),
    /// <p>The designated option group could not be found.</p>
    OptionGroupNotFoundFault(crate::types::error::OptionGroupNotFoundFault),
    /// <p>Request would result in user exceeding the allowed amount of storage available across all DB instances.</p>
    StorageQuotaExceededFault(crate::types::error::StorageQuotaExceededFault),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(::aws_smithy_types::error::Unhandled),
}
impl ::aws_smithy_runtime_api::client::result::CreateUnhandledError for RestoreDBClusterFromSnapshotError {
    fn create_unhandled_error(
        source: ::std::boxed::Box<dyn ::std::error::Error + ::std::marker::Send + ::std::marker::Sync + 'static>,
        meta: ::std::option::Option<::aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = ::aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl ::std::fmt::Display for RestoreDBClusterFromSnapshotError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::DbClusterAlreadyExistsFault(_inner) => _inner.fmt(f),
            Self::DbClusterParameterGroupNotFoundFault(_inner) => _inner.fmt(f),
            Self::DbClusterQuotaExceededFault(_inner) => _inner.fmt(f),
            Self::DbClusterSnapshotNotFoundFault(_inner) => _inner.fmt(f),
            Self::DbSnapshotNotFoundFault(_inner) => _inner.fmt(f),
            Self::DbSubnetGroupNotFoundFault(_inner) => _inner.fmt(f),
            Self::InsufficientDbClusterCapacityFault(_inner) => _inner.fmt(f),
            Self::InsufficientStorageClusterCapacityFault(_inner) => _inner.fmt(f),
            Self::InvalidDbClusterSnapshotStateFault(_inner) => _inner.fmt(f),
            Self::InvalidDbSnapshotStateFault(_inner) => _inner.fmt(f),
            Self::InvalidRestoreFault(_inner) => _inner.fmt(f),
            Self::InvalidSubnet(_inner) => _inner.fmt(f),
            Self::InvalidVpcNetworkStateFault(_inner) => _inner.fmt(f),
            Self::KmsKeyNotAccessibleFault(_inner) => _inner.fmt(f),
            Self::OptionGroupNotFoundFault(_inner) => _inner.fmt(f),
            Self::StorageQuotaExceededFault(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::aws_smithy_types::error::metadata::ProvideErrorMetadata for RestoreDBClusterFromSnapshotError {
    fn meta(&self) -> &::aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DbClusterAlreadyExistsFault(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::DbClusterParameterGroupNotFoundFault(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::DbClusterQuotaExceededFault(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::DbClusterSnapshotNotFoundFault(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::DbSnapshotNotFoundFault(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::DbSubnetGroupNotFoundFault(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InsufficientDbClusterCapacityFault(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InsufficientStorageClusterCapacityFault(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidDbClusterSnapshotStateFault(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidDbSnapshotStateFault(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidRestoreFault(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidSubnet(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidVpcNetworkStateFault(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::KmsKeyNotAccessibleFault(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::OptionGroupNotFoundFault(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::StorageQuotaExceededFault(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::Unhandled(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
        }
    }
}
impl ::aws_http::request_id::RequestId for crate::operation::restore_db_cluster_from_snapshot::RestoreDBClusterFromSnapshotError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl ::aws_smithy_types::retry::ProvideErrorKind for RestoreDBClusterFromSnapshotError {
    fn code(&self) -> ::std::option::Option<&str> {
        ::aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> ::std::option::Option<::aws_smithy_types::retry::ErrorKind> {
        ::std::option::Option::None
    }
}
impl RestoreDBClusterFromSnapshotError {
    /// Creates the `RestoreDBClusterFromSnapshotError::Unhandled` variant from any error type.
    pub fn unhandled(
        err: impl ::std::convert::Into<::std::boxed::Box<dyn ::std::error::Error + ::std::marker::Send + ::std::marker::Sync + 'static>>,
    ) -> Self {
        Self::Unhandled(::aws_smithy_types::error::Unhandled::builder().source(err).build())
    }

    /// Creates the `RestoreDBClusterFromSnapshotError::Unhandled` variant from a `::aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: ::aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(::aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &::aws_smithy_types::error::ErrorMetadata {
        use ::aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DbClusterAlreadyExistsFault(e) => e.meta(),
            Self::DbClusterParameterGroupNotFoundFault(e) => e.meta(),
            Self::DbClusterQuotaExceededFault(e) => e.meta(),
            Self::DbClusterSnapshotNotFoundFault(e) => e.meta(),
            Self::DbSnapshotNotFoundFault(e) => e.meta(),
            Self::DbSubnetGroupNotFoundFault(e) => e.meta(),
            Self::InsufficientDbClusterCapacityFault(e) => e.meta(),
            Self::InsufficientStorageClusterCapacityFault(e) => e.meta(),
            Self::InvalidDbClusterSnapshotStateFault(e) => e.meta(),
            Self::InvalidDbSnapshotStateFault(e) => e.meta(),
            Self::InvalidRestoreFault(e) => e.meta(),
            Self::InvalidSubnet(e) => e.meta(),
            Self::InvalidVpcNetworkStateFault(e) => e.meta(),
            Self::KmsKeyNotAccessibleFault(e) => e.meta(),
            Self::OptionGroupNotFoundFault(e) => e.meta(),
            Self::StorageQuotaExceededFault(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `RestoreDBClusterFromSnapshotError::DbClusterAlreadyExistsFault`.
    pub fn is_db_cluster_already_exists_fault(&self) -> bool {
        matches!(self, Self::DbClusterAlreadyExistsFault(_))
    }
    /// Returns `true` if the error kind is `RestoreDBClusterFromSnapshotError::DbClusterParameterGroupNotFoundFault`.
    pub fn is_db_cluster_parameter_group_not_found_fault(&self) -> bool {
        matches!(self, Self::DbClusterParameterGroupNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `RestoreDBClusterFromSnapshotError::DbClusterQuotaExceededFault`.
    pub fn is_db_cluster_quota_exceeded_fault(&self) -> bool {
        matches!(self, Self::DbClusterQuotaExceededFault(_))
    }
    /// Returns `true` if the error kind is `RestoreDBClusterFromSnapshotError::DbClusterSnapshotNotFoundFault`.
    pub fn is_db_cluster_snapshot_not_found_fault(&self) -> bool {
        matches!(self, Self::DbClusterSnapshotNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `RestoreDBClusterFromSnapshotError::DbSnapshotNotFoundFault`.
    pub fn is_db_snapshot_not_found_fault(&self) -> bool {
        matches!(self, Self::DbSnapshotNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `RestoreDBClusterFromSnapshotError::DbSubnetGroupNotFoundFault`.
    pub fn is_db_subnet_group_not_found_fault(&self) -> bool {
        matches!(self, Self::DbSubnetGroupNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `RestoreDBClusterFromSnapshotError::InsufficientDbClusterCapacityFault`.
    pub fn is_insufficient_db_cluster_capacity_fault(&self) -> bool {
        matches!(self, Self::InsufficientDbClusterCapacityFault(_))
    }
    /// Returns `true` if the error kind is `RestoreDBClusterFromSnapshotError::InsufficientStorageClusterCapacityFault`.
    pub fn is_insufficient_storage_cluster_capacity_fault(&self) -> bool {
        matches!(self, Self::InsufficientStorageClusterCapacityFault(_))
    }
    /// Returns `true` if the error kind is `RestoreDBClusterFromSnapshotError::InvalidDbClusterSnapshotStateFault`.
    pub fn is_invalid_db_cluster_snapshot_state_fault(&self) -> bool {
        matches!(self, Self::InvalidDbClusterSnapshotStateFault(_))
    }
    /// Returns `true` if the error kind is `RestoreDBClusterFromSnapshotError::InvalidDbSnapshotStateFault`.
    pub fn is_invalid_db_snapshot_state_fault(&self) -> bool {
        matches!(self, Self::InvalidDbSnapshotStateFault(_))
    }
    /// Returns `true` if the error kind is `RestoreDBClusterFromSnapshotError::InvalidRestoreFault`.
    pub fn is_invalid_restore_fault(&self) -> bool {
        matches!(self, Self::InvalidRestoreFault(_))
    }
    /// Returns `true` if the error kind is `RestoreDBClusterFromSnapshotError::InvalidSubnet`.
    pub fn is_invalid_subnet(&self) -> bool {
        matches!(self, Self::InvalidSubnet(_))
    }
    /// Returns `true` if the error kind is `RestoreDBClusterFromSnapshotError::InvalidVpcNetworkStateFault`.
    pub fn is_invalid_vpc_network_state_fault(&self) -> bool {
        matches!(self, Self::InvalidVpcNetworkStateFault(_))
    }
    /// Returns `true` if the error kind is `RestoreDBClusterFromSnapshotError::KmsKeyNotAccessibleFault`.
    pub fn is_kms_key_not_accessible_fault(&self) -> bool {
        matches!(self, Self::KmsKeyNotAccessibleFault(_))
    }
    /// Returns `true` if the error kind is `RestoreDBClusterFromSnapshotError::OptionGroupNotFoundFault`.
    pub fn is_option_group_not_found_fault(&self) -> bool {
        matches!(self, Self::OptionGroupNotFoundFault(_))
    }
    /// Returns `true` if the error kind is `RestoreDBClusterFromSnapshotError::StorageQuotaExceededFault`.
    pub fn is_storage_quota_exceeded_fault(&self) -> bool {
        matches!(self, Self::StorageQuotaExceededFault(_))
    }
}
impl ::std::error::Error for RestoreDBClusterFromSnapshotError {
    fn source(&self) -> ::std::option::Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            Self::DbClusterAlreadyExistsFault(_inner) => ::std::option::Option::Some(_inner),
            Self::DbClusterParameterGroupNotFoundFault(_inner) => ::std::option::Option::Some(_inner),
            Self::DbClusterQuotaExceededFault(_inner) => ::std::option::Option::Some(_inner),
            Self::DbClusterSnapshotNotFoundFault(_inner) => ::std::option::Option::Some(_inner),
            Self::DbSnapshotNotFoundFault(_inner) => ::std::option::Option::Some(_inner),
            Self::DbSubnetGroupNotFoundFault(_inner) => ::std::option::Option::Some(_inner),
            Self::InsufficientDbClusterCapacityFault(_inner) => ::std::option::Option::Some(_inner),
            Self::InsufficientStorageClusterCapacityFault(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidDbClusterSnapshotStateFault(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidDbSnapshotStateFault(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidRestoreFault(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidSubnet(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidVpcNetworkStateFault(_inner) => ::std::option::Option::Some(_inner),
            Self::KmsKeyNotAccessibleFault(_inner) => ::std::option::Option::Some(_inner),
            Self::OptionGroupNotFoundFault(_inner) => ::std::option::Option::Some(_inner),
            Self::StorageQuotaExceededFault(_inner) => ::std::option::Option::Some(_inner),
            Self::Unhandled(_inner) => ::std::option::Option::Some(_inner),
        }
    }
}

pub use crate::operation::restore_db_cluster_from_snapshot::_restore_db_cluster_from_snapshot_output::RestoreDbClusterFromSnapshotOutput;

pub use crate::operation::restore_db_cluster_from_snapshot::_restore_db_cluster_from_snapshot_input::RestoreDbClusterFromSnapshotInput;

mod _restore_db_cluster_from_snapshot_input;

mod _restore_db_cluster_from_snapshot_output;

/// Builders
pub mod builders;
