// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeNotificationRuleOutput {
    /// <p>The Amazon Resource Name (ARN) of the notification rule.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The name of the notification rule.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>A list of the event types associated with the notification rule.</p>
    #[doc(hidden)]
    pub event_types: std::option::Option<std::vec::Vec<crate::types::EventTypeSummary>>,
    /// <p>The Amazon Resource Name (ARN) of the resource associated with the notification rule.</p>
    #[doc(hidden)]
    pub resource: std::option::Option<std::string::String>,
    /// <p>A list of the Chatbot topics and Chatbot clients associated with the notification rule.</p>
    #[doc(hidden)]
    pub targets: std::option::Option<std::vec::Vec<crate::types::TargetSummary>>,
    /// <p>The level of detail included in the notifications for this resource. BASIC will include only the contents of the event as it would appear in Amazon CloudWatch. FULL will include any supplemental information provided by AWS CodeStar Notifications and/or the service for the resource for which the notification is created.</p>
    #[doc(hidden)]
    pub detail_type: std::option::Option<crate::types::DetailType>,
    /// <p>The name or email alias of the person who created the notification rule.</p>
    #[doc(hidden)]
    pub created_by: std::option::Option<std::string::String>,
    /// <p>The status of the notification rule. Valid statuses are on (sending notifications) or off (not sending notifications).</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::types::NotificationRuleStatus>,
    /// <p>The date and time the notification rule was created, in timestamp format.</p>
    #[doc(hidden)]
    pub created_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The date and time the notification rule was most recently updated, in timestamp format.</p>
    #[doc(hidden)]
    pub last_modified_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The tags associated with the notification rule.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    _request_id: Option<String>,
}
impl DescribeNotificationRuleOutput {
    /// <p>The Amazon Resource Name (ARN) of the notification rule.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The name of the notification rule.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A list of the event types associated with the notification rule.</p>
    pub fn event_types(&self) -> std::option::Option<&[crate::types::EventTypeSummary]> {
        self.event_types.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the resource associated with the notification rule.</p>
    pub fn resource(&self) -> std::option::Option<&str> {
        self.resource.as_deref()
    }
    /// <p>A list of the Chatbot topics and Chatbot clients associated with the notification rule.</p>
    pub fn targets(&self) -> std::option::Option<&[crate::types::TargetSummary]> {
        self.targets.as_deref()
    }
    /// <p>The level of detail included in the notifications for this resource. BASIC will include only the contents of the event as it would appear in Amazon CloudWatch. FULL will include any supplemental information provided by AWS CodeStar Notifications and/or the service for the resource for which the notification is created.</p>
    pub fn detail_type(&self) -> std::option::Option<&crate::types::DetailType> {
        self.detail_type.as_ref()
    }
    /// <p>The name or email alias of the person who created the notification rule.</p>
    pub fn created_by(&self) -> std::option::Option<&str> {
        self.created_by.as_deref()
    }
    /// <p>The status of the notification rule. Valid statuses are on (sending notifications) or off (not sending notifications).</p>
    pub fn status(&self) -> std::option::Option<&crate::types::NotificationRuleStatus> {
        self.status.as_ref()
    }
    /// <p>The date and time the notification rule was created, in timestamp format.</p>
    pub fn created_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_timestamp.as_ref()
    }
    /// <p>The date and time the notification rule was most recently updated, in timestamp format.</p>
    pub fn last_modified_timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modified_timestamp.as_ref()
    }
    /// <p>The tags associated with the notification rule.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
impl std::fmt::Debug for DescribeNotificationRuleOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeNotificationRuleOutput");
        formatter.field("arn", &self.arn);
        formatter.field("name", &"*** Sensitive Data Redacted ***");
        formatter.field("event_types", &self.event_types);
        formatter.field("resource", &self.resource);
        formatter.field("targets", &self.targets);
        formatter.field("detail_type", &self.detail_type);
        formatter.field("created_by", &self.created_by);
        formatter.field("status", &self.status);
        formatter.field("created_timestamp", &self.created_timestamp);
        formatter.field("last_modified_timestamp", &self.last_modified_timestamp);
        formatter.field("tags", &self.tags);
        formatter.field("_request_id", &self._request_id);
        formatter.finish()
    }
}
impl aws_http::request_id::RequestId for DescribeNotificationRuleOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
impl DescribeNotificationRuleOutput {
    /// Creates a new builder-style object to manufacture [`DescribeNotificationRuleOutput`](crate::operation::describe_notification_rule::DescribeNotificationRuleOutput).
    pub fn builder(
    ) -> crate::operation::describe_notification_rule::builders::DescribeNotificationRuleOutputBuilder
    {
        crate::operation::describe_notification_rule::builders::DescribeNotificationRuleOutputBuilder::default()
    }
}

/// A builder for [`DescribeNotificationRuleOutput`](crate::operation::describe_notification_rule::DescribeNotificationRuleOutput).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
pub struct DescribeNotificationRuleOutputBuilder {
    pub(crate) arn: std::option::Option<std::string::String>,
    pub(crate) name: std::option::Option<std::string::String>,
    pub(crate) event_types: std::option::Option<std::vec::Vec<crate::types::EventTypeSummary>>,
    pub(crate) resource: std::option::Option<std::string::String>,
    pub(crate) targets: std::option::Option<std::vec::Vec<crate::types::TargetSummary>>,
    pub(crate) detail_type: std::option::Option<crate::types::DetailType>,
    pub(crate) created_by: std::option::Option<std::string::String>,
    pub(crate) status: std::option::Option<crate::types::NotificationRuleStatus>,
    pub(crate) created_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    pub(crate) last_modified_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    pub(crate) tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    _request_id: Option<String>,
}
impl DescribeNotificationRuleOutputBuilder {
    /// <p>The Amazon Resource Name (ARN) of the notification rule.</p>
    pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
        self.arn = Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the notification rule.</p>
    pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.arn = input;
        self
    }
    /// <p>The name of the notification rule.</p>
    pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
        self.name = Some(input.into());
        self
    }
    /// <p>The name of the notification rule.</p>
    pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.name = input;
        self
    }
    /// Appends an item to `event_types`.
    ///
    /// To override the contents of this collection use [`set_event_types`](Self::set_event_types).
    ///
    /// <p>A list of the event types associated with the notification rule.</p>
    pub fn event_types(mut self, input: crate::types::EventTypeSummary) -> Self {
        let mut v = self.event_types.unwrap_or_default();
        v.push(input);
        self.event_types = Some(v);
        self
    }
    /// <p>A list of the event types associated with the notification rule.</p>
    pub fn set_event_types(
        mut self,
        input: std::option::Option<std::vec::Vec<crate::types::EventTypeSummary>>,
    ) -> Self {
        self.event_types = input;
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the resource associated with the notification rule.</p>
    pub fn resource(mut self, input: impl Into<std::string::String>) -> Self {
        self.resource = Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the resource associated with the notification rule.</p>
    pub fn set_resource(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.resource = input;
        self
    }
    /// Appends an item to `targets`.
    ///
    /// To override the contents of this collection use [`set_targets`](Self::set_targets).
    ///
    /// <p>A list of the Chatbot topics and Chatbot clients associated with the notification rule.</p>
    pub fn targets(mut self, input: crate::types::TargetSummary) -> Self {
        let mut v = self.targets.unwrap_or_default();
        v.push(input);
        self.targets = Some(v);
        self
    }
    /// <p>A list of the Chatbot topics and Chatbot clients associated with the notification rule.</p>
    pub fn set_targets(
        mut self,
        input: std::option::Option<std::vec::Vec<crate::types::TargetSummary>>,
    ) -> Self {
        self.targets = input;
        self
    }
    /// <p>The level of detail included in the notifications for this resource. BASIC will include only the contents of the event as it would appear in Amazon CloudWatch. FULL will include any supplemental information provided by AWS CodeStar Notifications and/or the service for the resource for which the notification is created.</p>
    pub fn detail_type(mut self, input: crate::types::DetailType) -> Self {
        self.detail_type = Some(input);
        self
    }
    /// <p>The level of detail included in the notifications for this resource. BASIC will include only the contents of the event as it would appear in Amazon CloudWatch. FULL will include any supplemental information provided by AWS CodeStar Notifications and/or the service for the resource for which the notification is created.</p>
    pub fn set_detail_type(mut self, input: std::option::Option<crate::types::DetailType>) -> Self {
        self.detail_type = input;
        self
    }
    /// <p>The name or email alias of the person who created the notification rule.</p>
    pub fn created_by(mut self, input: impl Into<std::string::String>) -> Self {
        self.created_by = Some(input.into());
        self
    }
    /// <p>The name or email alias of the person who created the notification rule.</p>
    pub fn set_created_by(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.created_by = input;
        self
    }
    /// <p>The status of the notification rule. Valid statuses are on (sending notifications) or off (not sending notifications).</p>
    pub fn status(mut self, input: crate::types::NotificationRuleStatus) -> Self {
        self.status = Some(input);
        self
    }
    /// <p>The status of the notification rule. Valid statuses are on (sending notifications) or off (not sending notifications).</p>
    pub fn set_status(
        mut self,
        input: std::option::Option<crate::types::NotificationRuleStatus>,
    ) -> Self {
        self.status = input;
        self
    }
    /// <p>The date and time the notification rule was created, in timestamp format.</p>
    pub fn created_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
        self.created_timestamp = Some(input);
        self
    }
    /// <p>The date and time the notification rule was created, in timestamp format.</p>
    pub fn set_created_timestamp(
        mut self,
        input: std::option::Option<aws_smithy_types::DateTime>,
    ) -> Self {
        self.created_timestamp = input;
        self
    }
    /// <p>The date and time the notification rule was most recently updated, in timestamp format.</p>
    pub fn last_modified_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
        self.last_modified_timestamp = Some(input);
        self
    }
    /// <p>The date and time the notification rule was most recently updated, in timestamp format.</p>
    pub fn set_last_modified_timestamp(
        mut self,
        input: std::option::Option<aws_smithy_types::DateTime>,
    ) -> Self {
        self.last_modified_timestamp = input;
        self
    }
    /// Adds a key-value pair to `tags`.
    ///
    /// To override the contents of this collection use [`set_tags`](Self::set_tags).
    ///
    /// <p>The tags associated with the notification rule.</p>
    pub fn tags(
        mut self,
        k: impl Into<std::string::String>,
        v: impl Into<std::string::String>,
    ) -> Self {
        let mut hash_map = self.tags.unwrap_or_default();
        hash_map.insert(k.into(), v.into());
        self.tags = Some(hash_map);
        self
    }
    /// <p>The tags associated with the notification rule.</p>
    pub fn set_tags(
        mut self,
        input: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    ) -> Self {
        self.tags = input;
        self
    }
    pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
        self._request_id = Some(request_id.into());
        self
    }

    pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
        self._request_id = request_id;
        self
    }
    /// Consumes the builder and constructs a [`DescribeNotificationRuleOutput`](crate::operation::describe_notification_rule::DescribeNotificationRuleOutput).
    pub fn build(
        self,
    ) -> crate::operation::describe_notification_rule::DescribeNotificationRuleOutput {
        crate::operation::describe_notification_rule::DescribeNotificationRuleOutput {
            arn: self.arn,
            name: self.name,
            event_types: self.event_types,
            resource: self.resource,
            targets: self.targets,
            detail_type: self.detail_type,
            created_by: self.created_by,
            status: self.status,
            created_timestamp: self.created_timestamp,
            last_modified_timestamp: self.last_modified_timestamp,
            tags: self.tags,
            _request_id: self._request_id,
        }
    }
}
impl std::fmt::Debug for DescribeNotificationRuleOutputBuilder {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeNotificationRuleOutputBuilder");
        formatter.field("arn", &self.arn);
        formatter.field("name", &"*** Sensitive Data Redacted ***");
        formatter.field("event_types", &self.event_types);
        formatter.field("resource", &self.resource);
        formatter.field("targets", &self.targets);
        formatter.field("detail_type", &self.detail_type);
        formatter.field("created_by", &self.created_by);
        formatter.field("status", &self.status);
        formatter.field("created_timestamp", &self.created_timestamp);
        formatter.field("last_modified_timestamp", &self.last_modified_timestamp);
        formatter.field("tags", &self.tags);
        formatter.field("_request_id", &self._request_id);
        formatter.finish()
    }
}
