// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Specifies the method setting properties.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct MethodSetting {
    /// <p>Specifies whether Amazon CloudWatch metrics are enabled for this method.</p>
    pub metrics_enabled: bool,
    /// <p>Specifies the logging level for this method, which affects the log entries pushed to Amazon CloudWatch Logs. Valid values are <code>OFF</code>, <code>ERROR</code>, and <code>INFO</code>. Choose <code>ERROR</code> to write only error-level entries to CloudWatch Logs, or choose <code>INFO</code> to include all <code>ERROR</code> events as well as extra informational events.</p>
    pub logging_level: ::std::option::Option<::std::string::String>,
    /// <p>Specifies whether data trace logging is enabled for this method, which affects the log entries pushed to Amazon CloudWatch Logs.</p>
    pub data_trace_enabled: bool,
    /// <p>Specifies the throttling burst limit.</p>
    pub throttling_burst_limit: i32,
    /// <p>Specifies the throttling rate limit.</p>
    pub throttling_rate_limit: f64,
    /// <p>Specifies whether responses should be cached and returned for requests. A cache cluster must be enabled on the stage for responses to be cached.</p>
    pub caching_enabled: bool,
    /// <p>Specifies the time to live (TTL), in seconds, for cached responses. The higher the TTL, the longer the response will be cached.</p>
    pub cache_ttl_in_seconds: i32,
    /// <p>Specifies whether the cached responses are encrypted.</p>
    pub cache_data_encrypted: bool,
    /// <p>Specifies whether authorization is required for a cache invalidation request.</p>
    pub require_authorization_for_cache_control: bool,
    /// <p>Specifies how to handle unauthorized requests for cache invalidation.</p>
    pub unauthorized_cache_control_header_strategy: ::std::option::Option<crate::types::UnauthorizedCacheControlHeaderStrategy>,
}
impl MethodSetting {
    /// <p>Specifies whether Amazon CloudWatch metrics are enabled for this method.</p>
    pub fn metrics_enabled(&self) -> bool {
        self.metrics_enabled
    }
    /// <p>Specifies the logging level for this method, which affects the log entries pushed to Amazon CloudWatch Logs. Valid values are <code>OFF</code>, <code>ERROR</code>, and <code>INFO</code>. Choose <code>ERROR</code> to write only error-level entries to CloudWatch Logs, or choose <code>INFO</code> to include all <code>ERROR</code> events as well as extra informational events.</p>
    pub fn logging_level(&self) -> ::std::option::Option<&str> {
        self.logging_level.as_deref()
    }
    /// <p>Specifies whether data trace logging is enabled for this method, which affects the log entries pushed to Amazon CloudWatch Logs.</p>
    pub fn data_trace_enabled(&self) -> bool {
        self.data_trace_enabled
    }
    /// <p>Specifies the throttling burst limit.</p>
    pub fn throttling_burst_limit(&self) -> i32 {
        self.throttling_burst_limit
    }
    /// <p>Specifies the throttling rate limit.</p>
    pub fn throttling_rate_limit(&self) -> f64 {
        self.throttling_rate_limit
    }
    /// <p>Specifies whether responses should be cached and returned for requests. A cache cluster must be enabled on the stage for responses to be cached.</p>
    pub fn caching_enabled(&self) -> bool {
        self.caching_enabled
    }
    /// <p>Specifies the time to live (TTL), in seconds, for cached responses. The higher the TTL, the longer the response will be cached.</p>
    pub fn cache_ttl_in_seconds(&self) -> i32 {
        self.cache_ttl_in_seconds
    }
    /// <p>Specifies whether the cached responses are encrypted.</p>
    pub fn cache_data_encrypted(&self) -> bool {
        self.cache_data_encrypted
    }
    /// <p>Specifies whether authorization is required for a cache invalidation request.</p>
    pub fn require_authorization_for_cache_control(&self) -> bool {
        self.require_authorization_for_cache_control
    }
    /// <p>Specifies how to handle unauthorized requests for cache invalidation.</p>
    pub fn unauthorized_cache_control_header_strategy(&self) -> ::std::option::Option<&crate::types::UnauthorizedCacheControlHeaderStrategy> {
        self.unauthorized_cache_control_header_strategy.as_ref()
    }
}
impl MethodSetting {
    /// Creates a new builder-style object to manufacture [`MethodSetting`](crate::types::MethodSetting).
    pub fn builder() -> crate::types::builders::MethodSettingBuilder {
        crate::types::builders::MethodSettingBuilder::default()
    }
}

/// A builder for [`MethodSetting`](crate::types::MethodSetting).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct MethodSettingBuilder {
    pub(crate) metrics_enabled: ::std::option::Option<bool>,
    pub(crate) logging_level: ::std::option::Option<::std::string::String>,
    pub(crate) data_trace_enabled: ::std::option::Option<bool>,
    pub(crate) throttling_burst_limit: ::std::option::Option<i32>,
    pub(crate) throttling_rate_limit: ::std::option::Option<f64>,
    pub(crate) caching_enabled: ::std::option::Option<bool>,
    pub(crate) cache_ttl_in_seconds: ::std::option::Option<i32>,
    pub(crate) cache_data_encrypted: ::std::option::Option<bool>,
    pub(crate) require_authorization_for_cache_control: ::std::option::Option<bool>,
    pub(crate) unauthorized_cache_control_header_strategy: ::std::option::Option<crate::types::UnauthorizedCacheControlHeaderStrategy>,
}
impl MethodSettingBuilder {
    /// <p>Specifies whether Amazon CloudWatch metrics are enabled for this method.</p>
    pub fn metrics_enabled(mut self, input: bool) -> Self {
        self.metrics_enabled = ::std::option::Option::Some(input);
        self
    }
    /// <p>Specifies whether Amazon CloudWatch metrics are enabled for this method.</p>
    pub fn set_metrics_enabled(mut self, input: ::std::option::Option<bool>) -> Self {
        self.metrics_enabled = input;
        self
    }
    /// <p>Specifies whether Amazon CloudWatch metrics are enabled for this method.</p>
    pub fn get_metrics_enabled(&self) -> &::std::option::Option<bool> {
        &self.metrics_enabled
    }
    /// <p>Specifies the logging level for this method, which affects the log entries pushed to Amazon CloudWatch Logs. Valid values are <code>OFF</code>, <code>ERROR</code>, and <code>INFO</code>. Choose <code>ERROR</code> to write only error-level entries to CloudWatch Logs, or choose <code>INFO</code> to include all <code>ERROR</code> events as well as extra informational events.</p>
    pub fn logging_level(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.logging_level = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Specifies the logging level for this method, which affects the log entries pushed to Amazon CloudWatch Logs. Valid values are <code>OFF</code>, <code>ERROR</code>, and <code>INFO</code>. Choose <code>ERROR</code> to write only error-level entries to CloudWatch Logs, or choose <code>INFO</code> to include all <code>ERROR</code> events as well as extra informational events.</p>
    pub fn set_logging_level(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.logging_level = input;
        self
    }
    /// <p>Specifies the logging level for this method, which affects the log entries pushed to Amazon CloudWatch Logs. Valid values are <code>OFF</code>, <code>ERROR</code>, and <code>INFO</code>. Choose <code>ERROR</code> to write only error-level entries to CloudWatch Logs, or choose <code>INFO</code> to include all <code>ERROR</code> events as well as extra informational events.</p>
    pub fn get_logging_level(&self) -> &::std::option::Option<::std::string::String> {
        &self.logging_level
    }
    /// <p>Specifies whether data trace logging is enabled for this method, which affects the log entries pushed to Amazon CloudWatch Logs.</p>
    pub fn data_trace_enabled(mut self, input: bool) -> Self {
        self.data_trace_enabled = ::std::option::Option::Some(input);
        self
    }
    /// <p>Specifies whether data trace logging is enabled for this method, which affects the log entries pushed to Amazon CloudWatch Logs.</p>
    pub fn set_data_trace_enabled(mut self, input: ::std::option::Option<bool>) -> Self {
        self.data_trace_enabled = input;
        self
    }
    /// <p>Specifies whether data trace logging is enabled for this method, which affects the log entries pushed to Amazon CloudWatch Logs.</p>
    pub fn get_data_trace_enabled(&self) -> &::std::option::Option<bool> {
        &self.data_trace_enabled
    }
    /// <p>Specifies the throttling burst limit.</p>
    pub fn throttling_burst_limit(mut self, input: i32) -> Self {
        self.throttling_burst_limit = ::std::option::Option::Some(input);
        self
    }
    /// <p>Specifies the throttling burst limit.</p>
    pub fn set_throttling_burst_limit(mut self, input: ::std::option::Option<i32>) -> Self {
        self.throttling_burst_limit = input;
        self
    }
    /// <p>Specifies the throttling burst limit.</p>
    pub fn get_throttling_burst_limit(&self) -> &::std::option::Option<i32> {
        &self.throttling_burst_limit
    }
    /// <p>Specifies the throttling rate limit.</p>
    pub fn throttling_rate_limit(mut self, input: f64) -> Self {
        self.throttling_rate_limit = ::std::option::Option::Some(input);
        self
    }
    /// <p>Specifies the throttling rate limit.</p>
    pub fn set_throttling_rate_limit(mut self, input: ::std::option::Option<f64>) -> Self {
        self.throttling_rate_limit = input;
        self
    }
    /// <p>Specifies the throttling rate limit.</p>
    pub fn get_throttling_rate_limit(&self) -> &::std::option::Option<f64> {
        &self.throttling_rate_limit
    }
    /// <p>Specifies whether responses should be cached and returned for requests. A cache cluster must be enabled on the stage for responses to be cached.</p>
    pub fn caching_enabled(mut self, input: bool) -> Self {
        self.caching_enabled = ::std::option::Option::Some(input);
        self
    }
    /// <p>Specifies whether responses should be cached and returned for requests. A cache cluster must be enabled on the stage for responses to be cached.</p>
    pub fn set_caching_enabled(mut self, input: ::std::option::Option<bool>) -> Self {
        self.caching_enabled = input;
        self
    }
    /// <p>Specifies whether responses should be cached and returned for requests. A cache cluster must be enabled on the stage for responses to be cached.</p>
    pub fn get_caching_enabled(&self) -> &::std::option::Option<bool> {
        &self.caching_enabled
    }
    /// <p>Specifies the time to live (TTL), in seconds, for cached responses. The higher the TTL, the longer the response will be cached.</p>
    pub fn cache_ttl_in_seconds(mut self, input: i32) -> Self {
        self.cache_ttl_in_seconds = ::std::option::Option::Some(input);
        self
    }
    /// <p>Specifies the time to live (TTL), in seconds, for cached responses. The higher the TTL, the longer the response will be cached.</p>
    pub fn set_cache_ttl_in_seconds(mut self, input: ::std::option::Option<i32>) -> Self {
        self.cache_ttl_in_seconds = input;
        self
    }
    /// <p>Specifies the time to live (TTL), in seconds, for cached responses. The higher the TTL, the longer the response will be cached.</p>
    pub fn get_cache_ttl_in_seconds(&self) -> &::std::option::Option<i32> {
        &self.cache_ttl_in_seconds
    }
    /// <p>Specifies whether the cached responses are encrypted.</p>
    pub fn cache_data_encrypted(mut self, input: bool) -> Self {
        self.cache_data_encrypted = ::std::option::Option::Some(input);
        self
    }
    /// <p>Specifies whether the cached responses are encrypted.</p>
    pub fn set_cache_data_encrypted(mut self, input: ::std::option::Option<bool>) -> Self {
        self.cache_data_encrypted = input;
        self
    }
    /// <p>Specifies whether the cached responses are encrypted.</p>
    pub fn get_cache_data_encrypted(&self) -> &::std::option::Option<bool> {
        &self.cache_data_encrypted
    }
    /// <p>Specifies whether authorization is required for a cache invalidation request.</p>
    pub fn require_authorization_for_cache_control(mut self, input: bool) -> Self {
        self.require_authorization_for_cache_control = ::std::option::Option::Some(input);
        self
    }
    /// <p>Specifies whether authorization is required for a cache invalidation request.</p>
    pub fn set_require_authorization_for_cache_control(mut self, input: ::std::option::Option<bool>) -> Self {
        self.require_authorization_for_cache_control = input;
        self
    }
    /// <p>Specifies whether authorization is required for a cache invalidation request.</p>
    pub fn get_require_authorization_for_cache_control(&self) -> &::std::option::Option<bool> {
        &self.require_authorization_for_cache_control
    }
    /// <p>Specifies how to handle unauthorized requests for cache invalidation.</p>
    pub fn unauthorized_cache_control_header_strategy(mut self, input: crate::types::UnauthorizedCacheControlHeaderStrategy) -> Self {
        self.unauthorized_cache_control_header_strategy = ::std::option::Option::Some(input);
        self
    }
    /// <p>Specifies how to handle unauthorized requests for cache invalidation.</p>
    pub fn set_unauthorized_cache_control_header_strategy(
        mut self,
        input: ::std::option::Option<crate::types::UnauthorizedCacheControlHeaderStrategy>,
    ) -> Self {
        self.unauthorized_cache_control_header_strategy = input;
        self
    }
    /// <p>Specifies how to handle unauthorized requests for cache invalidation.</p>
    pub fn get_unauthorized_cache_control_header_strategy(&self) -> &::std::option::Option<crate::types::UnauthorizedCacheControlHeaderStrategy> {
        &self.unauthorized_cache_control_header_strategy
    }
    /// Consumes the builder and constructs a [`MethodSetting`](crate::types::MethodSetting).
    pub fn build(self) -> crate::types::MethodSetting {
        crate::types::MethodSetting {
            metrics_enabled: self.metrics_enabled.unwrap_or_default(),
            logging_level: self.logging_level,
            data_trace_enabled: self.data_trace_enabled.unwrap_or_default(),
            throttling_burst_limit: self.throttling_burst_limit.unwrap_or_default(),
            throttling_rate_limit: self.throttling_rate_limit.unwrap_or_default(),
            caching_enabled: self.caching_enabled.unwrap_or_default(),
            cache_ttl_in_seconds: self.cache_ttl_in_seconds.unwrap_or_default(),
            cache_data_encrypted: self.cache_data_encrypted.unwrap_or_default(),
            require_authorization_for_cache_control: self.require_authorization_for_cache_control.unwrap_or_default(),
            unauthorized_cache_control_header_strategy: self.unauthorized_cache_control_header_strategy,
        }
    }
}
