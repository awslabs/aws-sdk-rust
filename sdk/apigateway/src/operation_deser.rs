// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_api_key_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateApiKeyOutput, crate::error::CreateApiKeyError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateApiKeyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateApiKeyError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::CreateApiKeyError {
            meta: generic,
            kind: crate::error::CreateApiKeyErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::CreateApiKeyError::unhandled)?;
                output.build()
            }),
        },
        "ConflictException" => crate::error::CreateApiKeyError {
            meta: generic,
            kind: crate::error::CreateApiKeyErrorKind::ConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::conflict_error::Builder::default();
                let _ = response;
                output = crate::json_deser::conflict_exception(response.body().as_ref(), output)
                    .map_err(crate::error::CreateApiKeyError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::CreateApiKeyError {
            meta: generic,
            kind: crate::error::CreateApiKeyErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::limit_exceeded_exception(response.body().as_ref(), output)
                        .map_err(crate::error::CreateApiKeyError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_create_api_key_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::CreateApiKeyError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "NotFoundException" => crate::error::CreateApiKeyError {
            meta: generic,
            kind: crate::error::CreateApiKeyErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::CreateApiKeyError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::CreateApiKeyError {
            meta: generic,
            kind: crate::error::CreateApiKeyErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateApiKeyError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_create_api_key_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::CreateApiKeyError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::CreateApiKeyError {
            meta: generic,
            kind: crate::error::CreateApiKeyErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::CreateApiKeyError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::CreateApiKeyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_api_key_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateApiKeyOutput, crate::error::CreateApiKeyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_api_key_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::create_api_key_deser_operation(response.body().as_ref(), output)
                .map_err(crate::error::CreateApiKeyError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_authorizer_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateAuthorizerOutput, crate::error::CreateAuthorizerError>
{
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateAuthorizerError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateAuthorizerError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::CreateAuthorizerError {
            meta: generic,
            kind: crate::error::CreateAuthorizerErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::CreateAuthorizerError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::CreateAuthorizerError {
            meta: generic,
            kind: crate::error::CreateAuthorizerErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::limit_exceeded_exception(response.body().as_ref(), output)
                        .map_err(crate::error::CreateAuthorizerError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_create_authorizer_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::CreateAuthorizerError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "NotFoundException" => crate::error::CreateAuthorizerError {
            meta: generic,
            kind: crate::error::CreateAuthorizerErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::CreateAuthorizerError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::CreateAuthorizerError {
            meta: generic,
            kind: crate::error::CreateAuthorizerErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateAuthorizerError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_create_authorizer_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::CreateAuthorizerError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::CreateAuthorizerError {
            meta: generic,
            kind: crate::error::CreateAuthorizerErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::CreateAuthorizerError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::CreateAuthorizerError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_authorizer_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateAuthorizerOutput, crate::error::CreateAuthorizerError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_authorizer_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::create_authorizer_deser_operation(response.body().as_ref(), output)
                .map_err(crate::error::CreateAuthorizerError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_base_path_mapping_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateBasePathMappingOutput,
    crate::error::CreateBasePathMappingError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateBasePathMappingError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateBasePathMappingError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::CreateBasePathMappingError {
            meta: generic,
            kind: crate::error::CreateBasePathMappingErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::CreateBasePathMappingError::unhandled)?;
                output.build()
            }),
        },
        "ConflictException" => crate::error::CreateBasePathMappingError {
            meta: generic,
            kind: crate::error::CreateBasePathMappingErrorKind::ConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::conflict_error::Builder::default();
                let _ = response;
                output = crate::json_deser::conflict_exception(response.body().as_ref(), output)
                    .map_err(crate::error::CreateBasePathMappingError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::CreateBasePathMappingError {
            meta: generic,
            kind: crate::error::CreateBasePathMappingErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::CreateBasePathMappingError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => {
            crate::error::CreateBasePathMappingError {
                meta: generic,
                kind: crate::error::CreateBasePathMappingErrorKind::TooManyRequestsError({
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_requests_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::too_many_requests_exception(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateBasePathMappingError::unhandled)?;
                    output = output.set_retry_after_seconds(
                crate::http_serde::deser_header_create_base_path_mapping_retry_after_seconds(response.headers())
                                            .map_err(|_|crate::error::CreateBasePathMappingError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
            );
                    output.build()
                }),
            }
        }
        "UnauthorizedException" => crate::error::CreateBasePathMappingError {
            meta: generic,
            kind: crate::error::CreateBasePathMappingErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::CreateBasePathMappingError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::CreateBasePathMappingError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_base_path_mapping_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateBasePathMappingOutput,
    crate::error::CreateBasePathMappingError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_base_path_mapping_output::Builder::default();
        let _ = response;
        output = crate::json_deser::create_base_path_mapping_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateBasePathMappingError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_deployment_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateDeploymentOutput, crate::error::CreateDeploymentError>
{
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateDeploymentError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateDeploymentError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::CreateDeploymentError {
            meta: generic,
            kind: crate::error::CreateDeploymentErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::CreateDeploymentError::unhandled)?;
                output.build()
            }),
        },
        "ConflictException" => crate::error::CreateDeploymentError {
            meta: generic,
            kind: crate::error::CreateDeploymentErrorKind::ConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::conflict_error::Builder::default();
                let _ = response;
                output = crate::json_deser::conflict_exception(response.body().as_ref(), output)
                    .map_err(crate::error::CreateDeploymentError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::CreateDeploymentError {
            meta: generic,
            kind: crate::error::CreateDeploymentErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::limit_exceeded_exception(response.body().as_ref(), output)
                        .map_err(crate::error::CreateDeploymentError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_create_deployment_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::CreateDeploymentError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "NotFoundException" => crate::error::CreateDeploymentError {
            meta: generic,
            kind: crate::error::CreateDeploymentErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::CreateDeploymentError::unhandled)?;
                output.build()
            }),
        },
        "ServiceUnavailableException" => crate::error::CreateDeploymentError {
            meta: generic,
            kind: crate::error::CreateDeploymentErrorKind::ServiceUnavailableError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_unavailable_error::Builder::default();
                let _ = response;
                output = crate::json_deser::service_unavailable_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateDeploymentError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_create_deployment_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::CreateDeploymentError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::CreateDeploymentError {
            meta: generic,
            kind: crate::error::CreateDeploymentErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateDeploymentError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_create_deployment_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::CreateDeploymentError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::CreateDeploymentError {
            meta: generic,
            kind: crate::error::CreateDeploymentErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::CreateDeploymentError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::CreateDeploymentError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_deployment_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateDeploymentOutput, crate::error::CreateDeploymentError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_deployment_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::create_deployment_deser_operation(response.body().as_ref(), output)
                .map_err(crate::error::CreateDeploymentError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_documentation_part_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateDocumentationPartOutput,
    crate::error::CreateDocumentationPartError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateDocumentationPartError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateDocumentationPartError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "BadRequestException" => crate::error::CreateDocumentationPartError {
            meta: generic,
            kind: crate::error::CreateDocumentationPartErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::CreateDocumentationPartError::unhandled)?;
                output.build()
            }),
        },
        "ConflictException" => crate::error::CreateDocumentationPartError {
            meta: generic,
            kind: crate::error::CreateDocumentationPartErrorKind::ConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::conflict_error::Builder::default();
                let _ = response;
                output = crate::json_deser::conflict_exception(response.body().as_ref(), output)
                    .map_err(crate::error::CreateDocumentationPartError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => {
            crate::error::CreateDocumentationPartError {
                meta: generic,
                kind: crate::error::CreateDocumentationPartErrorKind::LimitExceededError({
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::limit_exceeded_exception(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateDocumentationPartError::unhandled)?;
                    output = output.set_retry_after_seconds(
                crate::http_serde::deser_header_create_documentation_part_retry_after_seconds(response.headers())
                                            .map_err(|_|crate::error::CreateDocumentationPartError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
            );
                    output.build()
                }),
            }
        }
        "NotFoundException" => crate::error::CreateDocumentationPartError {
            meta: generic,
            kind: crate::error::CreateDocumentationPartErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::CreateDocumentationPartError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => {
            crate::error::CreateDocumentationPartError {
                meta: generic,
                kind: crate::error::CreateDocumentationPartErrorKind::TooManyRequestsError({
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_requests_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::too_many_requests_exception(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateDocumentationPartError::unhandled)?;
                    output = output.set_retry_after_seconds(
                crate::http_serde::deser_header_create_documentation_part_retry_after_seconds(response.headers())
                                            .map_err(|_|crate::error::CreateDocumentationPartError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
            );
                    output.build()
                }),
            }
        }
        "UnauthorizedException" => crate::error::CreateDocumentationPartError {
            meta: generic,
            kind: crate::error::CreateDocumentationPartErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::CreateDocumentationPartError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::CreateDocumentationPartError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_documentation_part_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateDocumentationPartOutput,
    crate::error::CreateDocumentationPartError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_documentation_part_output::Builder::default();
        let _ = response;
        output = crate::json_deser::create_documentation_part_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateDocumentationPartError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_documentation_version_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateDocumentationVersionOutput,
    crate::error::CreateDocumentationVersionError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateDocumentationVersionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateDocumentationVersionError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "BadRequestException" => crate::error::CreateDocumentationVersionError {
            meta: generic,
            kind: crate::error::CreateDocumentationVersionErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::CreateDocumentationVersionError::unhandled)?;
                output.build()
            }),
        },
        "ConflictException" => crate::error::CreateDocumentationVersionError {
            meta: generic,
            kind: crate::error::CreateDocumentationVersionErrorKind::ConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::conflict_error::Builder::default();
                let _ = response;
                output = crate::json_deser::conflict_exception(response.body().as_ref(), output)
                    .map_err(crate::error::CreateDocumentationVersionError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::CreateDocumentationVersionError {
            meta: generic,
            kind: crate::error::CreateDocumentationVersionErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::limit_exceeded_exception(response.body().as_ref(), output)
                        .map_err(crate::error::CreateDocumentationVersionError::unhandled)?;
                output = output.set_retry_after_seconds(
                crate::http_serde::deser_header_create_documentation_version_retry_after_seconds(response.headers())
                                            .map_err(|_|crate::error::CreateDocumentationVersionError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
            );
                output.build()
            }),
        },
        "NotFoundException" => crate::error::CreateDocumentationVersionError {
            meta: generic,
            kind: crate::error::CreateDocumentationVersionErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::CreateDocumentationVersionError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::CreateDocumentationVersionError {
            meta: generic,
            kind: crate::error::CreateDocumentationVersionErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateDocumentationVersionError::unhandled)?;
                output = output.set_retry_after_seconds(
                crate::http_serde::deser_header_create_documentation_version_retry_after_seconds(response.headers())
                                            .map_err(|_|crate::error::CreateDocumentationVersionError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
            );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::CreateDocumentationVersionError {
            meta: generic,
            kind: crate::error::CreateDocumentationVersionErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::CreateDocumentationVersionError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::CreateDocumentationVersionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_documentation_version_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateDocumentationVersionOutput,
    crate::error::CreateDocumentationVersionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_documentation_version_output::Builder::default();
        let _ = response;
        output = crate::json_deser::create_documentation_version_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateDocumentationVersionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_domain_name_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateDomainNameOutput, crate::error::CreateDomainNameError>
{
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateDomainNameError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateDomainNameError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::CreateDomainNameError {
            meta: generic,
            kind: crate::error::CreateDomainNameErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::CreateDomainNameError::unhandled)?;
                output.build()
            }),
        },
        "ConflictException" => crate::error::CreateDomainNameError {
            meta: generic,
            kind: crate::error::CreateDomainNameErrorKind::ConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::conflict_error::Builder::default();
                let _ = response;
                output = crate::json_deser::conflict_exception(response.body().as_ref(), output)
                    .map_err(crate::error::CreateDomainNameError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::CreateDomainNameError {
            meta: generic,
            kind: crate::error::CreateDomainNameErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateDomainNameError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_create_domain_name_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::CreateDomainNameError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::CreateDomainNameError {
            meta: generic,
            kind: crate::error::CreateDomainNameErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::CreateDomainNameError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::CreateDomainNameError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_domain_name_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateDomainNameOutput, crate::error::CreateDomainNameError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_domain_name_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::create_domain_name_deser_operation(response.body().as_ref(), output)
                .map_err(crate::error::CreateDomainNameError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_model_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateModelOutput, crate::error::CreateModelError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateModelError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateModelError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::CreateModelError {
            meta: generic,
            kind: crate::error::CreateModelErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::CreateModelError::unhandled)?;
                output.build()
            }),
        },
        "ConflictException" => crate::error::CreateModelError {
            meta: generic,
            kind: crate::error::CreateModelErrorKind::ConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::conflict_error::Builder::default();
                let _ = response;
                output = crate::json_deser::conflict_exception(response.body().as_ref(), output)
                    .map_err(crate::error::CreateModelError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::CreateModelError {
            meta: generic,
            kind: crate::error::CreateModelErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::limit_exceeded_exception(response.body().as_ref(), output)
                        .map_err(crate::error::CreateModelError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_create_model_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::CreateModelError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "NotFoundException" => crate::error::CreateModelError {
            meta: generic,
            kind: crate::error::CreateModelErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::CreateModelError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::CreateModelError {
            meta: generic,
            kind: crate::error::CreateModelErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateModelError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_create_model_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::CreateModelError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::CreateModelError {
            meta: generic,
            kind: crate::error::CreateModelErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::CreateModelError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::CreateModelError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_model_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateModelOutput, crate::error::CreateModelError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_model_output::Builder::default();
        let _ = response;
        output = crate::json_deser::create_model_deser_operation(response.body().as_ref(), output)
            .map_err(crate::error::CreateModelError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_request_validator_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateRequestValidatorOutput,
    crate::error::CreateRequestValidatorError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateRequestValidatorError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateRequestValidatorError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "BadRequestException" => crate::error::CreateRequestValidatorError {
            meta: generic,
            kind: crate::error::CreateRequestValidatorErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::CreateRequestValidatorError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => {
            crate::error::CreateRequestValidatorError {
                meta: generic,
                kind: crate::error::CreateRequestValidatorErrorKind::LimitExceededError({
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::limit_exceeded_exception(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateRequestValidatorError::unhandled)?;
                    output = output.set_retry_after_seconds(
                crate::http_serde::deser_header_create_request_validator_retry_after_seconds(response.headers())
                                            .map_err(|_|crate::error::CreateRequestValidatorError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
            );
                    output.build()
                }),
            }
        }
        "NotFoundException" => crate::error::CreateRequestValidatorError {
            meta: generic,
            kind: crate::error::CreateRequestValidatorErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::CreateRequestValidatorError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => {
            crate::error::CreateRequestValidatorError {
                meta: generic,
                kind: crate::error::CreateRequestValidatorErrorKind::TooManyRequestsError({
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_requests_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::too_many_requests_exception(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateRequestValidatorError::unhandled)?;
                    output = output.set_retry_after_seconds(
                crate::http_serde::deser_header_create_request_validator_retry_after_seconds(response.headers())
                                            .map_err(|_|crate::error::CreateRequestValidatorError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
            );
                    output.build()
                }),
            }
        }
        "UnauthorizedException" => crate::error::CreateRequestValidatorError {
            meta: generic,
            kind: crate::error::CreateRequestValidatorErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::CreateRequestValidatorError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::CreateRequestValidatorError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_request_validator_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateRequestValidatorOutput,
    crate::error::CreateRequestValidatorError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_request_validator_output::Builder::default();
        let _ = response;
        output = crate::json_deser::create_request_validator_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateRequestValidatorError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_resource_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateResourceOutput, crate::error::CreateResourceError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateResourceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateResourceError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::CreateResourceError {
            meta: generic,
            kind: crate::error::CreateResourceErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::CreateResourceError::unhandled)?;
                output.build()
            }),
        },
        "ConflictException" => crate::error::CreateResourceError {
            meta: generic,
            kind: crate::error::CreateResourceErrorKind::ConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::conflict_error::Builder::default();
                let _ = response;
                output = crate::json_deser::conflict_exception(response.body().as_ref(), output)
                    .map_err(crate::error::CreateResourceError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::CreateResourceError {
            meta: generic,
            kind: crate::error::CreateResourceErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::limit_exceeded_exception(response.body().as_ref(), output)
                        .map_err(crate::error::CreateResourceError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_create_resource_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::CreateResourceError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "NotFoundException" => crate::error::CreateResourceError {
            meta: generic,
            kind: crate::error::CreateResourceErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::CreateResourceError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::CreateResourceError {
            meta: generic,
            kind: crate::error::CreateResourceErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateResourceError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_create_resource_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::CreateResourceError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::CreateResourceError {
            meta: generic,
            kind: crate::error::CreateResourceErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::CreateResourceError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::CreateResourceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_resource_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateResourceOutput, crate::error::CreateResourceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_resource_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::create_resource_deser_operation(response.body().as_ref(), output)
                .map_err(crate::error::CreateResourceError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_rest_api_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateRestApiOutput, crate::error::CreateRestApiError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateRestApiError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateRestApiError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::CreateRestApiError {
            meta: generic,
            kind: crate::error::CreateRestApiErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::CreateRestApiError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::CreateRestApiError {
            meta: generic,
            kind: crate::error::CreateRestApiErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::limit_exceeded_exception(response.body().as_ref(), output)
                        .map_err(crate::error::CreateRestApiError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_create_rest_api_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::CreateRestApiError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::CreateRestApiError {
            meta: generic,
            kind: crate::error::CreateRestApiErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateRestApiError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_create_rest_api_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::CreateRestApiError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::CreateRestApiError {
            meta: generic,
            kind: crate::error::CreateRestApiErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::CreateRestApiError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::CreateRestApiError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_rest_api_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateRestApiOutput, crate::error::CreateRestApiError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_rest_api_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::create_rest_api_deser_operation(response.body().as_ref(), output)
                .map_err(crate::error::CreateRestApiError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_stage_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateStageOutput, crate::error::CreateStageError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateStageError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateStageError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::CreateStageError {
            meta: generic,
            kind: crate::error::CreateStageErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::CreateStageError::unhandled)?;
                output.build()
            }),
        },
        "ConflictException" => crate::error::CreateStageError {
            meta: generic,
            kind: crate::error::CreateStageErrorKind::ConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::conflict_error::Builder::default();
                let _ = response;
                output = crate::json_deser::conflict_exception(response.body().as_ref(), output)
                    .map_err(crate::error::CreateStageError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::CreateStageError {
            meta: generic,
            kind: crate::error::CreateStageErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::limit_exceeded_exception(response.body().as_ref(), output)
                        .map_err(crate::error::CreateStageError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_create_stage_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::CreateStageError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "NotFoundException" => crate::error::CreateStageError {
            meta: generic,
            kind: crate::error::CreateStageErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::CreateStageError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::CreateStageError {
            meta: generic,
            kind: crate::error::CreateStageErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateStageError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_create_stage_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::CreateStageError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::CreateStageError {
            meta: generic,
            kind: crate::error::CreateStageErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::CreateStageError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::CreateStageError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_stage_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateStageOutput, crate::error::CreateStageError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_stage_output::Builder::default();
        let _ = response;
        output = crate::json_deser::create_stage_deser_operation(response.body().as_ref(), output)
            .map_err(crate::error::CreateStageError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_usage_plan_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateUsagePlanOutput, crate::error::CreateUsagePlanError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateUsagePlanError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateUsagePlanError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::CreateUsagePlanError {
            meta: generic,
            kind: crate::error::CreateUsagePlanErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::CreateUsagePlanError::unhandled)?;
                output.build()
            }),
        },
        "ConflictException" => crate::error::CreateUsagePlanError {
            meta: generic,
            kind: crate::error::CreateUsagePlanErrorKind::ConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::conflict_error::Builder::default();
                let _ = response;
                output = crate::json_deser::conflict_exception(response.body().as_ref(), output)
                    .map_err(crate::error::CreateUsagePlanError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::CreateUsagePlanError {
            meta: generic,
            kind: crate::error::CreateUsagePlanErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::limit_exceeded_exception(response.body().as_ref(), output)
                        .map_err(crate::error::CreateUsagePlanError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_create_usage_plan_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::CreateUsagePlanError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "NotFoundException" => crate::error::CreateUsagePlanError {
            meta: generic,
            kind: crate::error::CreateUsagePlanErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::CreateUsagePlanError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::CreateUsagePlanError {
            meta: generic,
            kind: crate::error::CreateUsagePlanErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateUsagePlanError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_create_usage_plan_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::CreateUsagePlanError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::CreateUsagePlanError {
            meta: generic,
            kind: crate::error::CreateUsagePlanErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::CreateUsagePlanError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::CreateUsagePlanError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_usage_plan_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateUsagePlanOutput, crate::error::CreateUsagePlanError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_usage_plan_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::create_usage_plan_deser_operation(response.body().as_ref(), output)
                .map_err(crate::error::CreateUsagePlanError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_usage_plan_key_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateUsagePlanKeyOutput,
    crate::error::CreateUsagePlanKeyError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateUsagePlanKeyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateUsagePlanKeyError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::CreateUsagePlanKeyError {
            meta: generic,
            kind: crate::error::CreateUsagePlanKeyErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::CreateUsagePlanKeyError::unhandled)?;
                output.build()
            }),
        },
        "ConflictException" => crate::error::CreateUsagePlanKeyError {
            meta: generic,
            kind: crate::error::CreateUsagePlanKeyErrorKind::ConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::conflict_error::Builder::default();
                let _ = response;
                output = crate::json_deser::conflict_exception(response.body().as_ref(), output)
                    .map_err(crate::error::CreateUsagePlanKeyError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::CreateUsagePlanKeyError {
            meta: generic,
            kind: crate::error::CreateUsagePlanKeyErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::CreateUsagePlanKeyError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::CreateUsagePlanKeyError {
            meta: generic,
            kind: crate::error::CreateUsagePlanKeyErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateUsagePlanKeyError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_create_usage_plan_key_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::CreateUsagePlanKeyError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::CreateUsagePlanKeyError {
            meta: generic,
            kind: crate::error::CreateUsagePlanKeyErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::CreateUsagePlanKeyError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::CreateUsagePlanKeyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_usage_plan_key_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateUsagePlanKeyOutput,
    crate::error::CreateUsagePlanKeyError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_usage_plan_key_output::Builder::default();
        let _ = response;
        output = crate::json_deser::create_usage_plan_key_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateUsagePlanKeyError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_vpc_link_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateVpcLinkOutput, crate::error::CreateVpcLinkError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateVpcLinkError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateVpcLinkError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::CreateVpcLinkError {
            meta: generic,
            kind: crate::error::CreateVpcLinkErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::CreateVpcLinkError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::CreateVpcLinkError {
            meta: generic,
            kind: crate::error::CreateVpcLinkErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateVpcLinkError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_create_vpc_link_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::CreateVpcLinkError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::CreateVpcLinkError {
            meta: generic,
            kind: crate::error::CreateVpcLinkErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::CreateVpcLinkError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::CreateVpcLinkError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_vpc_link_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateVpcLinkOutput, crate::error::CreateVpcLinkError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_vpc_link_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::create_vpc_link_deser_operation(response.body().as_ref(), output)
                .map_err(crate::error::CreateVpcLinkError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_api_key_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteApiKeyOutput, crate::error::DeleteApiKeyError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteApiKeyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteApiKeyError::unhandled(generic)),
    };
    Err(match error_code {
        "NotFoundException" => crate::error::DeleteApiKeyError {
            meta: generic,
            kind: crate::error::DeleteApiKeyErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::DeleteApiKeyError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::DeleteApiKeyError {
            meta: generic,
            kind: crate::error::DeleteApiKeyErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteApiKeyError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_delete_api_key_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::DeleteApiKeyError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::DeleteApiKeyError {
            meta: generic,
            kind: crate::error::DeleteApiKeyErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::DeleteApiKeyError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DeleteApiKeyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_api_key_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteApiKeyOutput, crate::error::DeleteApiKeyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_api_key_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_authorizer_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteAuthorizerOutput, crate::error::DeleteAuthorizerError>
{
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteAuthorizerError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteAuthorizerError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::DeleteAuthorizerError {
            meta: generic,
            kind: crate::error::DeleteAuthorizerErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::DeleteAuthorizerError::unhandled)?;
                output.build()
            }),
        },
        "ConflictException" => crate::error::DeleteAuthorizerError {
            meta: generic,
            kind: crate::error::DeleteAuthorizerErrorKind::ConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::conflict_error::Builder::default();
                let _ = response;
                output = crate::json_deser::conflict_exception(response.body().as_ref(), output)
                    .map_err(crate::error::DeleteAuthorizerError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::DeleteAuthorizerError {
            meta: generic,
            kind: crate::error::DeleteAuthorizerErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::DeleteAuthorizerError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::DeleteAuthorizerError {
            meta: generic,
            kind: crate::error::DeleteAuthorizerErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteAuthorizerError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_delete_authorizer_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::DeleteAuthorizerError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::DeleteAuthorizerError {
            meta: generic,
            kind: crate::error::DeleteAuthorizerErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::DeleteAuthorizerError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DeleteAuthorizerError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_authorizer_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteAuthorizerOutput, crate::error::DeleteAuthorizerError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_authorizer_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_base_path_mapping_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteBasePathMappingOutput,
    crate::error::DeleteBasePathMappingError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteBasePathMappingError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteBasePathMappingError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::DeleteBasePathMappingError {
            meta: generic,
            kind: crate::error::DeleteBasePathMappingErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::DeleteBasePathMappingError::unhandled)?;
                output.build()
            }),
        },
        "ConflictException" => crate::error::DeleteBasePathMappingError {
            meta: generic,
            kind: crate::error::DeleteBasePathMappingErrorKind::ConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::conflict_error::Builder::default();
                let _ = response;
                output = crate::json_deser::conflict_exception(response.body().as_ref(), output)
                    .map_err(crate::error::DeleteBasePathMappingError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::DeleteBasePathMappingError {
            meta: generic,
            kind: crate::error::DeleteBasePathMappingErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::DeleteBasePathMappingError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => {
            crate::error::DeleteBasePathMappingError {
                meta: generic,
                kind: crate::error::DeleteBasePathMappingErrorKind::TooManyRequestsError({
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_requests_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::too_many_requests_exception(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteBasePathMappingError::unhandled)?;
                    output = output.set_retry_after_seconds(
                crate::http_serde::deser_header_delete_base_path_mapping_retry_after_seconds(response.headers())
                                            .map_err(|_|crate::error::DeleteBasePathMappingError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
            );
                    output.build()
                }),
            }
        }
        "UnauthorizedException" => crate::error::DeleteBasePathMappingError {
            meta: generic,
            kind: crate::error::DeleteBasePathMappingErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::DeleteBasePathMappingError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DeleteBasePathMappingError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_base_path_mapping_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteBasePathMappingOutput,
    crate::error::DeleteBasePathMappingError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_base_path_mapping_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_client_certificate_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteClientCertificateOutput,
    crate::error::DeleteClientCertificateError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteClientCertificateError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteClientCertificateError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "BadRequestException" => crate::error::DeleteClientCertificateError {
            meta: generic,
            kind: crate::error::DeleteClientCertificateErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::DeleteClientCertificateError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::DeleteClientCertificateError {
            meta: generic,
            kind: crate::error::DeleteClientCertificateErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::DeleteClientCertificateError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => {
            crate::error::DeleteClientCertificateError {
                meta: generic,
                kind: crate::error::DeleteClientCertificateErrorKind::TooManyRequestsError({
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_requests_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::too_many_requests_exception(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteClientCertificateError::unhandled)?;
                    output = output.set_retry_after_seconds(
                crate::http_serde::deser_header_delete_client_certificate_retry_after_seconds(response.headers())
                                            .map_err(|_|crate::error::DeleteClientCertificateError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
            );
                    output.build()
                }),
            }
        }
        "UnauthorizedException" => crate::error::DeleteClientCertificateError {
            meta: generic,
            kind: crate::error::DeleteClientCertificateErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::DeleteClientCertificateError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DeleteClientCertificateError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_client_certificate_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteClientCertificateOutput,
    crate::error::DeleteClientCertificateError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_client_certificate_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_deployment_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteDeploymentOutput, crate::error::DeleteDeploymentError>
{
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteDeploymentError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteDeploymentError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::DeleteDeploymentError {
            meta: generic,
            kind: crate::error::DeleteDeploymentErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::DeleteDeploymentError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::DeleteDeploymentError {
            meta: generic,
            kind: crate::error::DeleteDeploymentErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::DeleteDeploymentError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::DeleteDeploymentError {
            meta: generic,
            kind: crate::error::DeleteDeploymentErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteDeploymentError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_delete_deployment_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::DeleteDeploymentError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::DeleteDeploymentError {
            meta: generic,
            kind: crate::error::DeleteDeploymentErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::DeleteDeploymentError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DeleteDeploymentError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_deployment_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteDeploymentOutput, crate::error::DeleteDeploymentError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_deployment_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_documentation_part_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteDocumentationPartOutput,
    crate::error::DeleteDocumentationPartError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteDocumentationPartError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteDocumentationPartError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "BadRequestException" => crate::error::DeleteDocumentationPartError {
            meta: generic,
            kind: crate::error::DeleteDocumentationPartErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::DeleteDocumentationPartError::unhandled)?;
                output.build()
            }),
        },
        "ConflictException" => crate::error::DeleteDocumentationPartError {
            meta: generic,
            kind: crate::error::DeleteDocumentationPartErrorKind::ConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::conflict_error::Builder::default();
                let _ = response;
                output = crate::json_deser::conflict_exception(response.body().as_ref(), output)
                    .map_err(crate::error::DeleteDocumentationPartError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::DeleteDocumentationPartError {
            meta: generic,
            kind: crate::error::DeleteDocumentationPartErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::DeleteDocumentationPartError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => {
            crate::error::DeleteDocumentationPartError {
                meta: generic,
                kind: crate::error::DeleteDocumentationPartErrorKind::TooManyRequestsError({
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_requests_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::too_many_requests_exception(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteDocumentationPartError::unhandled)?;
                    output = output.set_retry_after_seconds(
                crate::http_serde::deser_header_delete_documentation_part_retry_after_seconds(response.headers())
                                            .map_err(|_|crate::error::DeleteDocumentationPartError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
            );
                    output.build()
                }),
            }
        }
        "UnauthorizedException" => crate::error::DeleteDocumentationPartError {
            meta: generic,
            kind: crate::error::DeleteDocumentationPartErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::DeleteDocumentationPartError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DeleteDocumentationPartError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_documentation_part_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteDocumentationPartOutput,
    crate::error::DeleteDocumentationPartError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_documentation_part_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_documentation_version_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteDocumentationVersionOutput,
    crate::error::DeleteDocumentationVersionError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteDocumentationVersionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteDocumentationVersionError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "BadRequestException" => crate::error::DeleteDocumentationVersionError {
            meta: generic,
            kind: crate::error::DeleteDocumentationVersionErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::DeleteDocumentationVersionError::unhandled)?;
                output.build()
            }),
        },
        "ConflictException" => crate::error::DeleteDocumentationVersionError {
            meta: generic,
            kind: crate::error::DeleteDocumentationVersionErrorKind::ConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::conflict_error::Builder::default();
                let _ = response;
                output = crate::json_deser::conflict_exception(response.body().as_ref(), output)
                    .map_err(crate::error::DeleteDocumentationVersionError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::DeleteDocumentationVersionError {
            meta: generic,
            kind: crate::error::DeleteDocumentationVersionErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::DeleteDocumentationVersionError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::DeleteDocumentationVersionError {
            meta: generic,
            kind: crate::error::DeleteDocumentationVersionErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteDocumentationVersionError::unhandled)?;
                output = output.set_retry_after_seconds(
                crate::http_serde::deser_header_delete_documentation_version_retry_after_seconds(response.headers())
                                            .map_err(|_|crate::error::DeleteDocumentationVersionError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
            );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::DeleteDocumentationVersionError {
            meta: generic,
            kind: crate::error::DeleteDocumentationVersionErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::DeleteDocumentationVersionError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DeleteDocumentationVersionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_documentation_version_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteDocumentationVersionOutput,
    crate::error::DeleteDocumentationVersionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_documentation_version_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_domain_name_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteDomainNameOutput, crate::error::DeleteDomainNameError>
{
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteDomainNameError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteDomainNameError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::DeleteDomainNameError {
            meta: generic,
            kind: crate::error::DeleteDomainNameErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::DeleteDomainNameError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::DeleteDomainNameError {
            meta: generic,
            kind: crate::error::DeleteDomainNameErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::DeleteDomainNameError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::DeleteDomainNameError {
            meta: generic,
            kind: crate::error::DeleteDomainNameErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteDomainNameError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_delete_domain_name_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::DeleteDomainNameError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::DeleteDomainNameError {
            meta: generic,
            kind: crate::error::DeleteDomainNameErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::DeleteDomainNameError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DeleteDomainNameError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_domain_name_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteDomainNameOutput, crate::error::DeleteDomainNameError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_domain_name_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_gateway_response_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteGatewayResponseOutput,
    crate::error::DeleteGatewayResponseError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteGatewayResponseError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteGatewayResponseError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::DeleteGatewayResponseError {
            meta: generic,
            kind: crate::error::DeleteGatewayResponseErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::DeleteGatewayResponseError::unhandled)?;
                output.build()
            }),
        },
        "ConflictException" => crate::error::DeleteGatewayResponseError {
            meta: generic,
            kind: crate::error::DeleteGatewayResponseErrorKind::ConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::conflict_error::Builder::default();
                let _ = response;
                output = crate::json_deser::conflict_exception(response.body().as_ref(), output)
                    .map_err(crate::error::DeleteGatewayResponseError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::DeleteGatewayResponseError {
            meta: generic,
            kind: crate::error::DeleteGatewayResponseErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::DeleteGatewayResponseError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => {
            crate::error::DeleteGatewayResponseError {
                meta: generic,
                kind: crate::error::DeleteGatewayResponseErrorKind::TooManyRequestsError({
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_requests_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::too_many_requests_exception(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteGatewayResponseError::unhandled)?;
                    output = output.set_retry_after_seconds(
                crate::http_serde::deser_header_delete_gateway_response_retry_after_seconds(response.headers())
                                            .map_err(|_|crate::error::DeleteGatewayResponseError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
            );
                    output.build()
                }),
            }
        }
        "UnauthorizedException" => crate::error::DeleteGatewayResponseError {
            meta: generic,
            kind: crate::error::DeleteGatewayResponseErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::DeleteGatewayResponseError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DeleteGatewayResponseError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_gateway_response_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteGatewayResponseOutput,
    crate::error::DeleteGatewayResponseError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_gateway_response_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_integration_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteIntegrationOutput, crate::error::DeleteIntegrationError>
{
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteIntegrationError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteIntegrationError::unhandled(generic)),
    };
    Err(match error_code {
        "ConflictException" => crate::error::DeleteIntegrationError {
            meta: generic,
            kind: crate::error::DeleteIntegrationErrorKind::ConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::conflict_error::Builder::default();
                let _ = response;
                output = crate::json_deser::conflict_exception(response.body().as_ref(), output)
                    .map_err(crate::error::DeleteIntegrationError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::DeleteIntegrationError {
            meta: generic,
            kind: crate::error::DeleteIntegrationErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::DeleteIntegrationError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::DeleteIntegrationError {
            meta: generic,
            kind: crate::error::DeleteIntegrationErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteIntegrationError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_delete_integration_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::DeleteIntegrationError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::DeleteIntegrationError {
            meta: generic,
            kind: crate::error::DeleteIntegrationErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::DeleteIntegrationError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DeleteIntegrationError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_integration_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteIntegrationOutput, crate::error::DeleteIntegrationError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_integration_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_integration_response_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteIntegrationResponseOutput,
    crate::error::DeleteIntegrationResponseError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteIntegrationResponseError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteIntegrationResponseError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "BadRequestException" => crate::error::DeleteIntegrationResponseError {
            meta: generic,
            kind: crate::error::DeleteIntegrationResponseErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::DeleteIntegrationResponseError::unhandled)?;
                output.build()
            }),
        },
        "ConflictException" => crate::error::DeleteIntegrationResponseError {
            meta: generic,
            kind: crate::error::DeleteIntegrationResponseErrorKind::ConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::conflict_error::Builder::default();
                let _ = response;
                output = crate::json_deser::conflict_exception(response.body().as_ref(), output)
                    .map_err(crate::error::DeleteIntegrationResponseError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::DeleteIntegrationResponseError {
            meta: generic,
            kind: crate::error::DeleteIntegrationResponseErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::DeleteIntegrationResponseError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::DeleteIntegrationResponseError {
            meta: generic,
            kind: crate::error::DeleteIntegrationResponseErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteIntegrationResponseError::unhandled)?;
                output = output.set_retry_after_seconds(
                crate::http_serde::deser_header_delete_integration_response_retry_after_seconds(response.headers())
                                            .map_err(|_|crate::error::DeleteIntegrationResponseError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
            );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::DeleteIntegrationResponseError {
            meta: generic,
            kind: crate::error::DeleteIntegrationResponseErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::DeleteIntegrationResponseError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DeleteIntegrationResponseError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_integration_response_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteIntegrationResponseOutput,
    crate::error::DeleteIntegrationResponseError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_integration_response_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_method_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteMethodOutput, crate::error::DeleteMethodError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteMethodError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteMethodError::unhandled(generic)),
    };
    Err(match error_code {
        "ConflictException" => crate::error::DeleteMethodError {
            meta: generic,
            kind: crate::error::DeleteMethodErrorKind::ConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::conflict_error::Builder::default();
                let _ = response;
                output = crate::json_deser::conflict_exception(response.body().as_ref(), output)
                    .map_err(crate::error::DeleteMethodError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::DeleteMethodError {
            meta: generic,
            kind: crate::error::DeleteMethodErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::DeleteMethodError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::DeleteMethodError {
            meta: generic,
            kind: crate::error::DeleteMethodErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteMethodError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_delete_method_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::DeleteMethodError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::DeleteMethodError {
            meta: generic,
            kind: crate::error::DeleteMethodErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::DeleteMethodError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DeleteMethodError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_method_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteMethodOutput, crate::error::DeleteMethodError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_method_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_method_response_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteMethodResponseOutput,
    crate::error::DeleteMethodResponseError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteMethodResponseError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteMethodResponseError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::DeleteMethodResponseError {
            meta: generic,
            kind: crate::error::DeleteMethodResponseErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::DeleteMethodResponseError::unhandled)?;
                output.build()
            }),
        },
        "ConflictException" => crate::error::DeleteMethodResponseError {
            meta: generic,
            kind: crate::error::DeleteMethodResponseErrorKind::ConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::conflict_error::Builder::default();
                let _ = response;
                output = crate::json_deser::conflict_exception(response.body().as_ref(), output)
                    .map_err(crate::error::DeleteMethodResponseError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::DeleteMethodResponseError {
            meta: generic,
            kind: crate::error::DeleteMethodResponseErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::DeleteMethodResponseError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::DeleteMethodResponseError {
            meta: generic,
            kind: crate::error::DeleteMethodResponseErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteMethodResponseError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_delete_method_response_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::DeleteMethodResponseError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::DeleteMethodResponseError {
            meta: generic,
            kind: crate::error::DeleteMethodResponseErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::DeleteMethodResponseError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DeleteMethodResponseError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_method_response_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteMethodResponseOutput,
    crate::error::DeleteMethodResponseError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_method_response_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_model_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteModelOutput, crate::error::DeleteModelError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteModelError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteModelError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::DeleteModelError {
            meta: generic,
            kind: crate::error::DeleteModelErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::DeleteModelError::unhandled)?;
                output.build()
            }),
        },
        "ConflictException" => crate::error::DeleteModelError {
            meta: generic,
            kind: crate::error::DeleteModelErrorKind::ConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::conflict_error::Builder::default();
                let _ = response;
                output = crate::json_deser::conflict_exception(response.body().as_ref(), output)
                    .map_err(crate::error::DeleteModelError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::DeleteModelError {
            meta: generic,
            kind: crate::error::DeleteModelErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::DeleteModelError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::DeleteModelError {
            meta: generic,
            kind: crate::error::DeleteModelErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteModelError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_delete_model_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::DeleteModelError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::DeleteModelError {
            meta: generic,
            kind: crate::error::DeleteModelErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::DeleteModelError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DeleteModelError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_model_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteModelOutput, crate::error::DeleteModelError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_model_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_request_validator_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteRequestValidatorOutput,
    crate::error::DeleteRequestValidatorError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteRequestValidatorError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteRequestValidatorError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "BadRequestException" => crate::error::DeleteRequestValidatorError {
            meta: generic,
            kind: crate::error::DeleteRequestValidatorErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::DeleteRequestValidatorError::unhandled)?;
                output.build()
            }),
        },
        "ConflictException" => crate::error::DeleteRequestValidatorError {
            meta: generic,
            kind: crate::error::DeleteRequestValidatorErrorKind::ConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::conflict_error::Builder::default();
                let _ = response;
                output = crate::json_deser::conflict_exception(response.body().as_ref(), output)
                    .map_err(crate::error::DeleteRequestValidatorError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::DeleteRequestValidatorError {
            meta: generic,
            kind: crate::error::DeleteRequestValidatorErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::DeleteRequestValidatorError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => {
            crate::error::DeleteRequestValidatorError {
                meta: generic,
                kind: crate::error::DeleteRequestValidatorErrorKind::TooManyRequestsError({
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_requests_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::too_many_requests_exception(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteRequestValidatorError::unhandled)?;
                    output = output.set_retry_after_seconds(
                crate::http_serde::deser_header_delete_request_validator_retry_after_seconds(response.headers())
                                            .map_err(|_|crate::error::DeleteRequestValidatorError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
            );
                    output.build()
                }),
            }
        }
        "UnauthorizedException" => crate::error::DeleteRequestValidatorError {
            meta: generic,
            kind: crate::error::DeleteRequestValidatorErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::DeleteRequestValidatorError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DeleteRequestValidatorError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_request_validator_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteRequestValidatorOutput,
    crate::error::DeleteRequestValidatorError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_request_validator_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_resource_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteResourceOutput, crate::error::DeleteResourceError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteResourceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteResourceError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::DeleteResourceError {
            meta: generic,
            kind: crate::error::DeleteResourceErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::DeleteResourceError::unhandled)?;
                output.build()
            }),
        },
        "ConflictException" => crate::error::DeleteResourceError {
            meta: generic,
            kind: crate::error::DeleteResourceErrorKind::ConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::conflict_error::Builder::default();
                let _ = response;
                output = crate::json_deser::conflict_exception(response.body().as_ref(), output)
                    .map_err(crate::error::DeleteResourceError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::DeleteResourceError {
            meta: generic,
            kind: crate::error::DeleteResourceErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::DeleteResourceError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::DeleteResourceError {
            meta: generic,
            kind: crate::error::DeleteResourceErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteResourceError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_delete_resource_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::DeleteResourceError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::DeleteResourceError {
            meta: generic,
            kind: crate::error::DeleteResourceErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::DeleteResourceError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DeleteResourceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_resource_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteResourceOutput, crate::error::DeleteResourceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_resource_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_rest_api_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteRestApiOutput, crate::error::DeleteRestApiError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteRestApiError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteRestApiError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::DeleteRestApiError {
            meta: generic,
            kind: crate::error::DeleteRestApiErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::DeleteRestApiError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::DeleteRestApiError {
            meta: generic,
            kind: crate::error::DeleteRestApiErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::DeleteRestApiError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::DeleteRestApiError {
            meta: generic,
            kind: crate::error::DeleteRestApiErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteRestApiError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_delete_rest_api_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::DeleteRestApiError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::DeleteRestApiError {
            meta: generic,
            kind: crate::error::DeleteRestApiErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::DeleteRestApiError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DeleteRestApiError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_rest_api_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteRestApiOutput, crate::error::DeleteRestApiError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_rest_api_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_stage_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteStageOutput, crate::error::DeleteStageError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteStageError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteStageError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::DeleteStageError {
            meta: generic,
            kind: crate::error::DeleteStageErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::DeleteStageError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::DeleteStageError {
            meta: generic,
            kind: crate::error::DeleteStageErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::DeleteStageError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::DeleteStageError {
            meta: generic,
            kind: crate::error::DeleteStageErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteStageError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_delete_stage_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::DeleteStageError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::DeleteStageError {
            meta: generic,
            kind: crate::error::DeleteStageErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::DeleteStageError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DeleteStageError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_stage_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteStageOutput, crate::error::DeleteStageError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_stage_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_usage_plan_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteUsagePlanOutput, crate::error::DeleteUsagePlanError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteUsagePlanError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteUsagePlanError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::DeleteUsagePlanError {
            meta: generic,
            kind: crate::error::DeleteUsagePlanErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::DeleteUsagePlanError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::DeleteUsagePlanError {
            meta: generic,
            kind: crate::error::DeleteUsagePlanErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::DeleteUsagePlanError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::DeleteUsagePlanError {
            meta: generic,
            kind: crate::error::DeleteUsagePlanErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteUsagePlanError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_delete_usage_plan_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::DeleteUsagePlanError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::DeleteUsagePlanError {
            meta: generic,
            kind: crate::error::DeleteUsagePlanErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::DeleteUsagePlanError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DeleteUsagePlanError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_usage_plan_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteUsagePlanOutput, crate::error::DeleteUsagePlanError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_usage_plan_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_usage_plan_key_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteUsagePlanKeyOutput,
    crate::error::DeleteUsagePlanKeyError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteUsagePlanKeyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteUsagePlanKeyError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::DeleteUsagePlanKeyError {
            meta: generic,
            kind: crate::error::DeleteUsagePlanKeyErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::DeleteUsagePlanKeyError::unhandled)?;
                output.build()
            }),
        },
        "ConflictException" => crate::error::DeleteUsagePlanKeyError {
            meta: generic,
            kind: crate::error::DeleteUsagePlanKeyErrorKind::ConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::conflict_error::Builder::default();
                let _ = response;
                output = crate::json_deser::conflict_exception(response.body().as_ref(), output)
                    .map_err(crate::error::DeleteUsagePlanKeyError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::DeleteUsagePlanKeyError {
            meta: generic,
            kind: crate::error::DeleteUsagePlanKeyErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::DeleteUsagePlanKeyError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::DeleteUsagePlanKeyError {
            meta: generic,
            kind: crate::error::DeleteUsagePlanKeyErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteUsagePlanKeyError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_delete_usage_plan_key_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::DeleteUsagePlanKeyError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::DeleteUsagePlanKeyError {
            meta: generic,
            kind: crate::error::DeleteUsagePlanKeyErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::DeleteUsagePlanKeyError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DeleteUsagePlanKeyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_usage_plan_key_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteUsagePlanKeyOutput,
    crate::error::DeleteUsagePlanKeyError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_usage_plan_key_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_vpc_link_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteVpcLinkOutput, crate::error::DeleteVpcLinkError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteVpcLinkError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteVpcLinkError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::DeleteVpcLinkError {
            meta: generic,
            kind: crate::error::DeleteVpcLinkErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::DeleteVpcLinkError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::DeleteVpcLinkError {
            meta: generic,
            kind: crate::error::DeleteVpcLinkErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::DeleteVpcLinkError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::DeleteVpcLinkError {
            meta: generic,
            kind: crate::error::DeleteVpcLinkErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteVpcLinkError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_delete_vpc_link_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::DeleteVpcLinkError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::DeleteVpcLinkError {
            meta: generic,
            kind: crate::error::DeleteVpcLinkErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::DeleteVpcLinkError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DeleteVpcLinkError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_vpc_link_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteVpcLinkOutput, crate::error::DeleteVpcLinkError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_vpc_link_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_flush_stage_authorizers_cache_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::FlushStageAuthorizersCacheOutput,
    crate::error::FlushStageAuthorizersCacheError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::FlushStageAuthorizersCacheError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::FlushStageAuthorizersCacheError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "BadRequestException" => crate::error::FlushStageAuthorizersCacheError {
            meta: generic,
            kind: crate::error::FlushStageAuthorizersCacheErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::FlushStageAuthorizersCacheError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::FlushStageAuthorizersCacheError {
            meta: generic,
            kind: crate::error::FlushStageAuthorizersCacheErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::FlushStageAuthorizersCacheError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::FlushStageAuthorizersCacheError {
            meta: generic,
            kind: crate::error::FlushStageAuthorizersCacheErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::FlushStageAuthorizersCacheError::unhandled)?;
                output = output.set_retry_after_seconds(
                crate::http_serde::deser_header_flush_stage_authorizers_cache_retry_after_seconds(response.headers())
                                            .map_err(|_|crate::error::FlushStageAuthorizersCacheError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
            );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::FlushStageAuthorizersCacheError {
            meta: generic,
            kind: crate::error::FlushStageAuthorizersCacheErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::FlushStageAuthorizersCacheError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::FlushStageAuthorizersCacheError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_flush_stage_authorizers_cache_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::FlushStageAuthorizersCacheOutput,
    crate::error::FlushStageAuthorizersCacheError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::flush_stage_authorizers_cache_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_flush_stage_cache_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::FlushStageCacheOutput, crate::error::FlushStageCacheError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::FlushStageCacheError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::FlushStageCacheError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::FlushStageCacheError {
            meta: generic,
            kind: crate::error::FlushStageCacheErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::FlushStageCacheError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::FlushStageCacheError {
            meta: generic,
            kind: crate::error::FlushStageCacheErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::FlushStageCacheError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::FlushStageCacheError {
            meta: generic,
            kind: crate::error::FlushStageCacheErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::FlushStageCacheError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_flush_stage_cache_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::FlushStageCacheError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::FlushStageCacheError {
            meta: generic,
            kind: crate::error::FlushStageCacheErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::FlushStageCacheError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::FlushStageCacheError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_flush_stage_cache_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::FlushStageCacheOutput, crate::error::FlushStageCacheError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::flush_stage_cache_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_generate_client_certificate_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GenerateClientCertificateOutput,
    crate::error::GenerateClientCertificateError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GenerateClientCertificateError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GenerateClientCertificateError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "LimitExceededException" => crate::error::GenerateClientCertificateError {
            meta: generic,
            kind: crate::error::GenerateClientCertificateErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::limit_exceeded_exception(response.body().as_ref(), output)
                        .map_err(crate::error::GenerateClientCertificateError::unhandled)?;
                output = output.set_retry_after_seconds(
                crate::http_serde::deser_header_generate_client_certificate_retry_after_seconds(response.headers())
                                            .map_err(|_|crate::error::GenerateClientCertificateError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
            );
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::GenerateClientCertificateError {
            meta: generic,
            kind: crate::error::GenerateClientCertificateErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GenerateClientCertificateError::unhandled)?;
                output = output.set_retry_after_seconds(
                crate::http_serde::deser_header_generate_client_certificate_retry_after_seconds(response.headers())
                                            .map_err(|_|crate::error::GenerateClientCertificateError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
            );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::GenerateClientCertificateError {
            meta: generic,
            kind: crate::error::GenerateClientCertificateErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::GenerateClientCertificateError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GenerateClientCertificateError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_generate_client_certificate_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GenerateClientCertificateOutput,
    crate::error::GenerateClientCertificateError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::generate_client_certificate_output::Builder::default();
        let _ = response;
        output = crate::json_deser::generate_client_certificate_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GenerateClientCertificateError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_account_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetAccountOutput, crate::error::GetAccountError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetAccountError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetAccountError::unhandled(generic)),
    };
    Err(match error_code {
        "NotFoundException" => crate::error::GetAccountError {
            meta: generic,
            kind: crate::error::GetAccountErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetAccountError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::GetAccountError {
            meta: generic,
            kind: crate::error::GetAccountErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetAccountError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_get_account_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::GetAccountError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::GetAccountError {
            meta: generic,
            kind: crate::error::GetAccountErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::GetAccountError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetAccountError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_account_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetAccountOutput, crate::error::GetAccountError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_account_output::Builder::default();
        let _ = response;
        output = crate::json_deser::get_account_deser_operation(response.body().as_ref(), output)
            .map_err(crate::error::GetAccountError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_api_key_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetApiKeyOutput, crate::error::GetApiKeyError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetApiKeyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetApiKeyError::unhandled(generic)),
    };
    Err(match error_code {
        "NotFoundException" => crate::error::GetApiKeyError {
            meta: generic,
            kind: crate::error::GetApiKeyErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetApiKeyError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::GetApiKeyError {
            meta: generic,
            kind: crate::error::GetApiKeyErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetApiKeyError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_get_api_key_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::GetApiKeyError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::GetApiKeyError {
            meta: generic,
            kind: crate::error::GetApiKeyErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::GetApiKeyError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetApiKeyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_api_key_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetApiKeyOutput, crate::error::GetApiKeyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_api_key_output::Builder::default();
        let _ = response;
        output = crate::json_deser::get_api_key_deser_operation(response.body().as_ref(), output)
            .map_err(crate::error::GetApiKeyError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_api_keys_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetApiKeysOutput, crate::error::GetApiKeysError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetApiKeysError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetApiKeysError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::GetApiKeysError {
            meta: generic,
            kind: crate::error::GetApiKeysErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetApiKeysError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::GetApiKeysError {
            meta: generic,
            kind: crate::error::GetApiKeysErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetApiKeysError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_get_api_keys_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::GetApiKeysError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::GetApiKeysError {
            meta: generic,
            kind: crate::error::GetApiKeysErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::GetApiKeysError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetApiKeysError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_api_keys_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetApiKeysOutput, crate::error::GetApiKeysError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_api_keys_output::Builder::default();
        let _ = response;
        output = crate::json_deser::get_api_keys_deser_operation(response.body().as_ref(), output)
            .map_err(crate::error::GetApiKeysError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_authorizer_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetAuthorizerOutput, crate::error::GetAuthorizerError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetAuthorizerError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetAuthorizerError::unhandled(generic)),
    };
    Err(match error_code {
        "NotFoundException" => crate::error::GetAuthorizerError {
            meta: generic,
            kind: crate::error::GetAuthorizerErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetAuthorizerError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::GetAuthorizerError {
            meta: generic,
            kind: crate::error::GetAuthorizerErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetAuthorizerError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_get_authorizer_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::GetAuthorizerError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::GetAuthorizerError {
            meta: generic,
            kind: crate::error::GetAuthorizerErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::GetAuthorizerError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetAuthorizerError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_authorizer_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetAuthorizerOutput, crate::error::GetAuthorizerError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_authorizer_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::get_authorizer_deser_operation(response.body().as_ref(), output)
                .map_err(crate::error::GetAuthorizerError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_authorizers_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetAuthorizersOutput, crate::error::GetAuthorizersError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetAuthorizersError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetAuthorizersError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::GetAuthorizersError {
            meta: generic,
            kind: crate::error::GetAuthorizersErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetAuthorizersError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::GetAuthorizersError {
            meta: generic,
            kind: crate::error::GetAuthorizersErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetAuthorizersError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::GetAuthorizersError {
            meta: generic,
            kind: crate::error::GetAuthorizersErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetAuthorizersError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_get_authorizers_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::GetAuthorizersError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::GetAuthorizersError {
            meta: generic,
            kind: crate::error::GetAuthorizersErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::GetAuthorizersError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetAuthorizersError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_authorizers_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetAuthorizersOutput, crate::error::GetAuthorizersError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_authorizers_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::get_authorizers_deser_operation(response.body().as_ref(), output)
                .map_err(crate::error::GetAuthorizersError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_base_path_mapping_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetBasePathMappingOutput,
    crate::error::GetBasePathMappingError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetBasePathMappingError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetBasePathMappingError::unhandled(generic)),
    };
    Err(match error_code {
        "NotFoundException" => crate::error::GetBasePathMappingError {
            meta: generic,
            kind: crate::error::GetBasePathMappingErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetBasePathMappingError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::GetBasePathMappingError {
            meta: generic,
            kind: crate::error::GetBasePathMappingErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetBasePathMappingError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_get_base_path_mapping_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::GetBasePathMappingError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::GetBasePathMappingError {
            meta: generic,
            kind: crate::error::GetBasePathMappingErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::GetBasePathMappingError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetBasePathMappingError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_base_path_mapping_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetBasePathMappingOutput,
    crate::error::GetBasePathMappingError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_base_path_mapping_output::Builder::default();
        let _ = response;
        output = crate::json_deser::get_base_path_mapping_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetBasePathMappingError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_base_path_mappings_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetBasePathMappingsOutput,
    crate::error::GetBasePathMappingsError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetBasePathMappingsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetBasePathMappingsError::unhandled(generic)),
    };
    Err(match error_code {
        "NotFoundException" => crate::error::GetBasePathMappingsError {
            meta: generic,
            kind: crate::error::GetBasePathMappingsErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetBasePathMappingsError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::GetBasePathMappingsError {
            meta: generic,
            kind: crate::error::GetBasePathMappingsErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetBasePathMappingsError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_get_base_path_mappings_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::GetBasePathMappingsError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::GetBasePathMappingsError {
            meta: generic,
            kind: crate::error::GetBasePathMappingsErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::GetBasePathMappingsError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetBasePathMappingsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_base_path_mappings_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetBasePathMappingsOutput,
    crate::error::GetBasePathMappingsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_base_path_mappings_output::Builder::default();
        let _ = response;
        output = crate::json_deser::get_base_path_mappings_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetBasePathMappingsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_client_certificate_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetClientCertificateOutput,
    crate::error::GetClientCertificateError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetClientCertificateError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetClientCertificateError::unhandled(generic)),
    };
    Err(match error_code {
        "NotFoundException" => crate::error::GetClientCertificateError {
            meta: generic,
            kind: crate::error::GetClientCertificateErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetClientCertificateError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::GetClientCertificateError {
            meta: generic,
            kind: crate::error::GetClientCertificateErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetClientCertificateError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_get_client_certificate_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::GetClientCertificateError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::GetClientCertificateError {
            meta: generic,
            kind: crate::error::GetClientCertificateErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::GetClientCertificateError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetClientCertificateError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_client_certificate_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetClientCertificateOutput,
    crate::error::GetClientCertificateError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_client_certificate_output::Builder::default();
        let _ = response;
        output = crate::json_deser::get_client_certificate_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetClientCertificateError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_client_certificates_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetClientCertificatesOutput,
    crate::error::GetClientCertificatesError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetClientCertificatesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetClientCertificatesError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::GetClientCertificatesError {
            meta: generic,
            kind: crate::error::GetClientCertificatesErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetClientCertificatesError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => {
            crate::error::GetClientCertificatesError {
                meta: generic,
                kind: crate::error::GetClientCertificatesErrorKind::TooManyRequestsError({
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_requests_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::too_many_requests_exception(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetClientCertificatesError::unhandled)?;
                    output = output.set_retry_after_seconds(
                crate::http_serde::deser_header_get_client_certificates_retry_after_seconds(response.headers())
                                            .map_err(|_|crate::error::GetClientCertificatesError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
            );
                    output.build()
                }),
            }
        }
        "UnauthorizedException" => crate::error::GetClientCertificatesError {
            meta: generic,
            kind: crate::error::GetClientCertificatesErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::GetClientCertificatesError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetClientCertificatesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_client_certificates_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetClientCertificatesOutput,
    crate::error::GetClientCertificatesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_client_certificates_output::Builder::default();
        let _ = response;
        output = crate::json_deser::get_client_certificates_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetClientCertificatesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_deployment_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetDeploymentOutput, crate::error::GetDeploymentError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetDeploymentError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetDeploymentError::unhandled(generic)),
    };
    Err(match error_code {
        "NotFoundException" => crate::error::GetDeploymentError {
            meta: generic,
            kind: crate::error::GetDeploymentErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetDeploymentError::unhandled)?;
                output.build()
            }),
        },
        "ServiceUnavailableException" => crate::error::GetDeploymentError {
            meta: generic,
            kind: crate::error::GetDeploymentErrorKind::ServiceUnavailableError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_unavailable_error::Builder::default();
                let _ = response;
                output = crate::json_deser::service_unavailable_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetDeploymentError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_get_deployment_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::GetDeploymentError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::GetDeploymentError {
            meta: generic,
            kind: crate::error::GetDeploymentErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetDeploymentError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_get_deployment_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::GetDeploymentError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::GetDeploymentError {
            meta: generic,
            kind: crate::error::GetDeploymentErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::GetDeploymentError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetDeploymentError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_deployment_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetDeploymentOutput, crate::error::GetDeploymentError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_deployment_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::get_deployment_deser_operation(response.body().as_ref(), output)
                .map_err(crate::error::GetDeploymentError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_deployments_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetDeploymentsOutput, crate::error::GetDeploymentsError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetDeploymentsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetDeploymentsError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::GetDeploymentsError {
            meta: generic,
            kind: crate::error::GetDeploymentsErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetDeploymentsError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::GetDeploymentsError {
            meta: generic,
            kind: crate::error::GetDeploymentsErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetDeploymentsError::unhandled)?;
                output.build()
            }),
        },
        "ServiceUnavailableException" => crate::error::GetDeploymentsError {
            meta: generic,
            kind: crate::error::GetDeploymentsErrorKind::ServiceUnavailableError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_unavailable_error::Builder::default();
                let _ = response;
                output = crate::json_deser::service_unavailable_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetDeploymentsError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_get_deployments_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::GetDeploymentsError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::GetDeploymentsError {
            meta: generic,
            kind: crate::error::GetDeploymentsErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetDeploymentsError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_get_deployments_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::GetDeploymentsError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::GetDeploymentsError {
            meta: generic,
            kind: crate::error::GetDeploymentsErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::GetDeploymentsError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetDeploymentsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_deployments_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetDeploymentsOutput, crate::error::GetDeploymentsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_deployments_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::get_deployments_deser_operation(response.body().as_ref(), output)
                .map_err(crate::error::GetDeploymentsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_documentation_part_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetDocumentationPartOutput,
    crate::error::GetDocumentationPartError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetDocumentationPartError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetDocumentationPartError::unhandled(generic)),
    };
    Err(match error_code {
        "NotFoundException" => crate::error::GetDocumentationPartError {
            meta: generic,
            kind: crate::error::GetDocumentationPartErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetDocumentationPartError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::GetDocumentationPartError {
            meta: generic,
            kind: crate::error::GetDocumentationPartErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetDocumentationPartError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_get_documentation_part_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::GetDocumentationPartError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::GetDocumentationPartError {
            meta: generic,
            kind: crate::error::GetDocumentationPartErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::GetDocumentationPartError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetDocumentationPartError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_documentation_part_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetDocumentationPartOutput,
    crate::error::GetDocumentationPartError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_documentation_part_output::Builder::default();
        let _ = response;
        output = crate::json_deser::get_documentation_part_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetDocumentationPartError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_documentation_parts_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetDocumentationPartsOutput,
    crate::error::GetDocumentationPartsError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetDocumentationPartsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetDocumentationPartsError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::GetDocumentationPartsError {
            meta: generic,
            kind: crate::error::GetDocumentationPartsErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetDocumentationPartsError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::GetDocumentationPartsError {
            meta: generic,
            kind: crate::error::GetDocumentationPartsErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetDocumentationPartsError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => {
            crate::error::GetDocumentationPartsError {
                meta: generic,
                kind: crate::error::GetDocumentationPartsErrorKind::TooManyRequestsError({
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_requests_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::too_many_requests_exception(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetDocumentationPartsError::unhandled)?;
                    output = output.set_retry_after_seconds(
                crate::http_serde::deser_header_get_documentation_parts_retry_after_seconds(response.headers())
                                            .map_err(|_|crate::error::GetDocumentationPartsError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
            );
                    output.build()
                }),
            }
        }
        "UnauthorizedException" => crate::error::GetDocumentationPartsError {
            meta: generic,
            kind: crate::error::GetDocumentationPartsErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::GetDocumentationPartsError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetDocumentationPartsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_documentation_parts_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetDocumentationPartsOutput,
    crate::error::GetDocumentationPartsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_documentation_parts_output::Builder::default();
        let _ = response;
        output = crate::json_deser::get_documentation_parts_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetDocumentationPartsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_documentation_version_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetDocumentationVersionOutput,
    crate::error::GetDocumentationVersionError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetDocumentationVersionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetDocumentationVersionError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "NotFoundException" => crate::error::GetDocumentationVersionError {
            meta: generic,
            kind: crate::error::GetDocumentationVersionErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetDocumentationVersionError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => {
            crate::error::GetDocumentationVersionError {
                meta: generic,
                kind: crate::error::GetDocumentationVersionErrorKind::TooManyRequestsError({
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_requests_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::too_many_requests_exception(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetDocumentationVersionError::unhandled)?;
                    output = output.set_retry_after_seconds(
                crate::http_serde::deser_header_get_documentation_version_retry_after_seconds(response.headers())
                                            .map_err(|_|crate::error::GetDocumentationVersionError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
            );
                    output.build()
                }),
            }
        }
        "UnauthorizedException" => crate::error::GetDocumentationVersionError {
            meta: generic,
            kind: crate::error::GetDocumentationVersionErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::GetDocumentationVersionError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetDocumentationVersionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_documentation_version_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetDocumentationVersionOutput,
    crate::error::GetDocumentationVersionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_documentation_version_output::Builder::default();
        let _ = response;
        output = crate::json_deser::get_documentation_version_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetDocumentationVersionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_documentation_versions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetDocumentationVersionsOutput,
    crate::error::GetDocumentationVersionsError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetDocumentationVersionsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetDocumentationVersionsError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "BadRequestException" => crate::error::GetDocumentationVersionsError {
            meta: generic,
            kind: crate::error::GetDocumentationVersionsErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetDocumentationVersionsError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::GetDocumentationVersionsError {
            meta: generic,
            kind: crate::error::GetDocumentationVersionsErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetDocumentationVersionsError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => {
            crate::error::GetDocumentationVersionsError {
                meta: generic,
                kind: crate::error::GetDocumentationVersionsErrorKind::TooManyRequestsError({
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_requests_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::too_many_requests_exception(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetDocumentationVersionsError::unhandled)?;
                    output = output.set_retry_after_seconds(
                crate::http_serde::deser_header_get_documentation_versions_retry_after_seconds(response.headers())
                                            .map_err(|_|crate::error::GetDocumentationVersionsError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
            );
                    output.build()
                }),
            }
        }
        "UnauthorizedException" => crate::error::GetDocumentationVersionsError {
            meta: generic,
            kind: crate::error::GetDocumentationVersionsErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::GetDocumentationVersionsError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetDocumentationVersionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_documentation_versions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetDocumentationVersionsOutput,
    crate::error::GetDocumentationVersionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_documentation_versions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::get_documentation_versions_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetDocumentationVersionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_domain_name_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetDomainNameOutput, crate::error::GetDomainNameError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetDomainNameError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetDomainNameError::unhandled(generic)),
    };
    Err(match error_code {
        "NotFoundException" => crate::error::GetDomainNameError {
            meta: generic,
            kind: crate::error::GetDomainNameErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetDomainNameError::unhandled)?;
                output.build()
            }),
        },
        "ServiceUnavailableException" => crate::error::GetDomainNameError {
            meta: generic,
            kind: crate::error::GetDomainNameErrorKind::ServiceUnavailableError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_unavailable_error::Builder::default();
                let _ = response;
                output = crate::json_deser::service_unavailable_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetDomainNameError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_get_domain_name_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::GetDomainNameError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::GetDomainNameError {
            meta: generic,
            kind: crate::error::GetDomainNameErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetDomainNameError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_get_domain_name_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::GetDomainNameError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::GetDomainNameError {
            meta: generic,
            kind: crate::error::GetDomainNameErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::GetDomainNameError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetDomainNameError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_domain_name_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetDomainNameOutput, crate::error::GetDomainNameError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_domain_name_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::get_domain_name_deser_operation(response.body().as_ref(), output)
                .map_err(crate::error::GetDomainNameError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_domain_names_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetDomainNamesOutput, crate::error::GetDomainNamesError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetDomainNamesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetDomainNamesError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::GetDomainNamesError {
            meta: generic,
            kind: crate::error::GetDomainNamesErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetDomainNamesError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::GetDomainNamesError {
            meta: generic,
            kind: crate::error::GetDomainNamesErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetDomainNamesError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_get_domain_names_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::GetDomainNamesError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::GetDomainNamesError {
            meta: generic,
            kind: crate::error::GetDomainNamesErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::GetDomainNamesError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetDomainNamesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_domain_names_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetDomainNamesOutput, crate::error::GetDomainNamesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_domain_names_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::get_domain_names_deser_operation(response.body().as_ref(), output)
                .map_err(crate::error::GetDomainNamesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_export_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetExportOutput, crate::error::GetExportError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetExportError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetExportError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::GetExportError {
            meta: generic,
            kind: crate::error::GetExportErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetExportError::unhandled)?;
                output.build()
            }),
        },
        "ConflictException" => crate::error::GetExportError {
            meta: generic,
            kind: crate::error::GetExportErrorKind::ConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::conflict_error::Builder::default();
                let _ = response;
                output = crate::json_deser::conflict_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetExportError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::GetExportError {
            meta: generic,
            kind: crate::error::GetExportErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetExportError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::GetExportError {
            meta: generic,
            kind: crate::error::GetExportErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetExportError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_get_export_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::GetExportError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::GetExportError {
            meta: generic,
            kind: crate::error::GetExportErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::GetExportError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetExportError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_export_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetExportOutput, crate::error::GetExportError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_export_output::Builder::default();
        let _ = response;
        output = output.set_body(crate::http_serde::deser_payload_get_export_body(
            response.body().as_ref(),
        )?);
        output = output.set_content_disposition(
            crate::http_serde::deser_header_get_export_content_disposition(response.headers())
                .map_err(|_| {
                    crate::error::GetExportError::unhandled(
                        "Failed to parse contentDisposition from header `Content-Disposition",
                    )
                })?,
        );
        output = output.set_content_type(
            crate::http_serde::deser_header_get_export_content_type(response.headers()).map_err(
                |_| {
                    crate::error::GetExportError::unhandled(
                        "Failed to parse contentType from header `Content-Type",
                    )
                },
            )?,
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_gateway_response_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetGatewayResponseOutput,
    crate::error::GetGatewayResponseError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetGatewayResponseError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetGatewayResponseError::unhandled(generic)),
    };
    Err(match error_code {
        "NotFoundException" => crate::error::GetGatewayResponseError {
            meta: generic,
            kind: crate::error::GetGatewayResponseErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetGatewayResponseError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::GetGatewayResponseError {
            meta: generic,
            kind: crate::error::GetGatewayResponseErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetGatewayResponseError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_get_gateway_response_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::GetGatewayResponseError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::GetGatewayResponseError {
            meta: generic,
            kind: crate::error::GetGatewayResponseErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::GetGatewayResponseError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetGatewayResponseError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_gateway_response_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetGatewayResponseOutput,
    crate::error::GetGatewayResponseError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_gateway_response_output::Builder::default();
        let _ = response;
        output = crate::json_deser::get_gateway_response_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetGatewayResponseError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_gateway_responses_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetGatewayResponsesOutput,
    crate::error::GetGatewayResponsesError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetGatewayResponsesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetGatewayResponsesError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::GetGatewayResponsesError {
            meta: generic,
            kind: crate::error::GetGatewayResponsesErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetGatewayResponsesError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::GetGatewayResponsesError {
            meta: generic,
            kind: crate::error::GetGatewayResponsesErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetGatewayResponsesError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::GetGatewayResponsesError {
            meta: generic,
            kind: crate::error::GetGatewayResponsesErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetGatewayResponsesError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_get_gateway_responses_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::GetGatewayResponsesError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::GetGatewayResponsesError {
            meta: generic,
            kind: crate::error::GetGatewayResponsesErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::GetGatewayResponsesError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetGatewayResponsesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_gateway_responses_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetGatewayResponsesOutput,
    crate::error::GetGatewayResponsesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_gateway_responses_output::Builder::default();
        let _ = response;
        output = crate::json_deser::get_gateway_responses_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetGatewayResponsesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_integration_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetIntegrationOutput, crate::error::GetIntegrationError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetIntegrationError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetIntegrationError::unhandled(generic)),
    };
    Err(match error_code {
        "NotFoundException" => crate::error::GetIntegrationError {
            meta: generic,
            kind: crate::error::GetIntegrationErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetIntegrationError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::GetIntegrationError {
            meta: generic,
            kind: crate::error::GetIntegrationErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetIntegrationError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_get_integration_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::GetIntegrationError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::GetIntegrationError {
            meta: generic,
            kind: crate::error::GetIntegrationErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::GetIntegrationError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetIntegrationError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_integration_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetIntegrationOutput, crate::error::GetIntegrationError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_integration_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::get_integration_deser_operation(response.body().as_ref(), output)
                .map_err(crate::error::GetIntegrationError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_integration_response_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetIntegrationResponseOutput,
    crate::error::GetIntegrationResponseError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetIntegrationResponseError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetIntegrationResponseError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "NotFoundException" => crate::error::GetIntegrationResponseError {
            meta: generic,
            kind: crate::error::GetIntegrationResponseErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetIntegrationResponseError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => {
            crate::error::GetIntegrationResponseError {
                meta: generic,
                kind: crate::error::GetIntegrationResponseErrorKind::TooManyRequestsError({
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_requests_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::too_many_requests_exception(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetIntegrationResponseError::unhandled)?;
                    output = output.set_retry_after_seconds(
                crate::http_serde::deser_header_get_integration_response_retry_after_seconds(response.headers())
                                            .map_err(|_|crate::error::GetIntegrationResponseError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
            );
                    output.build()
                }),
            }
        }
        "UnauthorizedException" => crate::error::GetIntegrationResponseError {
            meta: generic,
            kind: crate::error::GetIntegrationResponseErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::GetIntegrationResponseError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetIntegrationResponseError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_integration_response_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetIntegrationResponseOutput,
    crate::error::GetIntegrationResponseError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_integration_response_output::Builder::default();
        let _ = response;
        output = crate::json_deser::get_integration_response_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetIntegrationResponseError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_method_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetMethodOutput, crate::error::GetMethodError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetMethodError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetMethodError::unhandled(generic)),
    };
    Err(match error_code {
        "NotFoundException" => crate::error::GetMethodError {
            meta: generic,
            kind: crate::error::GetMethodErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetMethodError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::GetMethodError {
            meta: generic,
            kind: crate::error::GetMethodErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetMethodError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_get_method_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::GetMethodError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::GetMethodError {
            meta: generic,
            kind: crate::error::GetMethodErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::GetMethodError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetMethodError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_method_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetMethodOutput, crate::error::GetMethodError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_method_output::Builder::default();
        let _ = response;
        output = crate::json_deser::get_method_deser_operation(response.body().as_ref(), output)
            .map_err(crate::error::GetMethodError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_method_response_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetMethodResponseOutput, crate::error::GetMethodResponseError>
{
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetMethodResponseError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetMethodResponseError::unhandled(generic)),
    };
    Err(match error_code {
        "NotFoundException" => crate::error::GetMethodResponseError {
            meta: generic,
            kind: crate::error::GetMethodResponseErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetMethodResponseError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::GetMethodResponseError {
            meta: generic,
            kind: crate::error::GetMethodResponseErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetMethodResponseError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_get_method_response_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::GetMethodResponseError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::GetMethodResponseError {
            meta: generic,
            kind: crate::error::GetMethodResponseErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::GetMethodResponseError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetMethodResponseError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_method_response_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetMethodResponseOutput, crate::error::GetMethodResponseError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_method_response_output::Builder::default();
        let _ = response;
        output = crate::json_deser::get_method_response_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetMethodResponseError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_model_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetModelOutput, crate::error::GetModelError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetModelError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetModelError::unhandled(generic)),
    };
    Err(match error_code {
        "NotFoundException" => crate::error::GetModelError {
            meta: generic,
            kind: crate::error::GetModelErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetModelError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::GetModelError {
            meta: generic,
            kind: crate::error::GetModelErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetModelError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_get_model_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::GetModelError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::GetModelError {
            meta: generic,
            kind: crate::error::GetModelErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::GetModelError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetModelError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_model_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetModelOutput, crate::error::GetModelError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_model_output::Builder::default();
        let _ = response;
        output = crate::json_deser::get_model_deser_operation(response.body().as_ref(), output)
            .map_err(crate::error::GetModelError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_models_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetModelsOutput, crate::error::GetModelsError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetModelsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetModelsError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::GetModelsError {
            meta: generic,
            kind: crate::error::GetModelsErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetModelsError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::GetModelsError {
            meta: generic,
            kind: crate::error::GetModelsErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetModelsError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::GetModelsError {
            meta: generic,
            kind: crate::error::GetModelsErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetModelsError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_get_models_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::GetModelsError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::GetModelsError {
            meta: generic,
            kind: crate::error::GetModelsErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::GetModelsError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetModelsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_models_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetModelsOutput, crate::error::GetModelsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_models_output::Builder::default();
        let _ = response;
        output = crate::json_deser::get_models_deser_operation(response.body().as_ref(), output)
            .map_err(crate::error::GetModelsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_model_template_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetModelTemplateOutput, crate::error::GetModelTemplateError>
{
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetModelTemplateError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetModelTemplateError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::GetModelTemplateError {
            meta: generic,
            kind: crate::error::GetModelTemplateErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetModelTemplateError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::GetModelTemplateError {
            meta: generic,
            kind: crate::error::GetModelTemplateErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetModelTemplateError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::GetModelTemplateError {
            meta: generic,
            kind: crate::error::GetModelTemplateErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetModelTemplateError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_get_model_template_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::GetModelTemplateError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::GetModelTemplateError {
            meta: generic,
            kind: crate::error::GetModelTemplateErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::GetModelTemplateError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetModelTemplateError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_model_template_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetModelTemplateOutput, crate::error::GetModelTemplateError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_model_template_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::get_model_template_deser_operation(response.body().as_ref(), output)
                .map_err(crate::error::GetModelTemplateError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_request_validator_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetRequestValidatorOutput,
    crate::error::GetRequestValidatorError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetRequestValidatorError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetRequestValidatorError::unhandled(generic)),
    };
    Err(match error_code {
        "NotFoundException" => crate::error::GetRequestValidatorError {
            meta: generic,
            kind: crate::error::GetRequestValidatorErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetRequestValidatorError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::GetRequestValidatorError {
            meta: generic,
            kind: crate::error::GetRequestValidatorErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetRequestValidatorError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_get_request_validator_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::GetRequestValidatorError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::GetRequestValidatorError {
            meta: generic,
            kind: crate::error::GetRequestValidatorErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::GetRequestValidatorError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetRequestValidatorError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_request_validator_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetRequestValidatorOutput,
    crate::error::GetRequestValidatorError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_request_validator_output::Builder::default();
        let _ = response;
        output = crate::json_deser::get_request_validator_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetRequestValidatorError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_request_validators_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetRequestValidatorsOutput,
    crate::error::GetRequestValidatorsError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetRequestValidatorsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetRequestValidatorsError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::GetRequestValidatorsError {
            meta: generic,
            kind: crate::error::GetRequestValidatorsErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetRequestValidatorsError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::GetRequestValidatorsError {
            meta: generic,
            kind: crate::error::GetRequestValidatorsErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetRequestValidatorsError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::GetRequestValidatorsError {
            meta: generic,
            kind: crate::error::GetRequestValidatorsErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetRequestValidatorsError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_get_request_validators_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::GetRequestValidatorsError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::GetRequestValidatorsError {
            meta: generic,
            kind: crate::error::GetRequestValidatorsErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::GetRequestValidatorsError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetRequestValidatorsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_request_validators_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetRequestValidatorsOutput,
    crate::error::GetRequestValidatorsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_request_validators_output::Builder::default();
        let _ = response;
        output = crate::json_deser::get_request_validators_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetRequestValidatorsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_resource_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetResourceOutput, crate::error::GetResourceError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetResourceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetResourceError::unhandled(generic)),
    };
    Err(match error_code {
        "NotFoundException" => crate::error::GetResourceError {
            meta: generic,
            kind: crate::error::GetResourceErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetResourceError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::GetResourceError {
            meta: generic,
            kind: crate::error::GetResourceErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetResourceError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_get_resource_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::GetResourceError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::GetResourceError {
            meta: generic,
            kind: crate::error::GetResourceErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::GetResourceError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetResourceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_resource_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetResourceOutput, crate::error::GetResourceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_resource_output::Builder::default();
        let _ = response;
        output = crate::json_deser::get_resource_deser_operation(response.body().as_ref(), output)
            .map_err(crate::error::GetResourceError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_resources_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetResourcesOutput, crate::error::GetResourcesError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetResourcesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetResourcesError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::GetResourcesError {
            meta: generic,
            kind: crate::error::GetResourcesErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetResourcesError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::GetResourcesError {
            meta: generic,
            kind: crate::error::GetResourcesErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetResourcesError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::GetResourcesError {
            meta: generic,
            kind: crate::error::GetResourcesErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetResourcesError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_get_resources_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::GetResourcesError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::GetResourcesError {
            meta: generic,
            kind: crate::error::GetResourcesErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::GetResourcesError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetResourcesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_resources_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetResourcesOutput, crate::error::GetResourcesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_resources_output::Builder::default();
        let _ = response;
        output = crate::json_deser::get_resources_deser_operation(response.body().as_ref(), output)
            .map_err(crate::error::GetResourcesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_rest_api_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetRestApiOutput, crate::error::GetRestApiError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetRestApiError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetRestApiError::unhandled(generic)),
    };
    Err(match error_code {
        "NotFoundException" => crate::error::GetRestApiError {
            meta: generic,
            kind: crate::error::GetRestApiErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetRestApiError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::GetRestApiError {
            meta: generic,
            kind: crate::error::GetRestApiErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetRestApiError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_get_rest_api_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::GetRestApiError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::GetRestApiError {
            meta: generic,
            kind: crate::error::GetRestApiErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::GetRestApiError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetRestApiError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_rest_api_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetRestApiOutput, crate::error::GetRestApiError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_rest_api_output::Builder::default();
        let _ = response;
        output = crate::json_deser::get_rest_api_deser_operation(response.body().as_ref(), output)
            .map_err(crate::error::GetRestApiError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_rest_apis_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetRestApisOutput, crate::error::GetRestApisError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetRestApisError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetRestApisError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::GetRestApisError {
            meta: generic,
            kind: crate::error::GetRestApisErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetRestApisError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::GetRestApisError {
            meta: generic,
            kind: crate::error::GetRestApisErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetRestApisError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_get_rest_apis_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::GetRestApisError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::GetRestApisError {
            meta: generic,
            kind: crate::error::GetRestApisErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::GetRestApisError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetRestApisError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_rest_apis_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetRestApisOutput, crate::error::GetRestApisError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_rest_apis_output::Builder::default();
        let _ = response;
        output = crate::json_deser::get_rest_apis_deser_operation(response.body().as_ref(), output)
            .map_err(crate::error::GetRestApisError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_sdk_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetSdkOutput, crate::error::GetSdkError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetSdkError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetSdkError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::GetSdkError {
            meta: generic,
            kind: crate::error::GetSdkErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetSdkError::unhandled)?;
                output.build()
            }),
        },
        "ConflictException" => crate::error::GetSdkError {
            meta: generic,
            kind: crate::error::GetSdkErrorKind::ConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::conflict_error::Builder::default();
                let _ = response;
                output = crate::json_deser::conflict_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetSdkError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::GetSdkError {
            meta: generic,
            kind: crate::error::GetSdkErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetSdkError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::GetSdkError {
            meta: generic,
            kind: crate::error::GetSdkErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetSdkError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_get_sdk_retry_after_seconds(response.headers())
                        .map_err(|_| {
                            crate::error::GetSdkError::unhandled(
                                "Failed to parse retryAfterSeconds from header `Retry-After",
                            )
                        })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::GetSdkError {
            meta: generic,
            kind: crate::error::GetSdkErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::GetSdkError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetSdkError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_sdk_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetSdkOutput, crate::error::GetSdkError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_sdk_output::Builder::default();
        let _ = response;
        output = output.set_body(crate::http_serde::deser_payload_get_sdk_body(
            response.body().as_ref(),
        )?);
        output = output.set_content_disposition(
            crate::http_serde::deser_header_get_sdk_content_disposition(response.headers())
                .map_err(|_| {
                    crate::error::GetSdkError::unhandled(
                        "Failed to parse contentDisposition from header `Content-Disposition",
                    )
                })?,
        );
        output = output.set_content_type(
            crate::http_serde::deser_header_get_sdk_content_type(response.headers()).map_err(
                |_| {
                    crate::error::GetSdkError::unhandled(
                        "Failed to parse contentType from header `Content-Type",
                    )
                },
            )?,
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_sdk_type_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetSdkTypeOutput, crate::error::GetSdkTypeError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetSdkTypeError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetSdkTypeError::unhandled(generic)),
    };
    Err(match error_code {
        "NotFoundException" => crate::error::GetSdkTypeError {
            meta: generic,
            kind: crate::error::GetSdkTypeErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetSdkTypeError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::GetSdkTypeError {
            meta: generic,
            kind: crate::error::GetSdkTypeErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetSdkTypeError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_get_sdk_type_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::GetSdkTypeError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::GetSdkTypeError {
            meta: generic,
            kind: crate::error::GetSdkTypeErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::GetSdkTypeError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetSdkTypeError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_sdk_type_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetSdkTypeOutput, crate::error::GetSdkTypeError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_sdk_type_output::Builder::default();
        let _ = response;
        output = crate::json_deser::get_sdk_type_deser_operation(response.body().as_ref(), output)
            .map_err(crate::error::GetSdkTypeError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_sdk_types_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetSdkTypesOutput, crate::error::GetSdkTypesError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetSdkTypesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetSdkTypesError::unhandled(generic)),
    };
    Err(match error_code {
        "TooManyRequestsException" => crate::error::GetSdkTypesError {
            meta: generic,
            kind: crate::error::GetSdkTypesErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetSdkTypesError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_get_sdk_types_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::GetSdkTypesError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::GetSdkTypesError {
            meta: generic,
            kind: crate::error::GetSdkTypesErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::GetSdkTypesError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetSdkTypesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_sdk_types_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetSdkTypesOutput, crate::error::GetSdkTypesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_sdk_types_output::Builder::default();
        let _ = response;
        output = crate::json_deser::get_sdk_types_deser_operation(response.body().as_ref(), output)
            .map_err(crate::error::GetSdkTypesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_stage_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetStageOutput, crate::error::GetStageError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetStageError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetStageError::unhandled(generic)),
    };
    Err(match error_code {
        "NotFoundException" => crate::error::GetStageError {
            meta: generic,
            kind: crate::error::GetStageErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetStageError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::GetStageError {
            meta: generic,
            kind: crate::error::GetStageErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetStageError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_get_stage_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::GetStageError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::GetStageError {
            meta: generic,
            kind: crate::error::GetStageErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::GetStageError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetStageError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_stage_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetStageOutput, crate::error::GetStageError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_stage_output::Builder::default();
        let _ = response;
        output = crate::json_deser::get_stage_deser_operation(response.body().as_ref(), output)
            .map_err(crate::error::GetStageError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_stages_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetStagesOutput, crate::error::GetStagesError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetStagesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetStagesError::unhandled(generic)),
    };
    Err(match error_code {
        "NotFoundException" => crate::error::GetStagesError {
            meta: generic,
            kind: crate::error::GetStagesErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetStagesError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::GetStagesError {
            meta: generic,
            kind: crate::error::GetStagesErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetStagesError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_get_stages_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::GetStagesError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::GetStagesError {
            meta: generic,
            kind: crate::error::GetStagesErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::GetStagesError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetStagesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_stages_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetStagesOutput, crate::error::GetStagesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_stages_output::Builder::default();
        let _ = response;
        output = crate::json_deser::get_stages_deser_operation(response.body().as_ref(), output)
            .map_err(crate::error::GetStagesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_tags_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetTagsOutput, crate::error::GetTagsError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetTagsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetTagsError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::GetTagsError {
            meta: generic,
            kind: crate::error::GetTagsErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetTagsError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::GetTagsError {
            meta: generic,
            kind: crate::error::GetTagsErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::limit_exceeded_exception(response.body().as_ref(), output)
                        .map_err(crate::error::GetTagsError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_get_tags_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::GetTagsError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "NotFoundException" => crate::error::GetTagsError {
            meta: generic,
            kind: crate::error::GetTagsErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetTagsError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::GetTagsError {
            meta: generic,
            kind: crate::error::GetTagsErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetTagsError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_get_tags_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::GetTagsError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::GetTagsError {
            meta: generic,
            kind: crate::error::GetTagsErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::GetTagsError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetTagsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_tags_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetTagsOutput, crate::error::GetTagsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_tags_output::Builder::default();
        let _ = response;
        output = crate::json_deser::get_tags_deser_operation(response.body().as_ref(), output)
            .map_err(crate::error::GetTagsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_usage_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetUsageOutput, crate::error::GetUsageError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetUsageError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetUsageError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::GetUsageError {
            meta: generic,
            kind: crate::error::GetUsageErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetUsageError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::GetUsageError {
            meta: generic,
            kind: crate::error::GetUsageErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetUsageError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::GetUsageError {
            meta: generic,
            kind: crate::error::GetUsageErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetUsageError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_get_usage_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::GetUsageError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::GetUsageError {
            meta: generic,
            kind: crate::error::GetUsageErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::GetUsageError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetUsageError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_usage_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetUsageOutput, crate::error::GetUsageError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_usage_output::Builder::default();
        let _ = response;
        output = crate::json_deser::get_usage_deser_operation(response.body().as_ref(), output)
            .map_err(crate::error::GetUsageError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_usage_plan_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetUsagePlanOutput, crate::error::GetUsagePlanError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetUsagePlanError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetUsagePlanError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::GetUsagePlanError {
            meta: generic,
            kind: crate::error::GetUsagePlanErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetUsagePlanError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::GetUsagePlanError {
            meta: generic,
            kind: crate::error::GetUsagePlanErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetUsagePlanError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::GetUsagePlanError {
            meta: generic,
            kind: crate::error::GetUsagePlanErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetUsagePlanError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_get_usage_plan_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::GetUsagePlanError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::GetUsagePlanError {
            meta: generic,
            kind: crate::error::GetUsagePlanErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::GetUsagePlanError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetUsagePlanError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_usage_plan_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetUsagePlanOutput, crate::error::GetUsagePlanError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_usage_plan_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::get_usage_plan_deser_operation(response.body().as_ref(), output)
                .map_err(crate::error::GetUsagePlanError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_usage_plan_key_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetUsagePlanKeyOutput, crate::error::GetUsagePlanKeyError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetUsagePlanKeyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetUsagePlanKeyError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::GetUsagePlanKeyError {
            meta: generic,
            kind: crate::error::GetUsagePlanKeyErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetUsagePlanKeyError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::GetUsagePlanKeyError {
            meta: generic,
            kind: crate::error::GetUsagePlanKeyErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetUsagePlanKeyError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::GetUsagePlanKeyError {
            meta: generic,
            kind: crate::error::GetUsagePlanKeyErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetUsagePlanKeyError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_get_usage_plan_key_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::GetUsagePlanKeyError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::GetUsagePlanKeyError {
            meta: generic,
            kind: crate::error::GetUsagePlanKeyErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::GetUsagePlanKeyError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetUsagePlanKeyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_usage_plan_key_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetUsagePlanKeyOutput, crate::error::GetUsagePlanKeyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_usage_plan_key_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::get_usage_plan_key_deser_operation(response.body().as_ref(), output)
                .map_err(crate::error::GetUsagePlanKeyError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_usage_plan_keys_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetUsagePlanKeysOutput, crate::error::GetUsagePlanKeysError>
{
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetUsagePlanKeysError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetUsagePlanKeysError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::GetUsagePlanKeysError {
            meta: generic,
            kind: crate::error::GetUsagePlanKeysErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetUsagePlanKeysError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::GetUsagePlanKeysError {
            meta: generic,
            kind: crate::error::GetUsagePlanKeysErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetUsagePlanKeysError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::GetUsagePlanKeysError {
            meta: generic,
            kind: crate::error::GetUsagePlanKeysErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetUsagePlanKeysError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_get_usage_plan_keys_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::GetUsagePlanKeysError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::GetUsagePlanKeysError {
            meta: generic,
            kind: crate::error::GetUsagePlanKeysErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::GetUsagePlanKeysError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetUsagePlanKeysError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_usage_plan_keys_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetUsagePlanKeysOutput, crate::error::GetUsagePlanKeysError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_usage_plan_keys_output::Builder::default();
        let _ = response;
        output = crate::json_deser::get_usage_plan_keys_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetUsagePlanKeysError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_usage_plans_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetUsagePlansOutput, crate::error::GetUsagePlansError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetUsagePlansError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetUsagePlansError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::GetUsagePlansError {
            meta: generic,
            kind: crate::error::GetUsagePlansErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetUsagePlansError::unhandled)?;
                output.build()
            }),
        },
        "ConflictException" => crate::error::GetUsagePlansError {
            meta: generic,
            kind: crate::error::GetUsagePlansErrorKind::ConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::conflict_error::Builder::default();
                let _ = response;
                output = crate::json_deser::conflict_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetUsagePlansError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::GetUsagePlansError {
            meta: generic,
            kind: crate::error::GetUsagePlansErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetUsagePlansError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::GetUsagePlansError {
            meta: generic,
            kind: crate::error::GetUsagePlansErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetUsagePlansError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_get_usage_plans_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::GetUsagePlansError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::GetUsagePlansError {
            meta: generic,
            kind: crate::error::GetUsagePlansErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::GetUsagePlansError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetUsagePlansError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_usage_plans_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetUsagePlansOutput, crate::error::GetUsagePlansError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_usage_plans_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::get_usage_plans_deser_operation(response.body().as_ref(), output)
                .map_err(crate::error::GetUsagePlansError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_vpc_link_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetVpcLinkOutput, crate::error::GetVpcLinkError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetVpcLinkError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetVpcLinkError::unhandled(generic)),
    };
    Err(match error_code {
        "NotFoundException" => crate::error::GetVpcLinkError {
            meta: generic,
            kind: crate::error::GetVpcLinkErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetVpcLinkError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::GetVpcLinkError {
            meta: generic,
            kind: crate::error::GetVpcLinkErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetVpcLinkError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_get_vpc_link_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::GetVpcLinkError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::GetVpcLinkError {
            meta: generic,
            kind: crate::error::GetVpcLinkErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::GetVpcLinkError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetVpcLinkError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_vpc_link_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetVpcLinkOutput, crate::error::GetVpcLinkError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_vpc_link_output::Builder::default();
        let _ = response;
        output = crate::json_deser::get_vpc_link_deser_operation(response.body().as_ref(), output)
            .map_err(crate::error::GetVpcLinkError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_vpc_links_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetVpcLinksOutput, crate::error::GetVpcLinksError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetVpcLinksError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetVpcLinksError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::GetVpcLinksError {
            meta: generic,
            kind: crate::error::GetVpcLinksErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetVpcLinksError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::GetVpcLinksError {
            meta: generic,
            kind: crate::error::GetVpcLinksErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetVpcLinksError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_get_vpc_links_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::GetVpcLinksError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::GetVpcLinksError {
            meta: generic,
            kind: crate::error::GetVpcLinksErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::GetVpcLinksError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetVpcLinksError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_vpc_links_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetVpcLinksOutput, crate::error::GetVpcLinksError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_vpc_links_output::Builder::default();
        let _ = response;
        output = crate::json_deser::get_vpc_links_deser_operation(response.body().as_ref(), output)
            .map_err(crate::error::GetVpcLinksError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_import_api_keys_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ImportApiKeysOutput, crate::error::ImportApiKeysError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ImportApiKeysError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ImportApiKeysError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::ImportApiKeysError {
            meta: generic,
            kind: crate::error::ImportApiKeysErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::ImportApiKeysError::unhandled)?;
                output.build()
            }),
        },
        "ConflictException" => crate::error::ImportApiKeysError {
            meta: generic,
            kind: crate::error::ImportApiKeysErrorKind::ConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::conflict_error::Builder::default();
                let _ = response;
                output = crate::json_deser::conflict_exception(response.body().as_ref(), output)
                    .map_err(crate::error::ImportApiKeysError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::ImportApiKeysError {
            meta: generic,
            kind: crate::error::ImportApiKeysErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::limit_exceeded_exception(response.body().as_ref(), output)
                        .map_err(crate::error::ImportApiKeysError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_import_api_keys_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::ImportApiKeysError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "NotFoundException" => crate::error::ImportApiKeysError {
            meta: generic,
            kind: crate::error::ImportApiKeysErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::ImportApiKeysError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::ImportApiKeysError {
            meta: generic,
            kind: crate::error::ImportApiKeysErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ImportApiKeysError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_import_api_keys_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::ImportApiKeysError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::ImportApiKeysError {
            meta: generic,
            kind: crate::error::ImportApiKeysErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::ImportApiKeysError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::ImportApiKeysError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_import_api_keys_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ImportApiKeysOutput, crate::error::ImportApiKeysError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::import_api_keys_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::import_api_keys_deser_operation(response.body().as_ref(), output)
                .map_err(crate::error::ImportApiKeysError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_import_documentation_parts_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ImportDocumentationPartsOutput,
    crate::error::ImportDocumentationPartsError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ImportDocumentationPartsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ImportDocumentationPartsError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "BadRequestException" => crate::error::ImportDocumentationPartsError {
            meta: generic,
            kind: crate::error::ImportDocumentationPartsErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::ImportDocumentationPartsError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => {
            crate::error::ImportDocumentationPartsError {
                meta: generic,
                kind: crate::error::ImportDocumentationPartsErrorKind::LimitExceededError({
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::limit_exceeded_exception(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ImportDocumentationPartsError::unhandled)?;
                    output = output.set_retry_after_seconds(
                crate::http_serde::deser_header_import_documentation_parts_retry_after_seconds(response.headers())
                                            .map_err(|_|crate::error::ImportDocumentationPartsError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
            );
                    output.build()
                }),
            }
        }
        "NotFoundException" => crate::error::ImportDocumentationPartsError {
            meta: generic,
            kind: crate::error::ImportDocumentationPartsErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::ImportDocumentationPartsError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => {
            crate::error::ImportDocumentationPartsError {
                meta: generic,
                kind: crate::error::ImportDocumentationPartsErrorKind::TooManyRequestsError({
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_requests_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::too_many_requests_exception(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ImportDocumentationPartsError::unhandled)?;
                    output = output.set_retry_after_seconds(
                crate::http_serde::deser_header_import_documentation_parts_retry_after_seconds(response.headers())
                                            .map_err(|_|crate::error::ImportDocumentationPartsError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
            );
                    output.build()
                }),
            }
        }
        "UnauthorizedException" => crate::error::ImportDocumentationPartsError {
            meta: generic,
            kind: crate::error::ImportDocumentationPartsErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::ImportDocumentationPartsError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::ImportDocumentationPartsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_import_documentation_parts_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ImportDocumentationPartsOutput,
    crate::error::ImportDocumentationPartsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::import_documentation_parts_output::Builder::default();
        let _ = response;
        output = crate::json_deser::import_documentation_parts_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ImportDocumentationPartsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_import_rest_api_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ImportRestApiOutput, crate::error::ImportRestApiError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ImportRestApiError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ImportRestApiError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::ImportRestApiError {
            meta: generic,
            kind: crate::error::ImportRestApiErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::ImportRestApiError::unhandled)?;
                output.build()
            }),
        },
        "ConflictException" => crate::error::ImportRestApiError {
            meta: generic,
            kind: crate::error::ImportRestApiErrorKind::ConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::conflict_error::Builder::default();
                let _ = response;
                output = crate::json_deser::conflict_exception(response.body().as_ref(), output)
                    .map_err(crate::error::ImportRestApiError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::ImportRestApiError {
            meta: generic,
            kind: crate::error::ImportRestApiErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::limit_exceeded_exception(response.body().as_ref(), output)
                        .map_err(crate::error::ImportRestApiError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_import_rest_api_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::ImportRestApiError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::ImportRestApiError {
            meta: generic,
            kind: crate::error::ImportRestApiErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ImportRestApiError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_import_rest_api_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::ImportRestApiError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::ImportRestApiError {
            meta: generic,
            kind: crate::error::ImportRestApiErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::ImportRestApiError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::ImportRestApiError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_import_rest_api_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ImportRestApiOutput, crate::error::ImportRestApiError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::import_rest_api_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::import_rest_api_deser_operation(response.body().as_ref(), output)
                .map_err(crate::error::ImportRestApiError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_gateway_response_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutGatewayResponseOutput,
    crate::error::PutGatewayResponseError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::PutGatewayResponseError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::PutGatewayResponseError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::PutGatewayResponseError {
            meta: generic,
            kind: crate::error::PutGatewayResponseErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::PutGatewayResponseError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::PutGatewayResponseError {
            meta: generic,
            kind: crate::error::PutGatewayResponseErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::limit_exceeded_exception(response.body().as_ref(), output)
                        .map_err(crate::error::PutGatewayResponseError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_put_gateway_response_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::PutGatewayResponseError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "NotFoundException" => crate::error::PutGatewayResponseError {
            meta: generic,
            kind: crate::error::PutGatewayResponseErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::PutGatewayResponseError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::PutGatewayResponseError {
            meta: generic,
            kind: crate::error::PutGatewayResponseErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::PutGatewayResponseError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_put_gateway_response_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::PutGatewayResponseError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::PutGatewayResponseError {
            meta: generic,
            kind: crate::error::PutGatewayResponseErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::PutGatewayResponseError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::PutGatewayResponseError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_gateway_response_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutGatewayResponseOutput,
    crate::error::PutGatewayResponseError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_gateway_response_output::Builder::default();
        let _ = response;
        output = crate::json_deser::put_gateway_response_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::PutGatewayResponseError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_integration_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::PutIntegrationOutput, crate::error::PutIntegrationError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::PutIntegrationError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::PutIntegrationError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::PutIntegrationError {
            meta: generic,
            kind: crate::error::PutIntegrationErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::PutIntegrationError::unhandled)?;
                output.build()
            }),
        },
        "ConflictException" => crate::error::PutIntegrationError {
            meta: generic,
            kind: crate::error::PutIntegrationErrorKind::ConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::conflict_error::Builder::default();
                let _ = response;
                output = crate::json_deser::conflict_exception(response.body().as_ref(), output)
                    .map_err(crate::error::PutIntegrationError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::PutIntegrationError {
            meta: generic,
            kind: crate::error::PutIntegrationErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::PutIntegrationError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::PutIntegrationError {
            meta: generic,
            kind: crate::error::PutIntegrationErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::PutIntegrationError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_put_integration_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::PutIntegrationError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::PutIntegrationError {
            meta: generic,
            kind: crate::error::PutIntegrationErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::PutIntegrationError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::PutIntegrationError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_integration_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::PutIntegrationOutput, crate::error::PutIntegrationError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_integration_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::put_integration_deser_operation(response.body().as_ref(), output)
                .map_err(crate::error::PutIntegrationError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_integration_response_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutIntegrationResponseOutput,
    crate::error::PutIntegrationResponseError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::PutIntegrationResponseError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::PutIntegrationResponseError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "BadRequestException" => crate::error::PutIntegrationResponseError {
            meta: generic,
            kind: crate::error::PutIntegrationResponseErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::PutIntegrationResponseError::unhandled)?;
                output.build()
            }),
        },
        "ConflictException" => crate::error::PutIntegrationResponseError {
            meta: generic,
            kind: crate::error::PutIntegrationResponseErrorKind::ConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::conflict_error::Builder::default();
                let _ = response;
                output = crate::json_deser::conflict_exception(response.body().as_ref(), output)
                    .map_err(crate::error::PutIntegrationResponseError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => {
            crate::error::PutIntegrationResponseError {
                meta: generic,
                kind: crate::error::PutIntegrationResponseErrorKind::LimitExceededError({
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::limit_exceeded_exception(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::PutIntegrationResponseError::unhandled)?;
                    output = output.set_retry_after_seconds(
                crate::http_serde::deser_header_put_integration_response_retry_after_seconds(response.headers())
                                            .map_err(|_|crate::error::PutIntegrationResponseError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
            );
                    output.build()
                }),
            }
        }
        "NotFoundException" => crate::error::PutIntegrationResponseError {
            meta: generic,
            kind: crate::error::PutIntegrationResponseErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::PutIntegrationResponseError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => {
            crate::error::PutIntegrationResponseError {
                meta: generic,
                kind: crate::error::PutIntegrationResponseErrorKind::TooManyRequestsError({
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_requests_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::too_many_requests_exception(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::PutIntegrationResponseError::unhandled)?;
                    output = output.set_retry_after_seconds(
                crate::http_serde::deser_header_put_integration_response_retry_after_seconds(response.headers())
                                            .map_err(|_|crate::error::PutIntegrationResponseError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
            );
                    output.build()
                }),
            }
        }
        "UnauthorizedException" => crate::error::PutIntegrationResponseError {
            meta: generic,
            kind: crate::error::PutIntegrationResponseErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::PutIntegrationResponseError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::PutIntegrationResponseError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_integration_response_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutIntegrationResponseOutput,
    crate::error::PutIntegrationResponseError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_integration_response_output::Builder::default();
        let _ = response;
        output = crate::json_deser::put_integration_response_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::PutIntegrationResponseError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_method_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::PutMethodOutput, crate::error::PutMethodError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::PutMethodError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::PutMethodError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::PutMethodError {
            meta: generic,
            kind: crate::error::PutMethodErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::PutMethodError::unhandled)?;
                output.build()
            }),
        },
        "ConflictException" => crate::error::PutMethodError {
            meta: generic,
            kind: crate::error::PutMethodErrorKind::ConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::conflict_error::Builder::default();
                let _ = response;
                output = crate::json_deser::conflict_exception(response.body().as_ref(), output)
                    .map_err(crate::error::PutMethodError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::PutMethodError {
            meta: generic,
            kind: crate::error::PutMethodErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::limit_exceeded_exception(response.body().as_ref(), output)
                        .map_err(crate::error::PutMethodError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_put_method_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::PutMethodError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "NotFoundException" => crate::error::PutMethodError {
            meta: generic,
            kind: crate::error::PutMethodErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::PutMethodError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::PutMethodError {
            meta: generic,
            kind: crate::error::PutMethodErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::PutMethodError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_put_method_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::PutMethodError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::PutMethodError {
            meta: generic,
            kind: crate::error::PutMethodErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::PutMethodError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::PutMethodError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_method_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::PutMethodOutput, crate::error::PutMethodError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_method_output::Builder::default();
        let _ = response;
        output = crate::json_deser::put_method_deser_operation(response.body().as_ref(), output)
            .map_err(crate::error::PutMethodError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_method_response_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::PutMethodResponseOutput, crate::error::PutMethodResponseError>
{
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::PutMethodResponseError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::PutMethodResponseError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::PutMethodResponseError {
            meta: generic,
            kind: crate::error::PutMethodResponseErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::PutMethodResponseError::unhandled)?;
                output.build()
            }),
        },
        "ConflictException" => crate::error::PutMethodResponseError {
            meta: generic,
            kind: crate::error::PutMethodResponseErrorKind::ConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::conflict_error::Builder::default();
                let _ = response;
                output = crate::json_deser::conflict_exception(response.body().as_ref(), output)
                    .map_err(crate::error::PutMethodResponseError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::PutMethodResponseError {
            meta: generic,
            kind: crate::error::PutMethodResponseErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::limit_exceeded_exception(response.body().as_ref(), output)
                        .map_err(crate::error::PutMethodResponseError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_put_method_response_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::PutMethodResponseError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "NotFoundException" => crate::error::PutMethodResponseError {
            meta: generic,
            kind: crate::error::PutMethodResponseErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::PutMethodResponseError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::PutMethodResponseError {
            meta: generic,
            kind: crate::error::PutMethodResponseErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::PutMethodResponseError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_put_method_response_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::PutMethodResponseError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::PutMethodResponseError {
            meta: generic,
            kind: crate::error::PutMethodResponseErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::PutMethodResponseError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::PutMethodResponseError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_method_response_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::PutMethodResponseOutput, crate::error::PutMethodResponseError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_method_response_output::Builder::default();
        let _ = response;
        output = crate::json_deser::put_method_response_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::PutMethodResponseError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_rest_api_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::PutRestApiOutput, crate::error::PutRestApiError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::PutRestApiError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::PutRestApiError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::PutRestApiError {
            meta: generic,
            kind: crate::error::PutRestApiErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::PutRestApiError::unhandled)?;
                output.build()
            }),
        },
        "ConflictException" => crate::error::PutRestApiError {
            meta: generic,
            kind: crate::error::PutRestApiErrorKind::ConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::conflict_error::Builder::default();
                let _ = response;
                output = crate::json_deser::conflict_exception(response.body().as_ref(), output)
                    .map_err(crate::error::PutRestApiError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::PutRestApiError {
            meta: generic,
            kind: crate::error::PutRestApiErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::limit_exceeded_exception(response.body().as_ref(), output)
                        .map_err(crate::error::PutRestApiError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_put_rest_api_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::PutRestApiError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "NotFoundException" => crate::error::PutRestApiError {
            meta: generic,
            kind: crate::error::PutRestApiErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::PutRestApiError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::PutRestApiError {
            meta: generic,
            kind: crate::error::PutRestApiErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::PutRestApiError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_put_rest_api_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::PutRestApiError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::PutRestApiError {
            meta: generic,
            kind: crate::error::PutRestApiErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::PutRestApiError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::PutRestApiError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_rest_api_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::PutRestApiOutput, crate::error::PutRestApiError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_rest_api_output::Builder::default();
        let _ = response;
        output = crate::json_deser::put_rest_api_deser_operation(response.body().as_ref(), output)
            .map_err(crate::error::PutRestApiError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_tag_resource_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::TagResourceOutput, crate::error::TagResourceError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::TagResourceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::TagResourceError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::TagResourceError {
            meta: generic,
            kind: crate::error::TagResourceErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::TagResourceError::unhandled)?;
                output.build()
            }),
        },
        "ConflictException" => crate::error::TagResourceError {
            meta: generic,
            kind: crate::error::TagResourceErrorKind::ConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::conflict_error::Builder::default();
                let _ = response;
                output = crate::json_deser::conflict_exception(response.body().as_ref(), output)
                    .map_err(crate::error::TagResourceError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::TagResourceError {
            meta: generic,
            kind: crate::error::TagResourceErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::limit_exceeded_exception(response.body().as_ref(), output)
                        .map_err(crate::error::TagResourceError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_tag_resource_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::TagResourceError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "NotFoundException" => crate::error::TagResourceError {
            meta: generic,
            kind: crate::error::TagResourceErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::TagResourceError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::TagResourceError {
            meta: generic,
            kind: crate::error::TagResourceErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::TagResourceError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_tag_resource_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::TagResourceError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::TagResourceError {
            meta: generic,
            kind: crate::error::TagResourceErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::TagResourceError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::TagResourceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_tag_resource_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::TagResourceOutput, crate::error::TagResourceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::tag_resource_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_test_invoke_authorizer_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::TestInvokeAuthorizerOutput,
    crate::error::TestInvokeAuthorizerError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::TestInvokeAuthorizerError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::TestInvokeAuthorizerError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::TestInvokeAuthorizerError {
            meta: generic,
            kind: crate::error::TestInvokeAuthorizerErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::TestInvokeAuthorizerError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::TestInvokeAuthorizerError {
            meta: generic,
            kind: crate::error::TestInvokeAuthorizerErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::TestInvokeAuthorizerError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::TestInvokeAuthorizerError {
            meta: generic,
            kind: crate::error::TestInvokeAuthorizerErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::TestInvokeAuthorizerError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_test_invoke_authorizer_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::TestInvokeAuthorizerError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::TestInvokeAuthorizerError {
            meta: generic,
            kind: crate::error::TestInvokeAuthorizerErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::TestInvokeAuthorizerError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::TestInvokeAuthorizerError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_test_invoke_authorizer_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::TestInvokeAuthorizerOutput,
    crate::error::TestInvokeAuthorizerError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::test_invoke_authorizer_output::Builder::default();
        let _ = response;
        output = crate::json_deser::test_invoke_authorizer_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::TestInvokeAuthorizerError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_test_invoke_method_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::TestInvokeMethodOutput, crate::error::TestInvokeMethodError>
{
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::TestInvokeMethodError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::TestInvokeMethodError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::TestInvokeMethodError {
            meta: generic,
            kind: crate::error::TestInvokeMethodErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::TestInvokeMethodError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::TestInvokeMethodError {
            meta: generic,
            kind: crate::error::TestInvokeMethodErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::TestInvokeMethodError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::TestInvokeMethodError {
            meta: generic,
            kind: crate::error::TestInvokeMethodErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::TestInvokeMethodError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_test_invoke_method_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::TestInvokeMethodError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::TestInvokeMethodError {
            meta: generic,
            kind: crate::error::TestInvokeMethodErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::TestInvokeMethodError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::TestInvokeMethodError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_test_invoke_method_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::TestInvokeMethodOutput, crate::error::TestInvokeMethodError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::test_invoke_method_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::test_invoke_method_deser_operation(response.body().as_ref(), output)
                .map_err(crate::error::TestInvokeMethodError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_untag_resource_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::UntagResourceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UntagResourceError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::UntagResourceError {
            meta: generic,
            kind: crate::error::UntagResourceErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UntagResourceError::unhandled)?;
                output.build()
            }),
        },
        "ConflictException" => crate::error::UntagResourceError {
            meta: generic,
            kind: crate::error::UntagResourceErrorKind::ConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::conflict_error::Builder::default();
                let _ = response;
                output = crate::json_deser::conflict_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UntagResourceError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::UntagResourceError {
            meta: generic,
            kind: crate::error::UntagResourceErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UntagResourceError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::UntagResourceError {
            meta: generic,
            kind: crate::error::UntagResourceErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UntagResourceError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_untag_resource_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::UntagResourceError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::UntagResourceError {
            meta: generic,
            kind: crate::error::UntagResourceErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::UntagResourceError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::UntagResourceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_untag_resource_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::untag_resource_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_account_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateAccountOutput, crate::error::UpdateAccountError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateAccountError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateAccountError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::UpdateAccountError {
            meta: generic,
            kind: crate::error::UpdateAccountErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UpdateAccountError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::UpdateAccountError {
            meta: generic,
            kind: crate::error::UpdateAccountErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UpdateAccountError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::UpdateAccountError {
            meta: generic,
            kind: crate::error::UpdateAccountErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateAccountError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_update_account_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::UpdateAccountError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::UpdateAccountError {
            meta: generic,
            kind: crate::error::UpdateAccountErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::UpdateAccountError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::UpdateAccountError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_account_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateAccountOutput, crate::error::UpdateAccountError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_account_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::update_account_deser_operation(response.body().as_ref(), output)
                .map_err(crate::error::UpdateAccountError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_api_key_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateApiKeyOutput, crate::error::UpdateApiKeyError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateApiKeyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateApiKeyError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::UpdateApiKeyError {
            meta: generic,
            kind: crate::error::UpdateApiKeyErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UpdateApiKeyError::unhandled)?;
                output.build()
            }),
        },
        "ConflictException" => crate::error::UpdateApiKeyError {
            meta: generic,
            kind: crate::error::UpdateApiKeyErrorKind::ConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::conflict_error::Builder::default();
                let _ = response;
                output = crate::json_deser::conflict_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UpdateApiKeyError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::UpdateApiKeyError {
            meta: generic,
            kind: crate::error::UpdateApiKeyErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UpdateApiKeyError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::UpdateApiKeyError {
            meta: generic,
            kind: crate::error::UpdateApiKeyErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateApiKeyError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_update_api_key_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::UpdateApiKeyError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::UpdateApiKeyError {
            meta: generic,
            kind: crate::error::UpdateApiKeyErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::UpdateApiKeyError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::UpdateApiKeyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_api_key_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateApiKeyOutput, crate::error::UpdateApiKeyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_api_key_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::update_api_key_deser_operation(response.body().as_ref(), output)
                .map_err(crate::error::UpdateApiKeyError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_authorizer_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateAuthorizerOutput, crate::error::UpdateAuthorizerError>
{
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateAuthorizerError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateAuthorizerError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::UpdateAuthorizerError {
            meta: generic,
            kind: crate::error::UpdateAuthorizerErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UpdateAuthorizerError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::UpdateAuthorizerError {
            meta: generic,
            kind: crate::error::UpdateAuthorizerErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UpdateAuthorizerError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::UpdateAuthorizerError {
            meta: generic,
            kind: crate::error::UpdateAuthorizerErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateAuthorizerError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_update_authorizer_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::UpdateAuthorizerError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::UpdateAuthorizerError {
            meta: generic,
            kind: crate::error::UpdateAuthorizerErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::UpdateAuthorizerError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::UpdateAuthorizerError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_authorizer_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateAuthorizerOutput, crate::error::UpdateAuthorizerError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_authorizer_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::update_authorizer_deser_operation(response.body().as_ref(), output)
                .map_err(crate::error::UpdateAuthorizerError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_base_path_mapping_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateBasePathMappingOutput,
    crate::error::UpdateBasePathMappingError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateBasePathMappingError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateBasePathMappingError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::UpdateBasePathMappingError {
            meta: generic,
            kind: crate::error::UpdateBasePathMappingErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UpdateBasePathMappingError::unhandled)?;
                output.build()
            }),
        },
        "ConflictException" => crate::error::UpdateBasePathMappingError {
            meta: generic,
            kind: crate::error::UpdateBasePathMappingErrorKind::ConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::conflict_error::Builder::default();
                let _ = response;
                output = crate::json_deser::conflict_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UpdateBasePathMappingError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::UpdateBasePathMappingError {
            meta: generic,
            kind: crate::error::UpdateBasePathMappingErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UpdateBasePathMappingError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => {
            crate::error::UpdateBasePathMappingError {
                meta: generic,
                kind: crate::error::UpdateBasePathMappingErrorKind::TooManyRequestsError({
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_requests_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::too_many_requests_exception(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateBasePathMappingError::unhandled)?;
                    output = output.set_retry_after_seconds(
                crate::http_serde::deser_header_update_base_path_mapping_retry_after_seconds(response.headers())
                                            .map_err(|_|crate::error::UpdateBasePathMappingError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
            );
                    output.build()
                }),
            }
        }
        "UnauthorizedException" => crate::error::UpdateBasePathMappingError {
            meta: generic,
            kind: crate::error::UpdateBasePathMappingErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::UpdateBasePathMappingError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::UpdateBasePathMappingError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_base_path_mapping_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateBasePathMappingOutput,
    crate::error::UpdateBasePathMappingError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_base_path_mapping_output::Builder::default();
        let _ = response;
        output = crate::json_deser::update_base_path_mapping_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateBasePathMappingError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_client_certificate_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateClientCertificateOutput,
    crate::error::UpdateClientCertificateError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateClientCertificateError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdateClientCertificateError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "BadRequestException" => crate::error::UpdateClientCertificateError {
            meta: generic,
            kind: crate::error::UpdateClientCertificateErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UpdateClientCertificateError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::UpdateClientCertificateError {
            meta: generic,
            kind: crate::error::UpdateClientCertificateErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UpdateClientCertificateError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => {
            crate::error::UpdateClientCertificateError {
                meta: generic,
                kind: crate::error::UpdateClientCertificateErrorKind::TooManyRequestsError({
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_requests_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::too_many_requests_exception(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateClientCertificateError::unhandled)?;
                    output = output.set_retry_after_seconds(
                crate::http_serde::deser_header_update_client_certificate_retry_after_seconds(response.headers())
                                            .map_err(|_|crate::error::UpdateClientCertificateError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
            );
                    output.build()
                }),
            }
        }
        "UnauthorizedException" => crate::error::UpdateClientCertificateError {
            meta: generic,
            kind: crate::error::UpdateClientCertificateErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::UpdateClientCertificateError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::UpdateClientCertificateError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_client_certificate_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateClientCertificateOutput,
    crate::error::UpdateClientCertificateError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_client_certificate_output::Builder::default();
        let _ = response;
        output = crate::json_deser::update_client_certificate_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateClientCertificateError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_deployment_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateDeploymentOutput, crate::error::UpdateDeploymentError>
{
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateDeploymentError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateDeploymentError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::UpdateDeploymentError {
            meta: generic,
            kind: crate::error::UpdateDeploymentErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UpdateDeploymentError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::UpdateDeploymentError {
            meta: generic,
            kind: crate::error::UpdateDeploymentErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UpdateDeploymentError::unhandled)?;
                output.build()
            }),
        },
        "ServiceUnavailableException" => crate::error::UpdateDeploymentError {
            meta: generic,
            kind: crate::error::UpdateDeploymentErrorKind::ServiceUnavailableError({
                #[allow(unused_mut)]
                let mut output = crate::error::service_unavailable_error::Builder::default();
                let _ = response;
                output = crate::json_deser::service_unavailable_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateDeploymentError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_update_deployment_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::UpdateDeploymentError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::UpdateDeploymentError {
            meta: generic,
            kind: crate::error::UpdateDeploymentErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateDeploymentError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_update_deployment_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::UpdateDeploymentError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::UpdateDeploymentError {
            meta: generic,
            kind: crate::error::UpdateDeploymentErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::UpdateDeploymentError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::UpdateDeploymentError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_deployment_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateDeploymentOutput, crate::error::UpdateDeploymentError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_deployment_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::update_deployment_deser_operation(response.body().as_ref(), output)
                .map_err(crate::error::UpdateDeploymentError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_documentation_part_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateDocumentationPartOutput,
    crate::error::UpdateDocumentationPartError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateDocumentationPartError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdateDocumentationPartError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "BadRequestException" => crate::error::UpdateDocumentationPartError {
            meta: generic,
            kind: crate::error::UpdateDocumentationPartErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UpdateDocumentationPartError::unhandled)?;
                output.build()
            }),
        },
        "ConflictException" => crate::error::UpdateDocumentationPartError {
            meta: generic,
            kind: crate::error::UpdateDocumentationPartErrorKind::ConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::conflict_error::Builder::default();
                let _ = response;
                output = crate::json_deser::conflict_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UpdateDocumentationPartError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => {
            crate::error::UpdateDocumentationPartError {
                meta: generic,
                kind: crate::error::UpdateDocumentationPartErrorKind::LimitExceededError({
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::limit_exceeded_exception(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateDocumentationPartError::unhandled)?;
                    output = output.set_retry_after_seconds(
                crate::http_serde::deser_header_update_documentation_part_retry_after_seconds(response.headers())
                                            .map_err(|_|crate::error::UpdateDocumentationPartError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
            );
                    output.build()
                }),
            }
        }
        "NotFoundException" => crate::error::UpdateDocumentationPartError {
            meta: generic,
            kind: crate::error::UpdateDocumentationPartErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UpdateDocumentationPartError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => {
            crate::error::UpdateDocumentationPartError {
                meta: generic,
                kind: crate::error::UpdateDocumentationPartErrorKind::TooManyRequestsError({
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_requests_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::too_many_requests_exception(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateDocumentationPartError::unhandled)?;
                    output = output.set_retry_after_seconds(
                crate::http_serde::deser_header_update_documentation_part_retry_after_seconds(response.headers())
                                            .map_err(|_|crate::error::UpdateDocumentationPartError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
            );
                    output.build()
                }),
            }
        }
        "UnauthorizedException" => crate::error::UpdateDocumentationPartError {
            meta: generic,
            kind: crate::error::UpdateDocumentationPartErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::UpdateDocumentationPartError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::UpdateDocumentationPartError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_documentation_part_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateDocumentationPartOutput,
    crate::error::UpdateDocumentationPartError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_documentation_part_output::Builder::default();
        let _ = response;
        output = crate::json_deser::update_documentation_part_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateDocumentationPartError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_documentation_version_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateDocumentationVersionOutput,
    crate::error::UpdateDocumentationVersionError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateDocumentationVersionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdateDocumentationVersionError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "BadRequestException" => crate::error::UpdateDocumentationVersionError {
            meta: generic,
            kind: crate::error::UpdateDocumentationVersionErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UpdateDocumentationVersionError::unhandled)?;
                output.build()
            }),
        },
        "ConflictException" => crate::error::UpdateDocumentationVersionError {
            meta: generic,
            kind: crate::error::UpdateDocumentationVersionErrorKind::ConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::conflict_error::Builder::default();
                let _ = response;
                output = crate::json_deser::conflict_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UpdateDocumentationVersionError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::UpdateDocumentationVersionError {
            meta: generic,
            kind: crate::error::UpdateDocumentationVersionErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UpdateDocumentationVersionError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::UpdateDocumentationVersionError {
            meta: generic,
            kind: crate::error::UpdateDocumentationVersionErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateDocumentationVersionError::unhandled)?;
                output = output.set_retry_after_seconds(
                crate::http_serde::deser_header_update_documentation_version_retry_after_seconds(response.headers())
                                            .map_err(|_|crate::error::UpdateDocumentationVersionError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
            );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::UpdateDocumentationVersionError {
            meta: generic,
            kind: crate::error::UpdateDocumentationVersionErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::UpdateDocumentationVersionError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::UpdateDocumentationVersionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_documentation_version_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateDocumentationVersionOutput,
    crate::error::UpdateDocumentationVersionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_documentation_version_output::Builder::default();
        let _ = response;
        output = crate::json_deser::update_documentation_version_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateDocumentationVersionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_domain_name_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateDomainNameOutput, crate::error::UpdateDomainNameError>
{
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateDomainNameError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateDomainNameError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::UpdateDomainNameError {
            meta: generic,
            kind: crate::error::UpdateDomainNameErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UpdateDomainNameError::unhandled)?;
                output.build()
            }),
        },
        "ConflictException" => crate::error::UpdateDomainNameError {
            meta: generic,
            kind: crate::error::UpdateDomainNameErrorKind::ConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::conflict_error::Builder::default();
                let _ = response;
                output = crate::json_deser::conflict_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UpdateDomainNameError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::UpdateDomainNameError {
            meta: generic,
            kind: crate::error::UpdateDomainNameErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UpdateDomainNameError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::UpdateDomainNameError {
            meta: generic,
            kind: crate::error::UpdateDomainNameErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateDomainNameError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_update_domain_name_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::UpdateDomainNameError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::UpdateDomainNameError {
            meta: generic,
            kind: crate::error::UpdateDomainNameErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::UpdateDomainNameError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::UpdateDomainNameError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_domain_name_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateDomainNameOutput, crate::error::UpdateDomainNameError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_domain_name_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::update_domain_name_deser_operation(response.body().as_ref(), output)
                .map_err(crate::error::UpdateDomainNameError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_gateway_response_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateGatewayResponseOutput,
    crate::error::UpdateGatewayResponseError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateGatewayResponseError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateGatewayResponseError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::UpdateGatewayResponseError {
            meta: generic,
            kind: crate::error::UpdateGatewayResponseErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UpdateGatewayResponseError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::UpdateGatewayResponseError {
            meta: generic,
            kind: crate::error::UpdateGatewayResponseErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UpdateGatewayResponseError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => {
            crate::error::UpdateGatewayResponseError {
                meta: generic,
                kind: crate::error::UpdateGatewayResponseErrorKind::TooManyRequestsError({
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_requests_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::too_many_requests_exception(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateGatewayResponseError::unhandled)?;
                    output = output.set_retry_after_seconds(
                crate::http_serde::deser_header_update_gateway_response_retry_after_seconds(response.headers())
                                            .map_err(|_|crate::error::UpdateGatewayResponseError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
            );
                    output.build()
                }),
            }
        }
        "UnauthorizedException" => crate::error::UpdateGatewayResponseError {
            meta: generic,
            kind: crate::error::UpdateGatewayResponseErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::UpdateGatewayResponseError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::UpdateGatewayResponseError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_gateway_response_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateGatewayResponseOutput,
    crate::error::UpdateGatewayResponseError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_gateway_response_output::Builder::default();
        let _ = response;
        output = crate::json_deser::update_gateway_response_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateGatewayResponseError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_integration_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateIntegrationOutput, crate::error::UpdateIntegrationError>
{
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateIntegrationError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateIntegrationError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::UpdateIntegrationError {
            meta: generic,
            kind: crate::error::UpdateIntegrationErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UpdateIntegrationError::unhandled)?;
                output.build()
            }),
        },
        "ConflictException" => crate::error::UpdateIntegrationError {
            meta: generic,
            kind: crate::error::UpdateIntegrationErrorKind::ConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::conflict_error::Builder::default();
                let _ = response;
                output = crate::json_deser::conflict_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UpdateIntegrationError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::UpdateIntegrationError {
            meta: generic,
            kind: crate::error::UpdateIntegrationErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UpdateIntegrationError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::UpdateIntegrationError {
            meta: generic,
            kind: crate::error::UpdateIntegrationErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateIntegrationError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_update_integration_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::UpdateIntegrationError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::UpdateIntegrationError {
            meta: generic,
            kind: crate::error::UpdateIntegrationErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::UpdateIntegrationError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::UpdateIntegrationError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_integration_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateIntegrationOutput, crate::error::UpdateIntegrationError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_integration_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::update_integration_deser_operation(response.body().as_ref(), output)
                .map_err(crate::error::UpdateIntegrationError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_integration_response_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateIntegrationResponseOutput,
    crate::error::UpdateIntegrationResponseError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateIntegrationResponseError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdateIntegrationResponseError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "BadRequestException" => crate::error::UpdateIntegrationResponseError {
            meta: generic,
            kind: crate::error::UpdateIntegrationResponseErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UpdateIntegrationResponseError::unhandled)?;
                output.build()
            }),
        },
        "ConflictException" => crate::error::UpdateIntegrationResponseError {
            meta: generic,
            kind: crate::error::UpdateIntegrationResponseErrorKind::ConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::conflict_error::Builder::default();
                let _ = response;
                output = crate::json_deser::conflict_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UpdateIntegrationResponseError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::UpdateIntegrationResponseError {
            meta: generic,
            kind: crate::error::UpdateIntegrationResponseErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UpdateIntegrationResponseError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::UpdateIntegrationResponseError {
            meta: generic,
            kind: crate::error::UpdateIntegrationResponseErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateIntegrationResponseError::unhandled)?;
                output = output.set_retry_after_seconds(
                crate::http_serde::deser_header_update_integration_response_retry_after_seconds(response.headers())
                                            .map_err(|_|crate::error::UpdateIntegrationResponseError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
            );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::UpdateIntegrationResponseError {
            meta: generic,
            kind: crate::error::UpdateIntegrationResponseErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::UpdateIntegrationResponseError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::UpdateIntegrationResponseError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_integration_response_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateIntegrationResponseOutput,
    crate::error::UpdateIntegrationResponseError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_integration_response_output::Builder::default();
        let _ = response;
        output = crate::json_deser::update_integration_response_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateIntegrationResponseError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_method_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateMethodOutput, crate::error::UpdateMethodError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateMethodError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateMethodError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::UpdateMethodError {
            meta: generic,
            kind: crate::error::UpdateMethodErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UpdateMethodError::unhandled)?;
                output.build()
            }),
        },
        "ConflictException" => crate::error::UpdateMethodError {
            meta: generic,
            kind: crate::error::UpdateMethodErrorKind::ConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::conflict_error::Builder::default();
                let _ = response;
                output = crate::json_deser::conflict_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UpdateMethodError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::UpdateMethodError {
            meta: generic,
            kind: crate::error::UpdateMethodErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UpdateMethodError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::UpdateMethodError {
            meta: generic,
            kind: crate::error::UpdateMethodErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateMethodError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_update_method_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::UpdateMethodError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::UpdateMethodError {
            meta: generic,
            kind: crate::error::UpdateMethodErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::UpdateMethodError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::UpdateMethodError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_method_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateMethodOutput, crate::error::UpdateMethodError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_method_output::Builder::default();
        let _ = response;
        output = crate::json_deser::update_method_deser_operation(response.body().as_ref(), output)
            .map_err(crate::error::UpdateMethodError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_method_response_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateMethodResponseOutput,
    crate::error::UpdateMethodResponseError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateMethodResponseError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateMethodResponseError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::UpdateMethodResponseError {
            meta: generic,
            kind: crate::error::UpdateMethodResponseErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UpdateMethodResponseError::unhandled)?;
                output.build()
            }),
        },
        "ConflictException" => crate::error::UpdateMethodResponseError {
            meta: generic,
            kind: crate::error::UpdateMethodResponseErrorKind::ConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::conflict_error::Builder::default();
                let _ = response;
                output = crate::json_deser::conflict_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UpdateMethodResponseError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::UpdateMethodResponseError {
            meta: generic,
            kind: crate::error::UpdateMethodResponseErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::limit_exceeded_exception(response.body().as_ref(), output)
                        .map_err(crate::error::UpdateMethodResponseError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_update_method_response_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::UpdateMethodResponseError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "NotFoundException" => crate::error::UpdateMethodResponseError {
            meta: generic,
            kind: crate::error::UpdateMethodResponseErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UpdateMethodResponseError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::UpdateMethodResponseError {
            meta: generic,
            kind: crate::error::UpdateMethodResponseErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateMethodResponseError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_update_method_response_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::UpdateMethodResponseError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::UpdateMethodResponseError {
            meta: generic,
            kind: crate::error::UpdateMethodResponseErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::UpdateMethodResponseError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::UpdateMethodResponseError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_method_response_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateMethodResponseOutput,
    crate::error::UpdateMethodResponseError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_method_response_output::Builder::default();
        let _ = response;
        output = crate::json_deser::update_method_response_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateMethodResponseError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_model_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateModelOutput, crate::error::UpdateModelError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateModelError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateModelError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::UpdateModelError {
            meta: generic,
            kind: crate::error::UpdateModelErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UpdateModelError::unhandled)?;
                output.build()
            }),
        },
        "ConflictException" => crate::error::UpdateModelError {
            meta: generic,
            kind: crate::error::UpdateModelErrorKind::ConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::conflict_error::Builder::default();
                let _ = response;
                output = crate::json_deser::conflict_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UpdateModelError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::UpdateModelError {
            meta: generic,
            kind: crate::error::UpdateModelErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UpdateModelError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::UpdateModelError {
            meta: generic,
            kind: crate::error::UpdateModelErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateModelError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_update_model_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::UpdateModelError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::UpdateModelError {
            meta: generic,
            kind: crate::error::UpdateModelErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::UpdateModelError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::UpdateModelError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_model_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateModelOutput, crate::error::UpdateModelError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_model_output::Builder::default();
        let _ = response;
        output = crate::json_deser::update_model_deser_operation(response.body().as_ref(), output)
            .map_err(crate::error::UpdateModelError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_request_validator_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateRequestValidatorOutput,
    crate::error::UpdateRequestValidatorError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateRequestValidatorError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdateRequestValidatorError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "BadRequestException" => crate::error::UpdateRequestValidatorError {
            meta: generic,
            kind: crate::error::UpdateRequestValidatorErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UpdateRequestValidatorError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::UpdateRequestValidatorError {
            meta: generic,
            kind: crate::error::UpdateRequestValidatorErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UpdateRequestValidatorError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => {
            crate::error::UpdateRequestValidatorError {
                meta: generic,
                kind: crate::error::UpdateRequestValidatorErrorKind::TooManyRequestsError({
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_requests_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::too_many_requests_exception(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateRequestValidatorError::unhandled)?;
                    output = output.set_retry_after_seconds(
                crate::http_serde::deser_header_update_request_validator_retry_after_seconds(response.headers())
                                            .map_err(|_|crate::error::UpdateRequestValidatorError::unhandled("Failed to parse retryAfterSeconds from header `Retry-After"))?
            );
                    output.build()
                }),
            }
        }
        "UnauthorizedException" => crate::error::UpdateRequestValidatorError {
            meta: generic,
            kind: crate::error::UpdateRequestValidatorErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::UpdateRequestValidatorError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::UpdateRequestValidatorError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_request_validator_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateRequestValidatorOutput,
    crate::error::UpdateRequestValidatorError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_request_validator_output::Builder::default();
        let _ = response;
        output = crate::json_deser::update_request_validator_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateRequestValidatorError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_resource_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateResourceOutput, crate::error::UpdateResourceError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateResourceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateResourceError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::UpdateResourceError {
            meta: generic,
            kind: crate::error::UpdateResourceErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UpdateResourceError::unhandled)?;
                output.build()
            }),
        },
        "ConflictException" => crate::error::UpdateResourceError {
            meta: generic,
            kind: crate::error::UpdateResourceErrorKind::ConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::conflict_error::Builder::default();
                let _ = response;
                output = crate::json_deser::conflict_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UpdateResourceError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::UpdateResourceError {
            meta: generic,
            kind: crate::error::UpdateResourceErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UpdateResourceError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::UpdateResourceError {
            meta: generic,
            kind: crate::error::UpdateResourceErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateResourceError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_update_resource_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::UpdateResourceError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::UpdateResourceError {
            meta: generic,
            kind: crate::error::UpdateResourceErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::UpdateResourceError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::UpdateResourceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_resource_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateResourceOutput, crate::error::UpdateResourceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_resource_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::update_resource_deser_operation(response.body().as_ref(), output)
                .map_err(crate::error::UpdateResourceError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_rest_api_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateRestApiOutput, crate::error::UpdateRestApiError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateRestApiError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateRestApiError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::UpdateRestApiError {
            meta: generic,
            kind: crate::error::UpdateRestApiErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UpdateRestApiError::unhandled)?;
                output.build()
            }),
        },
        "ConflictException" => crate::error::UpdateRestApiError {
            meta: generic,
            kind: crate::error::UpdateRestApiErrorKind::ConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::conflict_error::Builder::default();
                let _ = response;
                output = crate::json_deser::conflict_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UpdateRestApiError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::UpdateRestApiError {
            meta: generic,
            kind: crate::error::UpdateRestApiErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UpdateRestApiError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::UpdateRestApiError {
            meta: generic,
            kind: crate::error::UpdateRestApiErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateRestApiError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_update_rest_api_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::UpdateRestApiError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::UpdateRestApiError {
            meta: generic,
            kind: crate::error::UpdateRestApiErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::UpdateRestApiError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::UpdateRestApiError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_rest_api_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateRestApiOutput, crate::error::UpdateRestApiError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_rest_api_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::update_rest_api_deser_operation(response.body().as_ref(), output)
                .map_err(crate::error::UpdateRestApiError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_stage_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateStageOutput, crate::error::UpdateStageError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateStageError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateStageError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::UpdateStageError {
            meta: generic,
            kind: crate::error::UpdateStageErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UpdateStageError::unhandled)?;
                output.build()
            }),
        },
        "ConflictException" => crate::error::UpdateStageError {
            meta: generic,
            kind: crate::error::UpdateStageErrorKind::ConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::conflict_error::Builder::default();
                let _ = response;
                output = crate::json_deser::conflict_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UpdateStageError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::UpdateStageError {
            meta: generic,
            kind: crate::error::UpdateStageErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UpdateStageError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::UpdateStageError {
            meta: generic,
            kind: crate::error::UpdateStageErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateStageError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_update_stage_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::UpdateStageError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::UpdateStageError {
            meta: generic,
            kind: crate::error::UpdateStageErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::UpdateStageError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::UpdateStageError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_stage_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateStageOutput, crate::error::UpdateStageError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_stage_output::Builder::default();
        let _ = response;
        output = crate::json_deser::update_stage_deser_operation(response.body().as_ref(), output)
            .map_err(crate::error::UpdateStageError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_usage_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateUsageOutput, crate::error::UpdateUsageError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateUsageError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateUsageError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::UpdateUsageError {
            meta: generic,
            kind: crate::error::UpdateUsageErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UpdateUsageError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::UpdateUsageError {
            meta: generic,
            kind: crate::error::UpdateUsageErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UpdateUsageError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::UpdateUsageError {
            meta: generic,
            kind: crate::error::UpdateUsageErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateUsageError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_update_usage_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::UpdateUsageError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::UpdateUsageError {
            meta: generic,
            kind: crate::error::UpdateUsageErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::UpdateUsageError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::UpdateUsageError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_usage_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateUsageOutput, crate::error::UpdateUsageError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_usage_output::Builder::default();
        let _ = response;
        output = crate::json_deser::update_usage_deser_operation(response.body().as_ref(), output)
            .map_err(crate::error::UpdateUsageError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_usage_plan_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateUsagePlanOutput, crate::error::UpdateUsagePlanError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateUsagePlanError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateUsagePlanError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::UpdateUsagePlanError {
            meta: generic,
            kind: crate::error::UpdateUsagePlanErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UpdateUsagePlanError::unhandled)?;
                output.build()
            }),
        },
        "ConflictException" => crate::error::UpdateUsagePlanError {
            meta: generic,
            kind: crate::error::UpdateUsagePlanErrorKind::ConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::conflict_error::Builder::default();
                let _ = response;
                output = crate::json_deser::conflict_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UpdateUsagePlanError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::UpdateUsagePlanError {
            meta: generic,
            kind: crate::error::UpdateUsagePlanErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UpdateUsagePlanError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::UpdateUsagePlanError {
            meta: generic,
            kind: crate::error::UpdateUsagePlanErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateUsagePlanError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_update_usage_plan_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::UpdateUsagePlanError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::UpdateUsagePlanError {
            meta: generic,
            kind: crate::error::UpdateUsagePlanErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::UpdateUsagePlanError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::UpdateUsagePlanError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_usage_plan_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateUsagePlanOutput, crate::error::UpdateUsagePlanError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_usage_plan_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::update_usage_plan_deser_operation(response.body().as_ref(), output)
                .map_err(crate::error::UpdateUsagePlanError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_vpc_link_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateVpcLinkOutput, crate::error::UpdateVpcLinkError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateVpcLinkError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateVpcLinkError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::UpdateVpcLinkError {
            meta: generic,
            kind: crate::error::UpdateVpcLinkErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UpdateVpcLinkError::unhandled)?;
                output.build()
            }),
        },
        "ConflictException" => crate::error::UpdateVpcLinkError {
            meta: generic,
            kind: crate::error::UpdateVpcLinkErrorKind::ConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::conflict_error::Builder::default();
                let _ = response;
                output = crate::json_deser::conflict_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UpdateVpcLinkError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::UpdateVpcLinkError {
            meta: generic,
            kind: crate::error::UpdateVpcLinkErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UpdateVpcLinkError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::UpdateVpcLinkError {
            meta: generic,
            kind: crate::error::UpdateVpcLinkErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateVpcLinkError::unhandled)?;
                output = output.set_retry_after_seconds(
                    crate::http_serde::deser_header_update_vpc_link_retry_after_seconds(
                        response.headers(),
                    )
                    .map_err(|_| {
                        crate::error::UpdateVpcLinkError::unhandled(
                            "Failed to parse retryAfterSeconds from header `Retry-After",
                        )
                    })?,
                );
                output.build()
            }),
        },
        "UnauthorizedException" => crate::error::UpdateVpcLinkError {
            meta: generic,
            kind: crate::error::UpdateVpcLinkErrorKind::UnauthorizedError({
                #[allow(unused_mut)]
                let mut output = crate::error::unauthorized_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::unauthorized_exception(response.body().as_ref(), output)
                        .map_err(crate::error::UpdateVpcLinkError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::UpdateVpcLinkError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_vpc_link_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateVpcLinkOutput, crate::error::UpdateVpcLinkError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_vpc_link_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::update_vpc_link_deser_operation(response.body().as_ref(), output)
                .map_err(crate::error::UpdateVpcLinkError::unhandled)?;
        output.build()
    })
}
