// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateApiKeyError {
    pub kind: CreateApiKeyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateApiKeyErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateApiKeyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateApiKeyErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateApiKeyErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateApiKeyErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateApiKeyErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateApiKeyErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            CreateApiKeyErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            CreateApiKeyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateApiKeyError {
    fn code(&self) -> Option<&str> {
        CreateApiKeyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateApiKeyError {
    pub fn new(kind: CreateApiKeyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateApiKeyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateApiKeyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, CreateApiKeyErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, CreateApiKeyErrorKind::ConflictException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, CreateApiKeyErrorKind::LimitExceededException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, CreateApiKeyErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateApiKeyErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, CreateApiKeyErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for CreateApiKeyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateApiKeyErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateApiKeyErrorKind::ConflictException(_inner) => Some(_inner),
            CreateApiKeyErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateApiKeyErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateApiKeyErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            CreateApiKeyErrorKind::UnauthorizedException(_inner) => Some(_inner),
            CreateApiKeyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateAuthorizerError {
    pub kind: CreateAuthorizerErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateAuthorizerErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateAuthorizerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateAuthorizerErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateAuthorizerErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateAuthorizerErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateAuthorizerErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateAuthorizerErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            CreateAuthorizerErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            CreateAuthorizerErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateAuthorizerError {
    fn code(&self) -> Option<&str> {
        CreateAuthorizerError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateAuthorizerError {
    pub fn new(kind: CreateAuthorizerErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateAuthorizerErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateAuthorizerErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAuthorizerErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, CreateAuthorizerErrorKind::ConflictException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAuthorizerErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, CreateAuthorizerErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAuthorizerErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAuthorizerErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for CreateAuthorizerError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateAuthorizerErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateAuthorizerErrorKind::ConflictException(_inner) => Some(_inner),
            CreateAuthorizerErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateAuthorizerErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateAuthorizerErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            CreateAuthorizerErrorKind::UnauthorizedException(_inner) => Some(_inner),
            CreateAuthorizerErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateBasePathMappingError {
    pub kind: CreateBasePathMappingErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateBasePathMappingErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateBasePathMappingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateBasePathMappingErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateBasePathMappingErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateBasePathMappingErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateBasePathMappingErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateBasePathMappingErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            CreateBasePathMappingErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            CreateBasePathMappingErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateBasePathMappingError {
    fn code(&self) -> Option<&str> {
        CreateBasePathMappingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateBasePathMappingError {
    pub fn new(kind: CreateBasePathMappingErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateBasePathMappingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateBasePathMappingErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBasePathMappingErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBasePathMappingErrorKind::ConflictException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBasePathMappingErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBasePathMappingErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBasePathMappingErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBasePathMappingErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for CreateBasePathMappingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateBasePathMappingErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateBasePathMappingErrorKind::ConflictException(_inner) => Some(_inner),
            CreateBasePathMappingErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateBasePathMappingErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateBasePathMappingErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            CreateBasePathMappingErrorKind::UnauthorizedException(_inner) => Some(_inner),
            CreateBasePathMappingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateDeploymentError {
    pub kind: CreateDeploymentErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDeploymentErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateDeploymentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateDeploymentErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateDeploymentErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateDeploymentErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateDeploymentErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateDeploymentErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateDeploymentErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            CreateDeploymentErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            CreateDeploymentErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateDeploymentError {
    fn code(&self) -> Option<&str> {
        CreateDeploymentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDeploymentError {
    pub fn new(kind: CreateDeploymentErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateDeploymentErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateDeploymentErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDeploymentErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, CreateDeploymentErrorKind::ConflictException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDeploymentErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, CreateDeploymentErrorKind::NotFoundException(_))
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDeploymentErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDeploymentErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDeploymentErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for CreateDeploymentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateDeploymentErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateDeploymentErrorKind::ConflictException(_inner) => Some(_inner),
            CreateDeploymentErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateDeploymentErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateDeploymentErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateDeploymentErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            CreateDeploymentErrorKind::UnauthorizedException(_inner) => Some(_inner),
            CreateDeploymentErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateDocumentationPartError {
    pub kind: CreateDocumentationPartErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDocumentationPartErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateDocumentationPartError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateDocumentationPartErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateDocumentationPartErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateDocumentationPartErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateDocumentationPartErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateDocumentationPartErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            CreateDocumentationPartErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            CreateDocumentationPartErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateDocumentationPartError {
    fn code(&self) -> Option<&str> {
        CreateDocumentationPartError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDocumentationPartError {
    pub fn new(kind: CreateDocumentationPartErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateDocumentationPartErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateDocumentationPartErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDocumentationPartErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDocumentationPartErrorKind::ConflictException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDocumentationPartErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDocumentationPartErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDocumentationPartErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDocumentationPartErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for CreateDocumentationPartError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateDocumentationPartErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateDocumentationPartErrorKind::ConflictException(_inner) => Some(_inner),
            CreateDocumentationPartErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateDocumentationPartErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateDocumentationPartErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            CreateDocumentationPartErrorKind::UnauthorizedException(_inner) => Some(_inner),
            CreateDocumentationPartErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateDocumentationVersionError {
    pub kind: CreateDocumentationVersionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDocumentationVersionErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateDocumentationVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateDocumentationVersionErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateDocumentationVersionErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateDocumentationVersionErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateDocumentationVersionErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateDocumentationVersionErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            CreateDocumentationVersionErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            CreateDocumentationVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateDocumentationVersionError {
    fn code(&self) -> Option<&str> {
        CreateDocumentationVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDocumentationVersionError {
    pub fn new(kind: CreateDocumentationVersionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateDocumentationVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateDocumentationVersionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDocumentationVersionErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDocumentationVersionErrorKind::ConflictException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDocumentationVersionErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDocumentationVersionErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDocumentationVersionErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDocumentationVersionErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for CreateDocumentationVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateDocumentationVersionErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateDocumentationVersionErrorKind::ConflictException(_inner) => Some(_inner),
            CreateDocumentationVersionErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateDocumentationVersionErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateDocumentationVersionErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            CreateDocumentationVersionErrorKind::UnauthorizedException(_inner) => Some(_inner),
            CreateDocumentationVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateDomainNameError {
    pub kind: CreateDomainNameErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDomainNameErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    LimitExceededException(crate::error::LimitExceededException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateDomainNameError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateDomainNameErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateDomainNameErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateDomainNameErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateDomainNameErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            CreateDomainNameErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            CreateDomainNameErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateDomainNameError {
    fn code(&self) -> Option<&str> {
        CreateDomainNameError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDomainNameError {
    pub fn new(kind: CreateDomainNameErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateDomainNameErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateDomainNameErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDomainNameErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, CreateDomainNameErrorKind::ConflictException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDomainNameErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDomainNameErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDomainNameErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for CreateDomainNameError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateDomainNameErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateDomainNameErrorKind::ConflictException(_inner) => Some(_inner),
            CreateDomainNameErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateDomainNameErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            CreateDomainNameErrorKind::UnauthorizedException(_inner) => Some(_inner),
            CreateDomainNameErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateModelError {
    pub kind: CreateModelErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateModelErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateModelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateModelErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateModelErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateModelErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateModelErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateModelErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            CreateModelErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            CreateModelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateModelError {
    fn code(&self) -> Option<&str> {
        CreateModelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateModelError {
    pub fn new(kind: CreateModelErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateModelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateModelErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, CreateModelErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, CreateModelErrorKind::ConflictException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, CreateModelErrorKind::LimitExceededException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, CreateModelErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateModelErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, CreateModelErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for CreateModelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateModelErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateModelErrorKind::ConflictException(_inner) => Some(_inner),
            CreateModelErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateModelErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateModelErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            CreateModelErrorKind::UnauthorizedException(_inner) => Some(_inner),
            CreateModelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateRequestValidatorError {
    pub kind: CreateRequestValidatorErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateRequestValidatorErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateRequestValidatorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateRequestValidatorErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateRequestValidatorErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateRequestValidatorErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateRequestValidatorErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateRequestValidatorErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            CreateRequestValidatorErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            CreateRequestValidatorErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateRequestValidatorError {
    fn code(&self) -> Option<&str> {
        CreateRequestValidatorError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateRequestValidatorError {
    pub fn new(kind: CreateRequestValidatorErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateRequestValidatorErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateRequestValidatorErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRequestValidatorErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRequestValidatorErrorKind::ConflictException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRequestValidatorErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRequestValidatorErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRequestValidatorErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRequestValidatorErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for CreateRequestValidatorError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateRequestValidatorErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateRequestValidatorErrorKind::ConflictException(_inner) => Some(_inner),
            CreateRequestValidatorErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateRequestValidatorErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateRequestValidatorErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            CreateRequestValidatorErrorKind::UnauthorizedException(_inner) => Some(_inner),
            CreateRequestValidatorErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateResourceError {
    pub kind: CreateResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateResourceErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateResourceErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateResourceErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateResourceErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateResourceErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateResourceErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            CreateResourceErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            CreateResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateResourceError {
    fn code(&self) -> Option<&str> {
        CreateResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateResourceError {
    pub fn new(kind: CreateResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, CreateResourceErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, CreateResourceErrorKind::ConflictException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateResourceErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, CreateResourceErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateResourceErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateResourceErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for CreateResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateResourceErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateResourceErrorKind::ConflictException(_inner) => Some(_inner),
            CreateResourceErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateResourceErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateResourceErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            CreateResourceErrorKind::UnauthorizedException(_inner) => Some(_inner),
            CreateResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateRestApiError {
    pub kind: CreateRestApiErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateRestApiErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    LimitExceededException(crate::error::LimitExceededException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateRestApiError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateRestApiErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateRestApiErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateRestApiErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateRestApiErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            CreateRestApiErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            CreateRestApiErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateRestApiError {
    fn code(&self) -> Option<&str> {
        CreateRestApiError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateRestApiError {
    pub fn new(kind: CreateRestApiErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateRestApiErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateRestApiErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, CreateRestApiErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, CreateRestApiErrorKind::ConflictException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRestApiErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRestApiErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, CreateRestApiErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for CreateRestApiError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateRestApiErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateRestApiErrorKind::ConflictException(_inner) => Some(_inner),
            CreateRestApiErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateRestApiErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            CreateRestApiErrorKind::UnauthorizedException(_inner) => Some(_inner),
            CreateRestApiErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateStageError {
    pub kind: CreateStageErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateStageErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateStageError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateStageErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateStageErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateStageErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateStageErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateStageErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            CreateStageErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            CreateStageErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateStageError {
    fn code(&self) -> Option<&str> {
        CreateStageError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateStageError {
    pub fn new(kind: CreateStageErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateStageErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateStageErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, CreateStageErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, CreateStageErrorKind::ConflictException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, CreateStageErrorKind::LimitExceededException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, CreateStageErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateStageErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, CreateStageErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for CreateStageError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateStageErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateStageErrorKind::ConflictException(_inner) => Some(_inner),
            CreateStageErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateStageErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateStageErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            CreateStageErrorKind::UnauthorizedException(_inner) => Some(_inner),
            CreateStageErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateUsagePlanError {
    pub kind: CreateUsagePlanErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateUsagePlanErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateUsagePlanError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateUsagePlanErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateUsagePlanErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateUsagePlanErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateUsagePlanErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateUsagePlanErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            CreateUsagePlanErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            CreateUsagePlanErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateUsagePlanError {
    fn code(&self) -> Option<&str> {
        CreateUsagePlanError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateUsagePlanError {
    pub fn new(kind: CreateUsagePlanErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateUsagePlanErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateUsagePlanErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, CreateUsagePlanErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, CreateUsagePlanErrorKind::ConflictException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUsagePlanErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, CreateUsagePlanErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUsagePlanErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUsagePlanErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for CreateUsagePlanError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateUsagePlanErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateUsagePlanErrorKind::ConflictException(_inner) => Some(_inner),
            CreateUsagePlanErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateUsagePlanErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateUsagePlanErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            CreateUsagePlanErrorKind::UnauthorizedException(_inner) => Some(_inner),
            CreateUsagePlanErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateUsagePlanKeyError {
    pub kind: CreateUsagePlanKeyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateUsagePlanKeyErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateUsagePlanKeyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateUsagePlanKeyErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateUsagePlanKeyErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateUsagePlanKeyErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateUsagePlanKeyErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateUsagePlanKeyErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            CreateUsagePlanKeyErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            CreateUsagePlanKeyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateUsagePlanKeyError {
    fn code(&self) -> Option<&str> {
        CreateUsagePlanKeyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateUsagePlanKeyError {
    pub fn new(kind: CreateUsagePlanKeyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateUsagePlanKeyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateUsagePlanKeyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUsagePlanKeyErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUsagePlanKeyErrorKind::ConflictException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUsagePlanKeyErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUsagePlanKeyErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUsagePlanKeyErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUsagePlanKeyErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for CreateUsagePlanKeyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateUsagePlanKeyErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateUsagePlanKeyErrorKind::ConflictException(_inner) => Some(_inner),
            CreateUsagePlanKeyErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateUsagePlanKeyErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateUsagePlanKeyErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            CreateUsagePlanKeyErrorKind::UnauthorizedException(_inner) => Some(_inner),
            CreateUsagePlanKeyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateVpcLinkError {
    pub kind: CreateVpcLinkErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateVpcLinkErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    LimitExceededException(crate::error::LimitExceededException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateVpcLinkError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateVpcLinkErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateVpcLinkErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateVpcLinkErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateVpcLinkErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            CreateVpcLinkErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            CreateVpcLinkErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateVpcLinkError {
    fn code(&self) -> Option<&str> {
        CreateVpcLinkError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateVpcLinkError {
    pub fn new(kind: CreateVpcLinkErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateVpcLinkErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateVpcLinkErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, CreateVpcLinkErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, CreateVpcLinkErrorKind::ConflictException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVpcLinkErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVpcLinkErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, CreateVpcLinkErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for CreateVpcLinkError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateVpcLinkErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateVpcLinkErrorKind::ConflictException(_inner) => Some(_inner),
            CreateVpcLinkErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateVpcLinkErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            CreateVpcLinkErrorKind::UnauthorizedException(_inner) => Some(_inner),
            CreateVpcLinkErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteApiKeyError {
    pub kind: DeleteApiKeyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteApiKeyErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteApiKeyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteApiKeyErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteApiKeyErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteApiKeyErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteApiKeyErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteApiKeyErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DeleteApiKeyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteApiKeyError {
    fn code(&self) -> Option<&str> {
        DeleteApiKeyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteApiKeyError {
    pub fn new(kind: DeleteApiKeyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteApiKeyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteApiKeyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, DeleteApiKeyErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, DeleteApiKeyErrorKind::ConflictException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteApiKeyErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteApiKeyErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, DeleteApiKeyErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for DeleteApiKeyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteApiKeyErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteApiKeyErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteApiKeyErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteApiKeyErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteApiKeyErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DeleteApiKeyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteAuthorizerError {
    pub kind: DeleteAuthorizerErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteAuthorizerErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteAuthorizerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteAuthorizerErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteAuthorizerErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteAuthorizerErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteAuthorizerErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteAuthorizerErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DeleteAuthorizerErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteAuthorizerError {
    fn code(&self) -> Option<&str> {
        DeleteAuthorizerError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteAuthorizerError {
    pub fn new(kind: DeleteAuthorizerErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteAuthorizerErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteAuthorizerErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAuthorizerErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, DeleteAuthorizerErrorKind::ConflictException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteAuthorizerErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAuthorizerErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAuthorizerErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DeleteAuthorizerError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteAuthorizerErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteAuthorizerErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteAuthorizerErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteAuthorizerErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteAuthorizerErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DeleteAuthorizerErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteBasePathMappingError {
    pub kind: DeleteBasePathMappingErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteBasePathMappingErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteBasePathMappingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteBasePathMappingErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteBasePathMappingErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteBasePathMappingErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteBasePathMappingErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteBasePathMappingErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DeleteBasePathMappingErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteBasePathMappingError {
    fn code(&self) -> Option<&str> {
        DeleteBasePathMappingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteBasePathMappingError {
    pub fn new(kind: DeleteBasePathMappingErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteBasePathMappingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteBasePathMappingErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBasePathMappingErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBasePathMappingErrorKind::ConflictException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBasePathMappingErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBasePathMappingErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBasePathMappingErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DeleteBasePathMappingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteBasePathMappingErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteBasePathMappingErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteBasePathMappingErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteBasePathMappingErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteBasePathMappingErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DeleteBasePathMappingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteClientCertificateError {
    pub kind: DeleteClientCertificateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteClientCertificateErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteClientCertificateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteClientCertificateErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteClientCertificateErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteClientCertificateErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteClientCertificateErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteClientCertificateErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DeleteClientCertificateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteClientCertificateError {
    fn code(&self) -> Option<&str> {
        DeleteClientCertificateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteClientCertificateError {
    pub fn new(kind: DeleteClientCertificateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteClientCertificateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteClientCertificateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteClientCertificateErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteClientCertificateErrorKind::ConflictException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteClientCertificateErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteClientCertificateErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteClientCertificateErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DeleteClientCertificateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteClientCertificateErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteClientCertificateErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteClientCertificateErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteClientCertificateErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteClientCertificateErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DeleteClientCertificateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteDeploymentError {
    pub kind: DeleteDeploymentErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDeploymentErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteDeploymentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteDeploymentErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteDeploymentErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteDeploymentErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            DeleteDeploymentErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteDeploymentErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteDeploymentErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DeleteDeploymentErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteDeploymentError {
    fn code(&self) -> Option<&str> {
        DeleteDeploymentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteDeploymentError {
    pub fn new(kind: DeleteDeploymentErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteDeploymentErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteDeploymentErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDeploymentErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, DeleteDeploymentErrorKind::ConflictException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDeploymentErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteDeploymentErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDeploymentErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDeploymentErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DeleteDeploymentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteDeploymentErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteDeploymentErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteDeploymentErrorKind::LimitExceededException(_inner) => Some(_inner),
            DeleteDeploymentErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteDeploymentErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteDeploymentErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DeleteDeploymentErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteDocumentationPartError {
    pub kind: DeleteDocumentationPartErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDocumentationPartErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteDocumentationPartError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteDocumentationPartErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteDocumentationPartErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteDocumentationPartErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteDocumentationPartErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteDocumentationPartErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DeleteDocumentationPartErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteDocumentationPartError {
    fn code(&self) -> Option<&str> {
        DeleteDocumentationPartError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteDocumentationPartError {
    pub fn new(kind: DeleteDocumentationPartErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteDocumentationPartErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteDocumentationPartErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDocumentationPartErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDocumentationPartErrorKind::ConflictException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDocumentationPartErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDocumentationPartErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDocumentationPartErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DeleteDocumentationPartError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteDocumentationPartErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteDocumentationPartErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteDocumentationPartErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteDocumentationPartErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteDocumentationPartErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DeleteDocumentationPartErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteDocumentationVersionError {
    pub kind: DeleteDocumentationVersionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDocumentationVersionErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteDocumentationVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteDocumentationVersionErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteDocumentationVersionErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteDocumentationVersionErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteDocumentationVersionErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteDocumentationVersionErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DeleteDocumentationVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteDocumentationVersionError {
    fn code(&self) -> Option<&str> {
        DeleteDocumentationVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteDocumentationVersionError {
    pub fn new(kind: DeleteDocumentationVersionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteDocumentationVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteDocumentationVersionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDocumentationVersionErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDocumentationVersionErrorKind::ConflictException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDocumentationVersionErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDocumentationVersionErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDocumentationVersionErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DeleteDocumentationVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteDocumentationVersionErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteDocumentationVersionErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteDocumentationVersionErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteDocumentationVersionErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteDocumentationVersionErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DeleteDocumentationVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteDomainNameError {
    pub kind: DeleteDomainNameErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDomainNameErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteDomainNameError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteDomainNameErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteDomainNameErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteDomainNameErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteDomainNameErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteDomainNameErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DeleteDomainNameErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteDomainNameError {
    fn code(&self) -> Option<&str> {
        DeleteDomainNameError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteDomainNameError {
    pub fn new(kind: DeleteDomainNameErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteDomainNameErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteDomainNameErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDomainNameErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, DeleteDomainNameErrorKind::ConflictException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteDomainNameErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDomainNameErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDomainNameErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DeleteDomainNameError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteDomainNameErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteDomainNameErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteDomainNameErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteDomainNameErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteDomainNameErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DeleteDomainNameErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteGatewayResponseError {
    pub kind: DeleteGatewayResponseErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteGatewayResponseErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteGatewayResponseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteGatewayResponseErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteGatewayResponseErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteGatewayResponseErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteGatewayResponseErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteGatewayResponseErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DeleteGatewayResponseErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteGatewayResponseError {
    fn code(&self) -> Option<&str> {
        DeleteGatewayResponseError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteGatewayResponseError {
    pub fn new(kind: DeleteGatewayResponseErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteGatewayResponseErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteGatewayResponseErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteGatewayResponseErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteGatewayResponseErrorKind::ConflictException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteGatewayResponseErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteGatewayResponseErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteGatewayResponseErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DeleteGatewayResponseError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteGatewayResponseErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteGatewayResponseErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteGatewayResponseErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteGatewayResponseErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteGatewayResponseErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DeleteGatewayResponseErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteIntegrationError {
    pub kind: DeleteIntegrationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteIntegrationErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteIntegrationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteIntegrationErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteIntegrationErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteIntegrationErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteIntegrationErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteIntegrationErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DeleteIntegrationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteIntegrationError {
    fn code(&self) -> Option<&str> {
        DeleteIntegrationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteIntegrationError {
    pub fn new(kind: DeleteIntegrationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteIntegrationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteIntegrationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteIntegrationErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, DeleteIntegrationErrorKind::ConflictException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteIntegrationErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteIntegrationErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteIntegrationErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DeleteIntegrationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteIntegrationErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteIntegrationErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteIntegrationErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteIntegrationErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteIntegrationErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DeleteIntegrationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteIntegrationResponseError {
    pub kind: DeleteIntegrationResponseErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteIntegrationResponseErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteIntegrationResponseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteIntegrationResponseErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteIntegrationResponseErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteIntegrationResponseErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteIntegrationResponseErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteIntegrationResponseErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DeleteIntegrationResponseErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteIntegrationResponseError {
    fn code(&self) -> Option<&str> {
        DeleteIntegrationResponseError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteIntegrationResponseError {
    pub fn new(kind: DeleteIntegrationResponseErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteIntegrationResponseErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteIntegrationResponseErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteIntegrationResponseErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteIntegrationResponseErrorKind::ConflictException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteIntegrationResponseErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteIntegrationResponseErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteIntegrationResponseErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DeleteIntegrationResponseError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteIntegrationResponseErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteIntegrationResponseErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteIntegrationResponseErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteIntegrationResponseErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteIntegrationResponseErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DeleteIntegrationResponseErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteMethodError {
    pub kind: DeleteMethodErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteMethodErrorKind {
    ConflictException(crate::error::ConflictException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteMethodError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteMethodErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteMethodErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteMethodErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteMethodErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DeleteMethodErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteMethodError {
    fn code(&self) -> Option<&str> {
        DeleteMethodError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteMethodError {
    pub fn new(kind: DeleteMethodErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteMethodErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteMethodErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, DeleteMethodErrorKind::ConflictException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteMethodErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMethodErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, DeleteMethodErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for DeleteMethodError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteMethodErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteMethodErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteMethodErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteMethodErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DeleteMethodErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteMethodResponseError {
    pub kind: DeleteMethodResponseErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteMethodResponseErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteMethodResponseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteMethodResponseErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteMethodResponseErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteMethodResponseErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteMethodResponseErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteMethodResponseErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DeleteMethodResponseErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteMethodResponseError {
    fn code(&self) -> Option<&str> {
        DeleteMethodResponseError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteMethodResponseError {
    pub fn new(kind: DeleteMethodResponseErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteMethodResponseErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteMethodResponseErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMethodResponseErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMethodResponseErrorKind::ConflictException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMethodResponseErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMethodResponseErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMethodResponseErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DeleteMethodResponseError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteMethodResponseErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteMethodResponseErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteMethodResponseErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteMethodResponseErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteMethodResponseErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DeleteMethodResponseErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteModelError {
    pub kind: DeleteModelErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteModelErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteModelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteModelErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteModelErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteModelErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteModelErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteModelErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DeleteModelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteModelError {
    fn code(&self) -> Option<&str> {
        DeleteModelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteModelError {
    pub fn new(kind: DeleteModelErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteModelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteModelErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, DeleteModelErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, DeleteModelErrorKind::ConflictException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteModelErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteModelErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, DeleteModelErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for DeleteModelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteModelErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteModelErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteModelErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteModelErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteModelErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DeleteModelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteRequestValidatorError {
    pub kind: DeleteRequestValidatorErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteRequestValidatorErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteRequestValidatorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteRequestValidatorErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteRequestValidatorErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteRequestValidatorErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteRequestValidatorErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteRequestValidatorErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DeleteRequestValidatorErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteRequestValidatorError {
    fn code(&self) -> Option<&str> {
        DeleteRequestValidatorError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteRequestValidatorError {
    pub fn new(kind: DeleteRequestValidatorErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteRequestValidatorErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteRequestValidatorErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRequestValidatorErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRequestValidatorErrorKind::ConflictException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRequestValidatorErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRequestValidatorErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRequestValidatorErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DeleteRequestValidatorError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteRequestValidatorErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteRequestValidatorErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteRequestValidatorErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteRequestValidatorErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteRequestValidatorErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DeleteRequestValidatorErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteResourceError {
    pub kind: DeleteResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteResourceErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteResourceErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteResourceErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteResourceErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteResourceErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteResourceErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DeleteResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteResourceError {
    fn code(&self) -> Option<&str> {
        DeleteResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteResourceError {
    pub fn new(kind: DeleteResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, DeleteResourceErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, DeleteResourceErrorKind::ConflictException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteResourceErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteResourceErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteResourceErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DeleteResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteResourceErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteResourceErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteResourceErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteResourceErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteResourceErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DeleteResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteRestApiError {
    pub kind: DeleteRestApiErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteRestApiErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteRestApiError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteRestApiErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteRestApiErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteRestApiErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteRestApiErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteRestApiErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DeleteRestApiErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteRestApiError {
    fn code(&self) -> Option<&str> {
        DeleteRestApiError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteRestApiError {
    pub fn new(kind: DeleteRestApiErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteRestApiErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteRestApiErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, DeleteRestApiErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, DeleteRestApiErrorKind::ConflictException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteRestApiErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRestApiErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, DeleteRestApiErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for DeleteRestApiError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteRestApiErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteRestApiErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteRestApiErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteRestApiErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteRestApiErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DeleteRestApiErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteStageError {
    pub kind: DeleteStageErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteStageErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteStageError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteStageErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteStageErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteStageErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            DeleteStageErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteStageErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteStageErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DeleteStageErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteStageError {
    fn code(&self) -> Option<&str> {
        DeleteStageError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteStageError {
    pub fn new(kind: DeleteStageErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteStageErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteStageErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, DeleteStageErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, DeleteStageErrorKind::ConflictException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, DeleteStageErrorKind::LimitExceededException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteStageErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteStageErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, DeleteStageErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for DeleteStageError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteStageErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteStageErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteStageErrorKind::LimitExceededException(_inner) => Some(_inner),
            DeleteStageErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteStageErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteStageErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DeleteStageErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteUsagePlanError {
    pub kind: DeleteUsagePlanErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteUsagePlanErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteUsagePlanError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteUsagePlanErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteUsagePlanErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteUsagePlanErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteUsagePlanErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteUsagePlanErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DeleteUsagePlanErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteUsagePlanError {
    fn code(&self) -> Option<&str> {
        DeleteUsagePlanError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteUsagePlanError {
    pub fn new(kind: DeleteUsagePlanErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteUsagePlanErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteUsagePlanErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, DeleteUsagePlanErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, DeleteUsagePlanErrorKind::ConflictException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteUsagePlanErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUsagePlanErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUsagePlanErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DeleteUsagePlanError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteUsagePlanErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteUsagePlanErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteUsagePlanErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteUsagePlanErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteUsagePlanErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DeleteUsagePlanErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteUsagePlanKeyError {
    pub kind: DeleteUsagePlanKeyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteUsagePlanKeyErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteUsagePlanKeyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteUsagePlanKeyErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteUsagePlanKeyErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteUsagePlanKeyErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteUsagePlanKeyErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteUsagePlanKeyErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DeleteUsagePlanKeyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteUsagePlanKeyError {
    fn code(&self) -> Option<&str> {
        DeleteUsagePlanKeyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteUsagePlanKeyError {
    pub fn new(kind: DeleteUsagePlanKeyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteUsagePlanKeyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteUsagePlanKeyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUsagePlanKeyErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUsagePlanKeyErrorKind::ConflictException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUsagePlanKeyErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUsagePlanKeyErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUsagePlanKeyErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DeleteUsagePlanKeyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteUsagePlanKeyErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteUsagePlanKeyErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteUsagePlanKeyErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteUsagePlanKeyErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteUsagePlanKeyErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DeleteUsagePlanKeyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteVpcLinkError {
    pub kind: DeleteVpcLinkErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteVpcLinkErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteVpcLinkError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteVpcLinkErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteVpcLinkErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteVpcLinkErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteVpcLinkErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteVpcLinkErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DeleteVpcLinkErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteVpcLinkError {
    fn code(&self) -> Option<&str> {
        DeleteVpcLinkError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteVpcLinkError {
    pub fn new(kind: DeleteVpcLinkErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteVpcLinkErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteVpcLinkErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, DeleteVpcLinkErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, DeleteVpcLinkErrorKind::ConflictException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteVpcLinkErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVpcLinkErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, DeleteVpcLinkErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for DeleteVpcLinkError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteVpcLinkErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteVpcLinkErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteVpcLinkErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteVpcLinkErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteVpcLinkErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DeleteVpcLinkErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct FlushStageAuthorizersCacheError {
    pub kind: FlushStageAuthorizersCacheErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum FlushStageAuthorizersCacheErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for FlushStageAuthorizersCacheError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            FlushStageAuthorizersCacheErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            FlushStageAuthorizersCacheErrorKind::ConflictException(_inner) => _inner.fmt(f),
            FlushStageAuthorizersCacheErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            FlushStageAuthorizersCacheErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            FlushStageAuthorizersCacheErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            FlushStageAuthorizersCacheErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            FlushStageAuthorizersCacheErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for FlushStageAuthorizersCacheError {
    fn code(&self) -> Option<&str> {
        FlushStageAuthorizersCacheError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl FlushStageAuthorizersCacheError {
    pub fn new(kind: FlushStageAuthorizersCacheErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: FlushStageAuthorizersCacheErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: FlushStageAuthorizersCacheErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            FlushStageAuthorizersCacheErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            FlushStageAuthorizersCacheErrorKind::ConflictException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            FlushStageAuthorizersCacheErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            FlushStageAuthorizersCacheErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            FlushStageAuthorizersCacheErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            FlushStageAuthorizersCacheErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for FlushStageAuthorizersCacheError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            FlushStageAuthorizersCacheErrorKind::BadRequestException(_inner) => Some(_inner),
            FlushStageAuthorizersCacheErrorKind::ConflictException(_inner) => Some(_inner),
            FlushStageAuthorizersCacheErrorKind::LimitExceededException(_inner) => Some(_inner),
            FlushStageAuthorizersCacheErrorKind::NotFoundException(_inner) => Some(_inner),
            FlushStageAuthorizersCacheErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            FlushStageAuthorizersCacheErrorKind::UnauthorizedException(_inner) => Some(_inner),
            FlushStageAuthorizersCacheErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct FlushStageCacheError {
    pub kind: FlushStageCacheErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum FlushStageCacheErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for FlushStageCacheError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            FlushStageCacheErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            FlushStageCacheErrorKind::ConflictException(_inner) => _inner.fmt(f),
            FlushStageCacheErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            FlushStageCacheErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            FlushStageCacheErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            FlushStageCacheErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            FlushStageCacheErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for FlushStageCacheError {
    fn code(&self) -> Option<&str> {
        FlushStageCacheError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl FlushStageCacheError {
    pub fn new(kind: FlushStageCacheErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: FlushStageCacheErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: FlushStageCacheErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, FlushStageCacheErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, FlushStageCacheErrorKind::ConflictException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            FlushStageCacheErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, FlushStageCacheErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            FlushStageCacheErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            FlushStageCacheErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for FlushStageCacheError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            FlushStageCacheErrorKind::BadRequestException(_inner) => Some(_inner),
            FlushStageCacheErrorKind::ConflictException(_inner) => Some(_inner),
            FlushStageCacheErrorKind::LimitExceededException(_inner) => Some(_inner),
            FlushStageCacheErrorKind::NotFoundException(_inner) => Some(_inner),
            FlushStageCacheErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            FlushStageCacheErrorKind::UnauthorizedException(_inner) => Some(_inner),
            FlushStageCacheErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GenerateClientCertificateError {
    pub kind: GenerateClientCertificateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GenerateClientCertificateErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    LimitExceededException(crate::error::LimitExceededException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GenerateClientCertificateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GenerateClientCertificateErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GenerateClientCertificateErrorKind::ConflictException(_inner) => _inner.fmt(f),
            GenerateClientCertificateErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            GenerateClientCertificateErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GenerateClientCertificateErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GenerateClientCertificateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GenerateClientCertificateError {
    fn code(&self) -> Option<&str> {
        GenerateClientCertificateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GenerateClientCertificateError {
    pub fn new(kind: GenerateClientCertificateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GenerateClientCertificateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GenerateClientCertificateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GenerateClientCertificateErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            GenerateClientCertificateErrorKind::ConflictException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GenerateClientCertificateErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GenerateClientCertificateErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            GenerateClientCertificateErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for GenerateClientCertificateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GenerateClientCertificateErrorKind::BadRequestException(_inner) => Some(_inner),
            GenerateClientCertificateErrorKind::ConflictException(_inner) => Some(_inner),
            GenerateClientCertificateErrorKind::LimitExceededException(_inner) => Some(_inner),
            GenerateClientCertificateErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GenerateClientCertificateErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GenerateClientCertificateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetAccountError {
    pub kind: GetAccountErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetAccountErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetAccountError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetAccountErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetAccountErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetAccountErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetAccountErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetAccountErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetAccountError {
    fn code(&self) -> Option<&str> {
        GetAccountError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetAccountError {
    pub fn new(kind: GetAccountErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetAccountErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetAccountErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetAccountErrorKind::BadRequestException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetAccountErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(&self.kind, GetAccountErrorKind::TooManyRequestsException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, GetAccountErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for GetAccountError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetAccountErrorKind::BadRequestException(_inner) => Some(_inner),
            GetAccountErrorKind::NotFoundException(_inner) => Some(_inner),
            GetAccountErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetAccountErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetAccountErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetApiKeyError {
    pub kind: GetApiKeyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetApiKeyErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetApiKeyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetApiKeyErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetApiKeyErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetApiKeyErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetApiKeyErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetApiKeyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetApiKeyError {
    fn code(&self) -> Option<&str> {
        GetApiKeyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetApiKeyError {
    pub fn new(kind: GetApiKeyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetApiKeyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetApiKeyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetApiKeyErrorKind::BadRequestException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetApiKeyErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(&self.kind, GetApiKeyErrorKind::TooManyRequestsException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, GetApiKeyErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for GetApiKeyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetApiKeyErrorKind::BadRequestException(_inner) => Some(_inner),
            GetApiKeyErrorKind::NotFoundException(_inner) => Some(_inner),
            GetApiKeyErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetApiKeyErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetApiKeyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetApiKeysError {
    pub kind: GetApiKeysErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetApiKeysErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetApiKeysError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetApiKeysErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetApiKeysErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetApiKeysErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetApiKeysErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetApiKeysErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetApiKeysError {
    fn code(&self) -> Option<&str> {
        GetApiKeysError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetApiKeysError {
    pub fn new(kind: GetApiKeysErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetApiKeysErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetApiKeysErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetApiKeysErrorKind::BadRequestException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetApiKeysErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(&self.kind, GetApiKeysErrorKind::TooManyRequestsException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, GetApiKeysErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for GetApiKeysError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetApiKeysErrorKind::BadRequestException(_inner) => Some(_inner),
            GetApiKeysErrorKind::NotFoundException(_inner) => Some(_inner),
            GetApiKeysErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetApiKeysErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetApiKeysErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetAuthorizerError {
    pub kind: GetAuthorizerErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetAuthorizerErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetAuthorizerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetAuthorizerErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetAuthorizerErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetAuthorizerErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetAuthorizerErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetAuthorizerErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetAuthorizerError {
    fn code(&self) -> Option<&str> {
        GetAuthorizerError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetAuthorizerError {
    pub fn new(kind: GetAuthorizerErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetAuthorizerErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetAuthorizerErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetAuthorizerErrorKind::BadRequestException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetAuthorizerErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAuthorizerErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, GetAuthorizerErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for GetAuthorizerError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetAuthorizerErrorKind::BadRequestException(_inner) => Some(_inner),
            GetAuthorizerErrorKind::NotFoundException(_inner) => Some(_inner),
            GetAuthorizerErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetAuthorizerErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetAuthorizerErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetAuthorizersError {
    pub kind: GetAuthorizersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetAuthorizersErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetAuthorizersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetAuthorizersErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetAuthorizersErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetAuthorizersErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetAuthorizersErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetAuthorizersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetAuthorizersError {
    fn code(&self) -> Option<&str> {
        GetAuthorizersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetAuthorizersError {
    pub fn new(kind: GetAuthorizersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetAuthorizersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetAuthorizersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetAuthorizersErrorKind::BadRequestException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetAuthorizersErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAuthorizersErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAuthorizersErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for GetAuthorizersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetAuthorizersErrorKind::BadRequestException(_inner) => Some(_inner),
            GetAuthorizersErrorKind::NotFoundException(_inner) => Some(_inner),
            GetAuthorizersErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetAuthorizersErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetAuthorizersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetBasePathMappingError {
    pub kind: GetBasePathMappingErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetBasePathMappingErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetBasePathMappingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetBasePathMappingErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetBasePathMappingErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetBasePathMappingErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetBasePathMappingErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetBasePathMappingErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetBasePathMappingError {
    fn code(&self) -> Option<&str> {
        GetBasePathMappingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetBasePathMappingError {
    pub fn new(kind: GetBasePathMappingErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetBasePathMappingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetBasePathMappingErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBasePathMappingErrorKind::BadRequestException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBasePathMappingErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBasePathMappingErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBasePathMappingErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for GetBasePathMappingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetBasePathMappingErrorKind::BadRequestException(_inner) => Some(_inner),
            GetBasePathMappingErrorKind::NotFoundException(_inner) => Some(_inner),
            GetBasePathMappingErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetBasePathMappingErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetBasePathMappingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetBasePathMappingsError {
    pub kind: GetBasePathMappingsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetBasePathMappingsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetBasePathMappingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetBasePathMappingsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetBasePathMappingsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetBasePathMappingsErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetBasePathMappingsErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetBasePathMappingsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetBasePathMappingsError {
    fn code(&self) -> Option<&str> {
        GetBasePathMappingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetBasePathMappingsError {
    pub fn new(kind: GetBasePathMappingsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetBasePathMappingsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetBasePathMappingsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBasePathMappingsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBasePathMappingsErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBasePathMappingsErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBasePathMappingsErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for GetBasePathMappingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetBasePathMappingsErrorKind::BadRequestException(_inner) => Some(_inner),
            GetBasePathMappingsErrorKind::NotFoundException(_inner) => Some(_inner),
            GetBasePathMappingsErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetBasePathMappingsErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetBasePathMappingsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetClientCertificateError {
    pub kind: GetClientCertificateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetClientCertificateErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetClientCertificateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetClientCertificateErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetClientCertificateErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetClientCertificateErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetClientCertificateErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetClientCertificateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetClientCertificateError {
    fn code(&self) -> Option<&str> {
        GetClientCertificateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetClientCertificateError {
    pub fn new(kind: GetClientCertificateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetClientCertificateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetClientCertificateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetClientCertificateErrorKind::BadRequestException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetClientCertificateErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetClientCertificateErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetClientCertificateErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for GetClientCertificateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetClientCertificateErrorKind::BadRequestException(_inner) => Some(_inner),
            GetClientCertificateErrorKind::NotFoundException(_inner) => Some(_inner),
            GetClientCertificateErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetClientCertificateErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetClientCertificateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetClientCertificatesError {
    pub kind: GetClientCertificatesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetClientCertificatesErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetClientCertificatesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetClientCertificatesErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetClientCertificatesErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetClientCertificatesErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetClientCertificatesErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetClientCertificatesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetClientCertificatesError {
    fn code(&self) -> Option<&str> {
        GetClientCertificatesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetClientCertificatesError {
    pub fn new(kind: GetClientCertificatesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetClientCertificatesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetClientCertificatesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetClientCertificatesErrorKind::BadRequestException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetClientCertificatesErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetClientCertificatesErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetClientCertificatesErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for GetClientCertificatesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetClientCertificatesErrorKind::BadRequestException(_inner) => Some(_inner),
            GetClientCertificatesErrorKind::NotFoundException(_inner) => Some(_inner),
            GetClientCertificatesErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetClientCertificatesErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetClientCertificatesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetDeploymentError {
    pub kind: GetDeploymentErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetDeploymentErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetDeploymentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetDeploymentErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetDeploymentErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetDeploymentErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            GetDeploymentErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetDeploymentErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetDeploymentErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetDeploymentError {
    fn code(&self) -> Option<&str> {
        GetDeploymentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetDeploymentError {
    pub fn new(kind: GetDeploymentErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetDeploymentErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetDeploymentErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetDeploymentErrorKind::BadRequestException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetDeploymentErrorKind::NotFoundException(_))
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDeploymentErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDeploymentErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, GetDeploymentErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for GetDeploymentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetDeploymentErrorKind::BadRequestException(_inner) => Some(_inner),
            GetDeploymentErrorKind::NotFoundException(_inner) => Some(_inner),
            GetDeploymentErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            GetDeploymentErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetDeploymentErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetDeploymentErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetDeploymentsError {
    pub kind: GetDeploymentsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetDeploymentsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetDeploymentsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetDeploymentsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetDeploymentsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetDeploymentsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            GetDeploymentsErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetDeploymentsErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetDeploymentsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetDeploymentsError {
    fn code(&self) -> Option<&str> {
        GetDeploymentsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetDeploymentsError {
    pub fn new(kind: GetDeploymentsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetDeploymentsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetDeploymentsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetDeploymentsErrorKind::BadRequestException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetDeploymentsErrorKind::NotFoundException(_))
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDeploymentsErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDeploymentsErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDeploymentsErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for GetDeploymentsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetDeploymentsErrorKind::BadRequestException(_inner) => Some(_inner),
            GetDeploymentsErrorKind::NotFoundException(_inner) => Some(_inner),
            GetDeploymentsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            GetDeploymentsErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetDeploymentsErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetDeploymentsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetDocumentationPartError {
    pub kind: GetDocumentationPartErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetDocumentationPartErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetDocumentationPartError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetDocumentationPartErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetDocumentationPartErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetDocumentationPartErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetDocumentationPartErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetDocumentationPartErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetDocumentationPartError {
    fn code(&self) -> Option<&str> {
        GetDocumentationPartError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetDocumentationPartError {
    pub fn new(kind: GetDocumentationPartErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetDocumentationPartErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetDocumentationPartErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDocumentationPartErrorKind::BadRequestException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDocumentationPartErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDocumentationPartErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDocumentationPartErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for GetDocumentationPartError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetDocumentationPartErrorKind::BadRequestException(_inner) => Some(_inner),
            GetDocumentationPartErrorKind::NotFoundException(_inner) => Some(_inner),
            GetDocumentationPartErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetDocumentationPartErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetDocumentationPartErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetDocumentationPartsError {
    pub kind: GetDocumentationPartsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetDocumentationPartsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetDocumentationPartsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetDocumentationPartsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetDocumentationPartsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetDocumentationPartsErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetDocumentationPartsErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetDocumentationPartsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetDocumentationPartsError {
    fn code(&self) -> Option<&str> {
        GetDocumentationPartsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetDocumentationPartsError {
    pub fn new(kind: GetDocumentationPartsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetDocumentationPartsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetDocumentationPartsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDocumentationPartsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDocumentationPartsErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDocumentationPartsErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDocumentationPartsErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for GetDocumentationPartsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetDocumentationPartsErrorKind::BadRequestException(_inner) => Some(_inner),
            GetDocumentationPartsErrorKind::NotFoundException(_inner) => Some(_inner),
            GetDocumentationPartsErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetDocumentationPartsErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetDocumentationPartsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetDocumentationVersionError {
    pub kind: GetDocumentationVersionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetDocumentationVersionErrorKind {
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetDocumentationVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetDocumentationVersionErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetDocumentationVersionErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetDocumentationVersionErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetDocumentationVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetDocumentationVersionError {
    fn code(&self) -> Option<&str> {
        GetDocumentationVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetDocumentationVersionError {
    pub fn new(kind: GetDocumentationVersionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetDocumentationVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetDocumentationVersionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDocumentationVersionErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDocumentationVersionErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDocumentationVersionErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for GetDocumentationVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetDocumentationVersionErrorKind::NotFoundException(_inner) => Some(_inner),
            GetDocumentationVersionErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetDocumentationVersionErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetDocumentationVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetDocumentationVersionsError {
    pub kind: GetDocumentationVersionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetDocumentationVersionsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetDocumentationVersionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetDocumentationVersionsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetDocumentationVersionsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetDocumentationVersionsErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetDocumentationVersionsErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetDocumentationVersionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetDocumentationVersionsError {
    fn code(&self) -> Option<&str> {
        GetDocumentationVersionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetDocumentationVersionsError {
    pub fn new(kind: GetDocumentationVersionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetDocumentationVersionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetDocumentationVersionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDocumentationVersionsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDocumentationVersionsErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDocumentationVersionsErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDocumentationVersionsErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for GetDocumentationVersionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetDocumentationVersionsErrorKind::BadRequestException(_inner) => Some(_inner),
            GetDocumentationVersionsErrorKind::NotFoundException(_inner) => Some(_inner),
            GetDocumentationVersionsErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetDocumentationVersionsErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetDocumentationVersionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetDomainNameError {
    pub kind: GetDomainNameErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetDomainNameErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetDomainNameError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetDomainNameErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetDomainNameErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetDomainNameErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetDomainNameErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetDomainNameErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetDomainNameError {
    fn code(&self) -> Option<&str> {
        GetDomainNameError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetDomainNameError {
    pub fn new(kind: GetDomainNameErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetDomainNameErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetDomainNameErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetDomainNameErrorKind::BadRequestException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetDomainNameErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDomainNameErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, GetDomainNameErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for GetDomainNameError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetDomainNameErrorKind::BadRequestException(_inner) => Some(_inner),
            GetDomainNameErrorKind::NotFoundException(_inner) => Some(_inner),
            GetDomainNameErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetDomainNameErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetDomainNameErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetDomainNamesError {
    pub kind: GetDomainNamesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetDomainNamesErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetDomainNamesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetDomainNamesErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetDomainNamesErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetDomainNamesErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetDomainNamesErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetDomainNamesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetDomainNamesError {
    fn code(&self) -> Option<&str> {
        GetDomainNamesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetDomainNamesError {
    pub fn new(kind: GetDomainNamesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetDomainNamesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetDomainNamesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetDomainNamesErrorKind::BadRequestException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetDomainNamesErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDomainNamesErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDomainNamesErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for GetDomainNamesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetDomainNamesErrorKind::BadRequestException(_inner) => Some(_inner),
            GetDomainNamesErrorKind::NotFoundException(_inner) => Some(_inner),
            GetDomainNamesErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetDomainNamesErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetDomainNamesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetExportError {
    pub kind: GetExportErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetExportErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetExportError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetExportErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetExportErrorKind::ConflictException(_inner) => _inner.fmt(f),
            GetExportErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            GetExportErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetExportErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetExportErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetExportErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetExportError {
    fn code(&self) -> Option<&str> {
        GetExportError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetExportError {
    pub fn new(kind: GetExportErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetExportErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetExportErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetExportErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, GetExportErrorKind::ConflictException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, GetExportErrorKind::LimitExceededException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetExportErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(&self.kind, GetExportErrorKind::TooManyRequestsException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, GetExportErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for GetExportError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetExportErrorKind::BadRequestException(_inner) => Some(_inner),
            GetExportErrorKind::ConflictException(_inner) => Some(_inner),
            GetExportErrorKind::LimitExceededException(_inner) => Some(_inner),
            GetExportErrorKind::NotFoundException(_inner) => Some(_inner),
            GetExportErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetExportErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetExportErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetGatewayResponseError {
    pub kind: GetGatewayResponseErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetGatewayResponseErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetGatewayResponseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetGatewayResponseErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetGatewayResponseErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetGatewayResponseErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetGatewayResponseErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetGatewayResponseErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetGatewayResponseError {
    fn code(&self) -> Option<&str> {
        GetGatewayResponseError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetGatewayResponseError {
    pub fn new(kind: GetGatewayResponseErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetGatewayResponseErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetGatewayResponseErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetGatewayResponseErrorKind::BadRequestException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetGatewayResponseErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetGatewayResponseErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetGatewayResponseErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for GetGatewayResponseError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetGatewayResponseErrorKind::BadRequestException(_inner) => Some(_inner),
            GetGatewayResponseErrorKind::NotFoundException(_inner) => Some(_inner),
            GetGatewayResponseErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetGatewayResponseErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetGatewayResponseErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetGatewayResponsesError {
    pub kind: GetGatewayResponsesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetGatewayResponsesErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetGatewayResponsesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetGatewayResponsesErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetGatewayResponsesErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetGatewayResponsesErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetGatewayResponsesErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetGatewayResponsesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetGatewayResponsesError {
    fn code(&self) -> Option<&str> {
        GetGatewayResponsesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetGatewayResponsesError {
    pub fn new(kind: GetGatewayResponsesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetGatewayResponsesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetGatewayResponsesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetGatewayResponsesErrorKind::BadRequestException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetGatewayResponsesErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetGatewayResponsesErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetGatewayResponsesErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for GetGatewayResponsesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetGatewayResponsesErrorKind::BadRequestException(_inner) => Some(_inner),
            GetGatewayResponsesErrorKind::NotFoundException(_inner) => Some(_inner),
            GetGatewayResponsesErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetGatewayResponsesErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetGatewayResponsesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetIntegrationError {
    pub kind: GetIntegrationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetIntegrationErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetIntegrationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetIntegrationErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetIntegrationErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetIntegrationErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetIntegrationErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetIntegrationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetIntegrationError {
    fn code(&self) -> Option<&str> {
        GetIntegrationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetIntegrationError {
    pub fn new(kind: GetIntegrationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetIntegrationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetIntegrationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetIntegrationErrorKind::BadRequestException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetIntegrationErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetIntegrationErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetIntegrationErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for GetIntegrationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetIntegrationErrorKind::BadRequestException(_inner) => Some(_inner),
            GetIntegrationErrorKind::NotFoundException(_inner) => Some(_inner),
            GetIntegrationErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetIntegrationErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetIntegrationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetIntegrationResponseError {
    pub kind: GetIntegrationResponseErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetIntegrationResponseErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetIntegrationResponseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetIntegrationResponseErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetIntegrationResponseErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetIntegrationResponseErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetIntegrationResponseErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetIntegrationResponseErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetIntegrationResponseError {
    fn code(&self) -> Option<&str> {
        GetIntegrationResponseError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetIntegrationResponseError {
    pub fn new(kind: GetIntegrationResponseErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetIntegrationResponseErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetIntegrationResponseErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetIntegrationResponseErrorKind::BadRequestException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetIntegrationResponseErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetIntegrationResponseErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetIntegrationResponseErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for GetIntegrationResponseError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetIntegrationResponseErrorKind::BadRequestException(_inner) => Some(_inner),
            GetIntegrationResponseErrorKind::NotFoundException(_inner) => Some(_inner),
            GetIntegrationResponseErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetIntegrationResponseErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetIntegrationResponseErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetMethodError {
    pub kind: GetMethodErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetMethodErrorKind {
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetMethodError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetMethodErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetMethodErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetMethodErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetMethodErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetMethodError {
    fn code(&self) -> Option<&str> {
        GetMethodError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetMethodError {
    pub fn new(kind: GetMethodErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetMethodErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetMethodErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetMethodErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(&self.kind, GetMethodErrorKind::TooManyRequestsException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, GetMethodErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for GetMethodError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetMethodErrorKind::NotFoundException(_inner) => Some(_inner),
            GetMethodErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetMethodErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetMethodErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetMethodResponseError {
    pub kind: GetMethodResponseErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetMethodResponseErrorKind {
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetMethodResponseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetMethodResponseErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetMethodResponseErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetMethodResponseErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetMethodResponseErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetMethodResponseError {
    fn code(&self) -> Option<&str> {
        GetMethodResponseError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetMethodResponseError {
    pub fn new(kind: GetMethodResponseErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetMethodResponseErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetMethodResponseErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetMethodResponseErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMethodResponseErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMethodResponseErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for GetMethodResponseError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetMethodResponseErrorKind::NotFoundException(_inner) => Some(_inner),
            GetMethodResponseErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetMethodResponseErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetMethodResponseErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetModelError {
    pub kind: GetModelErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetModelErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetModelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetModelErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetModelErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetModelErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetModelErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetModelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetModelError {
    fn code(&self) -> Option<&str> {
        GetModelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetModelError {
    pub fn new(kind: GetModelErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetModelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetModelErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetModelErrorKind::BadRequestException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetModelErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(&self.kind, GetModelErrorKind::TooManyRequestsException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, GetModelErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for GetModelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetModelErrorKind::BadRequestException(_inner) => Some(_inner),
            GetModelErrorKind::NotFoundException(_inner) => Some(_inner),
            GetModelErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetModelErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetModelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetModelsError {
    pub kind: GetModelsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetModelsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetModelsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetModelsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetModelsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetModelsErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetModelsErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetModelsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetModelsError {
    fn code(&self) -> Option<&str> {
        GetModelsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetModelsError {
    pub fn new(kind: GetModelsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetModelsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetModelsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetModelsErrorKind::BadRequestException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetModelsErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(&self.kind, GetModelsErrorKind::TooManyRequestsException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, GetModelsErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for GetModelsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetModelsErrorKind::BadRequestException(_inner) => Some(_inner),
            GetModelsErrorKind::NotFoundException(_inner) => Some(_inner),
            GetModelsErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetModelsErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetModelsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetModelTemplateError {
    pub kind: GetModelTemplateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetModelTemplateErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetModelTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetModelTemplateErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetModelTemplateErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetModelTemplateErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetModelTemplateErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetModelTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetModelTemplateError {
    fn code(&self) -> Option<&str> {
        GetModelTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetModelTemplateError {
    pub fn new(kind: GetModelTemplateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetModelTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetModelTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetModelTemplateErrorKind::BadRequestException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetModelTemplateErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetModelTemplateErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetModelTemplateErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for GetModelTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetModelTemplateErrorKind::BadRequestException(_inner) => Some(_inner),
            GetModelTemplateErrorKind::NotFoundException(_inner) => Some(_inner),
            GetModelTemplateErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetModelTemplateErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetModelTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetRequestValidatorError {
    pub kind: GetRequestValidatorErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetRequestValidatorErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetRequestValidatorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetRequestValidatorErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetRequestValidatorErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetRequestValidatorErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetRequestValidatorErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetRequestValidatorErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetRequestValidatorError {
    fn code(&self) -> Option<&str> {
        GetRequestValidatorError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetRequestValidatorError {
    pub fn new(kind: GetRequestValidatorErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetRequestValidatorErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetRequestValidatorErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRequestValidatorErrorKind::BadRequestException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRequestValidatorErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRequestValidatorErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRequestValidatorErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for GetRequestValidatorError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetRequestValidatorErrorKind::BadRequestException(_inner) => Some(_inner),
            GetRequestValidatorErrorKind::NotFoundException(_inner) => Some(_inner),
            GetRequestValidatorErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetRequestValidatorErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetRequestValidatorErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetRequestValidatorsError {
    pub kind: GetRequestValidatorsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetRequestValidatorsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetRequestValidatorsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetRequestValidatorsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetRequestValidatorsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetRequestValidatorsErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetRequestValidatorsErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetRequestValidatorsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetRequestValidatorsError {
    fn code(&self) -> Option<&str> {
        GetRequestValidatorsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetRequestValidatorsError {
    pub fn new(kind: GetRequestValidatorsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetRequestValidatorsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetRequestValidatorsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRequestValidatorsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRequestValidatorsErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRequestValidatorsErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRequestValidatorsErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for GetRequestValidatorsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetRequestValidatorsErrorKind::BadRequestException(_inner) => Some(_inner),
            GetRequestValidatorsErrorKind::NotFoundException(_inner) => Some(_inner),
            GetRequestValidatorsErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetRequestValidatorsErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetRequestValidatorsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetResourceError {
    pub kind: GetResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetResourceErrorKind {
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetResourceErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetResourceErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetResourceErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetResourceError {
    fn code(&self) -> Option<&str> {
        GetResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetResourceError {
    pub fn new(kind: GetResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetResourceErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetResourceErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, GetResourceErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for GetResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetResourceErrorKind::NotFoundException(_inner) => Some(_inner),
            GetResourceErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetResourceErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetResourcesError {
    pub kind: GetResourcesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetResourcesErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetResourcesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetResourcesErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetResourcesErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetResourcesErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetResourcesErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetResourcesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetResourcesError {
    fn code(&self) -> Option<&str> {
        GetResourcesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetResourcesError {
    pub fn new(kind: GetResourcesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetResourcesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetResourcesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetResourcesErrorKind::BadRequestException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetResourcesErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetResourcesErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, GetResourcesErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for GetResourcesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetResourcesErrorKind::BadRequestException(_inner) => Some(_inner),
            GetResourcesErrorKind::NotFoundException(_inner) => Some(_inner),
            GetResourcesErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetResourcesErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetResourcesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetRestApiError {
    pub kind: GetRestApiErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetRestApiErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetRestApiError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetRestApiErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetRestApiErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetRestApiErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetRestApiErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetRestApiErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetRestApiError {
    fn code(&self) -> Option<&str> {
        GetRestApiError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetRestApiError {
    pub fn new(kind: GetRestApiErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetRestApiErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetRestApiErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetRestApiErrorKind::BadRequestException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetRestApiErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(&self.kind, GetRestApiErrorKind::TooManyRequestsException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, GetRestApiErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for GetRestApiError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetRestApiErrorKind::BadRequestException(_inner) => Some(_inner),
            GetRestApiErrorKind::NotFoundException(_inner) => Some(_inner),
            GetRestApiErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetRestApiErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetRestApiErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetRestApisError {
    pub kind: GetRestApisErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetRestApisErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetRestApisError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetRestApisErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetRestApisErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetRestApisErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetRestApisErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetRestApisErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetRestApisError {
    fn code(&self) -> Option<&str> {
        GetRestApisError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetRestApisError {
    pub fn new(kind: GetRestApisErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetRestApisErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetRestApisErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetRestApisErrorKind::BadRequestException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetRestApisErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRestApisErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, GetRestApisErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for GetRestApisError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetRestApisErrorKind::BadRequestException(_inner) => Some(_inner),
            GetRestApisErrorKind::NotFoundException(_inner) => Some(_inner),
            GetRestApisErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetRestApisErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetRestApisErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetSdkError {
    pub kind: GetSdkErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetSdkErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetSdkError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetSdkErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetSdkErrorKind::ConflictException(_inner) => _inner.fmt(f),
            GetSdkErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            GetSdkErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetSdkErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetSdkErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetSdkErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetSdkError {
    fn code(&self) -> Option<&str> {
        GetSdkError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetSdkError {
    pub fn new(kind: GetSdkErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetSdkErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetSdkErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetSdkErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, GetSdkErrorKind::ConflictException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, GetSdkErrorKind::LimitExceededException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetSdkErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(&self.kind, GetSdkErrorKind::TooManyRequestsException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, GetSdkErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for GetSdkError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetSdkErrorKind::BadRequestException(_inner) => Some(_inner),
            GetSdkErrorKind::ConflictException(_inner) => Some(_inner),
            GetSdkErrorKind::LimitExceededException(_inner) => Some(_inner),
            GetSdkErrorKind::NotFoundException(_inner) => Some(_inner),
            GetSdkErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetSdkErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetSdkErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetSdkTypeError {
    pub kind: GetSdkTypeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetSdkTypeErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetSdkTypeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetSdkTypeErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetSdkTypeErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetSdkTypeErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetSdkTypeErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetSdkTypeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetSdkTypeError {
    fn code(&self) -> Option<&str> {
        GetSdkTypeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetSdkTypeError {
    pub fn new(kind: GetSdkTypeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetSdkTypeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetSdkTypeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetSdkTypeErrorKind::BadRequestException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetSdkTypeErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(&self.kind, GetSdkTypeErrorKind::TooManyRequestsException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, GetSdkTypeErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for GetSdkTypeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetSdkTypeErrorKind::BadRequestException(_inner) => Some(_inner),
            GetSdkTypeErrorKind::NotFoundException(_inner) => Some(_inner),
            GetSdkTypeErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetSdkTypeErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetSdkTypeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetSdkTypesError {
    pub kind: GetSdkTypesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetSdkTypesErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetSdkTypesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetSdkTypesErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetSdkTypesErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetSdkTypesErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetSdkTypesErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetSdkTypesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetSdkTypesError {
    fn code(&self) -> Option<&str> {
        GetSdkTypesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetSdkTypesError {
    pub fn new(kind: GetSdkTypesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetSdkTypesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetSdkTypesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetSdkTypesErrorKind::BadRequestException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetSdkTypesErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSdkTypesErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, GetSdkTypesErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for GetSdkTypesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetSdkTypesErrorKind::BadRequestException(_inner) => Some(_inner),
            GetSdkTypesErrorKind::NotFoundException(_inner) => Some(_inner),
            GetSdkTypesErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetSdkTypesErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetSdkTypesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetStageError {
    pub kind: GetStageErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetStageErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetStageError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetStageErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetStageErrorKind::ConflictException(_inner) => _inner.fmt(f),
            GetStageErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            GetStageErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetStageErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetStageErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetStageErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetStageError {
    fn code(&self) -> Option<&str> {
        GetStageError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetStageError {
    pub fn new(kind: GetStageErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetStageErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetStageErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetStageErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, GetStageErrorKind::ConflictException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, GetStageErrorKind::LimitExceededException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetStageErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(&self.kind, GetStageErrorKind::TooManyRequestsException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, GetStageErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for GetStageError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetStageErrorKind::BadRequestException(_inner) => Some(_inner),
            GetStageErrorKind::ConflictException(_inner) => Some(_inner),
            GetStageErrorKind::LimitExceededException(_inner) => Some(_inner),
            GetStageErrorKind::NotFoundException(_inner) => Some(_inner),
            GetStageErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetStageErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetStageErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetStagesError {
    pub kind: GetStagesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetStagesErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetStagesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetStagesErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetStagesErrorKind::ConflictException(_inner) => _inner.fmt(f),
            GetStagesErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            GetStagesErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetStagesErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetStagesErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetStagesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetStagesError {
    fn code(&self) -> Option<&str> {
        GetStagesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetStagesError {
    pub fn new(kind: GetStagesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetStagesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetStagesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetStagesErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, GetStagesErrorKind::ConflictException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, GetStagesErrorKind::LimitExceededException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetStagesErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(&self.kind, GetStagesErrorKind::TooManyRequestsException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, GetStagesErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for GetStagesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetStagesErrorKind::BadRequestException(_inner) => Some(_inner),
            GetStagesErrorKind::ConflictException(_inner) => Some(_inner),
            GetStagesErrorKind::LimitExceededException(_inner) => Some(_inner),
            GetStagesErrorKind::NotFoundException(_inner) => Some(_inner),
            GetStagesErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetStagesErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetStagesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetTagsError {
    pub kind: GetTagsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetTagsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetTagsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetTagsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetTagsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetTagsErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetTagsErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetTagsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetTagsError {
    fn code(&self) -> Option<&str> {
        GetTagsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetTagsError {
    pub fn new(kind: GetTagsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetTagsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetTagsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetTagsErrorKind::BadRequestException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetTagsErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(&self.kind, GetTagsErrorKind::TooManyRequestsException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, GetTagsErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for GetTagsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetTagsErrorKind::BadRequestException(_inner) => Some(_inner),
            GetTagsErrorKind::NotFoundException(_inner) => Some(_inner),
            GetTagsErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetTagsErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetTagsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetUsageError {
    pub kind: GetUsageErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetUsageErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetUsageError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetUsageErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetUsageErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetUsageErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetUsageErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetUsageErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetUsageError {
    fn code(&self) -> Option<&str> {
        GetUsageError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetUsageError {
    pub fn new(kind: GetUsageErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetUsageErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetUsageErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetUsageErrorKind::BadRequestException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetUsageErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(&self.kind, GetUsageErrorKind::TooManyRequestsException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, GetUsageErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for GetUsageError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetUsageErrorKind::BadRequestException(_inner) => Some(_inner),
            GetUsageErrorKind::NotFoundException(_inner) => Some(_inner),
            GetUsageErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetUsageErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetUsageErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetUsagePlanError {
    pub kind: GetUsagePlanErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetUsagePlanErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetUsagePlanError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetUsagePlanErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetUsagePlanErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetUsagePlanErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetUsagePlanErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetUsagePlanErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetUsagePlanError {
    fn code(&self) -> Option<&str> {
        GetUsagePlanError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetUsagePlanError {
    pub fn new(kind: GetUsagePlanErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetUsagePlanErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetUsagePlanErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetUsagePlanErrorKind::BadRequestException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetUsagePlanErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetUsagePlanErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, GetUsagePlanErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for GetUsagePlanError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetUsagePlanErrorKind::BadRequestException(_inner) => Some(_inner),
            GetUsagePlanErrorKind::NotFoundException(_inner) => Some(_inner),
            GetUsagePlanErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetUsagePlanErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetUsagePlanErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetUsagePlanKeyError {
    pub kind: GetUsagePlanKeyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetUsagePlanKeyErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetUsagePlanKeyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetUsagePlanKeyErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetUsagePlanKeyErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetUsagePlanKeyErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetUsagePlanKeyErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetUsagePlanKeyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetUsagePlanKeyError {
    fn code(&self) -> Option<&str> {
        GetUsagePlanKeyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetUsagePlanKeyError {
    pub fn new(kind: GetUsagePlanKeyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetUsagePlanKeyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetUsagePlanKeyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetUsagePlanKeyErrorKind::BadRequestException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetUsagePlanKeyErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetUsagePlanKeyErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetUsagePlanKeyErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for GetUsagePlanKeyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetUsagePlanKeyErrorKind::BadRequestException(_inner) => Some(_inner),
            GetUsagePlanKeyErrorKind::NotFoundException(_inner) => Some(_inner),
            GetUsagePlanKeyErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetUsagePlanKeyErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetUsagePlanKeyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetUsagePlanKeysError {
    pub kind: GetUsagePlanKeysErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetUsagePlanKeysErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetUsagePlanKeysError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetUsagePlanKeysErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetUsagePlanKeysErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetUsagePlanKeysErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetUsagePlanKeysErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetUsagePlanKeysErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetUsagePlanKeysError {
    fn code(&self) -> Option<&str> {
        GetUsagePlanKeysError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetUsagePlanKeysError {
    pub fn new(kind: GetUsagePlanKeysErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetUsagePlanKeysErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetUsagePlanKeysErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetUsagePlanKeysErrorKind::BadRequestException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetUsagePlanKeysErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetUsagePlanKeysErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetUsagePlanKeysErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for GetUsagePlanKeysError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetUsagePlanKeysErrorKind::BadRequestException(_inner) => Some(_inner),
            GetUsagePlanKeysErrorKind::NotFoundException(_inner) => Some(_inner),
            GetUsagePlanKeysErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetUsagePlanKeysErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetUsagePlanKeysErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetUsagePlansError {
    pub kind: GetUsagePlansErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetUsagePlansErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetUsagePlansError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetUsagePlansErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetUsagePlansErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetUsagePlansErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetUsagePlansErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetUsagePlansErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetUsagePlansError {
    fn code(&self) -> Option<&str> {
        GetUsagePlansError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetUsagePlansError {
    pub fn new(kind: GetUsagePlansErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetUsagePlansErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetUsagePlansErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetUsagePlansErrorKind::BadRequestException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetUsagePlansErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetUsagePlansErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, GetUsagePlansErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for GetUsagePlansError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetUsagePlansErrorKind::BadRequestException(_inner) => Some(_inner),
            GetUsagePlansErrorKind::NotFoundException(_inner) => Some(_inner),
            GetUsagePlansErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetUsagePlansErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetUsagePlansErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetVpcLinkError {
    pub kind: GetVpcLinkErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetVpcLinkErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetVpcLinkError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetVpcLinkErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetVpcLinkErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetVpcLinkErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetVpcLinkErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetVpcLinkErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetVpcLinkError {
    fn code(&self) -> Option<&str> {
        GetVpcLinkError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetVpcLinkError {
    pub fn new(kind: GetVpcLinkErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetVpcLinkErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetVpcLinkErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetVpcLinkErrorKind::BadRequestException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetVpcLinkErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(&self.kind, GetVpcLinkErrorKind::TooManyRequestsException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, GetVpcLinkErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for GetVpcLinkError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetVpcLinkErrorKind::BadRequestException(_inner) => Some(_inner),
            GetVpcLinkErrorKind::NotFoundException(_inner) => Some(_inner),
            GetVpcLinkErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetVpcLinkErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetVpcLinkErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetVpcLinksError {
    pub kind: GetVpcLinksErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetVpcLinksErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetVpcLinksError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetVpcLinksErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetVpcLinksErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetVpcLinksErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetVpcLinksErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetVpcLinksErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetVpcLinksError {
    fn code(&self) -> Option<&str> {
        GetVpcLinksError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetVpcLinksError {
    pub fn new(kind: GetVpcLinksErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetVpcLinksErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetVpcLinksErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetVpcLinksErrorKind::BadRequestException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetVpcLinksErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVpcLinksErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, GetVpcLinksErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for GetVpcLinksError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetVpcLinksErrorKind::BadRequestException(_inner) => Some(_inner),
            GetVpcLinksErrorKind::NotFoundException(_inner) => Some(_inner),
            GetVpcLinksErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetVpcLinksErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetVpcLinksErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ImportApiKeysError {
    pub kind: ImportApiKeysErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ImportApiKeysErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ImportApiKeysError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ImportApiKeysErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ImportApiKeysErrorKind::ConflictException(_inner) => _inner.fmt(f),
            ImportApiKeysErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            ImportApiKeysErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ImportApiKeysErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            ImportApiKeysErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ImportApiKeysErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ImportApiKeysError {
    fn code(&self) -> Option<&str> {
        ImportApiKeysError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ImportApiKeysError {
    pub fn new(kind: ImportApiKeysErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ImportApiKeysErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ImportApiKeysErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, ImportApiKeysErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, ImportApiKeysErrorKind::ConflictException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ImportApiKeysErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, ImportApiKeysErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            ImportApiKeysErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, ImportApiKeysErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for ImportApiKeysError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ImportApiKeysErrorKind::BadRequestException(_inner) => Some(_inner),
            ImportApiKeysErrorKind::ConflictException(_inner) => Some(_inner),
            ImportApiKeysErrorKind::LimitExceededException(_inner) => Some(_inner),
            ImportApiKeysErrorKind::NotFoundException(_inner) => Some(_inner),
            ImportApiKeysErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            ImportApiKeysErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ImportApiKeysErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ImportDocumentationPartsError {
    pub kind: ImportDocumentationPartsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ImportDocumentationPartsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ImportDocumentationPartsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ImportDocumentationPartsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ImportDocumentationPartsErrorKind::ConflictException(_inner) => _inner.fmt(f),
            ImportDocumentationPartsErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            ImportDocumentationPartsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ImportDocumentationPartsErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            ImportDocumentationPartsErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ImportDocumentationPartsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ImportDocumentationPartsError {
    fn code(&self) -> Option<&str> {
        ImportDocumentationPartsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ImportDocumentationPartsError {
    pub fn new(kind: ImportDocumentationPartsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ImportDocumentationPartsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ImportDocumentationPartsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ImportDocumentationPartsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            ImportDocumentationPartsErrorKind::ConflictException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ImportDocumentationPartsErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ImportDocumentationPartsErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            ImportDocumentationPartsErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ImportDocumentationPartsErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for ImportDocumentationPartsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ImportDocumentationPartsErrorKind::BadRequestException(_inner) => Some(_inner),
            ImportDocumentationPartsErrorKind::ConflictException(_inner) => Some(_inner),
            ImportDocumentationPartsErrorKind::LimitExceededException(_inner) => Some(_inner),
            ImportDocumentationPartsErrorKind::NotFoundException(_inner) => Some(_inner),
            ImportDocumentationPartsErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            ImportDocumentationPartsErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ImportDocumentationPartsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ImportRestApiError {
    pub kind: ImportRestApiErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ImportRestApiErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ImportRestApiError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ImportRestApiErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ImportRestApiErrorKind::ConflictException(_inner) => _inner.fmt(f),
            ImportRestApiErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            ImportRestApiErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ImportRestApiErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            ImportRestApiErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ImportRestApiErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ImportRestApiError {
    fn code(&self) -> Option<&str> {
        ImportRestApiError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ImportRestApiError {
    pub fn new(kind: ImportRestApiErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ImportRestApiErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ImportRestApiErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, ImportRestApiErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, ImportRestApiErrorKind::ConflictException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ImportRestApiErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, ImportRestApiErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            ImportRestApiErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, ImportRestApiErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for ImportRestApiError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ImportRestApiErrorKind::BadRequestException(_inner) => Some(_inner),
            ImportRestApiErrorKind::ConflictException(_inner) => Some(_inner),
            ImportRestApiErrorKind::LimitExceededException(_inner) => Some(_inner),
            ImportRestApiErrorKind::NotFoundException(_inner) => Some(_inner),
            ImportRestApiErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            ImportRestApiErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ImportRestApiErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutGatewayResponseError {
    pub kind: PutGatewayResponseErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutGatewayResponseErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutGatewayResponseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutGatewayResponseErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            PutGatewayResponseErrorKind::ConflictException(_inner) => _inner.fmt(f),
            PutGatewayResponseErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            PutGatewayResponseErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            PutGatewayResponseErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            PutGatewayResponseErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            PutGatewayResponseErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutGatewayResponseError {
    fn code(&self) -> Option<&str> {
        PutGatewayResponseError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutGatewayResponseError {
    pub fn new(kind: PutGatewayResponseErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutGatewayResponseErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutGatewayResponseErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutGatewayResponseErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutGatewayResponseErrorKind::ConflictException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutGatewayResponseErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutGatewayResponseErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutGatewayResponseErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutGatewayResponseErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for PutGatewayResponseError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutGatewayResponseErrorKind::BadRequestException(_inner) => Some(_inner),
            PutGatewayResponseErrorKind::ConflictException(_inner) => Some(_inner),
            PutGatewayResponseErrorKind::LimitExceededException(_inner) => Some(_inner),
            PutGatewayResponseErrorKind::NotFoundException(_inner) => Some(_inner),
            PutGatewayResponseErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            PutGatewayResponseErrorKind::UnauthorizedException(_inner) => Some(_inner),
            PutGatewayResponseErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutIntegrationError {
    pub kind: PutIntegrationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutIntegrationErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutIntegrationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutIntegrationErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            PutIntegrationErrorKind::ConflictException(_inner) => _inner.fmt(f),
            PutIntegrationErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            PutIntegrationErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            PutIntegrationErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            PutIntegrationErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            PutIntegrationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutIntegrationError {
    fn code(&self) -> Option<&str> {
        PutIntegrationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutIntegrationError {
    pub fn new(kind: PutIntegrationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutIntegrationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutIntegrationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, PutIntegrationErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, PutIntegrationErrorKind::ConflictException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutIntegrationErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, PutIntegrationErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutIntegrationErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutIntegrationErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for PutIntegrationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutIntegrationErrorKind::BadRequestException(_inner) => Some(_inner),
            PutIntegrationErrorKind::ConflictException(_inner) => Some(_inner),
            PutIntegrationErrorKind::LimitExceededException(_inner) => Some(_inner),
            PutIntegrationErrorKind::NotFoundException(_inner) => Some(_inner),
            PutIntegrationErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            PutIntegrationErrorKind::UnauthorizedException(_inner) => Some(_inner),
            PutIntegrationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutIntegrationResponseError {
    pub kind: PutIntegrationResponseErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutIntegrationResponseErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutIntegrationResponseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutIntegrationResponseErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            PutIntegrationResponseErrorKind::ConflictException(_inner) => _inner.fmt(f),
            PutIntegrationResponseErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            PutIntegrationResponseErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            PutIntegrationResponseErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            PutIntegrationResponseErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            PutIntegrationResponseErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutIntegrationResponseError {
    fn code(&self) -> Option<&str> {
        PutIntegrationResponseError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutIntegrationResponseError {
    pub fn new(kind: PutIntegrationResponseErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutIntegrationResponseErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutIntegrationResponseErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutIntegrationResponseErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutIntegrationResponseErrorKind::ConflictException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutIntegrationResponseErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutIntegrationResponseErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutIntegrationResponseErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutIntegrationResponseErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for PutIntegrationResponseError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutIntegrationResponseErrorKind::BadRequestException(_inner) => Some(_inner),
            PutIntegrationResponseErrorKind::ConflictException(_inner) => Some(_inner),
            PutIntegrationResponseErrorKind::LimitExceededException(_inner) => Some(_inner),
            PutIntegrationResponseErrorKind::NotFoundException(_inner) => Some(_inner),
            PutIntegrationResponseErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            PutIntegrationResponseErrorKind::UnauthorizedException(_inner) => Some(_inner),
            PutIntegrationResponseErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutMethodError {
    pub kind: PutMethodErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutMethodErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutMethodError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutMethodErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            PutMethodErrorKind::ConflictException(_inner) => _inner.fmt(f),
            PutMethodErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            PutMethodErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            PutMethodErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            PutMethodErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            PutMethodErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutMethodError {
    fn code(&self) -> Option<&str> {
        PutMethodError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutMethodError {
    pub fn new(kind: PutMethodErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutMethodErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutMethodErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, PutMethodErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, PutMethodErrorKind::ConflictException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, PutMethodErrorKind::LimitExceededException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, PutMethodErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(&self.kind, PutMethodErrorKind::TooManyRequestsException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, PutMethodErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for PutMethodError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutMethodErrorKind::BadRequestException(_inner) => Some(_inner),
            PutMethodErrorKind::ConflictException(_inner) => Some(_inner),
            PutMethodErrorKind::LimitExceededException(_inner) => Some(_inner),
            PutMethodErrorKind::NotFoundException(_inner) => Some(_inner),
            PutMethodErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            PutMethodErrorKind::UnauthorizedException(_inner) => Some(_inner),
            PutMethodErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutMethodResponseError {
    pub kind: PutMethodResponseErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutMethodResponseErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutMethodResponseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutMethodResponseErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            PutMethodResponseErrorKind::ConflictException(_inner) => _inner.fmt(f),
            PutMethodResponseErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            PutMethodResponseErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            PutMethodResponseErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            PutMethodResponseErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            PutMethodResponseErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutMethodResponseError {
    fn code(&self) -> Option<&str> {
        PutMethodResponseError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutMethodResponseError {
    pub fn new(kind: PutMethodResponseErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutMethodResponseErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutMethodResponseErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutMethodResponseErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, PutMethodResponseErrorKind::ConflictException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutMethodResponseErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, PutMethodResponseErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutMethodResponseErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutMethodResponseErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for PutMethodResponseError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutMethodResponseErrorKind::BadRequestException(_inner) => Some(_inner),
            PutMethodResponseErrorKind::ConflictException(_inner) => Some(_inner),
            PutMethodResponseErrorKind::LimitExceededException(_inner) => Some(_inner),
            PutMethodResponseErrorKind::NotFoundException(_inner) => Some(_inner),
            PutMethodResponseErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            PutMethodResponseErrorKind::UnauthorizedException(_inner) => Some(_inner),
            PutMethodResponseErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutRestApiError {
    pub kind: PutRestApiErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutRestApiErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutRestApiError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutRestApiErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            PutRestApiErrorKind::ConflictException(_inner) => _inner.fmt(f),
            PutRestApiErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            PutRestApiErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            PutRestApiErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            PutRestApiErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            PutRestApiErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutRestApiError {
    fn code(&self) -> Option<&str> {
        PutRestApiError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutRestApiError {
    pub fn new(kind: PutRestApiErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutRestApiErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutRestApiErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, PutRestApiErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, PutRestApiErrorKind::ConflictException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, PutRestApiErrorKind::LimitExceededException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, PutRestApiErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(&self.kind, PutRestApiErrorKind::TooManyRequestsException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, PutRestApiErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for PutRestApiError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutRestApiErrorKind::BadRequestException(_inner) => Some(_inner),
            PutRestApiErrorKind::ConflictException(_inner) => Some(_inner),
            PutRestApiErrorKind::LimitExceededException(_inner) => Some(_inner),
            PutRestApiErrorKind::NotFoundException(_inner) => Some(_inner),
            PutRestApiErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            PutRestApiErrorKind::UnauthorizedException(_inner) => Some(_inner),
            PutRestApiErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagResourceError {
    pub kind: TagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagResourceErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagResourceErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ConflictException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TagResourceError {
    fn code(&self) -> Option<&str> {
        TagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagResourceError {
    pub fn new(kind: TagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::ConflictException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::LimitExceededException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for TagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagResourceErrorKind::BadRequestException(_inner) => Some(_inner),
            TagResourceErrorKind::ConflictException(_inner) => Some(_inner),
            TagResourceErrorKind::LimitExceededException(_inner) => Some(_inner),
            TagResourceErrorKind::NotFoundException(_inner) => Some(_inner),
            TagResourceErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            TagResourceErrorKind::UnauthorizedException(_inner) => Some(_inner),
            TagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TestInvokeAuthorizerError {
    pub kind: TestInvokeAuthorizerErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TestInvokeAuthorizerErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TestInvokeAuthorizerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TestInvokeAuthorizerErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            TestInvokeAuthorizerErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            TestInvokeAuthorizerErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            TestInvokeAuthorizerErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            TestInvokeAuthorizerErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TestInvokeAuthorizerError {
    fn code(&self) -> Option<&str> {
        TestInvokeAuthorizerError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TestInvokeAuthorizerError {
    pub fn new(kind: TestInvokeAuthorizerErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TestInvokeAuthorizerErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TestInvokeAuthorizerErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestInvokeAuthorizerErrorKind::BadRequestException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestInvokeAuthorizerErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestInvokeAuthorizerErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestInvokeAuthorizerErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for TestInvokeAuthorizerError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TestInvokeAuthorizerErrorKind::BadRequestException(_inner) => Some(_inner),
            TestInvokeAuthorizerErrorKind::NotFoundException(_inner) => Some(_inner),
            TestInvokeAuthorizerErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            TestInvokeAuthorizerErrorKind::UnauthorizedException(_inner) => Some(_inner),
            TestInvokeAuthorizerErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TestInvokeMethodError {
    pub kind: TestInvokeMethodErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TestInvokeMethodErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TestInvokeMethodError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TestInvokeMethodErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            TestInvokeMethodErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            TestInvokeMethodErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            TestInvokeMethodErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            TestInvokeMethodErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TestInvokeMethodError {
    fn code(&self) -> Option<&str> {
        TestInvokeMethodError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TestInvokeMethodError {
    pub fn new(kind: TestInvokeMethodErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TestInvokeMethodErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TestInvokeMethodErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestInvokeMethodErrorKind::BadRequestException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, TestInvokeMethodErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestInvokeMethodErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestInvokeMethodErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for TestInvokeMethodError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TestInvokeMethodErrorKind::BadRequestException(_inner) => Some(_inner),
            TestInvokeMethodErrorKind::NotFoundException(_inner) => Some(_inner),
            TestInvokeMethodErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            TestInvokeMethodErrorKind::UnauthorizedException(_inner) => Some(_inner),
            TestInvokeMethodErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagResourceError {
    pub kind: UntagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagResourceErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UntagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagResourceErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UntagResourceError {
    fn code(&self) -> Option<&str> {
        UntagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagResourceError {
    pub fn new(kind: UntagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UntagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UntagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::ConflictException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for UntagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagResourceErrorKind::BadRequestException(_inner) => Some(_inner),
            UntagResourceErrorKind::ConflictException(_inner) => Some(_inner),
            UntagResourceErrorKind::LimitExceededException(_inner) => Some(_inner),
            UntagResourceErrorKind::NotFoundException(_inner) => Some(_inner),
            UntagResourceErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UntagResourceErrorKind::UnauthorizedException(_inner) => Some(_inner),
            UntagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateAccountError {
    pub kind: UpdateAccountErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateAccountErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateAccountError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateAccountErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateAccountErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateAccountErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UpdateAccountErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateAccountErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdateAccountErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            UpdateAccountErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateAccountError {
    fn code(&self) -> Option<&str> {
        UpdateAccountError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateAccountError {
    pub fn new(kind: UpdateAccountErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateAccountErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateAccountErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, UpdateAccountErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, UpdateAccountErrorKind::ConflictException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAccountErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateAccountErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAccountErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, UpdateAccountErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for UpdateAccountError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateAccountErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateAccountErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateAccountErrorKind::LimitExceededException(_inner) => Some(_inner),
            UpdateAccountErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateAccountErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateAccountErrorKind::UnauthorizedException(_inner) => Some(_inner),
            UpdateAccountErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateApiKeyError {
    pub kind: UpdateApiKeyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateApiKeyErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateApiKeyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateApiKeyErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateApiKeyErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateApiKeyErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UpdateApiKeyErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateApiKeyErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdateApiKeyErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            UpdateApiKeyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateApiKeyError {
    fn code(&self) -> Option<&str> {
        UpdateApiKeyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateApiKeyError {
    pub fn new(kind: UpdateApiKeyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateApiKeyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateApiKeyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, UpdateApiKeyErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, UpdateApiKeyErrorKind::ConflictException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, UpdateApiKeyErrorKind::LimitExceededException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateApiKeyErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateApiKeyErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, UpdateApiKeyErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for UpdateApiKeyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateApiKeyErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateApiKeyErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateApiKeyErrorKind::LimitExceededException(_inner) => Some(_inner),
            UpdateApiKeyErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateApiKeyErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateApiKeyErrorKind::UnauthorizedException(_inner) => Some(_inner),
            UpdateApiKeyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateAuthorizerError {
    pub kind: UpdateAuthorizerErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateAuthorizerErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateAuthorizerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateAuthorizerErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateAuthorizerErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateAuthorizerErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UpdateAuthorizerErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateAuthorizerErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdateAuthorizerErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            UpdateAuthorizerErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateAuthorizerError {
    fn code(&self) -> Option<&str> {
        UpdateAuthorizerError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateAuthorizerError {
    pub fn new(kind: UpdateAuthorizerErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateAuthorizerErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateAuthorizerErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAuthorizerErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, UpdateAuthorizerErrorKind::ConflictException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAuthorizerErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateAuthorizerErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAuthorizerErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAuthorizerErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for UpdateAuthorizerError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateAuthorizerErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateAuthorizerErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateAuthorizerErrorKind::LimitExceededException(_inner) => Some(_inner),
            UpdateAuthorizerErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateAuthorizerErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateAuthorizerErrorKind::UnauthorizedException(_inner) => Some(_inner),
            UpdateAuthorizerErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateBasePathMappingError {
    pub kind: UpdateBasePathMappingErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateBasePathMappingErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateBasePathMappingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateBasePathMappingErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateBasePathMappingErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateBasePathMappingErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UpdateBasePathMappingErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateBasePathMappingErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdateBasePathMappingErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            UpdateBasePathMappingErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateBasePathMappingError {
    fn code(&self) -> Option<&str> {
        UpdateBasePathMappingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateBasePathMappingError {
    pub fn new(kind: UpdateBasePathMappingErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateBasePathMappingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateBasePathMappingErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateBasePathMappingErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateBasePathMappingErrorKind::ConflictException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateBasePathMappingErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateBasePathMappingErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateBasePathMappingErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateBasePathMappingErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for UpdateBasePathMappingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateBasePathMappingErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateBasePathMappingErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateBasePathMappingErrorKind::LimitExceededException(_inner) => Some(_inner),
            UpdateBasePathMappingErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateBasePathMappingErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateBasePathMappingErrorKind::UnauthorizedException(_inner) => Some(_inner),
            UpdateBasePathMappingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateClientCertificateError {
    pub kind: UpdateClientCertificateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateClientCertificateErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateClientCertificateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateClientCertificateErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateClientCertificateErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateClientCertificateErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UpdateClientCertificateErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateClientCertificateErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdateClientCertificateErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            UpdateClientCertificateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateClientCertificateError {
    fn code(&self) -> Option<&str> {
        UpdateClientCertificateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateClientCertificateError {
    pub fn new(kind: UpdateClientCertificateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateClientCertificateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateClientCertificateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateClientCertificateErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateClientCertificateErrorKind::ConflictException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateClientCertificateErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateClientCertificateErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateClientCertificateErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateClientCertificateErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for UpdateClientCertificateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateClientCertificateErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateClientCertificateErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateClientCertificateErrorKind::LimitExceededException(_inner) => Some(_inner),
            UpdateClientCertificateErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateClientCertificateErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateClientCertificateErrorKind::UnauthorizedException(_inner) => Some(_inner),
            UpdateClientCertificateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateDeploymentError {
    pub kind: UpdateDeploymentErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateDeploymentErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateDeploymentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateDeploymentErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateDeploymentErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateDeploymentErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UpdateDeploymentErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateDeploymentErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            UpdateDeploymentErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdateDeploymentErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            UpdateDeploymentErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateDeploymentError {
    fn code(&self) -> Option<&str> {
        UpdateDeploymentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateDeploymentError {
    pub fn new(kind: UpdateDeploymentErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateDeploymentErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateDeploymentErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDeploymentErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, UpdateDeploymentErrorKind::ConflictException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDeploymentErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateDeploymentErrorKind::NotFoundException(_))
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDeploymentErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDeploymentErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDeploymentErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for UpdateDeploymentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateDeploymentErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateDeploymentErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateDeploymentErrorKind::LimitExceededException(_inner) => Some(_inner),
            UpdateDeploymentErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateDeploymentErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UpdateDeploymentErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateDeploymentErrorKind::UnauthorizedException(_inner) => Some(_inner),
            UpdateDeploymentErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateDocumentationPartError {
    pub kind: UpdateDocumentationPartErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateDocumentationPartErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateDocumentationPartError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateDocumentationPartErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateDocumentationPartErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateDocumentationPartErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UpdateDocumentationPartErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateDocumentationPartErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdateDocumentationPartErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            UpdateDocumentationPartErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateDocumentationPartError {
    fn code(&self) -> Option<&str> {
        UpdateDocumentationPartError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateDocumentationPartError {
    pub fn new(kind: UpdateDocumentationPartErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateDocumentationPartErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateDocumentationPartErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDocumentationPartErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDocumentationPartErrorKind::ConflictException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDocumentationPartErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDocumentationPartErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDocumentationPartErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDocumentationPartErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for UpdateDocumentationPartError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateDocumentationPartErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateDocumentationPartErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateDocumentationPartErrorKind::LimitExceededException(_inner) => Some(_inner),
            UpdateDocumentationPartErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateDocumentationPartErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateDocumentationPartErrorKind::UnauthorizedException(_inner) => Some(_inner),
            UpdateDocumentationPartErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateDocumentationVersionError {
    pub kind: UpdateDocumentationVersionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateDocumentationVersionErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateDocumentationVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateDocumentationVersionErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateDocumentationVersionErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateDocumentationVersionErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UpdateDocumentationVersionErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateDocumentationVersionErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdateDocumentationVersionErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            UpdateDocumentationVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateDocumentationVersionError {
    fn code(&self) -> Option<&str> {
        UpdateDocumentationVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateDocumentationVersionError {
    pub fn new(kind: UpdateDocumentationVersionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateDocumentationVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateDocumentationVersionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDocumentationVersionErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDocumentationVersionErrorKind::ConflictException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDocumentationVersionErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDocumentationVersionErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDocumentationVersionErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDocumentationVersionErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for UpdateDocumentationVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateDocumentationVersionErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateDocumentationVersionErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateDocumentationVersionErrorKind::LimitExceededException(_inner) => Some(_inner),
            UpdateDocumentationVersionErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateDocumentationVersionErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateDocumentationVersionErrorKind::UnauthorizedException(_inner) => Some(_inner),
            UpdateDocumentationVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateDomainNameError {
    pub kind: UpdateDomainNameErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateDomainNameErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateDomainNameError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateDomainNameErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateDomainNameErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateDomainNameErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UpdateDomainNameErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateDomainNameErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdateDomainNameErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            UpdateDomainNameErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateDomainNameError {
    fn code(&self) -> Option<&str> {
        UpdateDomainNameError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateDomainNameError {
    pub fn new(kind: UpdateDomainNameErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateDomainNameErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateDomainNameErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDomainNameErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, UpdateDomainNameErrorKind::ConflictException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDomainNameErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateDomainNameErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDomainNameErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDomainNameErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for UpdateDomainNameError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateDomainNameErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateDomainNameErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateDomainNameErrorKind::LimitExceededException(_inner) => Some(_inner),
            UpdateDomainNameErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateDomainNameErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateDomainNameErrorKind::UnauthorizedException(_inner) => Some(_inner),
            UpdateDomainNameErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateGatewayResponseError {
    pub kind: UpdateGatewayResponseErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateGatewayResponseErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateGatewayResponseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateGatewayResponseErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateGatewayResponseErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateGatewayResponseErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UpdateGatewayResponseErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateGatewayResponseErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdateGatewayResponseErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            UpdateGatewayResponseErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateGatewayResponseError {
    fn code(&self) -> Option<&str> {
        UpdateGatewayResponseError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateGatewayResponseError {
    pub fn new(kind: UpdateGatewayResponseErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateGatewayResponseErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateGatewayResponseErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateGatewayResponseErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateGatewayResponseErrorKind::ConflictException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateGatewayResponseErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateGatewayResponseErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateGatewayResponseErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateGatewayResponseErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for UpdateGatewayResponseError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateGatewayResponseErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateGatewayResponseErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateGatewayResponseErrorKind::LimitExceededException(_inner) => Some(_inner),
            UpdateGatewayResponseErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateGatewayResponseErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateGatewayResponseErrorKind::UnauthorizedException(_inner) => Some(_inner),
            UpdateGatewayResponseErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateIntegrationError {
    pub kind: UpdateIntegrationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateIntegrationErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateIntegrationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateIntegrationErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateIntegrationErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateIntegrationErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UpdateIntegrationErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateIntegrationErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdateIntegrationErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            UpdateIntegrationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateIntegrationError {
    fn code(&self) -> Option<&str> {
        UpdateIntegrationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateIntegrationError {
    pub fn new(kind: UpdateIntegrationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateIntegrationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateIntegrationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateIntegrationErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, UpdateIntegrationErrorKind::ConflictException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateIntegrationErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateIntegrationErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateIntegrationErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateIntegrationErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for UpdateIntegrationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateIntegrationErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateIntegrationErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateIntegrationErrorKind::LimitExceededException(_inner) => Some(_inner),
            UpdateIntegrationErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateIntegrationErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateIntegrationErrorKind::UnauthorizedException(_inner) => Some(_inner),
            UpdateIntegrationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateIntegrationResponseError {
    pub kind: UpdateIntegrationResponseErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateIntegrationResponseErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateIntegrationResponseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateIntegrationResponseErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateIntegrationResponseErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateIntegrationResponseErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UpdateIntegrationResponseErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateIntegrationResponseErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdateIntegrationResponseErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            UpdateIntegrationResponseErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateIntegrationResponseError {
    fn code(&self) -> Option<&str> {
        UpdateIntegrationResponseError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateIntegrationResponseError {
    pub fn new(kind: UpdateIntegrationResponseErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateIntegrationResponseErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateIntegrationResponseErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateIntegrationResponseErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateIntegrationResponseErrorKind::ConflictException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateIntegrationResponseErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateIntegrationResponseErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateIntegrationResponseErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateIntegrationResponseErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for UpdateIntegrationResponseError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateIntegrationResponseErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateIntegrationResponseErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateIntegrationResponseErrorKind::LimitExceededException(_inner) => Some(_inner),
            UpdateIntegrationResponseErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateIntegrationResponseErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateIntegrationResponseErrorKind::UnauthorizedException(_inner) => Some(_inner),
            UpdateIntegrationResponseErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateMethodError {
    pub kind: UpdateMethodErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateMethodErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateMethodError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateMethodErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateMethodErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateMethodErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateMethodErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdateMethodErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            UpdateMethodErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateMethodError {
    fn code(&self) -> Option<&str> {
        UpdateMethodError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateMethodError {
    pub fn new(kind: UpdateMethodErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateMethodErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateMethodErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, UpdateMethodErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, UpdateMethodErrorKind::ConflictException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateMethodErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateMethodErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, UpdateMethodErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for UpdateMethodError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateMethodErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateMethodErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateMethodErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateMethodErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateMethodErrorKind::UnauthorizedException(_inner) => Some(_inner),
            UpdateMethodErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateMethodResponseError {
    pub kind: UpdateMethodResponseErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateMethodResponseErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateMethodResponseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateMethodResponseErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateMethodResponseErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateMethodResponseErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UpdateMethodResponseErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateMethodResponseErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdateMethodResponseErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            UpdateMethodResponseErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateMethodResponseError {
    fn code(&self) -> Option<&str> {
        UpdateMethodResponseError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateMethodResponseError {
    pub fn new(kind: UpdateMethodResponseErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateMethodResponseErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateMethodResponseErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateMethodResponseErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateMethodResponseErrorKind::ConflictException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateMethodResponseErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateMethodResponseErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateMethodResponseErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateMethodResponseErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for UpdateMethodResponseError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateMethodResponseErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateMethodResponseErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateMethodResponseErrorKind::LimitExceededException(_inner) => Some(_inner),
            UpdateMethodResponseErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateMethodResponseErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateMethodResponseErrorKind::UnauthorizedException(_inner) => Some(_inner),
            UpdateMethodResponseErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateModelError {
    pub kind: UpdateModelErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateModelErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateModelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateModelErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateModelErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateModelErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UpdateModelErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateModelErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdateModelErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            UpdateModelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateModelError {
    fn code(&self) -> Option<&str> {
        UpdateModelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateModelError {
    pub fn new(kind: UpdateModelErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateModelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateModelErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, UpdateModelErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, UpdateModelErrorKind::ConflictException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, UpdateModelErrorKind::LimitExceededException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateModelErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateModelErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, UpdateModelErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for UpdateModelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateModelErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateModelErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateModelErrorKind::LimitExceededException(_inner) => Some(_inner),
            UpdateModelErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateModelErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateModelErrorKind::UnauthorizedException(_inner) => Some(_inner),
            UpdateModelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateRequestValidatorError {
    pub kind: UpdateRequestValidatorErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateRequestValidatorErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateRequestValidatorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateRequestValidatorErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateRequestValidatorErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateRequestValidatorErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UpdateRequestValidatorErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateRequestValidatorErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdateRequestValidatorErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            UpdateRequestValidatorErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateRequestValidatorError {
    fn code(&self) -> Option<&str> {
        UpdateRequestValidatorError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateRequestValidatorError {
    pub fn new(kind: UpdateRequestValidatorErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateRequestValidatorErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateRequestValidatorErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRequestValidatorErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRequestValidatorErrorKind::ConflictException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRequestValidatorErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRequestValidatorErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRequestValidatorErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRequestValidatorErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for UpdateRequestValidatorError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateRequestValidatorErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateRequestValidatorErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateRequestValidatorErrorKind::LimitExceededException(_inner) => Some(_inner),
            UpdateRequestValidatorErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateRequestValidatorErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateRequestValidatorErrorKind::UnauthorizedException(_inner) => Some(_inner),
            UpdateRequestValidatorErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateResourceError {
    pub kind: UpdateResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateResourceErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateResourceErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateResourceErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateResourceErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateResourceErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdateResourceErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            UpdateResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateResourceError {
    fn code(&self) -> Option<&str> {
        UpdateResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateResourceError {
    pub fn new(kind: UpdateResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, UpdateResourceErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, UpdateResourceErrorKind::ConflictException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateResourceErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateResourceErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateResourceErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for UpdateResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateResourceErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateResourceErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateResourceErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateResourceErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateResourceErrorKind::UnauthorizedException(_inner) => Some(_inner),
            UpdateResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateRestApiError {
    pub kind: UpdateRestApiErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateRestApiErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateRestApiError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateRestApiErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateRestApiErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateRestApiErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UpdateRestApiErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateRestApiErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdateRestApiErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            UpdateRestApiErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateRestApiError {
    fn code(&self) -> Option<&str> {
        UpdateRestApiError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateRestApiError {
    pub fn new(kind: UpdateRestApiErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateRestApiErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateRestApiErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, UpdateRestApiErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, UpdateRestApiErrorKind::ConflictException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRestApiErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateRestApiErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRestApiErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, UpdateRestApiErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for UpdateRestApiError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateRestApiErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateRestApiErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateRestApiErrorKind::LimitExceededException(_inner) => Some(_inner),
            UpdateRestApiErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateRestApiErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateRestApiErrorKind::UnauthorizedException(_inner) => Some(_inner),
            UpdateRestApiErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateStageError {
    pub kind: UpdateStageErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateStageErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateStageError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateStageErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateStageErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateStageErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UpdateStageErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateStageErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdateStageErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            UpdateStageErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateStageError {
    fn code(&self) -> Option<&str> {
        UpdateStageError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateStageError {
    pub fn new(kind: UpdateStageErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateStageErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateStageErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, UpdateStageErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, UpdateStageErrorKind::ConflictException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, UpdateStageErrorKind::LimitExceededException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateStageErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateStageErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, UpdateStageErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for UpdateStageError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateStageErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateStageErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateStageErrorKind::LimitExceededException(_inner) => Some(_inner),
            UpdateStageErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateStageErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateStageErrorKind::UnauthorizedException(_inner) => Some(_inner),
            UpdateStageErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateUsageError {
    pub kind: UpdateUsageErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateUsageErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateUsageError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateUsageErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateUsageErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateUsageErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UpdateUsageErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateUsageErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdateUsageErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            UpdateUsageErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateUsageError {
    fn code(&self) -> Option<&str> {
        UpdateUsageError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateUsageError {
    pub fn new(kind: UpdateUsageErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateUsageErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateUsageErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, UpdateUsageErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, UpdateUsageErrorKind::ConflictException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, UpdateUsageErrorKind::LimitExceededException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateUsageErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUsageErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, UpdateUsageErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for UpdateUsageError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateUsageErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateUsageErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateUsageErrorKind::LimitExceededException(_inner) => Some(_inner),
            UpdateUsageErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateUsageErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateUsageErrorKind::UnauthorizedException(_inner) => Some(_inner),
            UpdateUsageErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateUsagePlanError {
    pub kind: UpdateUsagePlanErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateUsagePlanErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateUsagePlanError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateUsagePlanErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateUsagePlanErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateUsagePlanErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UpdateUsagePlanErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateUsagePlanErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdateUsagePlanErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            UpdateUsagePlanErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateUsagePlanError {
    fn code(&self) -> Option<&str> {
        UpdateUsagePlanError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateUsagePlanError {
    pub fn new(kind: UpdateUsagePlanErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateUsagePlanErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateUsagePlanErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, UpdateUsagePlanErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, UpdateUsagePlanErrorKind::ConflictException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUsagePlanErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateUsagePlanErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUsagePlanErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUsagePlanErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for UpdateUsagePlanError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateUsagePlanErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateUsagePlanErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateUsagePlanErrorKind::LimitExceededException(_inner) => Some(_inner),
            UpdateUsagePlanErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateUsagePlanErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateUsagePlanErrorKind::UnauthorizedException(_inner) => Some(_inner),
            UpdateUsagePlanErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateVpcLinkError {
    pub kind: UpdateVpcLinkErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateVpcLinkErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateVpcLinkError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateVpcLinkErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateVpcLinkErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateVpcLinkErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UpdateVpcLinkErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateVpcLinkErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdateVpcLinkErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            UpdateVpcLinkErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateVpcLinkError {
    fn code(&self) -> Option<&str> {
        UpdateVpcLinkError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateVpcLinkError {
    pub fn new(kind: UpdateVpcLinkErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateVpcLinkErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateVpcLinkErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, UpdateVpcLinkErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, UpdateVpcLinkErrorKind::ConflictException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVpcLinkErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateVpcLinkErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVpcLinkErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, UpdateVpcLinkErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for UpdateVpcLinkError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateVpcLinkErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateVpcLinkErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateVpcLinkErrorKind::LimitExceededException(_inner) => Some(_inner),
            UpdateVpcLinkErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateVpcLinkErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateVpcLinkErrorKind::UnauthorizedException(_inner) => Some(_inner),
            UpdateVpcLinkErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// <p>The request is denied because the caller has insufficient permissions.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UnauthorizedException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UnauthorizedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UnauthorizedException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl UnauthorizedException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UnauthorizedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UnauthorizedException")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for UnauthorizedException {}
/// See [`UnauthorizedException`](crate::error::UnauthorizedException)
pub mod unauthorized_exception {
    /// A builder for [`UnauthorizedException`](crate::error::UnauthorizedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`UnauthorizedException`](crate::error::UnauthorizedException)
        pub fn build(self) -> crate::error::UnauthorizedException {
            crate::error::UnauthorizedException {
                message: self.message,
            }
        }
    }
}
impl UnauthorizedException {
    /// Creates a new builder-style object to manufacture [`UnauthorizedException`](crate::error::UnauthorizedException)
    pub fn builder() -> crate::error::unauthorized_exception::Builder {
        crate::error::unauthorized_exception::Builder::default()
    }
}

/// <p>The request has reached its throttling limit. Retry after the specified time period.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TooManyRequestsException {
    pub retry_after_seconds: std::option::Option<std::string::String>,
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TooManyRequestsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TooManyRequestsException");
        formatter.field("retry_after_seconds", &self.retry_after_seconds);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TooManyRequestsException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyRequestsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyRequestsException")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for TooManyRequestsException {}
/// See [`TooManyRequestsException`](crate::error::TooManyRequestsException)
pub mod too_many_requests_exception {
    /// A builder for [`TooManyRequestsException`](crate::error::TooManyRequestsException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) retry_after_seconds: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn retry_after_seconds(mut self, input: impl Into<std::string::String>) -> Self {
            self.retry_after_seconds = Some(input.into());
            self
        }
        pub fn set_retry_after_seconds(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.retry_after_seconds = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`TooManyRequestsException`](crate::error::TooManyRequestsException)
        pub fn build(self) -> crate::error::TooManyRequestsException {
            crate::error::TooManyRequestsException {
                retry_after_seconds: self.retry_after_seconds,
                message: self.message,
            }
        }
    }
}
impl TooManyRequestsException {
    /// Creates a new builder-style object to manufacture [`TooManyRequestsException`](crate::error::TooManyRequestsException)
    pub fn builder() -> crate::error::too_many_requests_exception::Builder {
        crate::error::too_many_requests_exception::Builder::default()
    }
}

/// <p>The requested resource is not found. Make sure that the request URI is correct.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NotFoundException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NotFoundException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl NotFoundException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NotFoundException")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for NotFoundException {}
/// See [`NotFoundException`](crate::error::NotFoundException)
pub mod not_found_exception {
    /// A builder for [`NotFoundException`](crate::error::NotFoundException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`NotFoundException`](crate::error::NotFoundException)
        pub fn build(self) -> crate::error::NotFoundException {
            crate::error::NotFoundException {
                message: self.message,
            }
        }
    }
}
impl NotFoundException {
    /// Creates a new builder-style object to manufacture [`NotFoundException`](crate::error::NotFoundException)
    pub fn builder() -> crate::error::not_found_exception::Builder {
        crate::error::not_found_exception::Builder::default()
    }
}

/// <p>The request exceeded the rate limit. Retry after the specified time period.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LimitExceededException {
    pub retry_after_seconds: std::option::Option<std::string::String>,
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LimitExceededException");
        formatter.field("retry_after_seconds", &self.retry_after_seconds);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl LimitExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for LimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "LimitExceededException")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for LimitExceededException {}
/// See [`LimitExceededException`](crate::error::LimitExceededException)
pub mod limit_exceeded_exception {
    /// A builder for [`LimitExceededException`](crate::error::LimitExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) retry_after_seconds: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn retry_after_seconds(mut self, input: impl Into<std::string::String>) -> Self {
            self.retry_after_seconds = Some(input.into());
            self
        }
        pub fn set_retry_after_seconds(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.retry_after_seconds = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`LimitExceededException`](crate::error::LimitExceededException)
        pub fn build(self) -> crate::error::LimitExceededException {
            crate::error::LimitExceededException {
                retry_after_seconds: self.retry_after_seconds,
                message: self.message,
            }
        }
    }
}
impl LimitExceededException {
    /// Creates a new builder-style object to manufacture [`LimitExceededException`](crate::error::LimitExceededException)
    pub fn builder() -> crate::error::limit_exceeded_exception::Builder {
        crate::error::limit_exceeded_exception::Builder::default()
    }
}

/// <p>The request configuration has conflicts. For details, see the accompanying error message.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ConflictException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ConflictException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ConflictException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ConflictException")?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for ConflictException {}
/// See [`ConflictException`](crate::error::ConflictException)
pub mod conflict_exception {
    /// A builder for [`ConflictException`](crate::error::ConflictException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ConflictException`](crate::error::ConflictException)
        pub fn build(self) -> crate::error::ConflictException {
            crate::error::ConflictException {
                message: self.message,
            }
        }
    }
}
impl ConflictException {
    /// Creates a new builder-style object to manufacture [`ConflictException`](crate::error::ConflictException)
    pub fn builder() -> crate::error::conflict_exception::Builder {
        crate::error::conflict_exception::Builder::default()
    }
}

/// <p>The submitted request is not valid, for example, the input is incomplete or incorrect. See the accompanying error message for details.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BadRequestException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for BadRequestException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BadRequestException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl BadRequestException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for BadRequestException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "BadRequestException")?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl std::error::Error for BadRequestException {}
/// See [`BadRequestException`](crate::error::BadRequestException)
pub mod bad_request_exception {
    /// A builder for [`BadRequestException`](crate::error::BadRequestException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`BadRequestException`](crate::error::BadRequestException)
        pub fn build(self) -> crate::error::BadRequestException {
            crate::error::BadRequestException {
                message: self.message,
            }
        }
    }
}
impl BadRequestException {
    /// Creates a new builder-style object to manufacture [`BadRequestException`](crate::error::BadRequestException)
    pub fn builder() -> crate::error::bad_request_exception::Builder {
        crate::error::bad_request_exception::Builder::default()
    }
}

/// <p>The requested service is not available. For details see the accompanying error message. Retry after the specified time period.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ServiceUnavailableException {
    pub retry_after_seconds: std::option::Option<std::string::String>,
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ServiceUnavailableException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ServiceUnavailableException");
        formatter.field("retry_after_seconds", &self.retry_after_seconds);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ServiceUnavailableException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ServiceUnavailableException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ServiceUnavailableException")?;
        if let Some(inner_7) = &self.message {
            write!(f, ": {}", inner_7)?;
        }
        Ok(())
    }
}
impl std::error::Error for ServiceUnavailableException {}
/// See [`ServiceUnavailableException`](crate::error::ServiceUnavailableException)
pub mod service_unavailable_exception {
    /// A builder for [`ServiceUnavailableException`](crate::error::ServiceUnavailableException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) retry_after_seconds: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn retry_after_seconds(mut self, input: impl Into<std::string::String>) -> Self {
            self.retry_after_seconds = Some(input.into());
            self
        }
        pub fn set_retry_after_seconds(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.retry_after_seconds = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ServiceUnavailableException`](crate::error::ServiceUnavailableException)
        pub fn build(self) -> crate::error::ServiceUnavailableException {
            crate::error::ServiceUnavailableException {
                retry_after_seconds: self.retry_after_seconds,
                message: self.message,
            }
        }
    }
}
impl ServiceUnavailableException {
    /// Creates a new builder-style object to manufacture [`ServiceUnavailableException`](crate::error::ServiceUnavailableException)
    pub fn builder() -> crate::error::service_unavailable_exception::Builder {
        crate::error::service_unavailable_exception::Builder::default()
    }
}
