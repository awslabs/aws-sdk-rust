// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateApiKeyError {
    pub kind: CreateApiKeyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateApiKeyErrorKind {
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    LimitExceededError(crate::error::LimitExceededError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateApiKeyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateApiKeyErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            CreateApiKeyErrorKind::ConflictError(_inner) => _inner.fmt(f),
            CreateApiKeyErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            CreateApiKeyErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            CreateApiKeyErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            CreateApiKeyErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            CreateApiKeyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateApiKeyError {
    fn code(&self) -> Option<&str> {
        CreateApiKeyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl CreateApiKeyError {
    pub fn new(kind: CreateApiKeyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateApiKeyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateApiKeyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for CreateApiKeyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateApiKeyErrorKind::BadRequestError(_inner) => Some(_inner),
            CreateApiKeyErrorKind::ConflictError(_inner) => Some(_inner),
            CreateApiKeyErrorKind::LimitExceededError(_inner) => Some(_inner),
            CreateApiKeyErrorKind::NotFoundError(_inner) => Some(_inner),
            CreateApiKeyErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            CreateApiKeyErrorKind::UnauthorizedError(_inner) => Some(_inner),
            CreateApiKeyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateAuthorizerError {
    pub kind: CreateAuthorizerErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateAuthorizerErrorKind {
    BadRequestError(crate::error::BadRequestError),
    LimitExceededError(crate::error::LimitExceededError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateAuthorizerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateAuthorizerErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            CreateAuthorizerErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            CreateAuthorizerErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            CreateAuthorizerErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            CreateAuthorizerErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            CreateAuthorizerErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateAuthorizerError {
    fn code(&self) -> Option<&str> {
        CreateAuthorizerError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl CreateAuthorizerError {
    pub fn new(kind: CreateAuthorizerErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateAuthorizerErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateAuthorizerErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for CreateAuthorizerError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateAuthorizerErrorKind::BadRequestError(_inner) => Some(_inner),
            CreateAuthorizerErrorKind::LimitExceededError(_inner) => Some(_inner),
            CreateAuthorizerErrorKind::NotFoundError(_inner) => Some(_inner),
            CreateAuthorizerErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            CreateAuthorizerErrorKind::UnauthorizedError(_inner) => Some(_inner),
            CreateAuthorizerErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateBasePathMappingError {
    pub kind: CreateBasePathMappingErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateBasePathMappingErrorKind {
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateBasePathMappingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateBasePathMappingErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            CreateBasePathMappingErrorKind::ConflictError(_inner) => _inner.fmt(f),
            CreateBasePathMappingErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            CreateBasePathMappingErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            CreateBasePathMappingErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            CreateBasePathMappingErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateBasePathMappingError {
    fn code(&self) -> Option<&str> {
        CreateBasePathMappingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl CreateBasePathMappingError {
    pub fn new(kind: CreateBasePathMappingErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateBasePathMappingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateBasePathMappingErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for CreateBasePathMappingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateBasePathMappingErrorKind::BadRequestError(_inner) => Some(_inner),
            CreateBasePathMappingErrorKind::ConflictError(_inner) => Some(_inner),
            CreateBasePathMappingErrorKind::NotFoundError(_inner) => Some(_inner),
            CreateBasePathMappingErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            CreateBasePathMappingErrorKind::UnauthorizedError(_inner) => Some(_inner),
            CreateBasePathMappingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateDeploymentError {
    pub kind: CreateDeploymentErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDeploymentErrorKind {
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    LimitExceededError(crate::error::LimitExceededError),
    NotFoundError(crate::error::NotFoundError),
    ServiceUnavailableError(crate::error::ServiceUnavailableError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateDeploymentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateDeploymentErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            CreateDeploymentErrorKind::ConflictError(_inner) => _inner.fmt(f),
            CreateDeploymentErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            CreateDeploymentErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            CreateDeploymentErrorKind::ServiceUnavailableError(_inner) => _inner.fmt(f),
            CreateDeploymentErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            CreateDeploymentErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            CreateDeploymentErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateDeploymentError {
    fn code(&self) -> Option<&str> {
        CreateDeploymentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl CreateDeploymentError {
    pub fn new(kind: CreateDeploymentErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateDeploymentErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateDeploymentErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for CreateDeploymentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateDeploymentErrorKind::BadRequestError(_inner) => Some(_inner),
            CreateDeploymentErrorKind::ConflictError(_inner) => Some(_inner),
            CreateDeploymentErrorKind::LimitExceededError(_inner) => Some(_inner),
            CreateDeploymentErrorKind::NotFoundError(_inner) => Some(_inner),
            CreateDeploymentErrorKind::ServiceUnavailableError(_inner) => Some(_inner),
            CreateDeploymentErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            CreateDeploymentErrorKind::UnauthorizedError(_inner) => Some(_inner),
            CreateDeploymentErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateDocumentationPartError {
    pub kind: CreateDocumentationPartErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDocumentationPartErrorKind {
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    LimitExceededError(crate::error::LimitExceededError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateDocumentationPartError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateDocumentationPartErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            CreateDocumentationPartErrorKind::ConflictError(_inner) => _inner.fmt(f),
            CreateDocumentationPartErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            CreateDocumentationPartErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            CreateDocumentationPartErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            CreateDocumentationPartErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            CreateDocumentationPartErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateDocumentationPartError {
    fn code(&self) -> Option<&str> {
        CreateDocumentationPartError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl CreateDocumentationPartError {
    pub fn new(kind: CreateDocumentationPartErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateDocumentationPartErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateDocumentationPartErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for CreateDocumentationPartError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateDocumentationPartErrorKind::BadRequestError(_inner) => Some(_inner),
            CreateDocumentationPartErrorKind::ConflictError(_inner) => Some(_inner),
            CreateDocumentationPartErrorKind::LimitExceededError(_inner) => Some(_inner),
            CreateDocumentationPartErrorKind::NotFoundError(_inner) => Some(_inner),
            CreateDocumentationPartErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            CreateDocumentationPartErrorKind::UnauthorizedError(_inner) => Some(_inner),
            CreateDocumentationPartErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateDocumentationVersionError {
    pub kind: CreateDocumentationVersionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDocumentationVersionErrorKind {
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    LimitExceededError(crate::error::LimitExceededError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateDocumentationVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateDocumentationVersionErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            CreateDocumentationVersionErrorKind::ConflictError(_inner) => _inner.fmt(f),
            CreateDocumentationVersionErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            CreateDocumentationVersionErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            CreateDocumentationVersionErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            CreateDocumentationVersionErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            CreateDocumentationVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateDocumentationVersionError {
    fn code(&self) -> Option<&str> {
        CreateDocumentationVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl CreateDocumentationVersionError {
    pub fn new(kind: CreateDocumentationVersionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateDocumentationVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateDocumentationVersionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for CreateDocumentationVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateDocumentationVersionErrorKind::BadRequestError(_inner) => Some(_inner),
            CreateDocumentationVersionErrorKind::ConflictError(_inner) => Some(_inner),
            CreateDocumentationVersionErrorKind::LimitExceededError(_inner) => Some(_inner),
            CreateDocumentationVersionErrorKind::NotFoundError(_inner) => Some(_inner),
            CreateDocumentationVersionErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            CreateDocumentationVersionErrorKind::UnauthorizedError(_inner) => Some(_inner),
            CreateDocumentationVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateDomainNameError {
    pub kind: CreateDomainNameErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDomainNameErrorKind {
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateDomainNameError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateDomainNameErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            CreateDomainNameErrorKind::ConflictError(_inner) => _inner.fmt(f),
            CreateDomainNameErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            CreateDomainNameErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            CreateDomainNameErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateDomainNameError {
    fn code(&self) -> Option<&str> {
        CreateDomainNameError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl CreateDomainNameError {
    pub fn new(kind: CreateDomainNameErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateDomainNameErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateDomainNameErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for CreateDomainNameError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateDomainNameErrorKind::BadRequestError(_inner) => Some(_inner),
            CreateDomainNameErrorKind::ConflictError(_inner) => Some(_inner),
            CreateDomainNameErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            CreateDomainNameErrorKind::UnauthorizedError(_inner) => Some(_inner),
            CreateDomainNameErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateModelError {
    pub kind: CreateModelErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateModelErrorKind {
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    LimitExceededError(crate::error::LimitExceededError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateModelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateModelErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            CreateModelErrorKind::ConflictError(_inner) => _inner.fmt(f),
            CreateModelErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            CreateModelErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            CreateModelErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            CreateModelErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            CreateModelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateModelError {
    fn code(&self) -> Option<&str> {
        CreateModelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl CreateModelError {
    pub fn new(kind: CreateModelErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateModelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateModelErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for CreateModelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateModelErrorKind::BadRequestError(_inner) => Some(_inner),
            CreateModelErrorKind::ConflictError(_inner) => Some(_inner),
            CreateModelErrorKind::LimitExceededError(_inner) => Some(_inner),
            CreateModelErrorKind::NotFoundError(_inner) => Some(_inner),
            CreateModelErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            CreateModelErrorKind::UnauthorizedError(_inner) => Some(_inner),
            CreateModelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateRequestValidatorError {
    pub kind: CreateRequestValidatorErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateRequestValidatorErrorKind {
    BadRequestError(crate::error::BadRequestError),
    LimitExceededError(crate::error::LimitExceededError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateRequestValidatorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateRequestValidatorErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            CreateRequestValidatorErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            CreateRequestValidatorErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            CreateRequestValidatorErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            CreateRequestValidatorErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            CreateRequestValidatorErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateRequestValidatorError {
    fn code(&self) -> Option<&str> {
        CreateRequestValidatorError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl CreateRequestValidatorError {
    pub fn new(kind: CreateRequestValidatorErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateRequestValidatorErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateRequestValidatorErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for CreateRequestValidatorError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateRequestValidatorErrorKind::BadRequestError(_inner) => Some(_inner),
            CreateRequestValidatorErrorKind::LimitExceededError(_inner) => Some(_inner),
            CreateRequestValidatorErrorKind::NotFoundError(_inner) => Some(_inner),
            CreateRequestValidatorErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            CreateRequestValidatorErrorKind::UnauthorizedError(_inner) => Some(_inner),
            CreateRequestValidatorErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateResourceError {
    pub kind: CreateResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateResourceErrorKind {
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    LimitExceededError(crate::error::LimitExceededError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateResourceErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            CreateResourceErrorKind::ConflictError(_inner) => _inner.fmt(f),
            CreateResourceErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            CreateResourceErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            CreateResourceErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            CreateResourceErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            CreateResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateResourceError {
    fn code(&self) -> Option<&str> {
        CreateResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl CreateResourceError {
    pub fn new(kind: CreateResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for CreateResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateResourceErrorKind::BadRequestError(_inner) => Some(_inner),
            CreateResourceErrorKind::ConflictError(_inner) => Some(_inner),
            CreateResourceErrorKind::LimitExceededError(_inner) => Some(_inner),
            CreateResourceErrorKind::NotFoundError(_inner) => Some(_inner),
            CreateResourceErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            CreateResourceErrorKind::UnauthorizedError(_inner) => Some(_inner),
            CreateResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateRestApiError {
    pub kind: CreateRestApiErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateRestApiErrorKind {
    BadRequestError(crate::error::BadRequestError),
    LimitExceededError(crate::error::LimitExceededError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateRestApiError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateRestApiErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            CreateRestApiErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            CreateRestApiErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            CreateRestApiErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            CreateRestApiErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateRestApiError {
    fn code(&self) -> Option<&str> {
        CreateRestApiError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl CreateRestApiError {
    pub fn new(kind: CreateRestApiErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateRestApiErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateRestApiErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for CreateRestApiError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateRestApiErrorKind::BadRequestError(_inner) => Some(_inner),
            CreateRestApiErrorKind::LimitExceededError(_inner) => Some(_inner),
            CreateRestApiErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            CreateRestApiErrorKind::UnauthorizedError(_inner) => Some(_inner),
            CreateRestApiErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateStageError {
    pub kind: CreateStageErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateStageErrorKind {
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    LimitExceededError(crate::error::LimitExceededError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateStageError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateStageErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            CreateStageErrorKind::ConflictError(_inner) => _inner.fmt(f),
            CreateStageErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            CreateStageErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            CreateStageErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            CreateStageErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            CreateStageErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateStageError {
    fn code(&self) -> Option<&str> {
        CreateStageError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl CreateStageError {
    pub fn new(kind: CreateStageErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateStageErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateStageErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for CreateStageError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateStageErrorKind::BadRequestError(_inner) => Some(_inner),
            CreateStageErrorKind::ConflictError(_inner) => Some(_inner),
            CreateStageErrorKind::LimitExceededError(_inner) => Some(_inner),
            CreateStageErrorKind::NotFoundError(_inner) => Some(_inner),
            CreateStageErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            CreateStageErrorKind::UnauthorizedError(_inner) => Some(_inner),
            CreateStageErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateUsagePlanError {
    pub kind: CreateUsagePlanErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateUsagePlanErrorKind {
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    LimitExceededError(crate::error::LimitExceededError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateUsagePlanError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateUsagePlanErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            CreateUsagePlanErrorKind::ConflictError(_inner) => _inner.fmt(f),
            CreateUsagePlanErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            CreateUsagePlanErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            CreateUsagePlanErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            CreateUsagePlanErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            CreateUsagePlanErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateUsagePlanError {
    fn code(&self) -> Option<&str> {
        CreateUsagePlanError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl CreateUsagePlanError {
    pub fn new(kind: CreateUsagePlanErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateUsagePlanErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateUsagePlanErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for CreateUsagePlanError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateUsagePlanErrorKind::BadRequestError(_inner) => Some(_inner),
            CreateUsagePlanErrorKind::ConflictError(_inner) => Some(_inner),
            CreateUsagePlanErrorKind::LimitExceededError(_inner) => Some(_inner),
            CreateUsagePlanErrorKind::NotFoundError(_inner) => Some(_inner),
            CreateUsagePlanErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            CreateUsagePlanErrorKind::UnauthorizedError(_inner) => Some(_inner),
            CreateUsagePlanErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateUsagePlanKeyError {
    pub kind: CreateUsagePlanKeyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateUsagePlanKeyErrorKind {
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateUsagePlanKeyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateUsagePlanKeyErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            CreateUsagePlanKeyErrorKind::ConflictError(_inner) => _inner.fmt(f),
            CreateUsagePlanKeyErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            CreateUsagePlanKeyErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            CreateUsagePlanKeyErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            CreateUsagePlanKeyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateUsagePlanKeyError {
    fn code(&self) -> Option<&str> {
        CreateUsagePlanKeyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl CreateUsagePlanKeyError {
    pub fn new(kind: CreateUsagePlanKeyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateUsagePlanKeyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateUsagePlanKeyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for CreateUsagePlanKeyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateUsagePlanKeyErrorKind::BadRequestError(_inner) => Some(_inner),
            CreateUsagePlanKeyErrorKind::ConflictError(_inner) => Some(_inner),
            CreateUsagePlanKeyErrorKind::NotFoundError(_inner) => Some(_inner),
            CreateUsagePlanKeyErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            CreateUsagePlanKeyErrorKind::UnauthorizedError(_inner) => Some(_inner),
            CreateUsagePlanKeyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateVpcLinkError {
    pub kind: CreateVpcLinkErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateVpcLinkErrorKind {
    BadRequestError(crate::error::BadRequestError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateVpcLinkError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateVpcLinkErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            CreateVpcLinkErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            CreateVpcLinkErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            CreateVpcLinkErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateVpcLinkError {
    fn code(&self) -> Option<&str> {
        CreateVpcLinkError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl CreateVpcLinkError {
    pub fn new(kind: CreateVpcLinkErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateVpcLinkErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateVpcLinkErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for CreateVpcLinkError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateVpcLinkErrorKind::BadRequestError(_inner) => Some(_inner),
            CreateVpcLinkErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            CreateVpcLinkErrorKind::UnauthorizedError(_inner) => Some(_inner),
            CreateVpcLinkErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteApiKeyError {
    pub kind: DeleteApiKeyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteApiKeyErrorKind {
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteApiKeyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteApiKeyErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            DeleteApiKeyErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            DeleteApiKeyErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            DeleteApiKeyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteApiKeyError {
    fn code(&self) -> Option<&str> {
        DeleteApiKeyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl DeleteApiKeyError {
    pub fn new(kind: DeleteApiKeyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteApiKeyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteApiKeyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for DeleteApiKeyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteApiKeyErrorKind::NotFoundError(_inner) => Some(_inner),
            DeleteApiKeyErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            DeleteApiKeyErrorKind::UnauthorizedError(_inner) => Some(_inner),
            DeleteApiKeyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteAuthorizerError {
    pub kind: DeleteAuthorizerErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteAuthorizerErrorKind {
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteAuthorizerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteAuthorizerErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            DeleteAuthorizerErrorKind::ConflictError(_inner) => _inner.fmt(f),
            DeleteAuthorizerErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            DeleteAuthorizerErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            DeleteAuthorizerErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            DeleteAuthorizerErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteAuthorizerError {
    fn code(&self) -> Option<&str> {
        DeleteAuthorizerError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl DeleteAuthorizerError {
    pub fn new(kind: DeleteAuthorizerErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteAuthorizerErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteAuthorizerErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for DeleteAuthorizerError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteAuthorizerErrorKind::BadRequestError(_inner) => Some(_inner),
            DeleteAuthorizerErrorKind::ConflictError(_inner) => Some(_inner),
            DeleteAuthorizerErrorKind::NotFoundError(_inner) => Some(_inner),
            DeleteAuthorizerErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            DeleteAuthorizerErrorKind::UnauthorizedError(_inner) => Some(_inner),
            DeleteAuthorizerErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteBasePathMappingError {
    pub kind: DeleteBasePathMappingErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteBasePathMappingErrorKind {
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteBasePathMappingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteBasePathMappingErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            DeleteBasePathMappingErrorKind::ConflictError(_inner) => _inner.fmt(f),
            DeleteBasePathMappingErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            DeleteBasePathMappingErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            DeleteBasePathMappingErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            DeleteBasePathMappingErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteBasePathMappingError {
    fn code(&self) -> Option<&str> {
        DeleteBasePathMappingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl DeleteBasePathMappingError {
    pub fn new(kind: DeleteBasePathMappingErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteBasePathMappingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteBasePathMappingErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for DeleteBasePathMappingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteBasePathMappingErrorKind::BadRequestError(_inner) => Some(_inner),
            DeleteBasePathMappingErrorKind::ConflictError(_inner) => Some(_inner),
            DeleteBasePathMappingErrorKind::NotFoundError(_inner) => Some(_inner),
            DeleteBasePathMappingErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            DeleteBasePathMappingErrorKind::UnauthorizedError(_inner) => Some(_inner),
            DeleteBasePathMappingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteClientCertificateError {
    pub kind: DeleteClientCertificateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteClientCertificateErrorKind {
    BadRequestError(crate::error::BadRequestError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteClientCertificateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteClientCertificateErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            DeleteClientCertificateErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            DeleteClientCertificateErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            DeleteClientCertificateErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            DeleteClientCertificateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteClientCertificateError {
    fn code(&self) -> Option<&str> {
        DeleteClientCertificateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl DeleteClientCertificateError {
    pub fn new(kind: DeleteClientCertificateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteClientCertificateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteClientCertificateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for DeleteClientCertificateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteClientCertificateErrorKind::BadRequestError(_inner) => Some(_inner),
            DeleteClientCertificateErrorKind::NotFoundError(_inner) => Some(_inner),
            DeleteClientCertificateErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            DeleteClientCertificateErrorKind::UnauthorizedError(_inner) => Some(_inner),
            DeleteClientCertificateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteDeploymentError {
    pub kind: DeleteDeploymentErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDeploymentErrorKind {
    BadRequestError(crate::error::BadRequestError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteDeploymentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteDeploymentErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            DeleteDeploymentErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            DeleteDeploymentErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            DeleteDeploymentErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            DeleteDeploymentErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteDeploymentError {
    fn code(&self) -> Option<&str> {
        DeleteDeploymentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl DeleteDeploymentError {
    pub fn new(kind: DeleteDeploymentErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteDeploymentErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteDeploymentErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for DeleteDeploymentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteDeploymentErrorKind::BadRequestError(_inner) => Some(_inner),
            DeleteDeploymentErrorKind::NotFoundError(_inner) => Some(_inner),
            DeleteDeploymentErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            DeleteDeploymentErrorKind::UnauthorizedError(_inner) => Some(_inner),
            DeleteDeploymentErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteDocumentationPartError {
    pub kind: DeleteDocumentationPartErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDocumentationPartErrorKind {
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteDocumentationPartError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteDocumentationPartErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            DeleteDocumentationPartErrorKind::ConflictError(_inner) => _inner.fmt(f),
            DeleteDocumentationPartErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            DeleteDocumentationPartErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            DeleteDocumentationPartErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            DeleteDocumentationPartErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteDocumentationPartError {
    fn code(&self) -> Option<&str> {
        DeleteDocumentationPartError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl DeleteDocumentationPartError {
    pub fn new(kind: DeleteDocumentationPartErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteDocumentationPartErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteDocumentationPartErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for DeleteDocumentationPartError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteDocumentationPartErrorKind::BadRequestError(_inner) => Some(_inner),
            DeleteDocumentationPartErrorKind::ConflictError(_inner) => Some(_inner),
            DeleteDocumentationPartErrorKind::NotFoundError(_inner) => Some(_inner),
            DeleteDocumentationPartErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            DeleteDocumentationPartErrorKind::UnauthorizedError(_inner) => Some(_inner),
            DeleteDocumentationPartErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteDocumentationVersionError {
    pub kind: DeleteDocumentationVersionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDocumentationVersionErrorKind {
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteDocumentationVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteDocumentationVersionErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            DeleteDocumentationVersionErrorKind::ConflictError(_inner) => _inner.fmt(f),
            DeleteDocumentationVersionErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            DeleteDocumentationVersionErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            DeleteDocumentationVersionErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            DeleteDocumentationVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteDocumentationVersionError {
    fn code(&self) -> Option<&str> {
        DeleteDocumentationVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl DeleteDocumentationVersionError {
    pub fn new(kind: DeleteDocumentationVersionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteDocumentationVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteDocumentationVersionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for DeleteDocumentationVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteDocumentationVersionErrorKind::BadRequestError(_inner) => Some(_inner),
            DeleteDocumentationVersionErrorKind::ConflictError(_inner) => Some(_inner),
            DeleteDocumentationVersionErrorKind::NotFoundError(_inner) => Some(_inner),
            DeleteDocumentationVersionErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            DeleteDocumentationVersionErrorKind::UnauthorizedError(_inner) => Some(_inner),
            DeleteDocumentationVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteDomainNameError {
    pub kind: DeleteDomainNameErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDomainNameErrorKind {
    BadRequestError(crate::error::BadRequestError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteDomainNameError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteDomainNameErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            DeleteDomainNameErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            DeleteDomainNameErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            DeleteDomainNameErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            DeleteDomainNameErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteDomainNameError {
    fn code(&self) -> Option<&str> {
        DeleteDomainNameError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl DeleteDomainNameError {
    pub fn new(kind: DeleteDomainNameErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteDomainNameErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteDomainNameErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for DeleteDomainNameError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteDomainNameErrorKind::BadRequestError(_inner) => Some(_inner),
            DeleteDomainNameErrorKind::NotFoundError(_inner) => Some(_inner),
            DeleteDomainNameErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            DeleteDomainNameErrorKind::UnauthorizedError(_inner) => Some(_inner),
            DeleteDomainNameErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteGatewayResponseError {
    pub kind: DeleteGatewayResponseErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteGatewayResponseErrorKind {
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteGatewayResponseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteGatewayResponseErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            DeleteGatewayResponseErrorKind::ConflictError(_inner) => _inner.fmt(f),
            DeleteGatewayResponseErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            DeleteGatewayResponseErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            DeleteGatewayResponseErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            DeleteGatewayResponseErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteGatewayResponseError {
    fn code(&self) -> Option<&str> {
        DeleteGatewayResponseError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl DeleteGatewayResponseError {
    pub fn new(kind: DeleteGatewayResponseErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteGatewayResponseErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteGatewayResponseErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for DeleteGatewayResponseError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteGatewayResponseErrorKind::BadRequestError(_inner) => Some(_inner),
            DeleteGatewayResponseErrorKind::ConflictError(_inner) => Some(_inner),
            DeleteGatewayResponseErrorKind::NotFoundError(_inner) => Some(_inner),
            DeleteGatewayResponseErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            DeleteGatewayResponseErrorKind::UnauthorizedError(_inner) => Some(_inner),
            DeleteGatewayResponseErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteIntegrationError {
    pub kind: DeleteIntegrationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteIntegrationErrorKind {
    ConflictError(crate::error::ConflictError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteIntegrationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteIntegrationErrorKind::ConflictError(_inner) => _inner.fmt(f),
            DeleteIntegrationErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            DeleteIntegrationErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            DeleteIntegrationErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            DeleteIntegrationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteIntegrationError {
    fn code(&self) -> Option<&str> {
        DeleteIntegrationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl DeleteIntegrationError {
    pub fn new(kind: DeleteIntegrationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteIntegrationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteIntegrationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for DeleteIntegrationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteIntegrationErrorKind::ConflictError(_inner) => Some(_inner),
            DeleteIntegrationErrorKind::NotFoundError(_inner) => Some(_inner),
            DeleteIntegrationErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            DeleteIntegrationErrorKind::UnauthorizedError(_inner) => Some(_inner),
            DeleteIntegrationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteIntegrationResponseError {
    pub kind: DeleteIntegrationResponseErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteIntegrationResponseErrorKind {
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteIntegrationResponseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteIntegrationResponseErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            DeleteIntegrationResponseErrorKind::ConflictError(_inner) => _inner.fmt(f),
            DeleteIntegrationResponseErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            DeleteIntegrationResponseErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            DeleteIntegrationResponseErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            DeleteIntegrationResponseErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteIntegrationResponseError {
    fn code(&self) -> Option<&str> {
        DeleteIntegrationResponseError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl DeleteIntegrationResponseError {
    pub fn new(kind: DeleteIntegrationResponseErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteIntegrationResponseErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteIntegrationResponseErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for DeleteIntegrationResponseError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteIntegrationResponseErrorKind::BadRequestError(_inner) => Some(_inner),
            DeleteIntegrationResponseErrorKind::ConflictError(_inner) => Some(_inner),
            DeleteIntegrationResponseErrorKind::NotFoundError(_inner) => Some(_inner),
            DeleteIntegrationResponseErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            DeleteIntegrationResponseErrorKind::UnauthorizedError(_inner) => Some(_inner),
            DeleteIntegrationResponseErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteMethodError {
    pub kind: DeleteMethodErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteMethodErrorKind {
    ConflictError(crate::error::ConflictError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteMethodError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteMethodErrorKind::ConflictError(_inner) => _inner.fmt(f),
            DeleteMethodErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            DeleteMethodErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            DeleteMethodErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            DeleteMethodErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteMethodError {
    fn code(&self) -> Option<&str> {
        DeleteMethodError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl DeleteMethodError {
    pub fn new(kind: DeleteMethodErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteMethodErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteMethodErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for DeleteMethodError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteMethodErrorKind::ConflictError(_inner) => Some(_inner),
            DeleteMethodErrorKind::NotFoundError(_inner) => Some(_inner),
            DeleteMethodErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            DeleteMethodErrorKind::UnauthorizedError(_inner) => Some(_inner),
            DeleteMethodErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteMethodResponseError {
    pub kind: DeleteMethodResponseErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteMethodResponseErrorKind {
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteMethodResponseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteMethodResponseErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            DeleteMethodResponseErrorKind::ConflictError(_inner) => _inner.fmt(f),
            DeleteMethodResponseErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            DeleteMethodResponseErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            DeleteMethodResponseErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            DeleteMethodResponseErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteMethodResponseError {
    fn code(&self) -> Option<&str> {
        DeleteMethodResponseError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl DeleteMethodResponseError {
    pub fn new(kind: DeleteMethodResponseErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteMethodResponseErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteMethodResponseErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for DeleteMethodResponseError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteMethodResponseErrorKind::BadRequestError(_inner) => Some(_inner),
            DeleteMethodResponseErrorKind::ConflictError(_inner) => Some(_inner),
            DeleteMethodResponseErrorKind::NotFoundError(_inner) => Some(_inner),
            DeleteMethodResponseErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            DeleteMethodResponseErrorKind::UnauthorizedError(_inner) => Some(_inner),
            DeleteMethodResponseErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteModelError {
    pub kind: DeleteModelErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteModelErrorKind {
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteModelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteModelErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            DeleteModelErrorKind::ConflictError(_inner) => _inner.fmt(f),
            DeleteModelErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            DeleteModelErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            DeleteModelErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            DeleteModelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteModelError {
    fn code(&self) -> Option<&str> {
        DeleteModelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl DeleteModelError {
    pub fn new(kind: DeleteModelErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteModelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteModelErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for DeleteModelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteModelErrorKind::BadRequestError(_inner) => Some(_inner),
            DeleteModelErrorKind::ConflictError(_inner) => Some(_inner),
            DeleteModelErrorKind::NotFoundError(_inner) => Some(_inner),
            DeleteModelErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            DeleteModelErrorKind::UnauthorizedError(_inner) => Some(_inner),
            DeleteModelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteRequestValidatorError {
    pub kind: DeleteRequestValidatorErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteRequestValidatorErrorKind {
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteRequestValidatorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteRequestValidatorErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            DeleteRequestValidatorErrorKind::ConflictError(_inner) => _inner.fmt(f),
            DeleteRequestValidatorErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            DeleteRequestValidatorErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            DeleteRequestValidatorErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            DeleteRequestValidatorErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteRequestValidatorError {
    fn code(&self) -> Option<&str> {
        DeleteRequestValidatorError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl DeleteRequestValidatorError {
    pub fn new(kind: DeleteRequestValidatorErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteRequestValidatorErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteRequestValidatorErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for DeleteRequestValidatorError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteRequestValidatorErrorKind::BadRequestError(_inner) => Some(_inner),
            DeleteRequestValidatorErrorKind::ConflictError(_inner) => Some(_inner),
            DeleteRequestValidatorErrorKind::NotFoundError(_inner) => Some(_inner),
            DeleteRequestValidatorErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            DeleteRequestValidatorErrorKind::UnauthorizedError(_inner) => Some(_inner),
            DeleteRequestValidatorErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteResourceError {
    pub kind: DeleteResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteResourceErrorKind {
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteResourceErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            DeleteResourceErrorKind::ConflictError(_inner) => _inner.fmt(f),
            DeleteResourceErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            DeleteResourceErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            DeleteResourceErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            DeleteResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteResourceError {
    fn code(&self) -> Option<&str> {
        DeleteResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl DeleteResourceError {
    pub fn new(kind: DeleteResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for DeleteResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteResourceErrorKind::BadRequestError(_inner) => Some(_inner),
            DeleteResourceErrorKind::ConflictError(_inner) => Some(_inner),
            DeleteResourceErrorKind::NotFoundError(_inner) => Some(_inner),
            DeleteResourceErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            DeleteResourceErrorKind::UnauthorizedError(_inner) => Some(_inner),
            DeleteResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteRestApiError {
    pub kind: DeleteRestApiErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteRestApiErrorKind {
    BadRequestError(crate::error::BadRequestError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteRestApiError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteRestApiErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            DeleteRestApiErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            DeleteRestApiErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            DeleteRestApiErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            DeleteRestApiErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteRestApiError {
    fn code(&self) -> Option<&str> {
        DeleteRestApiError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl DeleteRestApiError {
    pub fn new(kind: DeleteRestApiErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteRestApiErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteRestApiErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for DeleteRestApiError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteRestApiErrorKind::BadRequestError(_inner) => Some(_inner),
            DeleteRestApiErrorKind::NotFoundError(_inner) => Some(_inner),
            DeleteRestApiErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            DeleteRestApiErrorKind::UnauthorizedError(_inner) => Some(_inner),
            DeleteRestApiErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteStageError {
    pub kind: DeleteStageErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteStageErrorKind {
    BadRequestError(crate::error::BadRequestError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteStageError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteStageErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            DeleteStageErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            DeleteStageErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            DeleteStageErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            DeleteStageErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteStageError {
    fn code(&self) -> Option<&str> {
        DeleteStageError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl DeleteStageError {
    pub fn new(kind: DeleteStageErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteStageErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteStageErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for DeleteStageError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteStageErrorKind::BadRequestError(_inner) => Some(_inner),
            DeleteStageErrorKind::NotFoundError(_inner) => Some(_inner),
            DeleteStageErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            DeleteStageErrorKind::UnauthorizedError(_inner) => Some(_inner),
            DeleteStageErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteUsagePlanError {
    pub kind: DeleteUsagePlanErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteUsagePlanErrorKind {
    BadRequestError(crate::error::BadRequestError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteUsagePlanError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteUsagePlanErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            DeleteUsagePlanErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            DeleteUsagePlanErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            DeleteUsagePlanErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            DeleteUsagePlanErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteUsagePlanError {
    fn code(&self) -> Option<&str> {
        DeleteUsagePlanError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl DeleteUsagePlanError {
    pub fn new(kind: DeleteUsagePlanErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteUsagePlanErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteUsagePlanErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for DeleteUsagePlanError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteUsagePlanErrorKind::BadRequestError(_inner) => Some(_inner),
            DeleteUsagePlanErrorKind::NotFoundError(_inner) => Some(_inner),
            DeleteUsagePlanErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            DeleteUsagePlanErrorKind::UnauthorizedError(_inner) => Some(_inner),
            DeleteUsagePlanErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteUsagePlanKeyError {
    pub kind: DeleteUsagePlanKeyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteUsagePlanKeyErrorKind {
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteUsagePlanKeyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteUsagePlanKeyErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            DeleteUsagePlanKeyErrorKind::ConflictError(_inner) => _inner.fmt(f),
            DeleteUsagePlanKeyErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            DeleteUsagePlanKeyErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            DeleteUsagePlanKeyErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            DeleteUsagePlanKeyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteUsagePlanKeyError {
    fn code(&self) -> Option<&str> {
        DeleteUsagePlanKeyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl DeleteUsagePlanKeyError {
    pub fn new(kind: DeleteUsagePlanKeyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteUsagePlanKeyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteUsagePlanKeyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for DeleteUsagePlanKeyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteUsagePlanKeyErrorKind::BadRequestError(_inner) => Some(_inner),
            DeleteUsagePlanKeyErrorKind::ConflictError(_inner) => Some(_inner),
            DeleteUsagePlanKeyErrorKind::NotFoundError(_inner) => Some(_inner),
            DeleteUsagePlanKeyErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            DeleteUsagePlanKeyErrorKind::UnauthorizedError(_inner) => Some(_inner),
            DeleteUsagePlanKeyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteVpcLinkError {
    pub kind: DeleteVpcLinkErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteVpcLinkErrorKind {
    BadRequestError(crate::error::BadRequestError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteVpcLinkError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteVpcLinkErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            DeleteVpcLinkErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            DeleteVpcLinkErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            DeleteVpcLinkErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            DeleteVpcLinkErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteVpcLinkError {
    fn code(&self) -> Option<&str> {
        DeleteVpcLinkError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl DeleteVpcLinkError {
    pub fn new(kind: DeleteVpcLinkErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteVpcLinkErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteVpcLinkErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for DeleteVpcLinkError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteVpcLinkErrorKind::BadRequestError(_inner) => Some(_inner),
            DeleteVpcLinkErrorKind::NotFoundError(_inner) => Some(_inner),
            DeleteVpcLinkErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            DeleteVpcLinkErrorKind::UnauthorizedError(_inner) => Some(_inner),
            DeleteVpcLinkErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct FlushStageAuthorizersCacheError {
    pub kind: FlushStageAuthorizersCacheErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum FlushStageAuthorizersCacheErrorKind {
    BadRequestError(crate::error::BadRequestError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for FlushStageAuthorizersCacheError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            FlushStageAuthorizersCacheErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            FlushStageAuthorizersCacheErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            FlushStageAuthorizersCacheErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            FlushStageAuthorizersCacheErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            FlushStageAuthorizersCacheErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for FlushStageAuthorizersCacheError {
    fn code(&self) -> Option<&str> {
        FlushStageAuthorizersCacheError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl FlushStageAuthorizersCacheError {
    pub fn new(kind: FlushStageAuthorizersCacheErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: FlushStageAuthorizersCacheErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: FlushStageAuthorizersCacheErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for FlushStageAuthorizersCacheError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            FlushStageAuthorizersCacheErrorKind::BadRequestError(_inner) => Some(_inner),
            FlushStageAuthorizersCacheErrorKind::NotFoundError(_inner) => Some(_inner),
            FlushStageAuthorizersCacheErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            FlushStageAuthorizersCacheErrorKind::UnauthorizedError(_inner) => Some(_inner),
            FlushStageAuthorizersCacheErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct FlushStageCacheError {
    pub kind: FlushStageCacheErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum FlushStageCacheErrorKind {
    BadRequestError(crate::error::BadRequestError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for FlushStageCacheError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            FlushStageCacheErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            FlushStageCacheErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            FlushStageCacheErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            FlushStageCacheErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            FlushStageCacheErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for FlushStageCacheError {
    fn code(&self) -> Option<&str> {
        FlushStageCacheError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl FlushStageCacheError {
    pub fn new(kind: FlushStageCacheErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: FlushStageCacheErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: FlushStageCacheErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for FlushStageCacheError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            FlushStageCacheErrorKind::BadRequestError(_inner) => Some(_inner),
            FlushStageCacheErrorKind::NotFoundError(_inner) => Some(_inner),
            FlushStageCacheErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            FlushStageCacheErrorKind::UnauthorizedError(_inner) => Some(_inner),
            FlushStageCacheErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GenerateClientCertificateError {
    pub kind: GenerateClientCertificateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GenerateClientCertificateErrorKind {
    LimitExceededError(crate::error::LimitExceededError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GenerateClientCertificateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GenerateClientCertificateErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            GenerateClientCertificateErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            GenerateClientCertificateErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            GenerateClientCertificateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GenerateClientCertificateError {
    fn code(&self) -> Option<&str> {
        GenerateClientCertificateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl GenerateClientCertificateError {
    pub fn new(kind: GenerateClientCertificateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GenerateClientCertificateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GenerateClientCertificateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for GenerateClientCertificateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GenerateClientCertificateErrorKind::LimitExceededError(_inner) => Some(_inner),
            GenerateClientCertificateErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            GenerateClientCertificateErrorKind::UnauthorizedError(_inner) => Some(_inner),
            GenerateClientCertificateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetAccountError {
    pub kind: GetAccountErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetAccountErrorKind {
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetAccountError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetAccountErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            GetAccountErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            GetAccountErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            GetAccountErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetAccountError {
    fn code(&self) -> Option<&str> {
        GetAccountError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl GetAccountError {
    pub fn new(kind: GetAccountErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetAccountErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetAccountErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for GetAccountError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetAccountErrorKind::NotFoundError(_inner) => Some(_inner),
            GetAccountErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            GetAccountErrorKind::UnauthorizedError(_inner) => Some(_inner),
            GetAccountErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetApiKeyError {
    pub kind: GetApiKeyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetApiKeyErrorKind {
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetApiKeyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetApiKeyErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            GetApiKeyErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            GetApiKeyErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            GetApiKeyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetApiKeyError {
    fn code(&self) -> Option<&str> {
        GetApiKeyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl GetApiKeyError {
    pub fn new(kind: GetApiKeyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetApiKeyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetApiKeyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for GetApiKeyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetApiKeyErrorKind::NotFoundError(_inner) => Some(_inner),
            GetApiKeyErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            GetApiKeyErrorKind::UnauthorizedError(_inner) => Some(_inner),
            GetApiKeyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetApiKeysError {
    pub kind: GetApiKeysErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetApiKeysErrorKind {
    BadRequestError(crate::error::BadRequestError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetApiKeysError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetApiKeysErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            GetApiKeysErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            GetApiKeysErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            GetApiKeysErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetApiKeysError {
    fn code(&self) -> Option<&str> {
        GetApiKeysError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl GetApiKeysError {
    pub fn new(kind: GetApiKeysErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetApiKeysErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetApiKeysErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for GetApiKeysError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetApiKeysErrorKind::BadRequestError(_inner) => Some(_inner),
            GetApiKeysErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            GetApiKeysErrorKind::UnauthorizedError(_inner) => Some(_inner),
            GetApiKeysErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetAuthorizerError {
    pub kind: GetAuthorizerErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetAuthorizerErrorKind {
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetAuthorizerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetAuthorizerErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            GetAuthorizerErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            GetAuthorizerErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            GetAuthorizerErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetAuthorizerError {
    fn code(&self) -> Option<&str> {
        GetAuthorizerError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl GetAuthorizerError {
    pub fn new(kind: GetAuthorizerErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetAuthorizerErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetAuthorizerErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for GetAuthorizerError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetAuthorizerErrorKind::NotFoundError(_inner) => Some(_inner),
            GetAuthorizerErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            GetAuthorizerErrorKind::UnauthorizedError(_inner) => Some(_inner),
            GetAuthorizerErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetAuthorizersError {
    pub kind: GetAuthorizersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetAuthorizersErrorKind {
    BadRequestError(crate::error::BadRequestError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetAuthorizersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetAuthorizersErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            GetAuthorizersErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            GetAuthorizersErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            GetAuthorizersErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            GetAuthorizersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetAuthorizersError {
    fn code(&self) -> Option<&str> {
        GetAuthorizersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl GetAuthorizersError {
    pub fn new(kind: GetAuthorizersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetAuthorizersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetAuthorizersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for GetAuthorizersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetAuthorizersErrorKind::BadRequestError(_inner) => Some(_inner),
            GetAuthorizersErrorKind::NotFoundError(_inner) => Some(_inner),
            GetAuthorizersErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            GetAuthorizersErrorKind::UnauthorizedError(_inner) => Some(_inner),
            GetAuthorizersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetBasePathMappingError {
    pub kind: GetBasePathMappingErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetBasePathMappingErrorKind {
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetBasePathMappingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetBasePathMappingErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            GetBasePathMappingErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            GetBasePathMappingErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            GetBasePathMappingErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetBasePathMappingError {
    fn code(&self) -> Option<&str> {
        GetBasePathMappingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl GetBasePathMappingError {
    pub fn new(kind: GetBasePathMappingErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetBasePathMappingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetBasePathMappingErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for GetBasePathMappingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetBasePathMappingErrorKind::NotFoundError(_inner) => Some(_inner),
            GetBasePathMappingErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            GetBasePathMappingErrorKind::UnauthorizedError(_inner) => Some(_inner),
            GetBasePathMappingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetBasePathMappingsError {
    pub kind: GetBasePathMappingsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetBasePathMappingsErrorKind {
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetBasePathMappingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetBasePathMappingsErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            GetBasePathMappingsErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            GetBasePathMappingsErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            GetBasePathMappingsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetBasePathMappingsError {
    fn code(&self) -> Option<&str> {
        GetBasePathMappingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl GetBasePathMappingsError {
    pub fn new(kind: GetBasePathMappingsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetBasePathMappingsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetBasePathMappingsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for GetBasePathMappingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetBasePathMappingsErrorKind::NotFoundError(_inner) => Some(_inner),
            GetBasePathMappingsErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            GetBasePathMappingsErrorKind::UnauthorizedError(_inner) => Some(_inner),
            GetBasePathMappingsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetClientCertificateError {
    pub kind: GetClientCertificateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetClientCertificateErrorKind {
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetClientCertificateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetClientCertificateErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            GetClientCertificateErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            GetClientCertificateErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            GetClientCertificateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetClientCertificateError {
    fn code(&self) -> Option<&str> {
        GetClientCertificateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl GetClientCertificateError {
    pub fn new(kind: GetClientCertificateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetClientCertificateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetClientCertificateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for GetClientCertificateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetClientCertificateErrorKind::NotFoundError(_inner) => Some(_inner),
            GetClientCertificateErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            GetClientCertificateErrorKind::UnauthorizedError(_inner) => Some(_inner),
            GetClientCertificateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetClientCertificatesError {
    pub kind: GetClientCertificatesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetClientCertificatesErrorKind {
    BadRequestError(crate::error::BadRequestError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetClientCertificatesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetClientCertificatesErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            GetClientCertificatesErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            GetClientCertificatesErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            GetClientCertificatesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetClientCertificatesError {
    fn code(&self) -> Option<&str> {
        GetClientCertificatesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl GetClientCertificatesError {
    pub fn new(kind: GetClientCertificatesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetClientCertificatesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetClientCertificatesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for GetClientCertificatesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetClientCertificatesErrorKind::BadRequestError(_inner) => Some(_inner),
            GetClientCertificatesErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            GetClientCertificatesErrorKind::UnauthorizedError(_inner) => Some(_inner),
            GetClientCertificatesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetDeploymentError {
    pub kind: GetDeploymentErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetDeploymentErrorKind {
    NotFoundError(crate::error::NotFoundError),
    ServiceUnavailableError(crate::error::ServiceUnavailableError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetDeploymentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetDeploymentErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            GetDeploymentErrorKind::ServiceUnavailableError(_inner) => _inner.fmt(f),
            GetDeploymentErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            GetDeploymentErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            GetDeploymentErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetDeploymentError {
    fn code(&self) -> Option<&str> {
        GetDeploymentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl GetDeploymentError {
    pub fn new(kind: GetDeploymentErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetDeploymentErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetDeploymentErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for GetDeploymentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetDeploymentErrorKind::NotFoundError(_inner) => Some(_inner),
            GetDeploymentErrorKind::ServiceUnavailableError(_inner) => Some(_inner),
            GetDeploymentErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            GetDeploymentErrorKind::UnauthorizedError(_inner) => Some(_inner),
            GetDeploymentErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetDeploymentsError {
    pub kind: GetDeploymentsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetDeploymentsErrorKind {
    BadRequestError(crate::error::BadRequestError),
    NotFoundError(crate::error::NotFoundError),
    ServiceUnavailableError(crate::error::ServiceUnavailableError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetDeploymentsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetDeploymentsErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            GetDeploymentsErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            GetDeploymentsErrorKind::ServiceUnavailableError(_inner) => _inner.fmt(f),
            GetDeploymentsErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            GetDeploymentsErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            GetDeploymentsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetDeploymentsError {
    fn code(&self) -> Option<&str> {
        GetDeploymentsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl GetDeploymentsError {
    pub fn new(kind: GetDeploymentsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetDeploymentsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetDeploymentsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for GetDeploymentsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetDeploymentsErrorKind::BadRequestError(_inner) => Some(_inner),
            GetDeploymentsErrorKind::NotFoundError(_inner) => Some(_inner),
            GetDeploymentsErrorKind::ServiceUnavailableError(_inner) => Some(_inner),
            GetDeploymentsErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            GetDeploymentsErrorKind::UnauthorizedError(_inner) => Some(_inner),
            GetDeploymentsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetDocumentationPartError {
    pub kind: GetDocumentationPartErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetDocumentationPartErrorKind {
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetDocumentationPartError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetDocumentationPartErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            GetDocumentationPartErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            GetDocumentationPartErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            GetDocumentationPartErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetDocumentationPartError {
    fn code(&self) -> Option<&str> {
        GetDocumentationPartError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl GetDocumentationPartError {
    pub fn new(kind: GetDocumentationPartErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetDocumentationPartErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetDocumentationPartErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for GetDocumentationPartError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetDocumentationPartErrorKind::NotFoundError(_inner) => Some(_inner),
            GetDocumentationPartErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            GetDocumentationPartErrorKind::UnauthorizedError(_inner) => Some(_inner),
            GetDocumentationPartErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetDocumentationPartsError {
    pub kind: GetDocumentationPartsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetDocumentationPartsErrorKind {
    BadRequestError(crate::error::BadRequestError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetDocumentationPartsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetDocumentationPartsErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            GetDocumentationPartsErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            GetDocumentationPartsErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            GetDocumentationPartsErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            GetDocumentationPartsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetDocumentationPartsError {
    fn code(&self) -> Option<&str> {
        GetDocumentationPartsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl GetDocumentationPartsError {
    pub fn new(kind: GetDocumentationPartsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetDocumentationPartsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetDocumentationPartsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for GetDocumentationPartsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetDocumentationPartsErrorKind::BadRequestError(_inner) => Some(_inner),
            GetDocumentationPartsErrorKind::NotFoundError(_inner) => Some(_inner),
            GetDocumentationPartsErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            GetDocumentationPartsErrorKind::UnauthorizedError(_inner) => Some(_inner),
            GetDocumentationPartsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetDocumentationVersionError {
    pub kind: GetDocumentationVersionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetDocumentationVersionErrorKind {
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetDocumentationVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetDocumentationVersionErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            GetDocumentationVersionErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            GetDocumentationVersionErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            GetDocumentationVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetDocumentationVersionError {
    fn code(&self) -> Option<&str> {
        GetDocumentationVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl GetDocumentationVersionError {
    pub fn new(kind: GetDocumentationVersionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetDocumentationVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetDocumentationVersionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for GetDocumentationVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetDocumentationVersionErrorKind::NotFoundError(_inner) => Some(_inner),
            GetDocumentationVersionErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            GetDocumentationVersionErrorKind::UnauthorizedError(_inner) => Some(_inner),
            GetDocumentationVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetDocumentationVersionsError {
    pub kind: GetDocumentationVersionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetDocumentationVersionsErrorKind {
    BadRequestError(crate::error::BadRequestError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetDocumentationVersionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetDocumentationVersionsErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            GetDocumentationVersionsErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            GetDocumentationVersionsErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            GetDocumentationVersionsErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            GetDocumentationVersionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetDocumentationVersionsError {
    fn code(&self) -> Option<&str> {
        GetDocumentationVersionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl GetDocumentationVersionsError {
    pub fn new(kind: GetDocumentationVersionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetDocumentationVersionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetDocumentationVersionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for GetDocumentationVersionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetDocumentationVersionsErrorKind::BadRequestError(_inner) => Some(_inner),
            GetDocumentationVersionsErrorKind::NotFoundError(_inner) => Some(_inner),
            GetDocumentationVersionsErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            GetDocumentationVersionsErrorKind::UnauthorizedError(_inner) => Some(_inner),
            GetDocumentationVersionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetDomainNameError {
    pub kind: GetDomainNameErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetDomainNameErrorKind {
    NotFoundError(crate::error::NotFoundError),
    ServiceUnavailableError(crate::error::ServiceUnavailableError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetDomainNameError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetDomainNameErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            GetDomainNameErrorKind::ServiceUnavailableError(_inner) => _inner.fmt(f),
            GetDomainNameErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            GetDomainNameErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            GetDomainNameErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetDomainNameError {
    fn code(&self) -> Option<&str> {
        GetDomainNameError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl GetDomainNameError {
    pub fn new(kind: GetDomainNameErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetDomainNameErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetDomainNameErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for GetDomainNameError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetDomainNameErrorKind::NotFoundError(_inner) => Some(_inner),
            GetDomainNameErrorKind::ServiceUnavailableError(_inner) => Some(_inner),
            GetDomainNameErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            GetDomainNameErrorKind::UnauthorizedError(_inner) => Some(_inner),
            GetDomainNameErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetDomainNamesError {
    pub kind: GetDomainNamesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetDomainNamesErrorKind {
    BadRequestError(crate::error::BadRequestError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetDomainNamesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetDomainNamesErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            GetDomainNamesErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            GetDomainNamesErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            GetDomainNamesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetDomainNamesError {
    fn code(&self) -> Option<&str> {
        GetDomainNamesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl GetDomainNamesError {
    pub fn new(kind: GetDomainNamesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetDomainNamesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetDomainNamesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for GetDomainNamesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetDomainNamesErrorKind::BadRequestError(_inner) => Some(_inner),
            GetDomainNamesErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            GetDomainNamesErrorKind::UnauthorizedError(_inner) => Some(_inner),
            GetDomainNamesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetExportError {
    pub kind: GetExportErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetExportErrorKind {
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetExportError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetExportErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            GetExportErrorKind::ConflictError(_inner) => _inner.fmt(f),
            GetExportErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            GetExportErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            GetExportErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            GetExportErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetExportError {
    fn code(&self) -> Option<&str> {
        GetExportError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl GetExportError {
    pub fn new(kind: GetExportErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetExportErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetExportErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for GetExportError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetExportErrorKind::BadRequestError(_inner) => Some(_inner),
            GetExportErrorKind::ConflictError(_inner) => Some(_inner),
            GetExportErrorKind::NotFoundError(_inner) => Some(_inner),
            GetExportErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            GetExportErrorKind::UnauthorizedError(_inner) => Some(_inner),
            GetExportErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetGatewayResponseError {
    pub kind: GetGatewayResponseErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetGatewayResponseErrorKind {
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetGatewayResponseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetGatewayResponseErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            GetGatewayResponseErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            GetGatewayResponseErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            GetGatewayResponseErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetGatewayResponseError {
    fn code(&self) -> Option<&str> {
        GetGatewayResponseError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl GetGatewayResponseError {
    pub fn new(kind: GetGatewayResponseErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetGatewayResponseErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetGatewayResponseErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for GetGatewayResponseError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetGatewayResponseErrorKind::NotFoundError(_inner) => Some(_inner),
            GetGatewayResponseErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            GetGatewayResponseErrorKind::UnauthorizedError(_inner) => Some(_inner),
            GetGatewayResponseErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetGatewayResponsesError {
    pub kind: GetGatewayResponsesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetGatewayResponsesErrorKind {
    BadRequestError(crate::error::BadRequestError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetGatewayResponsesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetGatewayResponsesErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            GetGatewayResponsesErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            GetGatewayResponsesErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            GetGatewayResponsesErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            GetGatewayResponsesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetGatewayResponsesError {
    fn code(&self) -> Option<&str> {
        GetGatewayResponsesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl GetGatewayResponsesError {
    pub fn new(kind: GetGatewayResponsesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetGatewayResponsesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetGatewayResponsesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for GetGatewayResponsesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetGatewayResponsesErrorKind::BadRequestError(_inner) => Some(_inner),
            GetGatewayResponsesErrorKind::NotFoundError(_inner) => Some(_inner),
            GetGatewayResponsesErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            GetGatewayResponsesErrorKind::UnauthorizedError(_inner) => Some(_inner),
            GetGatewayResponsesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetIntegrationError {
    pub kind: GetIntegrationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetIntegrationErrorKind {
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetIntegrationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetIntegrationErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            GetIntegrationErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            GetIntegrationErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            GetIntegrationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetIntegrationError {
    fn code(&self) -> Option<&str> {
        GetIntegrationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl GetIntegrationError {
    pub fn new(kind: GetIntegrationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetIntegrationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetIntegrationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for GetIntegrationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetIntegrationErrorKind::NotFoundError(_inner) => Some(_inner),
            GetIntegrationErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            GetIntegrationErrorKind::UnauthorizedError(_inner) => Some(_inner),
            GetIntegrationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetIntegrationResponseError {
    pub kind: GetIntegrationResponseErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetIntegrationResponseErrorKind {
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetIntegrationResponseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetIntegrationResponseErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            GetIntegrationResponseErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            GetIntegrationResponseErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            GetIntegrationResponseErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetIntegrationResponseError {
    fn code(&self) -> Option<&str> {
        GetIntegrationResponseError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl GetIntegrationResponseError {
    pub fn new(kind: GetIntegrationResponseErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetIntegrationResponseErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetIntegrationResponseErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for GetIntegrationResponseError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetIntegrationResponseErrorKind::NotFoundError(_inner) => Some(_inner),
            GetIntegrationResponseErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            GetIntegrationResponseErrorKind::UnauthorizedError(_inner) => Some(_inner),
            GetIntegrationResponseErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetMethodError {
    pub kind: GetMethodErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetMethodErrorKind {
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetMethodError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetMethodErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            GetMethodErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            GetMethodErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            GetMethodErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetMethodError {
    fn code(&self) -> Option<&str> {
        GetMethodError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl GetMethodError {
    pub fn new(kind: GetMethodErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetMethodErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetMethodErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for GetMethodError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetMethodErrorKind::NotFoundError(_inner) => Some(_inner),
            GetMethodErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            GetMethodErrorKind::UnauthorizedError(_inner) => Some(_inner),
            GetMethodErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetMethodResponseError {
    pub kind: GetMethodResponseErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetMethodResponseErrorKind {
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetMethodResponseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetMethodResponseErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            GetMethodResponseErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            GetMethodResponseErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            GetMethodResponseErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetMethodResponseError {
    fn code(&self) -> Option<&str> {
        GetMethodResponseError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl GetMethodResponseError {
    pub fn new(kind: GetMethodResponseErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetMethodResponseErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetMethodResponseErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for GetMethodResponseError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetMethodResponseErrorKind::NotFoundError(_inner) => Some(_inner),
            GetMethodResponseErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            GetMethodResponseErrorKind::UnauthorizedError(_inner) => Some(_inner),
            GetMethodResponseErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetModelError {
    pub kind: GetModelErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetModelErrorKind {
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetModelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetModelErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            GetModelErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            GetModelErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            GetModelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetModelError {
    fn code(&self) -> Option<&str> {
        GetModelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl GetModelError {
    pub fn new(kind: GetModelErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetModelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetModelErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for GetModelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetModelErrorKind::NotFoundError(_inner) => Some(_inner),
            GetModelErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            GetModelErrorKind::UnauthorizedError(_inner) => Some(_inner),
            GetModelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetModelsError {
    pub kind: GetModelsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetModelsErrorKind {
    BadRequestError(crate::error::BadRequestError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetModelsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetModelsErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            GetModelsErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            GetModelsErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            GetModelsErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            GetModelsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetModelsError {
    fn code(&self) -> Option<&str> {
        GetModelsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl GetModelsError {
    pub fn new(kind: GetModelsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetModelsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetModelsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for GetModelsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetModelsErrorKind::BadRequestError(_inner) => Some(_inner),
            GetModelsErrorKind::NotFoundError(_inner) => Some(_inner),
            GetModelsErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            GetModelsErrorKind::UnauthorizedError(_inner) => Some(_inner),
            GetModelsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetModelTemplateError {
    pub kind: GetModelTemplateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetModelTemplateErrorKind {
    BadRequestError(crate::error::BadRequestError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetModelTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetModelTemplateErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            GetModelTemplateErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            GetModelTemplateErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            GetModelTemplateErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            GetModelTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetModelTemplateError {
    fn code(&self) -> Option<&str> {
        GetModelTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl GetModelTemplateError {
    pub fn new(kind: GetModelTemplateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetModelTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetModelTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for GetModelTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetModelTemplateErrorKind::BadRequestError(_inner) => Some(_inner),
            GetModelTemplateErrorKind::NotFoundError(_inner) => Some(_inner),
            GetModelTemplateErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            GetModelTemplateErrorKind::UnauthorizedError(_inner) => Some(_inner),
            GetModelTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetRequestValidatorError {
    pub kind: GetRequestValidatorErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetRequestValidatorErrorKind {
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetRequestValidatorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetRequestValidatorErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            GetRequestValidatorErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            GetRequestValidatorErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            GetRequestValidatorErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetRequestValidatorError {
    fn code(&self) -> Option<&str> {
        GetRequestValidatorError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl GetRequestValidatorError {
    pub fn new(kind: GetRequestValidatorErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetRequestValidatorErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetRequestValidatorErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for GetRequestValidatorError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetRequestValidatorErrorKind::NotFoundError(_inner) => Some(_inner),
            GetRequestValidatorErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            GetRequestValidatorErrorKind::UnauthorizedError(_inner) => Some(_inner),
            GetRequestValidatorErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetRequestValidatorsError {
    pub kind: GetRequestValidatorsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetRequestValidatorsErrorKind {
    BadRequestError(crate::error::BadRequestError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetRequestValidatorsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetRequestValidatorsErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            GetRequestValidatorsErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            GetRequestValidatorsErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            GetRequestValidatorsErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            GetRequestValidatorsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetRequestValidatorsError {
    fn code(&self) -> Option<&str> {
        GetRequestValidatorsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl GetRequestValidatorsError {
    pub fn new(kind: GetRequestValidatorsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetRequestValidatorsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetRequestValidatorsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for GetRequestValidatorsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetRequestValidatorsErrorKind::BadRequestError(_inner) => Some(_inner),
            GetRequestValidatorsErrorKind::NotFoundError(_inner) => Some(_inner),
            GetRequestValidatorsErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            GetRequestValidatorsErrorKind::UnauthorizedError(_inner) => Some(_inner),
            GetRequestValidatorsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetResourceError {
    pub kind: GetResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetResourceErrorKind {
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetResourceErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            GetResourceErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            GetResourceErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            GetResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetResourceError {
    fn code(&self) -> Option<&str> {
        GetResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl GetResourceError {
    pub fn new(kind: GetResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for GetResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetResourceErrorKind::NotFoundError(_inner) => Some(_inner),
            GetResourceErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            GetResourceErrorKind::UnauthorizedError(_inner) => Some(_inner),
            GetResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetResourcesError {
    pub kind: GetResourcesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetResourcesErrorKind {
    BadRequestError(crate::error::BadRequestError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetResourcesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetResourcesErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            GetResourcesErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            GetResourcesErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            GetResourcesErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            GetResourcesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetResourcesError {
    fn code(&self) -> Option<&str> {
        GetResourcesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl GetResourcesError {
    pub fn new(kind: GetResourcesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetResourcesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetResourcesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for GetResourcesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetResourcesErrorKind::BadRequestError(_inner) => Some(_inner),
            GetResourcesErrorKind::NotFoundError(_inner) => Some(_inner),
            GetResourcesErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            GetResourcesErrorKind::UnauthorizedError(_inner) => Some(_inner),
            GetResourcesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetRestApiError {
    pub kind: GetRestApiErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetRestApiErrorKind {
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetRestApiError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetRestApiErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            GetRestApiErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            GetRestApiErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            GetRestApiErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetRestApiError {
    fn code(&self) -> Option<&str> {
        GetRestApiError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl GetRestApiError {
    pub fn new(kind: GetRestApiErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetRestApiErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetRestApiErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for GetRestApiError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetRestApiErrorKind::NotFoundError(_inner) => Some(_inner),
            GetRestApiErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            GetRestApiErrorKind::UnauthorizedError(_inner) => Some(_inner),
            GetRestApiErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetRestApisError {
    pub kind: GetRestApisErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetRestApisErrorKind {
    BadRequestError(crate::error::BadRequestError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetRestApisError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetRestApisErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            GetRestApisErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            GetRestApisErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            GetRestApisErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetRestApisError {
    fn code(&self) -> Option<&str> {
        GetRestApisError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl GetRestApisError {
    pub fn new(kind: GetRestApisErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetRestApisErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetRestApisErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for GetRestApisError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetRestApisErrorKind::BadRequestError(_inner) => Some(_inner),
            GetRestApisErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            GetRestApisErrorKind::UnauthorizedError(_inner) => Some(_inner),
            GetRestApisErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetSdkError {
    pub kind: GetSdkErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetSdkErrorKind {
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetSdkError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetSdkErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            GetSdkErrorKind::ConflictError(_inner) => _inner.fmt(f),
            GetSdkErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            GetSdkErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            GetSdkErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            GetSdkErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetSdkError {
    fn code(&self) -> Option<&str> {
        GetSdkError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl GetSdkError {
    pub fn new(kind: GetSdkErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetSdkErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetSdkErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for GetSdkError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetSdkErrorKind::BadRequestError(_inner) => Some(_inner),
            GetSdkErrorKind::ConflictError(_inner) => Some(_inner),
            GetSdkErrorKind::NotFoundError(_inner) => Some(_inner),
            GetSdkErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            GetSdkErrorKind::UnauthorizedError(_inner) => Some(_inner),
            GetSdkErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetSdkTypeError {
    pub kind: GetSdkTypeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetSdkTypeErrorKind {
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetSdkTypeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetSdkTypeErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            GetSdkTypeErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            GetSdkTypeErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            GetSdkTypeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetSdkTypeError {
    fn code(&self) -> Option<&str> {
        GetSdkTypeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl GetSdkTypeError {
    pub fn new(kind: GetSdkTypeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetSdkTypeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetSdkTypeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for GetSdkTypeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetSdkTypeErrorKind::NotFoundError(_inner) => Some(_inner),
            GetSdkTypeErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            GetSdkTypeErrorKind::UnauthorizedError(_inner) => Some(_inner),
            GetSdkTypeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetSdkTypesError {
    pub kind: GetSdkTypesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetSdkTypesErrorKind {
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetSdkTypesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetSdkTypesErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            GetSdkTypesErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            GetSdkTypesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetSdkTypesError {
    fn code(&self) -> Option<&str> {
        GetSdkTypesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl GetSdkTypesError {
    pub fn new(kind: GetSdkTypesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetSdkTypesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetSdkTypesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for GetSdkTypesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetSdkTypesErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            GetSdkTypesErrorKind::UnauthorizedError(_inner) => Some(_inner),
            GetSdkTypesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetStageError {
    pub kind: GetStageErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetStageErrorKind {
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetStageError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetStageErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            GetStageErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            GetStageErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            GetStageErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetStageError {
    fn code(&self) -> Option<&str> {
        GetStageError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl GetStageError {
    pub fn new(kind: GetStageErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetStageErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetStageErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for GetStageError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetStageErrorKind::NotFoundError(_inner) => Some(_inner),
            GetStageErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            GetStageErrorKind::UnauthorizedError(_inner) => Some(_inner),
            GetStageErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetStagesError {
    pub kind: GetStagesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetStagesErrorKind {
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetStagesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetStagesErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            GetStagesErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            GetStagesErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            GetStagesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetStagesError {
    fn code(&self) -> Option<&str> {
        GetStagesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl GetStagesError {
    pub fn new(kind: GetStagesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetStagesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetStagesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for GetStagesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetStagesErrorKind::NotFoundError(_inner) => Some(_inner),
            GetStagesErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            GetStagesErrorKind::UnauthorizedError(_inner) => Some(_inner),
            GetStagesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetTagsError {
    pub kind: GetTagsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetTagsErrorKind {
    BadRequestError(crate::error::BadRequestError),
    LimitExceededError(crate::error::LimitExceededError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetTagsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetTagsErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            GetTagsErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            GetTagsErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            GetTagsErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            GetTagsErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            GetTagsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetTagsError {
    fn code(&self) -> Option<&str> {
        GetTagsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl GetTagsError {
    pub fn new(kind: GetTagsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetTagsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetTagsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for GetTagsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetTagsErrorKind::BadRequestError(_inner) => Some(_inner),
            GetTagsErrorKind::LimitExceededError(_inner) => Some(_inner),
            GetTagsErrorKind::NotFoundError(_inner) => Some(_inner),
            GetTagsErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            GetTagsErrorKind::UnauthorizedError(_inner) => Some(_inner),
            GetTagsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetUsageError {
    pub kind: GetUsageErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetUsageErrorKind {
    BadRequestError(crate::error::BadRequestError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetUsageError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetUsageErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            GetUsageErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            GetUsageErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            GetUsageErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            GetUsageErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetUsageError {
    fn code(&self) -> Option<&str> {
        GetUsageError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl GetUsageError {
    pub fn new(kind: GetUsageErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetUsageErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetUsageErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for GetUsageError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetUsageErrorKind::BadRequestError(_inner) => Some(_inner),
            GetUsageErrorKind::NotFoundError(_inner) => Some(_inner),
            GetUsageErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            GetUsageErrorKind::UnauthorizedError(_inner) => Some(_inner),
            GetUsageErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetUsagePlanError {
    pub kind: GetUsagePlanErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetUsagePlanErrorKind {
    BadRequestError(crate::error::BadRequestError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetUsagePlanError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetUsagePlanErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            GetUsagePlanErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            GetUsagePlanErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            GetUsagePlanErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            GetUsagePlanErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetUsagePlanError {
    fn code(&self) -> Option<&str> {
        GetUsagePlanError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl GetUsagePlanError {
    pub fn new(kind: GetUsagePlanErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetUsagePlanErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetUsagePlanErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for GetUsagePlanError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetUsagePlanErrorKind::BadRequestError(_inner) => Some(_inner),
            GetUsagePlanErrorKind::NotFoundError(_inner) => Some(_inner),
            GetUsagePlanErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            GetUsagePlanErrorKind::UnauthorizedError(_inner) => Some(_inner),
            GetUsagePlanErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetUsagePlanKeyError {
    pub kind: GetUsagePlanKeyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetUsagePlanKeyErrorKind {
    BadRequestError(crate::error::BadRequestError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetUsagePlanKeyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetUsagePlanKeyErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            GetUsagePlanKeyErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            GetUsagePlanKeyErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            GetUsagePlanKeyErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            GetUsagePlanKeyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetUsagePlanKeyError {
    fn code(&self) -> Option<&str> {
        GetUsagePlanKeyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl GetUsagePlanKeyError {
    pub fn new(kind: GetUsagePlanKeyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetUsagePlanKeyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetUsagePlanKeyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for GetUsagePlanKeyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetUsagePlanKeyErrorKind::BadRequestError(_inner) => Some(_inner),
            GetUsagePlanKeyErrorKind::NotFoundError(_inner) => Some(_inner),
            GetUsagePlanKeyErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            GetUsagePlanKeyErrorKind::UnauthorizedError(_inner) => Some(_inner),
            GetUsagePlanKeyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetUsagePlanKeysError {
    pub kind: GetUsagePlanKeysErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetUsagePlanKeysErrorKind {
    BadRequestError(crate::error::BadRequestError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetUsagePlanKeysError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetUsagePlanKeysErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            GetUsagePlanKeysErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            GetUsagePlanKeysErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            GetUsagePlanKeysErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            GetUsagePlanKeysErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetUsagePlanKeysError {
    fn code(&self) -> Option<&str> {
        GetUsagePlanKeysError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl GetUsagePlanKeysError {
    pub fn new(kind: GetUsagePlanKeysErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetUsagePlanKeysErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetUsagePlanKeysErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for GetUsagePlanKeysError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetUsagePlanKeysErrorKind::BadRequestError(_inner) => Some(_inner),
            GetUsagePlanKeysErrorKind::NotFoundError(_inner) => Some(_inner),
            GetUsagePlanKeysErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            GetUsagePlanKeysErrorKind::UnauthorizedError(_inner) => Some(_inner),
            GetUsagePlanKeysErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetUsagePlansError {
    pub kind: GetUsagePlansErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetUsagePlansErrorKind {
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetUsagePlansError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetUsagePlansErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            GetUsagePlansErrorKind::ConflictError(_inner) => _inner.fmt(f),
            GetUsagePlansErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            GetUsagePlansErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            GetUsagePlansErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            GetUsagePlansErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetUsagePlansError {
    fn code(&self) -> Option<&str> {
        GetUsagePlansError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl GetUsagePlansError {
    pub fn new(kind: GetUsagePlansErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetUsagePlansErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetUsagePlansErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for GetUsagePlansError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetUsagePlansErrorKind::BadRequestError(_inner) => Some(_inner),
            GetUsagePlansErrorKind::ConflictError(_inner) => Some(_inner),
            GetUsagePlansErrorKind::NotFoundError(_inner) => Some(_inner),
            GetUsagePlansErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            GetUsagePlansErrorKind::UnauthorizedError(_inner) => Some(_inner),
            GetUsagePlansErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetVpcLinkError {
    pub kind: GetVpcLinkErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetVpcLinkErrorKind {
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetVpcLinkError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetVpcLinkErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            GetVpcLinkErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            GetVpcLinkErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            GetVpcLinkErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetVpcLinkError {
    fn code(&self) -> Option<&str> {
        GetVpcLinkError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl GetVpcLinkError {
    pub fn new(kind: GetVpcLinkErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetVpcLinkErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetVpcLinkErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for GetVpcLinkError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetVpcLinkErrorKind::NotFoundError(_inner) => Some(_inner),
            GetVpcLinkErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            GetVpcLinkErrorKind::UnauthorizedError(_inner) => Some(_inner),
            GetVpcLinkErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetVpcLinksError {
    pub kind: GetVpcLinksErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetVpcLinksErrorKind {
    BadRequestError(crate::error::BadRequestError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetVpcLinksError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetVpcLinksErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            GetVpcLinksErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            GetVpcLinksErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            GetVpcLinksErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetVpcLinksError {
    fn code(&self) -> Option<&str> {
        GetVpcLinksError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl GetVpcLinksError {
    pub fn new(kind: GetVpcLinksErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetVpcLinksErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetVpcLinksErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for GetVpcLinksError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetVpcLinksErrorKind::BadRequestError(_inner) => Some(_inner),
            GetVpcLinksErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            GetVpcLinksErrorKind::UnauthorizedError(_inner) => Some(_inner),
            GetVpcLinksErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ImportApiKeysError {
    pub kind: ImportApiKeysErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ImportApiKeysErrorKind {
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    LimitExceededError(crate::error::LimitExceededError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ImportApiKeysError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ImportApiKeysErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            ImportApiKeysErrorKind::ConflictError(_inner) => _inner.fmt(f),
            ImportApiKeysErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            ImportApiKeysErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            ImportApiKeysErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            ImportApiKeysErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            ImportApiKeysErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ImportApiKeysError {
    fn code(&self) -> Option<&str> {
        ImportApiKeysError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl ImportApiKeysError {
    pub fn new(kind: ImportApiKeysErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ImportApiKeysErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ImportApiKeysErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for ImportApiKeysError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ImportApiKeysErrorKind::BadRequestError(_inner) => Some(_inner),
            ImportApiKeysErrorKind::ConflictError(_inner) => Some(_inner),
            ImportApiKeysErrorKind::LimitExceededError(_inner) => Some(_inner),
            ImportApiKeysErrorKind::NotFoundError(_inner) => Some(_inner),
            ImportApiKeysErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            ImportApiKeysErrorKind::UnauthorizedError(_inner) => Some(_inner),
            ImportApiKeysErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ImportDocumentationPartsError {
    pub kind: ImportDocumentationPartsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ImportDocumentationPartsErrorKind {
    BadRequestError(crate::error::BadRequestError),
    LimitExceededError(crate::error::LimitExceededError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ImportDocumentationPartsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ImportDocumentationPartsErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            ImportDocumentationPartsErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            ImportDocumentationPartsErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            ImportDocumentationPartsErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            ImportDocumentationPartsErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            ImportDocumentationPartsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ImportDocumentationPartsError {
    fn code(&self) -> Option<&str> {
        ImportDocumentationPartsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl ImportDocumentationPartsError {
    pub fn new(kind: ImportDocumentationPartsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ImportDocumentationPartsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ImportDocumentationPartsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for ImportDocumentationPartsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ImportDocumentationPartsErrorKind::BadRequestError(_inner) => Some(_inner),
            ImportDocumentationPartsErrorKind::LimitExceededError(_inner) => Some(_inner),
            ImportDocumentationPartsErrorKind::NotFoundError(_inner) => Some(_inner),
            ImportDocumentationPartsErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            ImportDocumentationPartsErrorKind::UnauthorizedError(_inner) => Some(_inner),
            ImportDocumentationPartsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ImportRestApiError {
    pub kind: ImportRestApiErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ImportRestApiErrorKind {
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    LimitExceededError(crate::error::LimitExceededError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ImportRestApiError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ImportRestApiErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            ImportRestApiErrorKind::ConflictError(_inner) => _inner.fmt(f),
            ImportRestApiErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            ImportRestApiErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            ImportRestApiErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            ImportRestApiErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ImportRestApiError {
    fn code(&self) -> Option<&str> {
        ImportRestApiError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl ImportRestApiError {
    pub fn new(kind: ImportRestApiErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ImportRestApiErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ImportRestApiErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for ImportRestApiError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ImportRestApiErrorKind::BadRequestError(_inner) => Some(_inner),
            ImportRestApiErrorKind::ConflictError(_inner) => Some(_inner),
            ImportRestApiErrorKind::LimitExceededError(_inner) => Some(_inner),
            ImportRestApiErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            ImportRestApiErrorKind::UnauthorizedError(_inner) => Some(_inner),
            ImportRestApiErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutGatewayResponseError {
    pub kind: PutGatewayResponseErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutGatewayResponseErrorKind {
    BadRequestError(crate::error::BadRequestError),
    LimitExceededError(crate::error::LimitExceededError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutGatewayResponseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutGatewayResponseErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            PutGatewayResponseErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            PutGatewayResponseErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            PutGatewayResponseErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            PutGatewayResponseErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            PutGatewayResponseErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutGatewayResponseError {
    fn code(&self) -> Option<&str> {
        PutGatewayResponseError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl PutGatewayResponseError {
    pub fn new(kind: PutGatewayResponseErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutGatewayResponseErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutGatewayResponseErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for PutGatewayResponseError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutGatewayResponseErrorKind::BadRequestError(_inner) => Some(_inner),
            PutGatewayResponseErrorKind::LimitExceededError(_inner) => Some(_inner),
            PutGatewayResponseErrorKind::NotFoundError(_inner) => Some(_inner),
            PutGatewayResponseErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            PutGatewayResponseErrorKind::UnauthorizedError(_inner) => Some(_inner),
            PutGatewayResponseErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutIntegrationError {
    pub kind: PutIntegrationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutIntegrationErrorKind {
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutIntegrationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutIntegrationErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            PutIntegrationErrorKind::ConflictError(_inner) => _inner.fmt(f),
            PutIntegrationErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            PutIntegrationErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            PutIntegrationErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            PutIntegrationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutIntegrationError {
    fn code(&self) -> Option<&str> {
        PutIntegrationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl PutIntegrationError {
    pub fn new(kind: PutIntegrationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutIntegrationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutIntegrationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for PutIntegrationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutIntegrationErrorKind::BadRequestError(_inner) => Some(_inner),
            PutIntegrationErrorKind::ConflictError(_inner) => Some(_inner),
            PutIntegrationErrorKind::NotFoundError(_inner) => Some(_inner),
            PutIntegrationErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            PutIntegrationErrorKind::UnauthorizedError(_inner) => Some(_inner),
            PutIntegrationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutIntegrationResponseError {
    pub kind: PutIntegrationResponseErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutIntegrationResponseErrorKind {
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    LimitExceededError(crate::error::LimitExceededError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutIntegrationResponseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutIntegrationResponseErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            PutIntegrationResponseErrorKind::ConflictError(_inner) => _inner.fmt(f),
            PutIntegrationResponseErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            PutIntegrationResponseErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            PutIntegrationResponseErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            PutIntegrationResponseErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            PutIntegrationResponseErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutIntegrationResponseError {
    fn code(&self) -> Option<&str> {
        PutIntegrationResponseError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl PutIntegrationResponseError {
    pub fn new(kind: PutIntegrationResponseErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutIntegrationResponseErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutIntegrationResponseErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for PutIntegrationResponseError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutIntegrationResponseErrorKind::BadRequestError(_inner) => Some(_inner),
            PutIntegrationResponseErrorKind::ConflictError(_inner) => Some(_inner),
            PutIntegrationResponseErrorKind::LimitExceededError(_inner) => Some(_inner),
            PutIntegrationResponseErrorKind::NotFoundError(_inner) => Some(_inner),
            PutIntegrationResponseErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            PutIntegrationResponseErrorKind::UnauthorizedError(_inner) => Some(_inner),
            PutIntegrationResponseErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutMethodError {
    pub kind: PutMethodErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutMethodErrorKind {
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    LimitExceededError(crate::error::LimitExceededError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutMethodError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutMethodErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            PutMethodErrorKind::ConflictError(_inner) => _inner.fmt(f),
            PutMethodErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            PutMethodErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            PutMethodErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            PutMethodErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            PutMethodErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutMethodError {
    fn code(&self) -> Option<&str> {
        PutMethodError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl PutMethodError {
    pub fn new(kind: PutMethodErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutMethodErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutMethodErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for PutMethodError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutMethodErrorKind::BadRequestError(_inner) => Some(_inner),
            PutMethodErrorKind::ConflictError(_inner) => Some(_inner),
            PutMethodErrorKind::LimitExceededError(_inner) => Some(_inner),
            PutMethodErrorKind::NotFoundError(_inner) => Some(_inner),
            PutMethodErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            PutMethodErrorKind::UnauthorizedError(_inner) => Some(_inner),
            PutMethodErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutMethodResponseError {
    pub kind: PutMethodResponseErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutMethodResponseErrorKind {
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    LimitExceededError(crate::error::LimitExceededError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutMethodResponseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutMethodResponseErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            PutMethodResponseErrorKind::ConflictError(_inner) => _inner.fmt(f),
            PutMethodResponseErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            PutMethodResponseErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            PutMethodResponseErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            PutMethodResponseErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            PutMethodResponseErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutMethodResponseError {
    fn code(&self) -> Option<&str> {
        PutMethodResponseError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl PutMethodResponseError {
    pub fn new(kind: PutMethodResponseErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutMethodResponseErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutMethodResponseErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for PutMethodResponseError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutMethodResponseErrorKind::BadRequestError(_inner) => Some(_inner),
            PutMethodResponseErrorKind::ConflictError(_inner) => Some(_inner),
            PutMethodResponseErrorKind::LimitExceededError(_inner) => Some(_inner),
            PutMethodResponseErrorKind::NotFoundError(_inner) => Some(_inner),
            PutMethodResponseErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            PutMethodResponseErrorKind::UnauthorizedError(_inner) => Some(_inner),
            PutMethodResponseErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutRestApiError {
    pub kind: PutRestApiErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutRestApiErrorKind {
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    LimitExceededError(crate::error::LimitExceededError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutRestApiError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutRestApiErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            PutRestApiErrorKind::ConflictError(_inner) => _inner.fmt(f),
            PutRestApiErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            PutRestApiErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            PutRestApiErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            PutRestApiErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            PutRestApiErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutRestApiError {
    fn code(&self) -> Option<&str> {
        PutRestApiError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl PutRestApiError {
    pub fn new(kind: PutRestApiErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutRestApiErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutRestApiErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for PutRestApiError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutRestApiErrorKind::BadRequestError(_inner) => Some(_inner),
            PutRestApiErrorKind::ConflictError(_inner) => Some(_inner),
            PutRestApiErrorKind::LimitExceededError(_inner) => Some(_inner),
            PutRestApiErrorKind::NotFoundError(_inner) => Some(_inner),
            PutRestApiErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            PutRestApiErrorKind::UnauthorizedError(_inner) => Some(_inner),
            PutRestApiErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagResourceError {
    pub kind: TagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagResourceErrorKind {
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    LimitExceededError(crate::error::LimitExceededError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagResourceErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ConflictError(_inner) => _inner.fmt(f),
            TagResourceErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            TagResourceErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            TagResourceErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            TagResourceErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            TagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TagResourceError {
    fn code(&self) -> Option<&str> {
        TagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl TagResourceError {
    pub fn new(kind: TagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for TagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagResourceErrorKind::BadRequestError(_inner) => Some(_inner),
            TagResourceErrorKind::ConflictError(_inner) => Some(_inner),
            TagResourceErrorKind::LimitExceededError(_inner) => Some(_inner),
            TagResourceErrorKind::NotFoundError(_inner) => Some(_inner),
            TagResourceErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            TagResourceErrorKind::UnauthorizedError(_inner) => Some(_inner),
            TagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TestInvokeAuthorizerError {
    pub kind: TestInvokeAuthorizerErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TestInvokeAuthorizerErrorKind {
    BadRequestError(crate::error::BadRequestError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TestInvokeAuthorizerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TestInvokeAuthorizerErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            TestInvokeAuthorizerErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            TestInvokeAuthorizerErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            TestInvokeAuthorizerErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            TestInvokeAuthorizerErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TestInvokeAuthorizerError {
    fn code(&self) -> Option<&str> {
        TestInvokeAuthorizerError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl TestInvokeAuthorizerError {
    pub fn new(kind: TestInvokeAuthorizerErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TestInvokeAuthorizerErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TestInvokeAuthorizerErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for TestInvokeAuthorizerError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TestInvokeAuthorizerErrorKind::BadRequestError(_inner) => Some(_inner),
            TestInvokeAuthorizerErrorKind::NotFoundError(_inner) => Some(_inner),
            TestInvokeAuthorizerErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            TestInvokeAuthorizerErrorKind::UnauthorizedError(_inner) => Some(_inner),
            TestInvokeAuthorizerErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TestInvokeMethodError {
    pub kind: TestInvokeMethodErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TestInvokeMethodErrorKind {
    BadRequestError(crate::error::BadRequestError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TestInvokeMethodError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TestInvokeMethodErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            TestInvokeMethodErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            TestInvokeMethodErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            TestInvokeMethodErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            TestInvokeMethodErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TestInvokeMethodError {
    fn code(&self) -> Option<&str> {
        TestInvokeMethodError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl TestInvokeMethodError {
    pub fn new(kind: TestInvokeMethodErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TestInvokeMethodErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TestInvokeMethodErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for TestInvokeMethodError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TestInvokeMethodErrorKind::BadRequestError(_inner) => Some(_inner),
            TestInvokeMethodErrorKind::NotFoundError(_inner) => Some(_inner),
            TestInvokeMethodErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            TestInvokeMethodErrorKind::UnauthorizedError(_inner) => Some(_inner),
            TestInvokeMethodErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagResourceError {
    pub kind: UntagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagResourceErrorKind {
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UntagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagResourceErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ConflictError(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UntagResourceError {
    fn code(&self) -> Option<&str> {
        UntagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl UntagResourceError {
    pub fn new(kind: UntagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UntagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UntagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for UntagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagResourceErrorKind::BadRequestError(_inner) => Some(_inner),
            UntagResourceErrorKind::ConflictError(_inner) => Some(_inner),
            UntagResourceErrorKind::NotFoundError(_inner) => Some(_inner),
            UntagResourceErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            UntagResourceErrorKind::UnauthorizedError(_inner) => Some(_inner),
            UntagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateAccountError {
    pub kind: UpdateAccountErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateAccountErrorKind {
    BadRequestError(crate::error::BadRequestError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateAccountError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateAccountErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            UpdateAccountErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            UpdateAccountErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            UpdateAccountErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            UpdateAccountErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateAccountError {
    fn code(&self) -> Option<&str> {
        UpdateAccountError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl UpdateAccountError {
    pub fn new(kind: UpdateAccountErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateAccountErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateAccountErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for UpdateAccountError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateAccountErrorKind::BadRequestError(_inner) => Some(_inner),
            UpdateAccountErrorKind::NotFoundError(_inner) => Some(_inner),
            UpdateAccountErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            UpdateAccountErrorKind::UnauthorizedError(_inner) => Some(_inner),
            UpdateAccountErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateApiKeyError {
    pub kind: UpdateApiKeyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateApiKeyErrorKind {
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateApiKeyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateApiKeyErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            UpdateApiKeyErrorKind::ConflictError(_inner) => _inner.fmt(f),
            UpdateApiKeyErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            UpdateApiKeyErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            UpdateApiKeyErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            UpdateApiKeyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateApiKeyError {
    fn code(&self) -> Option<&str> {
        UpdateApiKeyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl UpdateApiKeyError {
    pub fn new(kind: UpdateApiKeyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateApiKeyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateApiKeyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for UpdateApiKeyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateApiKeyErrorKind::BadRequestError(_inner) => Some(_inner),
            UpdateApiKeyErrorKind::ConflictError(_inner) => Some(_inner),
            UpdateApiKeyErrorKind::NotFoundError(_inner) => Some(_inner),
            UpdateApiKeyErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            UpdateApiKeyErrorKind::UnauthorizedError(_inner) => Some(_inner),
            UpdateApiKeyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateAuthorizerError {
    pub kind: UpdateAuthorizerErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateAuthorizerErrorKind {
    BadRequestError(crate::error::BadRequestError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateAuthorizerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateAuthorizerErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            UpdateAuthorizerErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            UpdateAuthorizerErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            UpdateAuthorizerErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            UpdateAuthorizerErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateAuthorizerError {
    fn code(&self) -> Option<&str> {
        UpdateAuthorizerError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl UpdateAuthorizerError {
    pub fn new(kind: UpdateAuthorizerErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateAuthorizerErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateAuthorizerErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for UpdateAuthorizerError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateAuthorizerErrorKind::BadRequestError(_inner) => Some(_inner),
            UpdateAuthorizerErrorKind::NotFoundError(_inner) => Some(_inner),
            UpdateAuthorizerErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            UpdateAuthorizerErrorKind::UnauthorizedError(_inner) => Some(_inner),
            UpdateAuthorizerErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateBasePathMappingError {
    pub kind: UpdateBasePathMappingErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateBasePathMappingErrorKind {
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateBasePathMappingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateBasePathMappingErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            UpdateBasePathMappingErrorKind::ConflictError(_inner) => _inner.fmt(f),
            UpdateBasePathMappingErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            UpdateBasePathMappingErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            UpdateBasePathMappingErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            UpdateBasePathMappingErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateBasePathMappingError {
    fn code(&self) -> Option<&str> {
        UpdateBasePathMappingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl UpdateBasePathMappingError {
    pub fn new(kind: UpdateBasePathMappingErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateBasePathMappingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateBasePathMappingErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for UpdateBasePathMappingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateBasePathMappingErrorKind::BadRequestError(_inner) => Some(_inner),
            UpdateBasePathMappingErrorKind::ConflictError(_inner) => Some(_inner),
            UpdateBasePathMappingErrorKind::NotFoundError(_inner) => Some(_inner),
            UpdateBasePathMappingErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            UpdateBasePathMappingErrorKind::UnauthorizedError(_inner) => Some(_inner),
            UpdateBasePathMappingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateClientCertificateError {
    pub kind: UpdateClientCertificateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateClientCertificateErrorKind {
    BadRequestError(crate::error::BadRequestError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateClientCertificateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateClientCertificateErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            UpdateClientCertificateErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            UpdateClientCertificateErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            UpdateClientCertificateErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            UpdateClientCertificateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateClientCertificateError {
    fn code(&self) -> Option<&str> {
        UpdateClientCertificateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl UpdateClientCertificateError {
    pub fn new(kind: UpdateClientCertificateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateClientCertificateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateClientCertificateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for UpdateClientCertificateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateClientCertificateErrorKind::BadRequestError(_inner) => Some(_inner),
            UpdateClientCertificateErrorKind::NotFoundError(_inner) => Some(_inner),
            UpdateClientCertificateErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            UpdateClientCertificateErrorKind::UnauthorizedError(_inner) => Some(_inner),
            UpdateClientCertificateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateDeploymentError {
    pub kind: UpdateDeploymentErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateDeploymentErrorKind {
    BadRequestError(crate::error::BadRequestError),
    NotFoundError(crate::error::NotFoundError),
    ServiceUnavailableError(crate::error::ServiceUnavailableError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateDeploymentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateDeploymentErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            UpdateDeploymentErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            UpdateDeploymentErrorKind::ServiceUnavailableError(_inner) => _inner.fmt(f),
            UpdateDeploymentErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            UpdateDeploymentErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            UpdateDeploymentErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateDeploymentError {
    fn code(&self) -> Option<&str> {
        UpdateDeploymentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl UpdateDeploymentError {
    pub fn new(kind: UpdateDeploymentErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateDeploymentErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateDeploymentErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for UpdateDeploymentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateDeploymentErrorKind::BadRequestError(_inner) => Some(_inner),
            UpdateDeploymentErrorKind::NotFoundError(_inner) => Some(_inner),
            UpdateDeploymentErrorKind::ServiceUnavailableError(_inner) => Some(_inner),
            UpdateDeploymentErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            UpdateDeploymentErrorKind::UnauthorizedError(_inner) => Some(_inner),
            UpdateDeploymentErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateDocumentationPartError {
    pub kind: UpdateDocumentationPartErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateDocumentationPartErrorKind {
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    LimitExceededError(crate::error::LimitExceededError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateDocumentationPartError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateDocumentationPartErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            UpdateDocumentationPartErrorKind::ConflictError(_inner) => _inner.fmt(f),
            UpdateDocumentationPartErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            UpdateDocumentationPartErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            UpdateDocumentationPartErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            UpdateDocumentationPartErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            UpdateDocumentationPartErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateDocumentationPartError {
    fn code(&self) -> Option<&str> {
        UpdateDocumentationPartError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl UpdateDocumentationPartError {
    pub fn new(kind: UpdateDocumentationPartErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateDocumentationPartErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateDocumentationPartErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for UpdateDocumentationPartError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateDocumentationPartErrorKind::BadRequestError(_inner) => Some(_inner),
            UpdateDocumentationPartErrorKind::ConflictError(_inner) => Some(_inner),
            UpdateDocumentationPartErrorKind::LimitExceededError(_inner) => Some(_inner),
            UpdateDocumentationPartErrorKind::NotFoundError(_inner) => Some(_inner),
            UpdateDocumentationPartErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            UpdateDocumentationPartErrorKind::UnauthorizedError(_inner) => Some(_inner),
            UpdateDocumentationPartErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateDocumentationVersionError {
    pub kind: UpdateDocumentationVersionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateDocumentationVersionErrorKind {
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateDocumentationVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateDocumentationVersionErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            UpdateDocumentationVersionErrorKind::ConflictError(_inner) => _inner.fmt(f),
            UpdateDocumentationVersionErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            UpdateDocumentationVersionErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            UpdateDocumentationVersionErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            UpdateDocumentationVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateDocumentationVersionError {
    fn code(&self) -> Option<&str> {
        UpdateDocumentationVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl UpdateDocumentationVersionError {
    pub fn new(kind: UpdateDocumentationVersionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateDocumentationVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateDocumentationVersionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for UpdateDocumentationVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateDocumentationVersionErrorKind::BadRequestError(_inner) => Some(_inner),
            UpdateDocumentationVersionErrorKind::ConflictError(_inner) => Some(_inner),
            UpdateDocumentationVersionErrorKind::NotFoundError(_inner) => Some(_inner),
            UpdateDocumentationVersionErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            UpdateDocumentationVersionErrorKind::UnauthorizedError(_inner) => Some(_inner),
            UpdateDocumentationVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateDomainNameError {
    pub kind: UpdateDomainNameErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateDomainNameErrorKind {
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateDomainNameError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateDomainNameErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            UpdateDomainNameErrorKind::ConflictError(_inner) => _inner.fmt(f),
            UpdateDomainNameErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            UpdateDomainNameErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            UpdateDomainNameErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            UpdateDomainNameErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateDomainNameError {
    fn code(&self) -> Option<&str> {
        UpdateDomainNameError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl UpdateDomainNameError {
    pub fn new(kind: UpdateDomainNameErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateDomainNameErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateDomainNameErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for UpdateDomainNameError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateDomainNameErrorKind::BadRequestError(_inner) => Some(_inner),
            UpdateDomainNameErrorKind::ConflictError(_inner) => Some(_inner),
            UpdateDomainNameErrorKind::NotFoundError(_inner) => Some(_inner),
            UpdateDomainNameErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            UpdateDomainNameErrorKind::UnauthorizedError(_inner) => Some(_inner),
            UpdateDomainNameErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateGatewayResponseError {
    pub kind: UpdateGatewayResponseErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateGatewayResponseErrorKind {
    BadRequestError(crate::error::BadRequestError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateGatewayResponseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateGatewayResponseErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            UpdateGatewayResponseErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            UpdateGatewayResponseErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            UpdateGatewayResponseErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            UpdateGatewayResponseErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateGatewayResponseError {
    fn code(&self) -> Option<&str> {
        UpdateGatewayResponseError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl UpdateGatewayResponseError {
    pub fn new(kind: UpdateGatewayResponseErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateGatewayResponseErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateGatewayResponseErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for UpdateGatewayResponseError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateGatewayResponseErrorKind::BadRequestError(_inner) => Some(_inner),
            UpdateGatewayResponseErrorKind::NotFoundError(_inner) => Some(_inner),
            UpdateGatewayResponseErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            UpdateGatewayResponseErrorKind::UnauthorizedError(_inner) => Some(_inner),
            UpdateGatewayResponseErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateIntegrationError {
    pub kind: UpdateIntegrationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateIntegrationErrorKind {
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateIntegrationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateIntegrationErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            UpdateIntegrationErrorKind::ConflictError(_inner) => _inner.fmt(f),
            UpdateIntegrationErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            UpdateIntegrationErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            UpdateIntegrationErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            UpdateIntegrationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateIntegrationError {
    fn code(&self) -> Option<&str> {
        UpdateIntegrationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl UpdateIntegrationError {
    pub fn new(kind: UpdateIntegrationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateIntegrationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateIntegrationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for UpdateIntegrationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateIntegrationErrorKind::BadRequestError(_inner) => Some(_inner),
            UpdateIntegrationErrorKind::ConflictError(_inner) => Some(_inner),
            UpdateIntegrationErrorKind::NotFoundError(_inner) => Some(_inner),
            UpdateIntegrationErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            UpdateIntegrationErrorKind::UnauthorizedError(_inner) => Some(_inner),
            UpdateIntegrationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateIntegrationResponseError {
    pub kind: UpdateIntegrationResponseErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateIntegrationResponseErrorKind {
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateIntegrationResponseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateIntegrationResponseErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            UpdateIntegrationResponseErrorKind::ConflictError(_inner) => _inner.fmt(f),
            UpdateIntegrationResponseErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            UpdateIntegrationResponseErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            UpdateIntegrationResponseErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            UpdateIntegrationResponseErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateIntegrationResponseError {
    fn code(&self) -> Option<&str> {
        UpdateIntegrationResponseError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl UpdateIntegrationResponseError {
    pub fn new(kind: UpdateIntegrationResponseErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateIntegrationResponseErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateIntegrationResponseErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for UpdateIntegrationResponseError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateIntegrationResponseErrorKind::BadRequestError(_inner) => Some(_inner),
            UpdateIntegrationResponseErrorKind::ConflictError(_inner) => Some(_inner),
            UpdateIntegrationResponseErrorKind::NotFoundError(_inner) => Some(_inner),
            UpdateIntegrationResponseErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            UpdateIntegrationResponseErrorKind::UnauthorizedError(_inner) => Some(_inner),
            UpdateIntegrationResponseErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateMethodError {
    pub kind: UpdateMethodErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateMethodErrorKind {
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateMethodError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateMethodErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            UpdateMethodErrorKind::ConflictError(_inner) => _inner.fmt(f),
            UpdateMethodErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            UpdateMethodErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            UpdateMethodErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            UpdateMethodErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateMethodError {
    fn code(&self) -> Option<&str> {
        UpdateMethodError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl UpdateMethodError {
    pub fn new(kind: UpdateMethodErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateMethodErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateMethodErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for UpdateMethodError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateMethodErrorKind::BadRequestError(_inner) => Some(_inner),
            UpdateMethodErrorKind::ConflictError(_inner) => Some(_inner),
            UpdateMethodErrorKind::NotFoundError(_inner) => Some(_inner),
            UpdateMethodErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            UpdateMethodErrorKind::UnauthorizedError(_inner) => Some(_inner),
            UpdateMethodErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateMethodResponseError {
    pub kind: UpdateMethodResponseErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateMethodResponseErrorKind {
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    LimitExceededError(crate::error::LimitExceededError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateMethodResponseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateMethodResponseErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            UpdateMethodResponseErrorKind::ConflictError(_inner) => _inner.fmt(f),
            UpdateMethodResponseErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            UpdateMethodResponseErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            UpdateMethodResponseErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            UpdateMethodResponseErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            UpdateMethodResponseErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateMethodResponseError {
    fn code(&self) -> Option<&str> {
        UpdateMethodResponseError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl UpdateMethodResponseError {
    pub fn new(kind: UpdateMethodResponseErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateMethodResponseErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateMethodResponseErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for UpdateMethodResponseError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateMethodResponseErrorKind::BadRequestError(_inner) => Some(_inner),
            UpdateMethodResponseErrorKind::ConflictError(_inner) => Some(_inner),
            UpdateMethodResponseErrorKind::LimitExceededError(_inner) => Some(_inner),
            UpdateMethodResponseErrorKind::NotFoundError(_inner) => Some(_inner),
            UpdateMethodResponseErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            UpdateMethodResponseErrorKind::UnauthorizedError(_inner) => Some(_inner),
            UpdateMethodResponseErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateModelError {
    pub kind: UpdateModelErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateModelErrorKind {
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateModelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateModelErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            UpdateModelErrorKind::ConflictError(_inner) => _inner.fmt(f),
            UpdateModelErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            UpdateModelErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            UpdateModelErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            UpdateModelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateModelError {
    fn code(&self) -> Option<&str> {
        UpdateModelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl UpdateModelError {
    pub fn new(kind: UpdateModelErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateModelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateModelErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for UpdateModelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateModelErrorKind::BadRequestError(_inner) => Some(_inner),
            UpdateModelErrorKind::ConflictError(_inner) => Some(_inner),
            UpdateModelErrorKind::NotFoundError(_inner) => Some(_inner),
            UpdateModelErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            UpdateModelErrorKind::UnauthorizedError(_inner) => Some(_inner),
            UpdateModelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateRequestValidatorError {
    pub kind: UpdateRequestValidatorErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateRequestValidatorErrorKind {
    BadRequestError(crate::error::BadRequestError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateRequestValidatorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateRequestValidatorErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            UpdateRequestValidatorErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            UpdateRequestValidatorErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            UpdateRequestValidatorErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            UpdateRequestValidatorErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateRequestValidatorError {
    fn code(&self) -> Option<&str> {
        UpdateRequestValidatorError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl UpdateRequestValidatorError {
    pub fn new(kind: UpdateRequestValidatorErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateRequestValidatorErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateRequestValidatorErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for UpdateRequestValidatorError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateRequestValidatorErrorKind::BadRequestError(_inner) => Some(_inner),
            UpdateRequestValidatorErrorKind::NotFoundError(_inner) => Some(_inner),
            UpdateRequestValidatorErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            UpdateRequestValidatorErrorKind::UnauthorizedError(_inner) => Some(_inner),
            UpdateRequestValidatorErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateResourceError {
    pub kind: UpdateResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateResourceErrorKind {
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateResourceErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            UpdateResourceErrorKind::ConflictError(_inner) => _inner.fmt(f),
            UpdateResourceErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            UpdateResourceErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            UpdateResourceErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            UpdateResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateResourceError {
    fn code(&self) -> Option<&str> {
        UpdateResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl UpdateResourceError {
    pub fn new(kind: UpdateResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for UpdateResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateResourceErrorKind::BadRequestError(_inner) => Some(_inner),
            UpdateResourceErrorKind::ConflictError(_inner) => Some(_inner),
            UpdateResourceErrorKind::NotFoundError(_inner) => Some(_inner),
            UpdateResourceErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            UpdateResourceErrorKind::UnauthorizedError(_inner) => Some(_inner),
            UpdateResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateRestApiError {
    pub kind: UpdateRestApiErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateRestApiErrorKind {
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateRestApiError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateRestApiErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            UpdateRestApiErrorKind::ConflictError(_inner) => _inner.fmt(f),
            UpdateRestApiErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            UpdateRestApiErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            UpdateRestApiErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            UpdateRestApiErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateRestApiError {
    fn code(&self) -> Option<&str> {
        UpdateRestApiError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl UpdateRestApiError {
    pub fn new(kind: UpdateRestApiErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateRestApiErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateRestApiErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for UpdateRestApiError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateRestApiErrorKind::BadRequestError(_inner) => Some(_inner),
            UpdateRestApiErrorKind::ConflictError(_inner) => Some(_inner),
            UpdateRestApiErrorKind::NotFoundError(_inner) => Some(_inner),
            UpdateRestApiErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            UpdateRestApiErrorKind::UnauthorizedError(_inner) => Some(_inner),
            UpdateRestApiErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateStageError {
    pub kind: UpdateStageErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateStageErrorKind {
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateStageError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateStageErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            UpdateStageErrorKind::ConflictError(_inner) => _inner.fmt(f),
            UpdateStageErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            UpdateStageErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            UpdateStageErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            UpdateStageErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateStageError {
    fn code(&self) -> Option<&str> {
        UpdateStageError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl UpdateStageError {
    pub fn new(kind: UpdateStageErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateStageErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateStageErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for UpdateStageError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateStageErrorKind::BadRequestError(_inner) => Some(_inner),
            UpdateStageErrorKind::ConflictError(_inner) => Some(_inner),
            UpdateStageErrorKind::NotFoundError(_inner) => Some(_inner),
            UpdateStageErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            UpdateStageErrorKind::UnauthorizedError(_inner) => Some(_inner),
            UpdateStageErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateUsageError {
    pub kind: UpdateUsageErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateUsageErrorKind {
    BadRequestError(crate::error::BadRequestError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateUsageError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateUsageErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            UpdateUsageErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            UpdateUsageErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            UpdateUsageErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            UpdateUsageErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateUsageError {
    fn code(&self) -> Option<&str> {
        UpdateUsageError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl UpdateUsageError {
    pub fn new(kind: UpdateUsageErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateUsageErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateUsageErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for UpdateUsageError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateUsageErrorKind::BadRequestError(_inner) => Some(_inner),
            UpdateUsageErrorKind::NotFoundError(_inner) => Some(_inner),
            UpdateUsageErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            UpdateUsageErrorKind::UnauthorizedError(_inner) => Some(_inner),
            UpdateUsageErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateUsagePlanError {
    pub kind: UpdateUsagePlanErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateUsagePlanErrorKind {
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateUsagePlanError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateUsagePlanErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            UpdateUsagePlanErrorKind::ConflictError(_inner) => _inner.fmt(f),
            UpdateUsagePlanErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            UpdateUsagePlanErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            UpdateUsagePlanErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            UpdateUsagePlanErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateUsagePlanError {
    fn code(&self) -> Option<&str> {
        UpdateUsagePlanError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl UpdateUsagePlanError {
    pub fn new(kind: UpdateUsagePlanErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateUsagePlanErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateUsagePlanErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for UpdateUsagePlanError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateUsagePlanErrorKind::BadRequestError(_inner) => Some(_inner),
            UpdateUsagePlanErrorKind::ConflictError(_inner) => Some(_inner),
            UpdateUsagePlanErrorKind::NotFoundError(_inner) => Some(_inner),
            UpdateUsagePlanErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            UpdateUsagePlanErrorKind::UnauthorizedError(_inner) => Some(_inner),
            UpdateUsagePlanErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateVpcLinkError {
    pub kind: UpdateVpcLinkErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateVpcLinkErrorKind {
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    UnauthorizedError(crate::error::UnauthorizedError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateVpcLinkError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateVpcLinkErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            UpdateVpcLinkErrorKind::ConflictError(_inner) => _inner.fmt(f),
            UpdateVpcLinkErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            UpdateVpcLinkErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            UpdateVpcLinkErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
            UpdateVpcLinkErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateVpcLinkError {
    fn code(&self) -> Option<&str> {
        UpdateVpcLinkError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl UpdateVpcLinkError {
    pub fn new(kind: UpdateVpcLinkErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateVpcLinkErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateVpcLinkErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for UpdateVpcLinkError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateVpcLinkErrorKind::BadRequestError(_inner) => Some(_inner),
            UpdateVpcLinkErrorKind::ConflictError(_inner) => Some(_inner),
            UpdateVpcLinkErrorKind::NotFoundError(_inner) => Some(_inner),
            UpdateVpcLinkErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            UpdateVpcLinkErrorKind::UnauthorizedError(_inner) => Some(_inner),
            UpdateVpcLinkErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// <p>The request is denied because the caller has insufficient permissions.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct UnauthorizedError {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UnauthorizedError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UnauthorizedError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl UnauthorizedError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UnauthorizedError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UnauthorizedError [UnauthorizedException]")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for UnauthorizedError {}
/// See [`UnauthorizedError`](crate::error::UnauthorizedError)
pub mod unauthorized_error {
    /// A builder for [`UnauthorizedError`](crate::error::UnauthorizedError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`UnauthorizedError`](crate::error::UnauthorizedError)
        pub fn build(self) -> crate::error::UnauthorizedError {
            crate::error::UnauthorizedError {
                message: self.message,
            }
        }
    }
}
impl UnauthorizedError {
    /// Creates a new builder-style object to manufacture [`UnauthorizedError`](crate::error::UnauthorizedError)
    pub fn builder() -> crate::error::unauthorized_error::Builder {
        crate::error::unauthorized_error::Builder::default()
    }
}

/// <p>The request has reached its throttling limit. Retry after the specified time period.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct TooManyRequestsError {
    #[serde(rename = "retryAfterSeconds")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub retry_after_seconds: std::option::Option<std::string::String>,
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TooManyRequestsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TooManyRequestsError");
        formatter.field("retry_after_seconds", &self.retry_after_seconds);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TooManyRequestsError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyRequestsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyRequestsError [TooManyRequestsException]")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for TooManyRequestsError {}
/// See [`TooManyRequestsError`](crate::error::TooManyRequestsError)
pub mod too_many_requests_error {
    /// A builder for [`TooManyRequestsError`](crate::error::TooManyRequestsError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        retry_after_seconds: std::option::Option<std::string::String>,
        message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn retry_after_seconds(mut self, inp: impl Into<std::string::String>) -> Self {
            self.retry_after_seconds = Some(inp.into());
            self
        }
        pub fn set_retry_after_seconds(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.retry_after_seconds = inp;
            self
        }
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`TooManyRequestsError`](crate::error::TooManyRequestsError)
        pub fn build(self) -> crate::error::TooManyRequestsError {
            crate::error::TooManyRequestsError {
                retry_after_seconds: self.retry_after_seconds,
                message: self.message,
            }
        }
    }
}
impl TooManyRequestsError {
    /// Creates a new builder-style object to manufacture [`TooManyRequestsError`](crate::error::TooManyRequestsError)
    pub fn builder() -> crate::error::too_many_requests_error::Builder {
        crate::error::too_many_requests_error::Builder::default()
    }
}

/// <p>The requested resource is not found. Make sure that the request URI is correct.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct NotFoundError {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NotFoundError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl NotFoundError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NotFoundError [NotFoundException]")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for NotFoundError {}
/// See [`NotFoundError`](crate::error::NotFoundError)
pub mod not_found_error {
    /// A builder for [`NotFoundError`](crate::error::NotFoundError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`NotFoundError`](crate::error::NotFoundError)
        pub fn build(self) -> crate::error::NotFoundError {
            crate::error::NotFoundError {
                message: self.message,
            }
        }
    }
}
impl NotFoundError {
    /// Creates a new builder-style object to manufacture [`NotFoundError`](crate::error::NotFoundError)
    pub fn builder() -> crate::error::not_found_error::Builder {
        crate::error::not_found_error::Builder::default()
    }
}

/// <p>The request configuration has conflicts. For details, see the accompanying error message.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ConflictError {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ConflictError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ConflictError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ConflictError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ConflictError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ConflictError [ConflictException]")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for ConflictError {}
/// See [`ConflictError`](crate::error::ConflictError)
pub mod conflict_error {
    /// A builder for [`ConflictError`](crate::error::ConflictError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`ConflictError`](crate::error::ConflictError)
        pub fn build(self) -> crate::error::ConflictError {
            crate::error::ConflictError {
                message: self.message,
            }
        }
    }
}
impl ConflictError {
    /// Creates a new builder-style object to manufacture [`ConflictError`](crate::error::ConflictError)
    pub fn builder() -> crate::error::conflict_error::Builder {
        crate::error::conflict_error::Builder::default()
    }
}

/// <p>The submitted request is not valid, for example, the input is incomplete or incorrect. See the accompanying error message for details.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct BadRequestError {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for BadRequestError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BadRequestError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl BadRequestError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for BadRequestError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "BadRequestError [BadRequestException]")?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for BadRequestError {}
/// See [`BadRequestError`](crate::error::BadRequestError)
pub mod bad_request_error {
    /// A builder for [`BadRequestError`](crate::error::BadRequestError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`BadRequestError`](crate::error::BadRequestError)
        pub fn build(self) -> crate::error::BadRequestError {
            crate::error::BadRequestError {
                message: self.message,
            }
        }
    }
}
impl BadRequestError {
    /// Creates a new builder-style object to manufacture [`BadRequestError`](crate::error::BadRequestError)
    pub fn builder() -> crate::error::bad_request_error::Builder {
        crate::error::bad_request_error::Builder::default()
    }
}

/// <p>The request exceeded the rate limit. Retry after the specified time period.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct LimitExceededError {
    #[serde(rename = "retryAfterSeconds")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub retry_after_seconds: std::option::Option<std::string::String>,
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LimitExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LimitExceededError");
        formatter.field("retry_after_seconds", &self.retry_after_seconds);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl LimitExceededError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for LimitExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "LimitExceededError [LimitExceededException]")?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl std::error::Error for LimitExceededError {}
/// See [`LimitExceededError`](crate::error::LimitExceededError)
pub mod limit_exceeded_error {
    /// A builder for [`LimitExceededError`](crate::error::LimitExceededError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        retry_after_seconds: std::option::Option<std::string::String>,
        message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn retry_after_seconds(mut self, inp: impl Into<std::string::String>) -> Self {
            self.retry_after_seconds = Some(inp.into());
            self
        }
        pub fn set_retry_after_seconds(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.retry_after_seconds = inp;
            self
        }
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`LimitExceededError`](crate::error::LimitExceededError)
        pub fn build(self) -> crate::error::LimitExceededError {
            crate::error::LimitExceededError {
                retry_after_seconds: self.retry_after_seconds,
                message: self.message,
            }
        }
    }
}
impl LimitExceededError {
    /// Creates a new builder-style object to manufacture [`LimitExceededError`](crate::error::LimitExceededError)
    pub fn builder() -> crate::error::limit_exceeded_error::Builder {
        crate::error::limit_exceeded_error::Builder::default()
    }
}

/// <p>The requested service is not available. For details see the accompanying error message. Retry after the specified time period.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ServiceUnavailableError {
    #[serde(rename = "retryAfterSeconds")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub retry_after_seconds: std::option::Option<std::string::String>,
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ServiceUnavailableError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ServiceUnavailableError");
        formatter.field("retry_after_seconds", &self.retry_after_seconds);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ServiceUnavailableError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ServiceUnavailableError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ServiceUnavailableError [ServiceUnavailableException]")?;
        if let Some(inner_7) = &self.message {
            write!(f, ": {}", inner_7)?;
        }
        Ok(())
    }
}
impl std::error::Error for ServiceUnavailableError {}
/// See [`ServiceUnavailableError`](crate::error::ServiceUnavailableError)
pub mod service_unavailable_error {
    /// A builder for [`ServiceUnavailableError`](crate::error::ServiceUnavailableError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        retry_after_seconds: std::option::Option<std::string::String>,
        message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn retry_after_seconds(mut self, inp: impl Into<std::string::String>) -> Self {
            self.retry_after_seconds = Some(inp.into());
            self
        }
        pub fn set_retry_after_seconds(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.retry_after_seconds = inp;
            self
        }
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`ServiceUnavailableError`](crate::error::ServiceUnavailableError)
        pub fn build(self) -> crate::error::ServiceUnavailableError {
            crate::error::ServiceUnavailableError {
                retry_after_seconds: self.retry_after_seconds,
                message: self.message,
            }
        }
    }
}
impl ServiceUnavailableError {
    /// Creates a new builder-style object to manufacture [`ServiceUnavailableError`](crate::error::ServiceUnavailableError)
    pub fn builder() -> crate::error::service_unavailable_error::Builder {
        crate::error::service_unavailable_error::Builder::default()
    }
}
