// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Information about a TagOption.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TagOptionDetail {
    /// <p>The TagOption key.</p>
    #[doc(hidden)]
    pub key: std::option::Option<std::string::String>,
    /// <p>The TagOption value.</p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
    /// <p>The TagOption active state.</p>
    #[doc(hidden)]
    pub active: std::option::Option<bool>,
    /// <p>The TagOption identifier.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services account Id of the owner account that created the TagOption.</p>
    #[doc(hidden)]
    pub owner: std::option::Option<std::string::String>,
}
impl TagOptionDetail {
    /// <p>The TagOption key.</p>
    pub fn key(&self) -> std::option::Option<&str> {
        self.key.as_deref()
    }
    /// <p>The TagOption value.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
    /// <p>The TagOption active state.</p>
    pub fn active(&self) -> std::option::Option<bool> {
        self.active
    }
    /// <p>The TagOption identifier.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The Amazon Web Services account Id of the owner account that created the TagOption.</p>
    pub fn owner(&self) -> std::option::Option<&str> {
        self.owner.as_deref()
    }
}
impl TagOptionDetail {
    /// Creates a new builder-style object to manufacture [`TagOptionDetail`](crate::model::TagOptionDetail).
    pub fn builder() -> crate::model::tag_option_detail::Builder {
        crate::model::tag_option_detail::Builder::default()
    }
}

/// See [`TagOptionDetail`](crate::model::TagOptionDetail).
pub mod tag_option_detail {

    /// A builder for [`TagOptionDetail`](crate::model::TagOptionDetail).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
        pub(crate) active: std::option::Option<bool>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) owner: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The TagOption key.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        /// <p>The TagOption key.</p>
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The TagOption value.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The TagOption value.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// <p>The TagOption active state.</p>
        pub fn active(mut self, input: bool) -> Self {
            self.active = Some(input);
            self
        }
        /// <p>The TagOption active state.</p>
        pub fn set_active(mut self, input: std::option::Option<bool>) -> Self {
            self.active = input;
            self
        }
        /// <p>The TagOption identifier.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The TagOption identifier.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The Amazon Web Services account Id of the owner account that created the TagOption.</p>
        pub fn owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services account Id of the owner account that created the TagOption.</p>
        pub fn set_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner = input;
            self
        }
        /// Consumes the builder and constructs a [`TagOptionDetail`](crate::model::TagOptionDetail).
        pub fn build(self) -> crate::model::TagOptionDetail {
            crate::model::TagOptionDetail {
                key: self.key,
                value: self.value,
                active: self.active,
                id: self.id,
                owner: self.owner,
            }
        }
    }
}

/// <p>An object containing detailed information about the self-service action.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ServiceActionDetail {
    /// <p>Summary information about the self-service action.</p>
    #[doc(hidden)]
    pub service_action_summary: std::option::Option<crate::model::ServiceActionSummary>,
    /// <p>A map that defines the self-service action.</p>
    #[doc(hidden)]
    pub definition: std::option::Option<
        std::collections::HashMap<crate::model::ServiceActionDefinitionKey, std::string::String>,
    >,
}
impl ServiceActionDetail {
    /// <p>Summary information about the self-service action.</p>
    pub fn service_action_summary(
        &self,
    ) -> std::option::Option<&crate::model::ServiceActionSummary> {
        self.service_action_summary.as_ref()
    }
    /// <p>A map that defines the self-service action.</p>
    pub fn definition(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<crate::model::ServiceActionDefinitionKey, std::string::String>,
    > {
        self.definition.as_ref()
    }
}
impl ServiceActionDetail {
    /// Creates a new builder-style object to manufacture [`ServiceActionDetail`](crate::model::ServiceActionDetail).
    pub fn builder() -> crate::model::service_action_detail::Builder {
        crate::model::service_action_detail::Builder::default()
    }
}

/// See [`ServiceActionDetail`](crate::model::ServiceActionDetail).
pub mod service_action_detail {

    /// A builder for [`ServiceActionDetail`](crate::model::ServiceActionDetail).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) service_action_summary: std::option::Option<crate::model::ServiceActionSummary>,
        pub(crate) definition: std::option::Option<
            std::collections::HashMap<
                crate::model::ServiceActionDefinitionKey,
                std::string::String,
            >,
        >,
    }
    impl Builder {
        /// <p>Summary information about the self-service action.</p>
        pub fn service_action_summary(mut self, input: crate::model::ServiceActionSummary) -> Self {
            self.service_action_summary = Some(input);
            self
        }
        /// <p>Summary information about the self-service action.</p>
        pub fn set_service_action_summary(
            mut self,
            input: std::option::Option<crate::model::ServiceActionSummary>,
        ) -> Self {
            self.service_action_summary = input;
            self
        }
        /// Adds a key-value pair to `definition`.
        ///
        /// To override the contents of this collection use [`set_definition`](Self::set_definition).
        ///
        /// <p>A map that defines the self-service action.</p>
        pub fn definition(
            mut self,
            k: crate::model::ServiceActionDefinitionKey,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.definition.unwrap_or_default();
            hash_map.insert(k, v.into());
            self.definition = Some(hash_map);
            self
        }
        /// <p>A map that defines the self-service action.</p>
        pub fn set_definition(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<
                    crate::model::ServiceActionDefinitionKey,
                    std::string::String,
                >,
            >,
        ) -> Self {
            self.definition = input;
            self
        }
        /// Consumes the builder and constructs a [`ServiceActionDetail`](crate::model::ServiceActionDetail).
        pub fn build(self) -> crate::model::ServiceActionDetail {
            crate::model::ServiceActionDetail {
                service_action_summary: self.service_action_summary,
                definition: self.definition,
            }
        }
    }
}

/// When writing a match expression against `ServiceActionDefinitionKey`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let serviceactiondefinitionkey = unimplemented!();
/// match serviceactiondefinitionkey {
///     ServiceActionDefinitionKey::AssumeRole => { /* ... */ },
///     ServiceActionDefinitionKey::Name => { /* ... */ },
///     ServiceActionDefinitionKey::Parameters => { /* ... */ },
///     ServiceActionDefinitionKey::Version => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `serviceactiondefinitionkey` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ServiceActionDefinitionKey::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ServiceActionDefinitionKey::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ServiceActionDefinitionKey::NewFeature` is defined.
/// Specifically, when `serviceactiondefinitionkey` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ServiceActionDefinitionKey::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ServiceActionDefinitionKey {
    #[allow(missing_docs)] // documentation missing in model
    AssumeRole,
    #[allow(missing_docs)] // documentation missing in model
    Name,
    #[allow(missing_docs)] // documentation missing in model
    Parameters,
    #[allow(missing_docs)] // documentation missing in model
    Version,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ServiceActionDefinitionKey {
    fn from(s: &str) -> Self {
        match s {
            "AssumeRole" => ServiceActionDefinitionKey::AssumeRole,
            "Name" => ServiceActionDefinitionKey::Name,
            "Parameters" => ServiceActionDefinitionKey::Parameters,
            "Version" => ServiceActionDefinitionKey::Version,
            other => ServiceActionDefinitionKey::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for ServiceActionDefinitionKey {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ServiceActionDefinitionKey::from(s))
    }
}
impl ServiceActionDefinitionKey {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ServiceActionDefinitionKey::AssumeRole => "AssumeRole",
            ServiceActionDefinitionKey::Name => "Name",
            ServiceActionDefinitionKey::Parameters => "Parameters",
            ServiceActionDefinitionKey::Version => "Version",
            ServiceActionDefinitionKey::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["AssumeRole", "Name", "Parameters", "Version"]
    }
}
impl AsRef<str> for ServiceActionDefinitionKey {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Detailed information about the self-service action.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ServiceActionSummary {
    /// <p>The self-service action identifier.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The self-service action name.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The self-service action description.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The self-service action definition type. For example, <code>SSM_AUTOMATION</code>.</p>
    #[doc(hidden)]
    pub definition_type: std::option::Option<crate::model::ServiceActionDefinitionType>,
}
impl ServiceActionSummary {
    /// <p>The self-service action identifier.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The self-service action name.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The self-service action description.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The self-service action definition type. For example, <code>SSM_AUTOMATION</code>.</p>
    pub fn definition_type(
        &self,
    ) -> std::option::Option<&crate::model::ServiceActionDefinitionType> {
        self.definition_type.as_ref()
    }
}
impl ServiceActionSummary {
    /// Creates a new builder-style object to manufacture [`ServiceActionSummary`](crate::model::ServiceActionSummary).
    pub fn builder() -> crate::model::service_action_summary::Builder {
        crate::model::service_action_summary::Builder::default()
    }
}

/// See [`ServiceActionSummary`](crate::model::ServiceActionSummary).
pub mod service_action_summary {

    /// A builder for [`ServiceActionSummary`](crate::model::ServiceActionSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) definition_type: std::option::Option<crate::model::ServiceActionDefinitionType>,
    }
    impl Builder {
        /// <p>The self-service action identifier.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The self-service action identifier.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The self-service action name.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The self-service action name.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The self-service action description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The self-service action description.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The self-service action definition type. For example, <code>SSM_AUTOMATION</code>.</p>
        pub fn definition_type(mut self, input: crate::model::ServiceActionDefinitionType) -> Self {
            self.definition_type = Some(input);
            self
        }
        /// <p>The self-service action definition type. For example, <code>SSM_AUTOMATION</code>.</p>
        pub fn set_definition_type(
            mut self,
            input: std::option::Option<crate::model::ServiceActionDefinitionType>,
        ) -> Self {
            self.definition_type = input;
            self
        }
        /// Consumes the builder and constructs a [`ServiceActionSummary`](crate::model::ServiceActionSummary).
        pub fn build(self) -> crate::model::ServiceActionSummary {
            crate::model::ServiceActionSummary {
                id: self.id,
                name: self.name,
                description: self.description,
                definition_type: self.definition_type,
            }
        }
    }
}

/// When writing a match expression against `ServiceActionDefinitionType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let serviceactiondefinitiontype = unimplemented!();
/// match serviceactiondefinitiontype {
///     ServiceActionDefinitionType::SsmAutomation => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `serviceactiondefinitiontype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ServiceActionDefinitionType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ServiceActionDefinitionType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ServiceActionDefinitionType::NewFeature` is defined.
/// Specifically, when `serviceactiondefinitiontype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ServiceActionDefinitionType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ServiceActionDefinitionType {
    #[allow(missing_docs)] // documentation missing in model
    SsmAutomation,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ServiceActionDefinitionType {
    fn from(s: &str) -> Self {
        match s {
            "SSM_AUTOMATION" => ServiceActionDefinitionType::SsmAutomation,
            other => ServiceActionDefinitionType::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for ServiceActionDefinitionType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ServiceActionDefinitionType::from(s))
    }
}
impl ServiceActionDefinitionType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ServiceActionDefinitionType::SsmAutomation => "SSM_AUTOMATION",
            ServiceActionDefinitionType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["SSM_AUTOMATION"]
    }
}
impl AsRef<str> for ServiceActionDefinitionType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `Status`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let status = unimplemented!();
/// match status {
///     Status::Available => { /* ... */ },
///     Status::Creating => { /* ... */ },
///     Status::Failed => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `status` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Status::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Status::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Status::NewFeature` is defined.
/// Specifically, when `status` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Status::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Status {
    #[allow(missing_docs)] // documentation missing in model
    Available,
    #[allow(missing_docs)] // documentation missing in model
    Creating,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Status {
    fn from(s: &str) -> Self {
        match s {
            "AVAILABLE" => Status::Available,
            "CREATING" => Status::Creating,
            "FAILED" => Status::Failed,
            other => Status::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Status {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Status::from(s))
    }
}
impl Status {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Status::Available => "AVAILABLE",
            Status::Creating => "CREATING",
            Status::Failed => "FAILED",
            Status::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["AVAILABLE", "CREATING", "FAILED"]
    }
}
impl AsRef<str> for Status {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about a provisioning artifact (also known as a version) for a product.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ProvisioningArtifactDetail {
    /// <p>The identifier of the provisioning artifact.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The name of the provisioning artifact.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The description of the provisioning artifact.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The type of provisioning artifact.</p>
    /// <ul>
    /// <li> <p> <code>CLOUD_FORMATION_TEMPLATE</code> - CloudFormation template</p> </li>
    /// <li> <p> <code>MARKETPLACE_AMI</code> - Amazon Web Services Marketplace AMI</p> </li>
    /// <li> <p> <code>MARKETPLACE_CAR</code> - Amazon Web Services Marketplace Clusters and Amazon Web Services Resources</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::ProvisioningArtifactType>,
    /// <p>The UTC time stamp of the creation time.</p>
    #[doc(hidden)]
    pub created_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Indicates whether the product version is active.</p>
    #[doc(hidden)]
    pub active: std::option::Option<bool>,
    /// <p>Information set by the administrator to provide guidance to end users about which provisioning artifacts to use.</p>
    #[doc(hidden)]
    pub guidance: std::option::Option<crate::model::ProvisioningArtifactGuidance>,
    /// <p>Specifies the revision of the external artifact that was used to automatically sync the Service Catalog product and create the provisioning artifact. Service Catalog includes this response parameter as a high level field to the existing <code>ProvisioningArtifactDetail</code> type, which is returned as part of the response for <code>CreateProduct</code>, <code>UpdateProduct</code>, <code>DescribeProductAsAdmin</code>, <code>DescribeProvisioningArtifact</code>, <code>ListProvisioningArtifact</code>, and <code>UpdateProvisioningArticat</code> APIs. </p>
    /// <p>This field only exists for Repo-Synced products. </p>
    #[doc(hidden)]
    pub source_revision: std::option::Option<std::string::String>,
}
impl ProvisioningArtifactDetail {
    /// <p>The identifier of the provisioning artifact.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The name of the provisioning artifact.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The description of the provisioning artifact.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The type of provisioning artifact.</p>
    /// <ul>
    /// <li> <p> <code>CLOUD_FORMATION_TEMPLATE</code> - CloudFormation template</p> </li>
    /// <li> <p> <code>MARKETPLACE_AMI</code> - Amazon Web Services Marketplace AMI</p> </li>
    /// <li> <p> <code>MARKETPLACE_CAR</code> - Amazon Web Services Marketplace Clusters and Amazon Web Services Resources</p> </li>
    /// </ul>
    pub fn r#type(&self) -> std::option::Option<&crate::model::ProvisioningArtifactType> {
        self.r#type.as_ref()
    }
    /// <p>The UTC time stamp of the creation time.</p>
    pub fn created_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_time.as_ref()
    }
    /// <p>Indicates whether the product version is active.</p>
    pub fn active(&self) -> std::option::Option<bool> {
        self.active
    }
    /// <p>Information set by the administrator to provide guidance to end users about which provisioning artifacts to use.</p>
    pub fn guidance(&self) -> std::option::Option<&crate::model::ProvisioningArtifactGuidance> {
        self.guidance.as_ref()
    }
    /// <p>Specifies the revision of the external artifact that was used to automatically sync the Service Catalog product and create the provisioning artifact. Service Catalog includes this response parameter as a high level field to the existing <code>ProvisioningArtifactDetail</code> type, which is returned as part of the response for <code>CreateProduct</code>, <code>UpdateProduct</code>, <code>DescribeProductAsAdmin</code>, <code>DescribeProvisioningArtifact</code>, <code>ListProvisioningArtifact</code>, and <code>UpdateProvisioningArticat</code> APIs. </p>
    /// <p>This field only exists for Repo-Synced products. </p>
    pub fn source_revision(&self) -> std::option::Option<&str> {
        self.source_revision.as_deref()
    }
}
impl ProvisioningArtifactDetail {
    /// Creates a new builder-style object to manufacture [`ProvisioningArtifactDetail`](crate::model::ProvisioningArtifactDetail).
    pub fn builder() -> crate::model::provisioning_artifact_detail::Builder {
        crate::model::provisioning_artifact_detail::Builder::default()
    }
}

/// See [`ProvisioningArtifactDetail`](crate::model::ProvisioningArtifactDetail).
pub mod provisioning_artifact_detail {

    /// A builder for [`ProvisioningArtifactDetail`](crate::model::ProvisioningArtifactDetail).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::ProvisioningArtifactType>,
        pub(crate) created_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) active: std::option::Option<bool>,
        pub(crate) guidance: std::option::Option<crate::model::ProvisioningArtifactGuidance>,
        pub(crate) source_revision: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the provisioning artifact.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of the provisioning artifact.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The name of the provisioning artifact.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the provisioning artifact.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The description of the provisioning artifact.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the provisioning artifact.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The type of provisioning artifact.</p>
        /// <ul>
        /// <li> <p> <code>CLOUD_FORMATION_TEMPLATE</code> - CloudFormation template</p> </li>
        /// <li> <p> <code>MARKETPLACE_AMI</code> - Amazon Web Services Marketplace AMI</p> </li>
        /// <li> <p> <code>MARKETPLACE_CAR</code> - Amazon Web Services Marketplace Clusters and Amazon Web Services Resources</p> </li>
        /// </ul>
        pub fn r#type(mut self, input: crate::model::ProvisioningArtifactType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of provisioning artifact.</p>
        /// <ul>
        /// <li> <p> <code>CLOUD_FORMATION_TEMPLATE</code> - CloudFormation template</p> </li>
        /// <li> <p> <code>MARKETPLACE_AMI</code> - Amazon Web Services Marketplace AMI</p> </li>
        /// <li> <p> <code>MARKETPLACE_CAR</code> - Amazon Web Services Marketplace Clusters and Amazon Web Services Resources</p> </li>
        /// </ul>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::ProvisioningArtifactType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The UTC time stamp of the creation time.</p>
        pub fn created_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_time = Some(input);
            self
        }
        /// <p>The UTC time stamp of the creation time.</p>
        pub fn set_created_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_time = input;
            self
        }
        /// <p>Indicates whether the product version is active.</p>
        pub fn active(mut self, input: bool) -> Self {
            self.active = Some(input);
            self
        }
        /// <p>Indicates whether the product version is active.</p>
        pub fn set_active(mut self, input: std::option::Option<bool>) -> Self {
            self.active = input;
            self
        }
        /// <p>Information set by the administrator to provide guidance to end users about which provisioning artifacts to use.</p>
        pub fn guidance(mut self, input: crate::model::ProvisioningArtifactGuidance) -> Self {
            self.guidance = Some(input);
            self
        }
        /// <p>Information set by the administrator to provide guidance to end users about which provisioning artifacts to use.</p>
        pub fn set_guidance(
            mut self,
            input: std::option::Option<crate::model::ProvisioningArtifactGuidance>,
        ) -> Self {
            self.guidance = input;
            self
        }
        /// <p>Specifies the revision of the external artifact that was used to automatically sync the Service Catalog product and create the provisioning artifact. Service Catalog includes this response parameter as a high level field to the existing <code>ProvisioningArtifactDetail</code> type, which is returned as part of the response for <code>CreateProduct</code>, <code>UpdateProduct</code>, <code>DescribeProductAsAdmin</code>, <code>DescribeProvisioningArtifact</code>, <code>ListProvisioningArtifact</code>, and <code>UpdateProvisioningArticat</code> APIs. </p>
        /// <p>This field only exists for Repo-Synced products. </p>
        pub fn source_revision(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_revision = Some(input.into());
            self
        }
        /// <p>Specifies the revision of the external artifact that was used to automatically sync the Service Catalog product and create the provisioning artifact. Service Catalog includes this response parameter as a high level field to the existing <code>ProvisioningArtifactDetail</code> type, which is returned as part of the response for <code>CreateProduct</code>, <code>UpdateProduct</code>, <code>DescribeProductAsAdmin</code>, <code>DescribeProvisioningArtifact</code>, <code>ListProvisioningArtifact</code>, and <code>UpdateProvisioningArticat</code> APIs. </p>
        /// <p>This field only exists for Repo-Synced products. </p>
        pub fn set_source_revision(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_revision = input;
            self
        }
        /// Consumes the builder and constructs a [`ProvisioningArtifactDetail`](crate::model::ProvisioningArtifactDetail).
        pub fn build(self) -> crate::model::ProvisioningArtifactDetail {
            crate::model::ProvisioningArtifactDetail {
                id: self.id,
                name: self.name,
                description: self.description,
                r#type: self.r#type,
                created_time: self.created_time,
                active: self.active,
                guidance: self.guidance,
                source_revision: self.source_revision,
            }
        }
    }
}

/// When writing a match expression against `ProvisioningArtifactGuidance`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let provisioningartifactguidance = unimplemented!();
/// match provisioningartifactguidance {
///     ProvisioningArtifactGuidance::Default => { /* ... */ },
///     ProvisioningArtifactGuidance::Deprecated => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `provisioningartifactguidance` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ProvisioningArtifactGuidance::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ProvisioningArtifactGuidance::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ProvisioningArtifactGuidance::NewFeature` is defined.
/// Specifically, when `provisioningartifactguidance` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ProvisioningArtifactGuidance::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ProvisioningArtifactGuidance {
    #[allow(missing_docs)] // documentation missing in model
    Default,
    #[allow(missing_docs)] // documentation missing in model
    Deprecated,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ProvisioningArtifactGuidance {
    fn from(s: &str) -> Self {
        match s {
            "DEFAULT" => ProvisioningArtifactGuidance::Default,
            "DEPRECATED" => ProvisioningArtifactGuidance::Deprecated,
            other => ProvisioningArtifactGuidance::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for ProvisioningArtifactGuidance {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ProvisioningArtifactGuidance::from(s))
    }
}
impl ProvisioningArtifactGuidance {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ProvisioningArtifactGuidance::Default => "DEFAULT",
            ProvisioningArtifactGuidance::Deprecated => "DEPRECATED",
            ProvisioningArtifactGuidance::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DEFAULT", "DEPRECATED"]
    }
}
impl AsRef<str> for ProvisioningArtifactGuidance {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ProvisioningArtifactType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let provisioningartifacttype = unimplemented!();
/// match provisioningartifacttype {
///     ProvisioningArtifactType::CloudFormationTemplate => { /* ... */ },
///     ProvisioningArtifactType::MarketplaceAmi => { /* ... */ },
///     ProvisioningArtifactType::MarketplaceCar => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `provisioningartifacttype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ProvisioningArtifactType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ProvisioningArtifactType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ProvisioningArtifactType::NewFeature` is defined.
/// Specifically, when `provisioningartifacttype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ProvisioningArtifactType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ProvisioningArtifactType {
    #[allow(missing_docs)] // documentation missing in model
    CloudFormationTemplate,
    #[allow(missing_docs)] // documentation missing in model
    MarketplaceAmi,
    #[allow(missing_docs)] // documentation missing in model
    MarketplaceCar,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ProvisioningArtifactType {
    fn from(s: &str) -> Self {
        match s {
            "CLOUD_FORMATION_TEMPLATE" => ProvisioningArtifactType::CloudFormationTemplate,
            "MARKETPLACE_AMI" => ProvisioningArtifactType::MarketplaceAmi,
            "MARKETPLACE_CAR" => ProvisioningArtifactType::MarketplaceCar,
            other => ProvisioningArtifactType::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for ProvisioningArtifactType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ProvisioningArtifactType::from(s))
    }
}
impl ProvisioningArtifactType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ProvisioningArtifactType::CloudFormationTemplate => "CLOUD_FORMATION_TEMPLATE",
            ProvisioningArtifactType::MarketplaceAmi => "MARKETPLACE_AMI",
            ProvisioningArtifactType::MarketplaceCar => "MARKETPLACE_CAR",
            ProvisioningArtifactType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CLOUD_FORMATION_TEMPLATE",
            "MARKETPLACE_AMI",
            "MARKETPLACE_CAR",
        ]
    }
}
impl AsRef<str> for ProvisioningArtifactType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `RecordStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let recordstatus = unimplemented!();
/// match recordstatus {
///     RecordStatus::Created => { /* ... */ },
///     RecordStatus::Failed => { /* ... */ },
///     RecordStatus::InProgress => { /* ... */ },
///     RecordStatus::InProgressInError => { /* ... */ },
///     RecordStatus::Succeeded => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `recordstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `RecordStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `RecordStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `RecordStatus::NewFeature` is defined.
/// Specifically, when `recordstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `RecordStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RecordStatus {
    #[allow(missing_docs)] // documentation missing in model
    Created,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    #[allow(missing_docs)] // documentation missing in model
    InProgressInError,
    #[allow(missing_docs)] // documentation missing in model
    Succeeded,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for RecordStatus {
    fn from(s: &str) -> Self {
        match s {
            "CREATED" => RecordStatus::Created,
            "FAILED" => RecordStatus::Failed,
            "IN_PROGRESS" => RecordStatus::InProgress,
            "IN_PROGRESS_IN_ERROR" => RecordStatus::InProgressInError,
            "SUCCEEDED" => RecordStatus::Succeeded,
            other => RecordStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for RecordStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RecordStatus::from(s))
    }
}
impl RecordStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            RecordStatus::Created => "CREATED",
            RecordStatus::Failed => "FAILED",
            RecordStatus::InProgress => "IN_PROGRESS",
            RecordStatus::InProgressInError => "IN_PROGRESS_IN_ERROR",
            RecordStatus::Succeeded => "SUCCEEDED",
            RecordStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CREATED",
            "FAILED",
            "IN_PROGRESS",
            "IN_PROGRESS_IN_ERROR",
            "SUCCEEDED",
        ]
    }
}
impl AsRef<str> for RecordStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `PropertyKey`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let propertykey = unimplemented!();
/// match propertykey {
///     PropertyKey::LaunchRole => { /* ... */ },
///     PropertyKey::Owner => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `propertykey` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PropertyKey::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PropertyKey::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PropertyKey::NewFeature` is defined.
/// Specifically, when `propertykey` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PropertyKey::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PropertyKey {
    #[allow(missing_docs)] // documentation missing in model
    LaunchRole,
    #[allow(missing_docs)] // documentation missing in model
    Owner,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PropertyKey {
    fn from(s: &str) -> Self {
        match s {
            "LAUNCH_ROLE" => PropertyKey::LaunchRole,
            "OWNER" => PropertyKey::Owner,
            other => PropertyKey::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for PropertyKey {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PropertyKey::from(s))
    }
}
impl PropertyKey {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PropertyKey::LaunchRole => "LAUNCH_ROLE",
            PropertyKey::Owner => "OWNER",
            PropertyKey::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["LAUNCH_ROLE", "OWNER"]
    }
}
impl AsRef<str> for PropertyKey {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about a request operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RecordDetail {
    /// <p>The identifier of the record.</p>
    #[doc(hidden)]
    pub record_id: std::option::Option<std::string::String>,
    /// <p>The user-friendly name of the provisioned product.</p>
    #[doc(hidden)]
    pub provisioned_product_name: std::option::Option<std::string::String>,
    /// <p>The status of the provisioned product.</p>
    /// <ul>
    /// <li> <p> <code>CREATED</code> - The request was created but the operation has not started.</p> </li>
    /// <li> <p> <code>IN_PROGRESS</code> - The requested operation is in progress.</p> </li>
    /// <li> <p> <code>IN_PROGRESS_IN_ERROR</code> - The provisioned product is under change but the requested operation failed and some remediation is occurring. For example, a rollback.</p> </li>
    /// <li> <p> <code>SUCCEEDED</code> - The requested operation has successfully completed.</p> </li>
    /// <li> <p> <code>FAILED</code> - The requested operation has unsuccessfully completed. Investigate using the error messages returned.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::RecordStatus>,
    /// <p>The UTC time stamp of the creation time.</p>
    #[doc(hidden)]
    pub created_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time when the record was last updated.</p>
    #[doc(hidden)]
    pub updated_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The type of provisioned product. The supported values are <code>CFN_STACK</code> and <code>CFN_STACKSET</code>.</p>
    #[doc(hidden)]
    pub provisioned_product_type: std::option::Option<std::string::String>,
    /// <p>The record type.</p>
    /// <ul>
    /// <li> <p> <code>PROVISION_PRODUCT</code> </p> </li>
    /// <li> <p> <code>UPDATE_PROVISIONED_PRODUCT</code> </p> </li>
    /// <li> <p> <code>TERMINATE_PROVISIONED_PRODUCT</code> </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub record_type: std::option::Option<std::string::String>,
    /// <p>The identifier of the provisioned product.</p>
    #[doc(hidden)]
    pub provisioned_product_id: std::option::Option<std::string::String>,
    /// <p>The product identifier.</p>
    #[doc(hidden)]
    pub product_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the provisioning artifact.</p>
    #[doc(hidden)]
    pub provisioning_artifact_id: std::option::Option<std::string::String>,
    /// <p>The path identifier.</p>
    #[doc(hidden)]
    pub path_id: std::option::Option<std::string::String>,
    /// <p>The errors that occurred.</p>
    #[doc(hidden)]
    pub record_errors: std::option::Option<std::vec::Vec<crate::model::RecordError>>,
    /// <p>One or more tags.</p>
    #[doc(hidden)]
    pub record_tags: std::option::Option<std::vec::Vec<crate::model::RecordTag>>,
    /// <p>The ARN of the launch role associated with the provisioned product.</p>
    #[doc(hidden)]
    pub launch_role_arn: std::option::Option<std::string::String>,
}
impl RecordDetail {
    /// <p>The identifier of the record.</p>
    pub fn record_id(&self) -> std::option::Option<&str> {
        self.record_id.as_deref()
    }
    /// <p>The user-friendly name of the provisioned product.</p>
    pub fn provisioned_product_name(&self) -> std::option::Option<&str> {
        self.provisioned_product_name.as_deref()
    }
    /// <p>The status of the provisioned product.</p>
    /// <ul>
    /// <li> <p> <code>CREATED</code> - The request was created but the operation has not started.</p> </li>
    /// <li> <p> <code>IN_PROGRESS</code> - The requested operation is in progress.</p> </li>
    /// <li> <p> <code>IN_PROGRESS_IN_ERROR</code> - The provisioned product is under change but the requested operation failed and some remediation is occurring. For example, a rollback.</p> </li>
    /// <li> <p> <code>SUCCEEDED</code> - The requested operation has successfully completed.</p> </li>
    /// <li> <p> <code>FAILED</code> - The requested operation has unsuccessfully completed. Investigate using the error messages returned.</p> </li>
    /// </ul>
    pub fn status(&self) -> std::option::Option<&crate::model::RecordStatus> {
        self.status.as_ref()
    }
    /// <p>The UTC time stamp of the creation time.</p>
    pub fn created_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_time.as_ref()
    }
    /// <p>The time when the record was last updated.</p>
    pub fn updated_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.updated_time.as_ref()
    }
    /// <p>The type of provisioned product. The supported values are <code>CFN_STACK</code> and <code>CFN_STACKSET</code>.</p>
    pub fn provisioned_product_type(&self) -> std::option::Option<&str> {
        self.provisioned_product_type.as_deref()
    }
    /// <p>The record type.</p>
    /// <ul>
    /// <li> <p> <code>PROVISION_PRODUCT</code> </p> </li>
    /// <li> <p> <code>UPDATE_PROVISIONED_PRODUCT</code> </p> </li>
    /// <li> <p> <code>TERMINATE_PROVISIONED_PRODUCT</code> </p> </li>
    /// </ul>
    pub fn record_type(&self) -> std::option::Option<&str> {
        self.record_type.as_deref()
    }
    /// <p>The identifier of the provisioned product.</p>
    pub fn provisioned_product_id(&self) -> std::option::Option<&str> {
        self.provisioned_product_id.as_deref()
    }
    /// <p>The product identifier.</p>
    pub fn product_id(&self) -> std::option::Option<&str> {
        self.product_id.as_deref()
    }
    /// <p>The identifier of the provisioning artifact.</p>
    pub fn provisioning_artifact_id(&self) -> std::option::Option<&str> {
        self.provisioning_artifact_id.as_deref()
    }
    /// <p>The path identifier.</p>
    pub fn path_id(&self) -> std::option::Option<&str> {
        self.path_id.as_deref()
    }
    /// <p>The errors that occurred.</p>
    pub fn record_errors(&self) -> std::option::Option<&[crate::model::RecordError]> {
        self.record_errors.as_deref()
    }
    /// <p>One or more tags.</p>
    pub fn record_tags(&self) -> std::option::Option<&[crate::model::RecordTag]> {
        self.record_tags.as_deref()
    }
    /// <p>The ARN of the launch role associated with the provisioned product.</p>
    pub fn launch_role_arn(&self) -> std::option::Option<&str> {
        self.launch_role_arn.as_deref()
    }
}
impl RecordDetail {
    /// Creates a new builder-style object to manufacture [`RecordDetail`](crate::model::RecordDetail).
    pub fn builder() -> crate::model::record_detail::Builder {
        crate::model::record_detail::Builder::default()
    }
}

/// See [`RecordDetail`](crate::model::RecordDetail).
pub mod record_detail {

    /// A builder for [`RecordDetail`](crate::model::RecordDetail).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) record_id: std::option::Option<std::string::String>,
        pub(crate) provisioned_product_name: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::RecordStatus>,
        pub(crate) created_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) updated_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) provisioned_product_type: std::option::Option<std::string::String>,
        pub(crate) record_type: std::option::Option<std::string::String>,
        pub(crate) provisioned_product_id: std::option::Option<std::string::String>,
        pub(crate) product_id: std::option::Option<std::string::String>,
        pub(crate) provisioning_artifact_id: std::option::Option<std::string::String>,
        pub(crate) path_id: std::option::Option<std::string::String>,
        pub(crate) record_errors: std::option::Option<std::vec::Vec<crate::model::RecordError>>,
        pub(crate) record_tags: std::option::Option<std::vec::Vec<crate::model::RecordTag>>,
        pub(crate) launch_role_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the record.</p>
        pub fn record_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.record_id = Some(input.into());
            self
        }
        /// <p>The identifier of the record.</p>
        pub fn set_record_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.record_id = input;
            self
        }
        /// <p>The user-friendly name of the provisioned product.</p>
        pub fn provisioned_product_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.provisioned_product_name = Some(input.into());
            self
        }
        /// <p>The user-friendly name of the provisioned product.</p>
        pub fn set_provisioned_product_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.provisioned_product_name = input;
            self
        }
        /// <p>The status of the provisioned product.</p>
        /// <ul>
        /// <li> <p> <code>CREATED</code> - The request was created but the operation has not started.</p> </li>
        /// <li> <p> <code>IN_PROGRESS</code> - The requested operation is in progress.</p> </li>
        /// <li> <p> <code>IN_PROGRESS_IN_ERROR</code> - The provisioned product is under change but the requested operation failed and some remediation is occurring. For example, a rollback.</p> </li>
        /// <li> <p> <code>SUCCEEDED</code> - The requested operation has successfully completed.</p> </li>
        /// <li> <p> <code>FAILED</code> - The requested operation has unsuccessfully completed. Investigate using the error messages returned.</p> </li>
        /// </ul>
        pub fn status(mut self, input: crate::model::RecordStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the provisioned product.</p>
        /// <ul>
        /// <li> <p> <code>CREATED</code> - The request was created but the operation has not started.</p> </li>
        /// <li> <p> <code>IN_PROGRESS</code> - The requested operation is in progress.</p> </li>
        /// <li> <p> <code>IN_PROGRESS_IN_ERROR</code> - The provisioned product is under change but the requested operation failed and some remediation is occurring. For example, a rollback.</p> </li>
        /// <li> <p> <code>SUCCEEDED</code> - The requested operation has successfully completed.</p> </li>
        /// <li> <p> <code>FAILED</code> - The requested operation has unsuccessfully completed. Investigate using the error messages returned.</p> </li>
        /// </ul>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::RecordStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The UTC time stamp of the creation time.</p>
        pub fn created_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_time = Some(input);
            self
        }
        /// <p>The UTC time stamp of the creation time.</p>
        pub fn set_created_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_time = input;
            self
        }
        /// <p>The time when the record was last updated.</p>
        pub fn updated_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.updated_time = Some(input);
            self
        }
        /// <p>The time when the record was last updated.</p>
        pub fn set_updated_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.updated_time = input;
            self
        }
        /// <p>The type of provisioned product. The supported values are <code>CFN_STACK</code> and <code>CFN_STACKSET</code>.</p>
        pub fn provisioned_product_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.provisioned_product_type = Some(input.into());
            self
        }
        /// <p>The type of provisioned product. The supported values are <code>CFN_STACK</code> and <code>CFN_STACKSET</code>.</p>
        pub fn set_provisioned_product_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.provisioned_product_type = input;
            self
        }
        /// <p>The record type.</p>
        /// <ul>
        /// <li> <p> <code>PROVISION_PRODUCT</code> </p> </li>
        /// <li> <p> <code>UPDATE_PROVISIONED_PRODUCT</code> </p> </li>
        /// <li> <p> <code>TERMINATE_PROVISIONED_PRODUCT</code> </p> </li>
        /// </ul>
        pub fn record_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.record_type = Some(input.into());
            self
        }
        /// <p>The record type.</p>
        /// <ul>
        /// <li> <p> <code>PROVISION_PRODUCT</code> </p> </li>
        /// <li> <p> <code>UPDATE_PROVISIONED_PRODUCT</code> </p> </li>
        /// <li> <p> <code>TERMINATE_PROVISIONED_PRODUCT</code> </p> </li>
        /// </ul>
        pub fn set_record_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.record_type = input;
            self
        }
        /// <p>The identifier of the provisioned product.</p>
        pub fn provisioned_product_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.provisioned_product_id = Some(input.into());
            self
        }
        /// <p>The identifier of the provisioned product.</p>
        pub fn set_provisioned_product_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.provisioned_product_id = input;
            self
        }
        /// <p>The product identifier.</p>
        pub fn product_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.product_id = Some(input.into());
            self
        }
        /// <p>The product identifier.</p>
        pub fn set_product_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.product_id = input;
            self
        }
        /// <p>The identifier of the provisioning artifact.</p>
        pub fn provisioning_artifact_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.provisioning_artifact_id = Some(input.into());
            self
        }
        /// <p>The identifier of the provisioning artifact.</p>
        pub fn set_provisioning_artifact_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.provisioning_artifact_id = input;
            self
        }
        /// <p>The path identifier.</p>
        pub fn path_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.path_id = Some(input.into());
            self
        }
        /// <p>The path identifier.</p>
        pub fn set_path_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.path_id = input;
            self
        }
        /// Appends an item to `record_errors`.
        ///
        /// To override the contents of this collection use [`set_record_errors`](Self::set_record_errors).
        ///
        /// <p>The errors that occurred.</p>
        pub fn record_errors(mut self, input: crate::model::RecordError) -> Self {
            let mut v = self.record_errors.unwrap_or_default();
            v.push(input);
            self.record_errors = Some(v);
            self
        }
        /// <p>The errors that occurred.</p>
        pub fn set_record_errors(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RecordError>>,
        ) -> Self {
            self.record_errors = input;
            self
        }
        /// Appends an item to `record_tags`.
        ///
        /// To override the contents of this collection use [`set_record_tags`](Self::set_record_tags).
        ///
        /// <p>One or more tags.</p>
        pub fn record_tags(mut self, input: crate::model::RecordTag) -> Self {
            let mut v = self.record_tags.unwrap_or_default();
            v.push(input);
            self.record_tags = Some(v);
            self
        }
        /// <p>One or more tags.</p>
        pub fn set_record_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RecordTag>>,
        ) -> Self {
            self.record_tags = input;
            self
        }
        /// <p>The ARN of the launch role associated with the provisioned product.</p>
        pub fn launch_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.launch_role_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the launch role associated with the provisioned product.</p>
        pub fn set_launch_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.launch_role_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`RecordDetail`](crate::model::RecordDetail).
        pub fn build(self) -> crate::model::RecordDetail {
            crate::model::RecordDetail {
                record_id: self.record_id,
                provisioned_product_name: self.provisioned_product_name,
                status: self.status,
                created_time: self.created_time,
                updated_time: self.updated_time,
                provisioned_product_type: self.provisioned_product_type,
                record_type: self.record_type,
                provisioned_product_id: self.provisioned_product_id,
                product_id: self.product_id,
                provisioning_artifact_id: self.provisioning_artifact_id,
                path_id: self.path_id,
                record_errors: self.record_errors,
                record_tags: self.record_tags,
                launch_role_arn: self.launch_role_arn,
            }
        }
    }
}

/// <p>Information about a tag, which is a key-value pair.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RecordTag {
    /// <p>The key for this tag.</p>
    #[doc(hidden)]
    pub key: std::option::Option<std::string::String>,
    /// <p>The value for this tag.</p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
}
impl RecordTag {
    /// <p>The key for this tag.</p>
    pub fn key(&self) -> std::option::Option<&str> {
        self.key.as_deref()
    }
    /// <p>The value for this tag.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
impl RecordTag {
    /// Creates a new builder-style object to manufacture [`RecordTag`](crate::model::RecordTag).
    pub fn builder() -> crate::model::record_tag::Builder {
        crate::model::record_tag::Builder::default()
    }
}

/// See [`RecordTag`](crate::model::RecordTag).
pub mod record_tag {

    /// A builder for [`RecordTag`](crate::model::RecordTag).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The key for this tag.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        /// <p>The key for this tag.</p>
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The value for this tag.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The value for this tag.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`RecordTag`](crate::model::RecordTag).
        pub fn build(self) -> crate::model::RecordTag {
            crate::model::RecordTag {
                key: self.key,
                value: self.value,
            }
        }
    }
}

/// <p>The error code and description resulting from an operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RecordError {
    /// <p>The numeric value of the error.</p>
    #[doc(hidden)]
    pub code: std::option::Option<std::string::String>,
    /// <p>The description of the error.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
}
impl RecordError {
    /// <p>The numeric value of the error.</p>
    pub fn code(&self) -> std::option::Option<&str> {
        self.code.as_deref()
    }
    /// <p>The description of the error.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
}
impl RecordError {
    /// Creates a new builder-style object to manufacture [`RecordError`](crate::model::RecordError).
    pub fn builder() -> crate::model::record_error::Builder {
        crate::model::record_error::Builder::default()
    }
}

/// See [`RecordError`](crate::model::RecordError).
pub mod record_error {

    /// A builder for [`RecordError`](crate::model::RecordError).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The numeric value of the error.</p>
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        /// <p>The numeric value of the error.</p>
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// <p>The description of the error.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the error.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Consumes the builder and constructs a [`RecordError`](crate::model::RecordError).
        pub fn build(self) -> crate::model::RecordError {
            crate::model::RecordError {
                code: self.code,
                description: self.description,
            }
        }
    }
}

/// <p>Information about a tag. A tag is a key-value pair. Tags are propagated to the resources created when provisioning a product.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Tag {
    /// <p>The tag key.</p>
    #[doc(hidden)]
    pub key: std::option::Option<std::string::String>,
    /// <p>The value for this key.</p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
}
impl Tag {
    /// <p>The tag key.</p>
    pub fn key(&self) -> std::option::Option<&str> {
        self.key.as_deref()
    }
    /// <p>The value for this key.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
impl Tag {
    /// Creates a new builder-style object to manufacture [`Tag`](crate::model::Tag).
    pub fn builder() -> crate::model::tag::Builder {
        crate::model::tag::Builder::default()
    }
}

/// See [`Tag`](crate::model::Tag).
pub mod tag {

    /// A builder for [`Tag`](crate::model::Tag).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The tag key.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        /// <p>The tag key.</p>
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The value for this key.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The value for this key.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`Tag`](crate::model::Tag).
        pub fn build(self) -> crate::model::Tag {
            crate::model::Tag {
                key: self.key,
                value: self.value,
            }
        }
    }
}

/// <p>The user-defined preferences that will be applied when updating a provisioned product. Not all preferences are applicable to all provisioned product types.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateProvisioningPreferences {
    /// <p>One or more Amazon Web Services accounts that will have access to the provisioned product.</p>
    /// <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
    /// <p>The Amazon Web Services accounts specified should be within the list of accounts in the <code>STACKSET</code> constraint. To get the list of accounts in the <code>STACKSET</code> constraint, use the <code>DescribeProvisioningParameters</code> operation.</p>
    /// <p>If no values are specified, the default value is all accounts from the <code>STACKSET</code> constraint.</p>
    #[doc(hidden)]
    pub stack_set_accounts: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>One or more Amazon Web Services Regions where the provisioned product will be available.</p>
    /// <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
    /// <p>The specified Regions should be within the list of Regions from the <code>STACKSET</code> constraint. To get the list of Regions in the <code>STACKSET</code> constraint, use the <code>DescribeProvisioningParameters</code> operation.</p>
    /// <p>If no values are specified, the default value is all Regions from the <code>STACKSET</code> constraint.</p>
    #[doc(hidden)]
    pub stack_set_regions: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The number of accounts, per Region, for which this operation can fail before Service Catalog stops the operation in that Region. If the operation is stopped in a Region, Service Catalog doesn't attempt the operation in any subsequent Regions.</p>
    /// <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
    /// <p>Conditional: You must specify either <code>StackSetFailureToleranceCount</code> or <code>StackSetFailureTolerancePercentage</code>, but not both.</p>
    /// <p>The default value is <code>0</code> if no value is specified.</p>
    #[doc(hidden)]
    pub stack_set_failure_tolerance_count: std::option::Option<i32>,
    /// <p>The percentage of accounts, per Region, for which this stack operation can fail before Service Catalog stops the operation in that Region. If the operation is stopped in a Region, Service Catalog doesn't attempt the operation in any subsequent Regions.</p>
    /// <p>When calculating the number of accounts based on the specified percentage, Service Catalog rounds down to the next whole number.</p>
    /// <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
    /// <p>Conditional: You must specify either <code>StackSetFailureToleranceCount</code> or <code>StackSetFailureTolerancePercentage</code>, but not both.</p>
    #[doc(hidden)]
    pub stack_set_failure_tolerance_percentage: std::option::Option<i32>,
    /// <p>The maximum number of accounts in which to perform this operation at one time. This is dependent on the value of <code>StackSetFailureToleranceCount</code>. <code>StackSetMaxConcurrentCount</code> is at most one more than the <code>StackSetFailureToleranceCount</code>.</p>
    /// <p>Note that this setting lets you specify the maximum for operations. For large deployments, under certain circumstances the actual number of accounts acted upon concurrently may be lower due to service throttling.</p>
    /// <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
    /// <p>Conditional: You must specify either <code>StackSetMaxConcurrentCount</code> or <code>StackSetMaxConcurrentPercentage</code>, but not both.</p>
    #[doc(hidden)]
    pub stack_set_max_concurrency_count: std::option::Option<i32>,
    /// <p>The maximum percentage of accounts in which to perform this operation at one time.</p>
    /// <p>When calculating the number of accounts based on the specified percentage, Service Catalog rounds down to the next whole number. This is true except in cases where rounding down would result is zero. In this case, Service Catalog sets the number as <code>1</code> instead.</p>
    /// <p>Note that this setting lets you specify the maximum for operations. For large deployments, under certain circumstances the actual number of accounts acted upon concurrently may be lower due to service throttling.</p>
    /// <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
    /// <p>Conditional: You must specify either <code>StackSetMaxConcurrentCount</code> or <code>StackSetMaxConcurrentPercentage</code>, but not both.</p>
    #[doc(hidden)]
    pub stack_set_max_concurrency_percentage: std::option::Option<i32>,
    /// <p>Determines what action Service Catalog performs to a stack set or a stack instance represented by the provisioned product. The default value is <code>UPDATE</code> if nothing is specified.</p>
    /// <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
    /// <dl>
    /// <dt>
    /// CREATE
    /// </dt>
    /// <dd>
    /// <p>Creates a new stack instance in the stack set represented by the provisioned product. In this case, only new stack instances are created based on accounts and Regions; if new ProductId or ProvisioningArtifactID are passed, they will be ignored.</p>
    /// </dd>
    /// <dt>
    /// UPDATE
    /// </dt>
    /// <dd>
    /// <p>Updates the stack set represented by the provisioned product and also its stack instances.</p>
    /// </dd>
    /// <dt>
    /// DELETE
    /// </dt>
    /// <dd>
    /// <p>Deletes a stack instance in the stack set represented by the provisioned product.</p>
    /// </dd>
    /// </dl>
    #[doc(hidden)]
    pub stack_set_operation_type: std::option::Option<crate::model::StackSetOperationType>,
}
impl UpdateProvisioningPreferences {
    /// <p>One or more Amazon Web Services accounts that will have access to the provisioned product.</p>
    /// <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
    /// <p>The Amazon Web Services accounts specified should be within the list of accounts in the <code>STACKSET</code> constraint. To get the list of accounts in the <code>STACKSET</code> constraint, use the <code>DescribeProvisioningParameters</code> operation.</p>
    /// <p>If no values are specified, the default value is all accounts from the <code>STACKSET</code> constraint.</p>
    pub fn stack_set_accounts(&self) -> std::option::Option<&[std::string::String]> {
        self.stack_set_accounts.as_deref()
    }
    /// <p>One or more Amazon Web Services Regions where the provisioned product will be available.</p>
    /// <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
    /// <p>The specified Regions should be within the list of Regions from the <code>STACKSET</code> constraint. To get the list of Regions in the <code>STACKSET</code> constraint, use the <code>DescribeProvisioningParameters</code> operation.</p>
    /// <p>If no values are specified, the default value is all Regions from the <code>STACKSET</code> constraint.</p>
    pub fn stack_set_regions(&self) -> std::option::Option<&[std::string::String]> {
        self.stack_set_regions.as_deref()
    }
    /// <p>The number of accounts, per Region, for which this operation can fail before Service Catalog stops the operation in that Region. If the operation is stopped in a Region, Service Catalog doesn't attempt the operation in any subsequent Regions.</p>
    /// <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
    /// <p>Conditional: You must specify either <code>StackSetFailureToleranceCount</code> or <code>StackSetFailureTolerancePercentage</code>, but not both.</p>
    /// <p>The default value is <code>0</code> if no value is specified.</p>
    pub fn stack_set_failure_tolerance_count(&self) -> std::option::Option<i32> {
        self.stack_set_failure_tolerance_count
    }
    /// <p>The percentage of accounts, per Region, for which this stack operation can fail before Service Catalog stops the operation in that Region. If the operation is stopped in a Region, Service Catalog doesn't attempt the operation in any subsequent Regions.</p>
    /// <p>When calculating the number of accounts based on the specified percentage, Service Catalog rounds down to the next whole number.</p>
    /// <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
    /// <p>Conditional: You must specify either <code>StackSetFailureToleranceCount</code> or <code>StackSetFailureTolerancePercentage</code>, but not both.</p>
    pub fn stack_set_failure_tolerance_percentage(&self) -> std::option::Option<i32> {
        self.stack_set_failure_tolerance_percentage
    }
    /// <p>The maximum number of accounts in which to perform this operation at one time. This is dependent on the value of <code>StackSetFailureToleranceCount</code>. <code>StackSetMaxConcurrentCount</code> is at most one more than the <code>StackSetFailureToleranceCount</code>.</p>
    /// <p>Note that this setting lets you specify the maximum for operations. For large deployments, under certain circumstances the actual number of accounts acted upon concurrently may be lower due to service throttling.</p>
    /// <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
    /// <p>Conditional: You must specify either <code>StackSetMaxConcurrentCount</code> or <code>StackSetMaxConcurrentPercentage</code>, but not both.</p>
    pub fn stack_set_max_concurrency_count(&self) -> std::option::Option<i32> {
        self.stack_set_max_concurrency_count
    }
    /// <p>The maximum percentage of accounts in which to perform this operation at one time.</p>
    /// <p>When calculating the number of accounts based on the specified percentage, Service Catalog rounds down to the next whole number. This is true except in cases where rounding down would result is zero. In this case, Service Catalog sets the number as <code>1</code> instead.</p>
    /// <p>Note that this setting lets you specify the maximum for operations. For large deployments, under certain circumstances the actual number of accounts acted upon concurrently may be lower due to service throttling.</p>
    /// <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
    /// <p>Conditional: You must specify either <code>StackSetMaxConcurrentCount</code> or <code>StackSetMaxConcurrentPercentage</code>, but not both.</p>
    pub fn stack_set_max_concurrency_percentage(&self) -> std::option::Option<i32> {
        self.stack_set_max_concurrency_percentage
    }
    /// <p>Determines what action Service Catalog performs to a stack set or a stack instance represented by the provisioned product. The default value is <code>UPDATE</code> if nothing is specified.</p>
    /// <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
    /// <dl>
    /// <dt>
    /// CREATE
    /// </dt>
    /// <dd>
    /// <p>Creates a new stack instance in the stack set represented by the provisioned product. In this case, only new stack instances are created based on accounts and Regions; if new ProductId or ProvisioningArtifactID are passed, they will be ignored.</p>
    /// </dd>
    /// <dt>
    /// UPDATE
    /// </dt>
    /// <dd>
    /// <p>Updates the stack set represented by the provisioned product and also its stack instances.</p>
    /// </dd>
    /// <dt>
    /// DELETE
    /// </dt>
    /// <dd>
    /// <p>Deletes a stack instance in the stack set represented by the provisioned product.</p>
    /// </dd>
    /// </dl>
    pub fn stack_set_operation_type(
        &self,
    ) -> std::option::Option<&crate::model::StackSetOperationType> {
        self.stack_set_operation_type.as_ref()
    }
}
impl UpdateProvisioningPreferences {
    /// Creates a new builder-style object to manufacture [`UpdateProvisioningPreferences`](crate::model::UpdateProvisioningPreferences).
    pub fn builder() -> crate::model::update_provisioning_preferences::Builder {
        crate::model::update_provisioning_preferences::Builder::default()
    }
}

/// See [`UpdateProvisioningPreferences`](crate::model::UpdateProvisioningPreferences).
pub mod update_provisioning_preferences {

    /// A builder for [`UpdateProvisioningPreferences`](crate::model::UpdateProvisioningPreferences).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) stack_set_accounts: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) stack_set_regions: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) stack_set_failure_tolerance_count: std::option::Option<i32>,
        pub(crate) stack_set_failure_tolerance_percentage: std::option::Option<i32>,
        pub(crate) stack_set_max_concurrency_count: std::option::Option<i32>,
        pub(crate) stack_set_max_concurrency_percentage: std::option::Option<i32>,
        pub(crate) stack_set_operation_type:
            std::option::Option<crate::model::StackSetOperationType>,
    }
    impl Builder {
        /// Appends an item to `stack_set_accounts`.
        ///
        /// To override the contents of this collection use [`set_stack_set_accounts`](Self::set_stack_set_accounts).
        ///
        /// <p>One or more Amazon Web Services accounts that will have access to the provisioned product.</p>
        /// <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
        /// <p>The Amazon Web Services accounts specified should be within the list of accounts in the <code>STACKSET</code> constraint. To get the list of accounts in the <code>STACKSET</code> constraint, use the <code>DescribeProvisioningParameters</code> operation.</p>
        /// <p>If no values are specified, the default value is all accounts from the <code>STACKSET</code> constraint.</p>
        pub fn stack_set_accounts(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.stack_set_accounts.unwrap_or_default();
            v.push(input.into());
            self.stack_set_accounts = Some(v);
            self
        }
        /// <p>One or more Amazon Web Services accounts that will have access to the provisioned product.</p>
        /// <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
        /// <p>The Amazon Web Services accounts specified should be within the list of accounts in the <code>STACKSET</code> constraint. To get the list of accounts in the <code>STACKSET</code> constraint, use the <code>DescribeProvisioningParameters</code> operation.</p>
        /// <p>If no values are specified, the default value is all accounts from the <code>STACKSET</code> constraint.</p>
        pub fn set_stack_set_accounts(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.stack_set_accounts = input;
            self
        }
        /// Appends an item to `stack_set_regions`.
        ///
        /// To override the contents of this collection use [`set_stack_set_regions`](Self::set_stack_set_regions).
        ///
        /// <p>One or more Amazon Web Services Regions where the provisioned product will be available.</p>
        /// <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
        /// <p>The specified Regions should be within the list of Regions from the <code>STACKSET</code> constraint. To get the list of Regions in the <code>STACKSET</code> constraint, use the <code>DescribeProvisioningParameters</code> operation.</p>
        /// <p>If no values are specified, the default value is all Regions from the <code>STACKSET</code> constraint.</p>
        pub fn stack_set_regions(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.stack_set_regions.unwrap_or_default();
            v.push(input.into());
            self.stack_set_regions = Some(v);
            self
        }
        /// <p>One or more Amazon Web Services Regions where the provisioned product will be available.</p>
        /// <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
        /// <p>The specified Regions should be within the list of Regions from the <code>STACKSET</code> constraint. To get the list of Regions in the <code>STACKSET</code> constraint, use the <code>DescribeProvisioningParameters</code> operation.</p>
        /// <p>If no values are specified, the default value is all Regions from the <code>STACKSET</code> constraint.</p>
        pub fn set_stack_set_regions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.stack_set_regions = input;
            self
        }
        /// <p>The number of accounts, per Region, for which this operation can fail before Service Catalog stops the operation in that Region. If the operation is stopped in a Region, Service Catalog doesn't attempt the operation in any subsequent Regions.</p>
        /// <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
        /// <p>Conditional: You must specify either <code>StackSetFailureToleranceCount</code> or <code>StackSetFailureTolerancePercentage</code>, but not both.</p>
        /// <p>The default value is <code>0</code> if no value is specified.</p>
        pub fn stack_set_failure_tolerance_count(mut self, input: i32) -> Self {
            self.stack_set_failure_tolerance_count = Some(input);
            self
        }
        /// <p>The number of accounts, per Region, for which this operation can fail before Service Catalog stops the operation in that Region. If the operation is stopped in a Region, Service Catalog doesn't attempt the operation in any subsequent Regions.</p>
        /// <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
        /// <p>Conditional: You must specify either <code>StackSetFailureToleranceCount</code> or <code>StackSetFailureTolerancePercentage</code>, but not both.</p>
        /// <p>The default value is <code>0</code> if no value is specified.</p>
        pub fn set_stack_set_failure_tolerance_count(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.stack_set_failure_tolerance_count = input;
            self
        }
        /// <p>The percentage of accounts, per Region, for which this stack operation can fail before Service Catalog stops the operation in that Region. If the operation is stopped in a Region, Service Catalog doesn't attempt the operation in any subsequent Regions.</p>
        /// <p>When calculating the number of accounts based on the specified percentage, Service Catalog rounds down to the next whole number.</p>
        /// <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
        /// <p>Conditional: You must specify either <code>StackSetFailureToleranceCount</code> or <code>StackSetFailureTolerancePercentage</code>, but not both.</p>
        pub fn stack_set_failure_tolerance_percentage(mut self, input: i32) -> Self {
            self.stack_set_failure_tolerance_percentage = Some(input);
            self
        }
        /// <p>The percentage of accounts, per Region, for which this stack operation can fail before Service Catalog stops the operation in that Region. If the operation is stopped in a Region, Service Catalog doesn't attempt the operation in any subsequent Regions.</p>
        /// <p>When calculating the number of accounts based on the specified percentage, Service Catalog rounds down to the next whole number.</p>
        /// <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
        /// <p>Conditional: You must specify either <code>StackSetFailureToleranceCount</code> or <code>StackSetFailureTolerancePercentage</code>, but not both.</p>
        pub fn set_stack_set_failure_tolerance_percentage(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.stack_set_failure_tolerance_percentage = input;
            self
        }
        /// <p>The maximum number of accounts in which to perform this operation at one time. This is dependent on the value of <code>StackSetFailureToleranceCount</code>. <code>StackSetMaxConcurrentCount</code> is at most one more than the <code>StackSetFailureToleranceCount</code>.</p>
        /// <p>Note that this setting lets you specify the maximum for operations. For large deployments, under certain circumstances the actual number of accounts acted upon concurrently may be lower due to service throttling.</p>
        /// <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
        /// <p>Conditional: You must specify either <code>StackSetMaxConcurrentCount</code> or <code>StackSetMaxConcurrentPercentage</code>, but not both.</p>
        pub fn stack_set_max_concurrency_count(mut self, input: i32) -> Self {
            self.stack_set_max_concurrency_count = Some(input);
            self
        }
        /// <p>The maximum number of accounts in which to perform this operation at one time. This is dependent on the value of <code>StackSetFailureToleranceCount</code>. <code>StackSetMaxConcurrentCount</code> is at most one more than the <code>StackSetFailureToleranceCount</code>.</p>
        /// <p>Note that this setting lets you specify the maximum for operations. For large deployments, under certain circumstances the actual number of accounts acted upon concurrently may be lower due to service throttling.</p>
        /// <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
        /// <p>Conditional: You must specify either <code>StackSetMaxConcurrentCount</code> or <code>StackSetMaxConcurrentPercentage</code>, but not both.</p>
        pub fn set_stack_set_max_concurrency_count(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.stack_set_max_concurrency_count = input;
            self
        }
        /// <p>The maximum percentage of accounts in which to perform this operation at one time.</p>
        /// <p>When calculating the number of accounts based on the specified percentage, Service Catalog rounds down to the next whole number. This is true except in cases where rounding down would result is zero. In this case, Service Catalog sets the number as <code>1</code> instead.</p>
        /// <p>Note that this setting lets you specify the maximum for operations. For large deployments, under certain circumstances the actual number of accounts acted upon concurrently may be lower due to service throttling.</p>
        /// <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
        /// <p>Conditional: You must specify either <code>StackSetMaxConcurrentCount</code> or <code>StackSetMaxConcurrentPercentage</code>, but not both.</p>
        pub fn stack_set_max_concurrency_percentage(mut self, input: i32) -> Self {
            self.stack_set_max_concurrency_percentage = Some(input);
            self
        }
        /// <p>The maximum percentage of accounts in which to perform this operation at one time.</p>
        /// <p>When calculating the number of accounts based on the specified percentage, Service Catalog rounds down to the next whole number. This is true except in cases where rounding down would result is zero. In this case, Service Catalog sets the number as <code>1</code> instead.</p>
        /// <p>Note that this setting lets you specify the maximum for operations. For large deployments, under certain circumstances the actual number of accounts acted upon concurrently may be lower due to service throttling.</p>
        /// <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
        /// <p>Conditional: You must specify either <code>StackSetMaxConcurrentCount</code> or <code>StackSetMaxConcurrentPercentage</code>, but not both.</p>
        pub fn set_stack_set_max_concurrency_percentage(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.stack_set_max_concurrency_percentage = input;
            self
        }
        /// <p>Determines what action Service Catalog performs to a stack set or a stack instance represented by the provisioned product. The default value is <code>UPDATE</code> if nothing is specified.</p>
        /// <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
        /// <dl>
        /// <dt>
        /// CREATE
        /// </dt>
        /// <dd>
        /// <p>Creates a new stack instance in the stack set represented by the provisioned product. In this case, only new stack instances are created based on accounts and Regions; if new ProductId or ProvisioningArtifactID are passed, they will be ignored.</p>
        /// </dd>
        /// <dt>
        /// UPDATE
        /// </dt>
        /// <dd>
        /// <p>Updates the stack set represented by the provisioned product and also its stack instances.</p>
        /// </dd>
        /// <dt>
        /// DELETE
        /// </dt>
        /// <dd>
        /// <p>Deletes a stack instance in the stack set represented by the provisioned product.</p>
        /// </dd>
        /// </dl>
        pub fn stack_set_operation_type(
            mut self,
            input: crate::model::StackSetOperationType,
        ) -> Self {
            self.stack_set_operation_type = Some(input);
            self
        }
        /// <p>Determines what action Service Catalog performs to a stack set or a stack instance represented by the provisioned product. The default value is <code>UPDATE</code> if nothing is specified.</p>
        /// <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
        /// <dl>
        /// <dt>
        /// CREATE
        /// </dt>
        /// <dd>
        /// <p>Creates a new stack instance in the stack set represented by the provisioned product. In this case, only new stack instances are created based on accounts and Regions; if new ProductId or ProvisioningArtifactID are passed, they will be ignored.</p>
        /// </dd>
        /// <dt>
        /// UPDATE
        /// </dt>
        /// <dd>
        /// <p>Updates the stack set represented by the provisioned product and also its stack instances.</p>
        /// </dd>
        /// <dt>
        /// DELETE
        /// </dt>
        /// <dd>
        /// <p>Deletes a stack instance in the stack set represented by the provisioned product.</p>
        /// </dd>
        /// </dl>
        pub fn set_stack_set_operation_type(
            mut self,
            input: std::option::Option<crate::model::StackSetOperationType>,
        ) -> Self {
            self.stack_set_operation_type = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateProvisioningPreferences`](crate::model::UpdateProvisioningPreferences).
        pub fn build(self) -> crate::model::UpdateProvisioningPreferences {
            crate::model::UpdateProvisioningPreferences {
                stack_set_accounts: self.stack_set_accounts,
                stack_set_regions: self.stack_set_regions,
                stack_set_failure_tolerance_count: self.stack_set_failure_tolerance_count,
                stack_set_failure_tolerance_percentage: self.stack_set_failure_tolerance_percentage,
                stack_set_max_concurrency_count: self.stack_set_max_concurrency_count,
                stack_set_max_concurrency_percentage: self.stack_set_max_concurrency_percentage,
                stack_set_operation_type: self.stack_set_operation_type,
            }
        }
    }
}

/// When writing a match expression against `StackSetOperationType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let stacksetoperationtype = unimplemented!();
/// match stacksetoperationtype {
///     StackSetOperationType::Create => { /* ... */ },
///     StackSetOperationType::Delete => { /* ... */ },
///     StackSetOperationType::Update => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `stacksetoperationtype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `StackSetOperationType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `StackSetOperationType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `StackSetOperationType::NewFeature` is defined.
/// Specifically, when `stacksetoperationtype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `StackSetOperationType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StackSetOperationType {
    #[allow(missing_docs)] // documentation missing in model
    Create,
    #[allow(missing_docs)] // documentation missing in model
    Delete,
    #[allow(missing_docs)] // documentation missing in model
    Update,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for StackSetOperationType {
    fn from(s: &str) -> Self {
        match s {
            "CREATE" => StackSetOperationType::Create,
            "DELETE" => StackSetOperationType::Delete,
            "UPDATE" => StackSetOperationType::Update,
            other => {
                StackSetOperationType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for StackSetOperationType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StackSetOperationType::from(s))
    }
}
impl StackSetOperationType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            StackSetOperationType::Create => "CREATE",
            StackSetOperationType::Delete => "DELETE",
            StackSetOperationType::Update => "UPDATE",
            StackSetOperationType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CREATE", "DELETE", "UPDATE"]
    }
}
impl AsRef<str> for StackSetOperationType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The parameter key-value pair used to update a provisioned product.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateProvisioningParameter {
    /// <p>The parameter key.</p>
    #[doc(hidden)]
    pub key: std::option::Option<std::string::String>,
    /// <p>The parameter value.</p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
    /// <p>If set to true, <code>Value</code> is ignored and the previous parameter value is kept.</p>
    #[doc(hidden)]
    pub use_previous_value: bool,
}
impl UpdateProvisioningParameter {
    /// <p>The parameter key.</p>
    pub fn key(&self) -> std::option::Option<&str> {
        self.key.as_deref()
    }
    /// <p>The parameter value.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
    /// <p>If set to true, <code>Value</code> is ignored and the previous parameter value is kept.</p>
    pub fn use_previous_value(&self) -> bool {
        self.use_previous_value
    }
}
impl UpdateProvisioningParameter {
    /// Creates a new builder-style object to manufacture [`UpdateProvisioningParameter`](crate::model::UpdateProvisioningParameter).
    pub fn builder() -> crate::model::update_provisioning_parameter::Builder {
        crate::model::update_provisioning_parameter::Builder::default()
    }
}

/// See [`UpdateProvisioningParameter`](crate::model::UpdateProvisioningParameter).
pub mod update_provisioning_parameter {

    /// A builder for [`UpdateProvisioningParameter`](crate::model::UpdateProvisioningParameter).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
        pub(crate) use_previous_value: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The parameter key.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        /// <p>The parameter key.</p>
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The parameter value.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The parameter value.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// <p>If set to true, <code>Value</code> is ignored and the previous parameter value is kept.</p>
        pub fn use_previous_value(mut self, input: bool) -> Self {
            self.use_previous_value = Some(input);
            self
        }
        /// <p>If set to true, <code>Value</code> is ignored and the previous parameter value is kept.</p>
        pub fn set_use_previous_value(mut self, input: std::option::Option<bool>) -> Self {
            self.use_previous_value = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateProvisioningParameter`](crate::model::UpdateProvisioningParameter).
        pub fn build(self) -> crate::model::UpdateProvisioningParameter {
            crate::model::UpdateProvisioningParameter {
                key: self.key,
                value: self.value,
                use_previous_value: self.use_previous_value.unwrap_or_default(),
            }
        }
    }
}

/// <p>Information about a product view.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ProductViewDetail {
    /// <p>Summary information about the product view.</p>
    #[doc(hidden)]
    pub product_view_summary: std::option::Option<crate::model::ProductViewSummary>,
    /// <p>The status of the product.</p>
    /// <ul>
    /// <li> <p> <code>AVAILABLE</code> - The product is ready for use.</p> </li>
    /// <li> <p> <code>CREATING</code> - Product creation has started; the product is not ready for use.</p> </li>
    /// <li> <p> <code>FAILED</code> - An action failed.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::Status>,
    /// <p>The ARN of the product.</p>
    #[doc(hidden)]
    pub product_arn: std::option::Option<std::string::String>,
    /// <p>The UTC time stamp of the creation time.</p>
    #[doc(hidden)]
    pub created_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>A top level <code>ProductViewDetail</code> response containing details about the product’s connection. Service Catalog returns this field for the <code>CreateProduct</code>, <code>UpdateProduct</code>, <code>DescribeProductAsAdmin</code>, and <code>SearchProductAsAdmin</code> APIs. This response contains the same fields as the <code>ConnectionParameters</code> request, with the addition of the <code>LastSync</code> response.</p>
    #[doc(hidden)]
    pub source_connection: std::option::Option<crate::model::SourceConnectionDetail>,
}
impl ProductViewDetail {
    /// <p>Summary information about the product view.</p>
    pub fn product_view_summary(&self) -> std::option::Option<&crate::model::ProductViewSummary> {
        self.product_view_summary.as_ref()
    }
    /// <p>The status of the product.</p>
    /// <ul>
    /// <li> <p> <code>AVAILABLE</code> - The product is ready for use.</p> </li>
    /// <li> <p> <code>CREATING</code> - Product creation has started; the product is not ready for use.</p> </li>
    /// <li> <p> <code>FAILED</code> - An action failed.</p> </li>
    /// </ul>
    pub fn status(&self) -> std::option::Option<&crate::model::Status> {
        self.status.as_ref()
    }
    /// <p>The ARN of the product.</p>
    pub fn product_arn(&self) -> std::option::Option<&str> {
        self.product_arn.as_deref()
    }
    /// <p>The UTC time stamp of the creation time.</p>
    pub fn created_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_time.as_ref()
    }
    /// <p>A top level <code>ProductViewDetail</code> response containing details about the product’s connection. Service Catalog returns this field for the <code>CreateProduct</code>, <code>UpdateProduct</code>, <code>DescribeProductAsAdmin</code>, and <code>SearchProductAsAdmin</code> APIs. This response contains the same fields as the <code>ConnectionParameters</code> request, with the addition of the <code>LastSync</code> response.</p>
    pub fn source_connection(&self) -> std::option::Option<&crate::model::SourceConnectionDetail> {
        self.source_connection.as_ref()
    }
}
impl ProductViewDetail {
    /// Creates a new builder-style object to manufacture [`ProductViewDetail`](crate::model::ProductViewDetail).
    pub fn builder() -> crate::model::product_view_detail::Builder {
        crate::model::product_view_detail::Builder::default()
    }
}

/// See [`ProductViewDetail`](crate::model::ProductViewDetail).
pub mod product_view_detail {

    /// A builder for [`ProductViewDetail`](crate::model::ProductViewDetail).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) product_view_summary: std::option::Option<crate::model::ProductViewSummary>,
        pub(crate) status: std::option::Option<crate::model::Status>,
        pub(crate) product_arn: std::option::Option<std::string::String>,
        pub(crate) created_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) source_connection: std::option::Option<crate::model::SourceConnectionDetail>,
    }
    impl Builder {
        /// <p>Summary information about the product view.</p>
        pub fn product_view_summary(mut self, input: crate::model::ProductViewSummary) -> Self {
            self.product_view_summary = Some(input);
            self
        }
        /// <p>Summary information about the product view.</p>
        pub fn set_product_view_summary(
            mut self,
            input: std::option::Option<crate::model::ProductViewSummary>,
        ) -> Self {
            self.product_view_summary = input;
            self
        }
        /// <p>The status of the product.</p>
        /// <ul>
        /// <li> <p> <code>AVAILABLE</code> - The product is ready for use.</p> </li>
        /// <li> <p> <code>CREATING</code> - Product creation has started; the product is not ready for use.</p> </li>
        /// <li> <p> <code>FAILED</code> - An action failed.</p> </li>
        /// </ul>
        pub fn status(mut self, input: crate::model::Status) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the product.</p>
        /// <ul>
        /// <li> <p> <code>AVAILABLE</code> - The product is ready for use.</p> </li>
        /// <li> <p> <code>CREATING</code> - Product creation has started; the product is not ready for use.</p> </li>
        /// <li> <p> <code>FAILED</code> - An action failed.</p> </li>
        /// </ul>
        pub fn set_status(mut self, input: std::option::Option<crate::model::Status>) -> Self {
            self.status = input;
            self
        }
        /// <p>The ARN of the product.</p>
        pub fn product_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.product_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the product.</p>
        pub fn set_product_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.product_arn = input;
            self
        }
        /// <p>The UTC time stamp of the creation time.</p>
        pub fn created_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_time = Some(input);
            self
        }
        /// <p>The UTC time stamp of the creation time.</p>
        pub fn set_created_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_time = input;
            self
        }
        /// <p>A top level <code>ProductViewDetail</code> response containing details about the product’s connection. Service Catalog returns this field for the <code>CreateProduct</code>, <code>UpdateProduct</code>, <code>DescribeProductAsAdmin</code>, and <code>SearchProductAsAdmin</code> APIs. This response contains the same fields as the <code>ConnectionParameters</code> request, with the addition of the <code>LastSync</code> response.</p>
        pub fn source_connection(mut self, input: crate::model::SourceConnectionDetail) -> Self {
            self.source_connection = Some(input);
            self
        }
        /// <p>A top level <code>ProductViewDetail</code> response containing details about the product’s connection. Service Catalog returns this field for the <code>CreateProduct</code>, <code>UpdateProduct</code>, <code>DescribeProductAsAdmin</code>, and <code>SearchProductAsAdmin</code> APIs. This response contains the same fields as the <code>ConnectionParameters</code> request, with the addition of the <code>LastSync</code> response.</p>
        pub fn set_source_connection(
            mut self,
            input: std::option::Option<crate::model::SourceConnectionDetail>,
        ) -> Self {
            self.source_connection = input;
            self
        }
        /// Consumes the builder and constructs a [`ProductViewDetail`](crate::model::ProductViewDetail).
        pub fn build(self) -> crate::model::ProductViewDetail {
            crate::model::ProductViewDetail {
                product_view_summary: self.product_view_summary,
                status: self.status,
                product_arn: self.product_arn,
                created_time: self.created_time,
                source_connection: self.source_connection,
            }
        }
    }
}

/// <p>Provides details about the configured <code>SourceConnection</code>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SourceConnectionDetail {
    /// <p>The only supported <code>SourceConnection</code> type is Codestar.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::SourceType>,
    /// <p>The connection details based on the connection <code>Type</code>.</p>
    #[doc(hidden)]
    pub connection_parameters: std::option::Option<crate::model::SourceConnectionParameters>,
    /// <p>Provides details about the product's connection sync and contains the following sub-fields. </p>
    /// <ul>
    /// <li> <p> <code>LastSyncTime</code> </p> </li>
    /// <li> <p> <code>LastSyncStatus</code> </p> </li>
    /// <li> <p> <code>LastSyncStatusMessage</code> </p> </li>
    /// <li> <p> <code>LastSuccessfulSyncTime</code> </p> </li>
    /// <li> <p> <code>LastSuccessfulSyncProvisioningArtifactID</code> </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub last_sync: std::option::Option<crate::model::LastSync>,
}
impl SourceConnectionDetail {
    /// <p>The only supported <code>SourceConnection</code> type is Codestar.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::SourceType> {
        self.r#type.as_ref()
    }
    /// <p>The connection details based on the connection <code>Type</code>.</p>
    pub fn connection_parameters(
        &self,
    ) -> std::option::Option<&crate::model::SourceConnectionParameters> {
        self.connection_parameters.as_ref()
    }
    /// <p>Provides details about the product's connection sync and contains the following sub-fields. </p>
    /// <ul>
    /// <li> <p> <code>LastSyncTime</code> </p> </li>
    /// <li> <p> <code>LastSyncStatus</code> </p> </li>
    /// <li> <p> <code>LastSyncStatusMessage</code> </p> </li>
    /// <li> <p> <code>LastSuccessfulSyncTime</code> </p> </li>
    /// <li> <p> <code>LastSuccessfulSyncProvisioningArtifactID</code> </p> </li>
    /// </ul>
    pub fn last_sync(&self) -> std::option::Option<&crate::model::LastSync> {
        self.last_sync.as_ref()
    }
}
impl SourceConnectionDetail {
    /// Creates a new builder-style object to manufacture [`SourceConnectionDetail`](crate::model::SourceConnectionDetail).
    pub fn builder() -> crate::model::source_connection_detail::Builder {
        crate::model::source_connection_detail::Builder::default()
    }
}

/// See [`SourceConnectionDetail`](crate::model::SourceConnectionDetail).
pub mod source_connection_detail {

    /// A builder for [`SourceConnectionDetail`](crate::model::SourceConnectionDetail).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<crate::model::SourceType>,
        pub(crate) connection_parameters:
            std::option::Option<crate::model::SourceConnectionParameters>,
        pub(crate) last_sync: std::option::Option<crate::model::LastSync>,
    }
    impl Builder {
        /// <p>The only supported <code>SourceConnection</code> type is Codestar.</p>
        pub fn r#type(mut self, input: crate::model::SourceType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The only supported <code>SourceConnection</code> type is Codestar.</p>
        pub fn set_type(mut self, input: std::option::Option<crate::model::SourceType>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The connection details based on the connection <code>Type</code>.</p>
        pub fn connection_parameters(
            mut self,
            input: crate::model::SourceConnectionParameters,
        ) -> Self {
            self.connection_parameters = Some(input);
            self
        }
        /// <p>The connection details based on the connection <code>Type</code>.</p>
        pub fn set_connection_parameters(
            mut self,
            input: std::option::Option<crate::model::SourceConnectionParameters>,
        ) -> Self {
            self.connection_parameters = input;
            self
        }
        /// <p>Provides details about the product's connection sync and contains the following sub-fields. </p>
        /// <ul>
        /// <li> <p> <code>LastSyncTime</code> </p> </li>
        /// <li> <p> <code>LastSyncStatus</code> </p> </li>
        /// <li> <p> <code>LastSyncStatusMessage</code> </p> </li>
        /// <li> <p> <code>LastSuccessfulSyncTime</code> </p> </li>
        /// <li> <p> <code>LastSuccessfulSyncProvisioningArtifactID</code> </p> </li>
        /// </ul>
        pub fn last_sync(mut self, input: crate::model::LastSync) -> Self {
            self.last_sync = Some(input);
            self
        }
        /// <p>Provides details about the product's connection sync and contains the following sub-fields. </p>
        /// <ul>
        /// <li> <p> <code>LastSyncTime</code> </p> </li>
        /// <li> <p> <code>LastSyncStatus</code> </p> </li>
        /// <li> <p> <code>LastSyncStatusMessage</code> </p> </li>
        /// <li> <p> <code>LastSuccessfulSyncTime</code> </p> </li>
        /// <li> <p> <code>LastSuccessfulSyncProvisioningArtifactID</code> </p> </li>
        /// </ul>
        pub fn set_last_sync(mut self, input: std::option::Option<crate::model::LastSync>) -> Self {
            self.last_sync = input;
            self
        }
        /// Consumes the builder and constructs a [`SourceConnectionDetail`](crate::model::SourceConnectionDetail).
        pub fn build(self) -> crate::model::SourceConnectionDetail {
            crate::model::SourceConnectionDetail {
                r#type: self.r#type,
                connection_parameters: self.connection_parameters,
                last_sync: self.last_sync,
            }
        }
    }
}

/// <p>Provides details about the product's connection sync and contains the following sub-fields. </p>
/// <ul>
/// <li> <p> <code>LastSyncTime</code> </p> </li>
/// <li> <p> <code>LastSyncStatus</code> </p> </li>
/// <li> <p> <code>LastSyncStatusMessage</code> </p> </li>
/// <li> <p> <code>LastSuccessfulSyncTime</code> </p> </li>
/// <li> <p> <code>LastSuccessfulSyncProvisioningArtifactID</code> </p> </li>
/// </ul>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LastSync {
    /// <p>The time of the last attempted sync from the repository to the Service Catalog product. </p>
    #[doc(hidden)]
    pub last_sync_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The current status of the sync. Responses include <code>SUCCEEDED</code> or <code>FAILED</code>. </p>
    #[doc(hidden)]
    pub last_sync_status: std::option::Option<crate::model::LastSyncStatus>,
    /// <p>The sync's status message. </p>
    #[doc(hidden)]
    pub last_sync_status_message: std::option::Option<std::string::String>,
    /// <p>The time of the latest successful sync from the source repo artifact to the Service Catalog product.</p>
    #[doc(hidden)]
    pub last_successful_sync_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The ProvisioningArtifactID of the ProvisioningArtifact created from the latest successful sync. </p>
    #[doc(hidden)]
    pub last_successful_sync_provisioning_artifact_id: std::option::Option<std::string::String>,
}
impl LastSync {
    /// <p>The time of the last attempted sync from the repository to the Service Catalog product. </p>
    pub fn last_sync_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_sync_time.as_ref()
    }
    /// <p>The current status of the sync. Responses include <code>SUCCEEDED</code> or <code>FAILED</code>. </p>
    pub fn last_sync_status(&self) -> std::option::Option<&crate::model::LastSyncStatus> {
        self.last_sync_status.as_ref()
    }
    /// <p>The sync's status message. </p>
    pub fn last_sync_status_message(&self) -> std::option::Option<&str> {
        self.last_sync_status_message.as_deref()
    }
    /// <p>The time of the latest successful sync from the source repo artifact to the Service Catalog product.</p>
    pub fn last_successful_sync_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_successful_sync_time.as_ref()
    }
    /// <p>The ProvisioningArtifactID of the ProvisioningArtifact created from the latest successful sync. </p>
    pub fn last_successful_sync_provisioning_artifact_id(&self) -> std::option::Option<&str> {
        self.last_successful_sync_provisioning_artifact_id
            .as_deref()
    }
}
impl LastSync {
    /// Creates a new builder-style object to manufacture [`LastSync`](crate::model::LastSync).
    pub fn builder() -> crate::model::last_sync::Builder {
        crate::model::last_sync::Builder::default()
    }
}

/// See [`LastSync`](crate::model::LastSync).
pub mod last_sync {

    /// A builder for [`LastSync`](crate::model::LastSync).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) last_sync_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_sync_status: std::option::Option<crate::model::LastSyncStatus>,
        pub(crate) last_sync_status_message: std::option::Option<std::string::String>,
        pub(crate) last_successful_sync_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_successful_sync_provisioning_artifact_id:
            std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The time of the last attempted sync from the repository to the Service Catalog product. </p>
        pub fn last_sync_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_sync_time = Some(input);
            self
        }
        /// <p>The time of the last attempted sync from the repository to the Service Catalog product. </p>
        pub fn set_last_sync_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_sync_time = input;
            self
        }
        /// <p>The current status of the sync. Responses include <code>SUCCEEDED</code> or <code>FAILED</code>. </p>
        pub fn last_sync_status(mut self, input: crate::model::LastSyncStatus) -> Self {
            self.last_sync_status = Some(input);
            self
        }
        /// <p>The current status of the sync. Responses include <code>SUCCEEDED</code> or <code>FAILED</code>. </p>
        pub fn set_last_sync_status(
            mut self,
            input: std::option::Option<crate::model::LastSyncStatus>,
        ) -> Self {
            self.last_sync_status = input;
            self
        }
        /// <p>The sync's status message. </p>
        pub fn last_sync_status_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_sync_status_message = Some(input.into());
            self
        }
        /// <p>The sync's status message. </p>
        pub fn set_last_sync_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_sync_status_message = input;
            self
        }
        /// <p>The time of the latest successful sync from the source repo artifact to the Service Catalog product.</p>
        pub fn last_successful_sync_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_successful_sync_time = Some(input);
            self
        }
        /// <p>The time of the latest successful sync from the source repo artifact to the Service Catalog product.</p>
        pub fn set_last_successful_sync_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_successful_sync_time = input;
            self
        }
        /// <p>The ProvisioningArtifactID of the ProvisioningArtifact created from the latest successful sync. </p>
        pub fn last_successful_sync_provisioning_artifact_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.last_successful_sync_provisioning_artifact_id = Some(input.into());
            self
        }
        /// <p>The ProvisioningArtifactID of the ProvisioningArtifact created from the latest successful sync. </p>
        pub fn set_last_successful_sync_provisioning_artifact_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_successful_sync_provisioning_artifact_id = input;
            self
        }
        /// Consumes the builder and constructs a [`LastSync`](crate::model::LastSync).
        pub fn build(self) -> crate::model::LastSync {
            crate::model::LastSync {
                last_sync_time: self.last_sync_time,
                last_sync_status: self.last_sync_status,
                last_sync_status_message: self.last_sync_status_message,
                last_successful_sync_time: self.last_successful_sync_time,
                last_successful_sync_provisioning_artifact_id: self
                    .last_successful_sync_provisioning_artifact_id,
            }
        }
    }
}

/// When writing a match expression against `LastSyncStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let lastsyncstatus = unimplemented!();
/// match lastsyncstatus {
///     LastSyncStatus::Failed => { /* ... */ },
///     LastSyncStatus::Succeeded => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `lastsyncstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `LastSyncStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `LastSyncStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `LastSyncStatus::NewFeature` is defined.
/// Specifically, when `lastsyncstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `LastSyncStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LastSyncStatus {
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Succeeded,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for LastSyncStatus {
    fn from(s: &str) -> Self {
        match s {
            "FAILED" => LastSyncStatus::Failed,
            "SUCCEEDED" => LastSyncStatus::Succeeded,
            other => LastSyncStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for LastSyncStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LastSyncStatus::from(s))
    }
}
impl LastSyncStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            LastSyncStatus::Failed => "FAILED",
            LastSyncStatus::Succeeded => "SUCCEEDED",
            LastSyncStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["FAILED", "SUCCEEDED"]
    }
}
impl AsRef<str> for LastSyncStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides connection details.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SourceConnectionParameters {
    /// <p>Provides <code>ConnectionType</code> details.</p>
    #[doc(hidden)]
    pub code_star: std::option::Option<crate::model::CodeStarParameters>,
}
impl SourceConnectionParameters {
    /// <p>Provides <code>ConnectionType</code> details.</p>
    pub fn code_star(&self) -> std::option::Option<&crate::model::CodeStarParameters> {
        self.code_star.as_ref()
    }
}
impl SourceConnectionParameters {
    /// Creates a new builder-style object to manufacture [`SourceConnectionParameters`](crate::model::SourceConnectionParameters).
    pub fn builder() -> crate::model::source_connection_parameters::Builder {
        crate::model::source_connection_parameters::Builder::default()
    }
}

/// See [`SourceConnectionParameters`](crate::model::SourceConnectionParameters).
pub mod source_connection_parameters {

    /// A builder for [`SourceConnectionParameters`](crate::model::SourceConnectionParameters).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code_star: std::option::Option<crate::model::CodeStarParameters>,
    }
    impl Builder {
        /// <p>Provides <code>ConnectionType</code> details.</p>
        pub fn code_star(mut self, input: crate::model::CodeStarParameters) -> Self {
            self.code_star = Some(input);
            self
        }
        /// <p>Provides <code>ConnectionType</code> details.</p>
        pub fn set_code_star(
            mut self,
            input: std::option::Option<crate::model::CodeStarParameters>,
        ) -> Self {
            self.code_star = input;
            self
        }
        /// Consumes the builder and constructs a [`SourceConnectionParameters`](crate::model::SourceConnectionParameters).
        pub fn build(self) -> crate::model::SourceConnectionParameters {
            crate::model::SourceConnectionParameters {
                code_star: self.code_star,
            }
        }
    }
}

/// <p>The subtype containing details about the Codestar connection <code>Type</code>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CodeStarParameters {
    /// <p>The CodeStar ARN, which is the connection between Service Catalog and the external repository.</p>
    #[doc(hidden)]
    pub connection_arn: std::option::Option<std::string::String>,
    /// <p>The specific repository where the product’s artifact-to-be-synced resides, formatted as "Account/Repo." </p>
    #[doc(hidden)]
    pub repository: std::option::Option<std::string::String>,
    /// <p>The specific branch where the artifact resides. </p>
    #[doc(hidden)]
    pub branch: std::option::Option<std::string::String>,
    /// <p>The absolute path wehre the artifact resides within the repo and branch, formatted as "folder/file.json." </p>
    #[doc(hidden)]
    pub artifact_path: std::option::Option<std::string::String>,
}
impl CodeStarParameters {
    /// <p>The CodeStar ARN, which is the connection between Service Catalog and the external repository.</p>
    pub fn connection_arn(&self) -> std::option::Option<&str> {
        self.connection_arn.as_deref()
    }
    /// <p>The specific repository where the product’s artifact-to-be-synced resides, formatted as "Account/Repo." </p>
    pub fn repository(&self) -> std::option::Option<&str> {
        self.repository.as_deref()
    }
    /// <p>The specific branch where the artifact resides. </p>
    pub fn branch(&self) -> std::option::Option<&str> {
        self.branch.as_deref()
    }
    /// <p>The absolute path wehre the artifact resides within the repo and branch, formatted as "folder/file.json." </p>
    pub fn artifact_path(&self) -> std::option::Option<&str> {
        self.artifact_path.as_deref()
    }
}
impl CodeStarParameters {
    /// Creates a new builder-style object to manufacture [`CodeStarParameters`](crate::model::CodeStarParameters).
    pub fn builder() -> crate::model::code_star_parameters::Builder {
        crate::model::code_star_parameters::Builder::default()
    }
}

/// See [`CodeStarParameters`](crate::model::CodeStarParameters).
pub mod code_star_parameters {

    /// A builder for [`CodeStarParameters`](crate::model::CodeStarParameters).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) connection_arn: std::option::Option<std::string::String>,
        pub(crate) repository: std::option::Option<std::string::String>,
        pub(crate) branch: std::option::Option<std::string::String>,
        pub(crate) artifact_path: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The CodeStar ARN, which is the connection between Service Catalog and the external repository.</p>
        pub fn connection_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.connection_arn = Some(input.into());
            self
        }
        /// <p>The CodeStar ARN, which is the connection between Service Catalog and the external repository.</p>
        pub fn set_connection_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.connection_arn = input;
            self
        }
        /// <p>The specific repository where the product’s artifact-to-be-synced resides, formatted as "Account/Repo." </p>
        pub fn repository(mut self, input: impl Into<std::string::String>) -> Self {
            self.repository = Some(input.into());
            self
        }
        /// <p>The specific repository where the product’s artifact-to-be-synced resides, formatted as "Account/Repo." </p>
        pub fn set_repository(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.repository = input;
            self
        }
        /// <p>The specific branch where the artifact resides. </p>
        pub fn branch(mut self, input: impl Into<std::string::String>) -> Self {
            self.branch = Some(input.into());
            self
        }
        /// <p>The specific branch where the artifact resides. </p>
        pub fn set_branch(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.branch = input;
            self
        }
        /// <p>The absolute path wehre the artifact resides within the repo and branch, formatted as "folder/file.json." </p>
        pub fn artifact_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.artifact_path = Some(input.into());
            self
        }
        /// <p>The absolute path wehre the artifact resides within the repo and branch, formatted as "folder/file.json." </p>
        pub fn set_artifact_path(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.artifact_path = input;
            self
        }
        /// Consumes the builder and constructs a [`CodeStarParameters`](crate::model::CodeStarParameters).
        pub fn build(self) -> crate::model::CodeStarParameters {
            crate::model::CodeStarParameters {
                connection_arn: self.connection_arn,
                repository: self.repository,
                branch: self.branch,
                artifact_path: self.artifact_path,
            }
        }
    }
}

/// When writing a match expression against `SourceType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let sourcetype = unimplemented!();
/// match sourcetype {
///     SourceType::Codestar => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `sourcetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SourceType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SourceType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SourceType::NewFeature` is defined.
/// Specifically, when `sourcetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SourceType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SourceType {
    #[allow(missing_docs)] // documentation missing in model
    Codestar,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for SourceType {
    fn from(s: &str) -> Self {
        match s {
            "CODESTAR" => SourceType::Codestar,
            other => SourceType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for SourceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SourceType::from(s))
    }
}
impl SourceType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SourceType::Codestar => "CODESTAR",
            SourceType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CODESTAR"]
    }
}
impl AsRef<str> for SourceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Summary information about a product view.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ProductViewSummary {
    /// <p>The product view identifier.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The product identifier.</p>
    #[doc(hidden)]
    pub product_id: std::option::Option<std::string::String>,
    /// <p>The name of the product.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The owner of the product. Contact the product administrator for the significance of this value.</p>
    #[doc(hidden)]
    pub owner: std::option::Option<std::string::String>,
    /// <p>Short description of the product.</p>
    #[doc(hidden)]
    pub short_description: std::option::Option<std::string::String>,
    /// <p>The product type. Contact the product administrator for the significance of this value. If this value is <code>MARKETPLACE</code>, the product was created by Amazon Web Services Marketplace.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::ProductType>,
    /// <p>The distributor of the product. Contact the product administrator for the significance of this value.</p>
    #[doc(hidden)]
    pub distributor: std::option::Option<std::string::String>,
    /// <p>Indicates whether the product has a default path. If the product does not have a default path, call <code>ListLaunchPaths</code> to disambiguate between paths. Otherwise, <code>ListLaunchPaths</code> is not required, and the output of <code>ProductViewSummary</code> can be used directly with <code>DescribeProvisioningParameters</code>.</p>
    #[doc(hidden)]
    pub has_default_path: bool,
    /// <p>The email contact information to obtain support for this Product.</p>
    #[doc(hidden)]
    pub support_email: std::option::Option<std::string::String>,
    /// <p>The description of the support for this Product.</p>
    #[doc(hidden)]
    pub support_description: std::option::Option<std::string::String>,
    /// <p>The URL information to obtain support for this Product.</p>
    #[doc(hidden)]
    pub support_url: std::option::Option<std::string::String>,
}
impl ProductViewSummary {
    /// <p>The product view identifier.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The product identifier.</p>
    pub fn product_id(&self) -> std::option::Option<&str> {
        self.product_id.as_deref()
    }
    /// <p>The name of the product.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The owner of the product. Contact the product administrator for the significance of this value.</p>
    pub fn owner(&self) -> std::option::Option<&str> {
        self.owner.as_deref()
    }
    /// <p>Short description of the product.</p>
    pub fn short_description(&self) -> std::option::Option<&str> {
        self.short_description.as_deref()
    }
    /// <p>The product type. Contact the product administrator for the significance of this value. If this value is <code>MARKETPLACE</code>, the product was created by Amazon Web Services Marketplace.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::ProductType> {
        self.r#type.as_ref()
    }
    /// <p>The distributor of the product. Contact the product administrator for the significance of this value.</p>
    pub fn distributor(&self) -> std::option::Option<&str> {
        self.distributor.as_deref()
    }
    /// <p>Indicates whether the product has a default path. If the product does not have a default path, call <code>ListLaunchPaths</code> to disambiguate between paths. Otherwise, <code>ListLaunchPaths</code> is not required, and the output of <code>ProductViewSummary</code> can be used directly with <code>DescribeProvisioningParameters</code>.</p>
    pub fn has_default_path(&self) -> bool {
        self.has_default_path
    }
    /// <p>The email contact information to obtain support for this Product.</p>
    pub fn support_email(&self) -> std::option::Option<&str> {
        self.support_email.as_deref()
    }
    /// <p>The description of the support for this Product.</p>
    pub fn support_description(&self) -> std::option::Option<&str> {
        self.support_description.as_deref()
    }
    /// <p>The URL information to obtain support for this Product.</p>
    pub fn support_url(&self) -> std::option::Option<&str> {
        self.support_url.as_deref()
    }
}
impl ProductViewSummary {
    /// Creates a new builder-style object to manufacture [`ProductViewSummary`](crate::model::ProductViewSummary).
    pub fn builder() -> crate::model::product_view_summary::Builder {
        crate::model::product_view_summary::Builder::default()
    }
}

/// See [`ProductViewSummary`](crate::model::ProductViewSummary).
pub mod product_view_summary {

    /// A builder for [`ProductViewSummary`](crate::model::ProductViewSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) product_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) owner: std::option::Option<std::string::String>,
        pub(crate) short_description: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::ProductType>,
        pub(crate) distributor: std::option::Option<std::string::String>,
        pub(crate) has_default_path: std::option::Option<bool>,
        pub(crate) support_email: std::option::Option<std::string::String>,
        pub(crate) support_description: std::option::Option<std::string::String>,
        pub(crate) support_url: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The product view identifier.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The product view identifier.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The product identifier.</p>
        pub fn product_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.product_id = Some(input.into());
            self
        }
        /// <p>The product identifier.</p>
        pub fn set_product_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.product_id = input;
            self
        }
        /// <p>The name of the product.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the product.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The owner of the product. Contact the product administrator for the significance of this value.</p>
        pub fn owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner = Some(input.into());
            self
        }
        /// <p>The owner of the product. Contact the product administrator for the significance of this value.</p>
        pub fn set_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner = input;
            self
        }
        /// <p>Short description of the product.</p>
        pub fn short_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.short_description = Some(input.into());
            self
        }
        /// <p>Short description of the product.</p>
        pub fn set_short_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.short_description = input;
            self
        }
        /// <p>The product type. Contact the product administrator for the significance of this value. If this value is <code>MARKETPLACE</code>, the product was created by Amazon Web Services Marketplace.</p>
        pub fn r#type(mut self, input: crate::model::ProductType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The product type. Contact the product administrator for the significance of this value. If this value is <code>MARKETPLACE</code>, the product was created by Amazon Web Services Marketplace.</p>
        pub fn set_type(mut self, input: std::option::Option<crate::model::ProductType>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The distributor of the product. Contact the product administrator for the significance of this value.</p>
        pub fn distributor(mut self, input: impl Into<std::string::String>) -> Self {
            self.distributor = Some(input.into());
            self
        }
        /// <p>The distributor of the product. Contact the product administrator for the significance of this value.</p>
        pub fn set_distributor(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.distributor = input;
            self
        }
        /// <p>Indicates whether the product has a default path. If the product does not have a default path, call <code>ListLaunchPaths</code> to disambiguate between paths. Otherwise, <code>ListLaunchPaths</code> is not required, and the output of <code>ProductViewSummary</code> can be used directly with <code>DescribeProvisioningParameters</code>.</p>
        pub fn has_default_path(mut self, input: bool) -> Self {
            self.has_default_path = Some(input);
            self
        }
        /// <p>Indicates whether the product has a default path. If the product does not have a default path, call <code>ListLaunchPaths</code> to disambiguate between paths. Otherwise, <code>ListLaunchPaths</code> is not required, and the output of <code>ProductViewSummary</code> can be used directly with <code>DescribeProvisioningParameters</code>.</p>
        pub fn set_has_default_path(mut self, input: std::option::Option<bool>) -> Self {
            self.has_default_path = input;
            self
        }
        /// <p>The email contact information to obtain support for this Product.</p>
        pub fn support_email(mut self, input: impl Into<std::string::String>) -> Self {
            self.support_email = Some(input.into());
            self
        }
        /// <p>The email contact information to obtain support for this Product.</p>
        pub fn set_support_email(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.support_email = input;
            self
        }
        /// <p>The description of the support for this Product.</p>
        pub fn support_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.support_description = Some(input.into());
            self
        }
        /// <p>The description of the support for this Product.</p>
        pub fn set_support_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.support_description = input;
            self
        }
        /// <p>The URL information to obtain support for this Product.</p>
        pub fn support_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.support_url = Some(input.into());
            self
        }
        /// <p>The URL information to obtain support for this Product.</p>
        pub fn set_support_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.support_url = input;
            self
        }
        /// Consumes the builder and constructs a [`ProductViewSummary`](crate::model::ProductViewSummary).
        pub fn build(self) -> crate::model::ProductViewSummary {
            crate::model::ProductViewSummary {
                id: self.id,
                product_id: self.product_id,
                name: self.name,
                owner: self.owner,
                short_description: self.short_description,
                r#type: self.r#type,
                distributor: self.distributor,
                has_default_path: self.has_default_path.unwrap_or_default(),
                support_email: self.support_email,
                support_description: self.support_description,
                support_url: self.support_url,
            }
        }
    }
}

/// When writing a match expression against `ProductType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let producttype = unimplemented!();
/// match producttype {
///     ProductType::CloudFormationTemplate => { /* ... */ },
///     ProductType::Marketplace => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `producttype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ProductType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ProductType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ProductType::NewFeature` is defined.
/// Specifically, when `producttype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ProductType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ProductType {
    #[allow(missing_docs)] // documentation missing in model
    CloudFormationTemplate,
    #[allow(missing_docs)] // documentation missing in model
    Marketplace,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ProductType {
    fn from(s: &str) -> Self {
        match s {
            "CLOUD_FORMATION_TEMPLATE" => ProductType::CloudFormationTemplate,
            "MARKETPLACE" => ProductType::Marketplace,
            other => ProductType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ProductType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ProductType::from(s))
    }
}
impl ProductType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ProductType::CloudFormationTemplate => "CLOUD_FORMATION_TEMPLATE",
            ProductType::Marketplace => "MARKETPLACE",
            ProductType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CLOUD_FORMATION_TEMPLATE", "MARKETPLACE"]
    }
}
impl AsRef<str> for ProductType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A top level <code>ProductViewDetail</code> response containing details about the product’s connection. Service Catalog returns this field for the <code>CreateProduct</code>, <code>UpdateProduct</code>, <code>DescribeProductAsAdmin</code>, and <code>SearchProductAsAdmin</code> APIs. This response contains the same fields as the <code>ConnectionParameters</code> request, with the addition of the <code>LastSync</code> response.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SourceConnection {
    /// <p>The only supported <code>SourceConnection</code> type is Codestar. </p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::SourceType>,
    /// <p>The connection details based on the connection <code>Type</code>. </p>
    #[doc(hidden)]
    pub connection_parameters: std::option::Option<crate::model::SourceConnectionParameters>,
}
impl SourceConnection {
    /// <p>The only supported <code>SourceConnection</code> type is Codestar. </p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::SourceType> {
        self.r#type.as_ref()
    }
    /// <p>The connection details based on the connection <code>Type</code>. </p>
    pub fn connection_parameters(
        &self,
    ) -> std::option::Option<&crate::model::SourceConnectionParameters> {
        self.connection_parameters.as_ref()
    }
}
impl SourceConnection {
    /// Creates a new builder-style object to manufacture [`SourceConnection`](crate::model::SourceConnection).
    pub fn builder() -> crate::model::source_connection::Builder {
        crate::model::source_connection::Builder::default()
    }
}

/// See [`SourceConnection`](crate::model::SourceConnection).
pub mod source_connection {

    /// A builder for [`SourceConnection`](crate::model::SourceConnection).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<crate::model::SourceType>,
        pub(crate) connection_parameters:
            std::option::Option<crate::model::SourceConnectionParameters>,
    }
    impl Builder {
        /// <p>The only supported <code>SourceConnection</code> type is Codestar. </p>
        pub fn r#type(mut self, input: crate::model::SourceType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The only supported <code>SourceConnection</code> type is Codestar. </p>
        pub fn set_type(mut self, input: std::option::Option<crate::model::SourceType>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The connection details based on the connection <code>Type</code>. </p>
        pub fn connection_parameters(
            mut self,
            input: crate::model::SourceConnectionParameters,
        ) -> Self {
            self.connection_parameters = Some(input);
            self
        }
        /// <p>The connection details based on the connection <code>Type</code>. </p>
        pub fn set_connection_parameters(
            mut self,
            input: std::option::Option<crate::model::SourceConnectionParameters>,
        ) -> Self {
            self.connection_parameters = input;
            self
        }
        /// Consumes the builder and constructs a [`SourceConnection`](crate::model::SourceConnection).
        pub fn build(self) -> crate::model::SourceConnection {
            crate::model::SourceConnection {
                r#type: self.r#type,
                connection_parameters: self.connection_parameters,
            }
        }
    }
}

/// When writing a match expression against `ShareStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let sharestatus = unimplemented!();
/// match sharestatus {
///     ShareStatus::Completed => { /* ... */ },
///     ShareStatus::CompletedWithErrors => { /* ... */ },
///     ShareStatus::Error => { /* ... */ },
///     ShareStatus::InProgress => { /* ... */ },
///     ShareStatus::NotStarted => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `sharestatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ShareStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ShareStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ShareStatus::NewFeature` is defined.
/// Specifically, when `sharestatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ShareStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ShareStatus {
    #[allow(missing_docs)] // documentation missing in model
    Completed,
    #[allow(missing_docs)] // documentation missing in model
    CompletedWithErrors,
    #[allow(missing_docs)] // documentation missing in model
    Error,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    #[allow(missing_docs)] // documentation missing in model
    NotStarted,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ShareStatus {
    fn from(s: &str) -> Self {
        match s {
            "COMPLETED" => ShareStatus::Completed,
            "COMPLETED_WITH_ERRORS" => ShareStatus::CompletedWithErrors,
            "ERROR" => ShareStatus::Error,
            "IN_PROGRESS" => ShareStatus::InProgress,
            "NOT_STARTED" => ShareStatus::NotStarted,
            other => ShareStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ShareStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ShareStatus::from(s))
    }
}
impl ShareStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ShareStatus::Completed => "COMPLETED",
            ShareStatus::CompletedWithErrors => "COMPLETED_WITH_ERRORS",
            ShareStatus::Error => "ERROR",
            ShareStatus::InProgress => "IN_PROGRESS",
            ShareStatus::NotStarted => "NOT_STARTED",
            ShareStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "COMPLETED",
            "COMPLETED_WITH_ERRORS",
            "ERROR",
            "IN_PROGRESS",
            "NOT_STARTED",
        ]
    }
}
impl AsRef<str> for ShareStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about the organization node.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct OrganizationNode {
    /// <p>The organization node type.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::OrganizationNodeType>,
    /// <p>The identifier of the organization node.</p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
}
impl OrganizationNode {
    /// <p>The organization node type.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::OrganizationNodeType> {
        self.r#type.as_ref()
    }
    /// <p>The identifier of the organization node.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
impl OrganizationNode {
    /// Creates a new builder-style object to manufacture [`OrganizationNode`](crate::model::OrganizationNode).
    pub fn builder() -> crate::model::organization_node::Builder {
        crate::model::organization_node::Builder::default()
    }
}

/// See [`OrganizationNode`](crate::model::OrganizationNode).
pub mod organization_node {

    /// A builder for [`OrganizationNode`](crate::model::OrganizationNode).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<crate::model::OrganizationNodeType>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The organization node type.</p>
        pub fn r#type(mut self, input: crate::model::OrganizationNodeType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The organization node type.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::OrganizationNodeType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The identifier of the organization node.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The identifier of the organization node.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`OrganizationNode`](crate::model::OrganizationNode).
        pub fn build(self) -> crate::model::OrganizationNode {
            crate::model::OrganizationNode {
                r#type: self.r#type,
                value: self.value,
            }
        }
    }
}

/// When writing a match expression against `OrganizationNodeType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let organizationnodetype = unimplemented!();
/// match organizationnodetype {
///     OrganizationNodeType::Account => { /* ... */ },
///     OrganizationNodeType::Organization => { /* ... */ },
///     OrganizationNodeType::OrganizationalUnit => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `organizationnodetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `OrganizationNodeType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `OrganizationNodeType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `OrganizationNodeType::NewFeature` is defined.
/// Specifically, when `organizationnodetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `OrganizationNodeType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum OrganizationNodeType {
    #[allow(missing_docs)] // documentation missing in model
    Account,
    #[allow(missing_docs)] // documentation missing in model
    Organization,
    #[allow(missing_docs)] // documentation missing in model
    OrganizationalUnit,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for OrganizationNodeType {
    fn from(s: &str) -> Self {
        match s {
            "ACCOUNT" => OrganizationNodeType::Account,
            "ORGANIZATION" => OrganizationNodeType::Organization,
            "ORGANIZATIONAL_UNIT" => OrganizationNodeType::OrganizationalUnit,
            other => {
                OrganizationNodeType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for OrganizationNodeType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(OrganizationNodeType::from(s))
    }
}
impl OrganizationNodeType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            OrganizationNodeType::Account => "ACCOUNT",
            OrganizationNodeType::Organization => "ORGANIZATION",
            OrganizationNodeType::OrganizationalUnit => "ORGANIZATIONAL_UNIT",
            OrganizationNodeType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ACCOUNT", "ORGANIZATION", "ORGANIZATIONAL_UNIT"]
    }
}
impl AsRef<str> for OrganizationNodeType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about a portfolio.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PortfolioDetail {
    /// <p>The portfolio identifier.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The ARN assigned to the portfolio.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The name to use for display purposes.</p>
    #[doc(hidden)]
    pub display_name: std::option::Option<std::string::String>,
    /// <p>The description of the portfolio.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The UTC time stamp of the creation time.</p>
    #[doc(hidden)]
    pub created_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The name of the portfolio provider.</p>
    #[doc(hidden)]
    pub provider_name: std::option::Option<std::string::String>,
}
impl PortfolioDetail {
    /// <p>The portfolio identifier.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The ARN assigned to the portfolio.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The name to use for display purposes.</p>
    pub fn display_name(&self) -> std::option::Option<&str> {
        self.display_name.as_deref()
    }
    /// <p>The description of the portfolio.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The UTC time stamp of the creation time.</p>
    pub fn created_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_time.as_ref()
    }
    /// <p>The name of the portfolio provider.</p>
    pub fn provider_name(&self) -> std::option::Option<&str> {
        self.provider_name.as_deref()
    }
}
impl PortfolioDetail {
    /// Creates a new builder-style object to manufacture [`PortfolioDetail`](crate::model::PortfolioDetail).
    pub fn builder() -> crate::model::portfolio_detail::Builder {
        crate::model::portfolio_detail::Builder::default()
    }
}

/// See [`PortfolioDetail`](crate::model::PortfolioDetail).
pub mod portfolio_detail {

    /// A builder for [`PortfolioDetail`](crate::model::PortfolioDetail).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) display_name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) created_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) provider_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The portfolio identifier.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The portfolio identifier.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The ARN assigned to the portfolio.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The ARN assigned to the portfolio.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The name to use for display purposes.</p>
        pub fn display_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.display_name = Some(input.into());
            self
        }
        /// <p>The name to use for display purposes.</p>
        pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.display_name = input;
            self
        }
        /// <p>The description of the portfolio.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the portfolio.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The UTC time stamp of the creation time.</p>
        pub fn created_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_time = Some(input);
            self
        }
        /// <p>The UTC time stamp of the creation time.</p>
        pub fn set_created_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_time = input;
            self
        }
        /// <p>The name of the portfolio provider.</p>
        pub fn provider_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.provider_name = Some(input.into());
            self
        }
        /// <p>The name of the portfolio provider.</p>
        pub fn set_provider_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.provider_name = input;
            self
        }
        /// Consumes the builder and constructs a [`PortfolioDetail`](crate::model::PortfolioDetail).
        pub fn build(self) -> crate::model::PortfolioDetail {
            crate::model::PortfolioDetail {
                id: self.id,
                arn: self.arn,
                display_name: self.display_name,
                description: self.description,
                created_time: self.created_time,
                provider_name: self.provider_name,
            }
        }
    }
}

/// <p>Information about a constraint.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConstraintDetail {
    /// <p>The identifier of the constraint.</p>
    #[doc(hidden)]
    pub constraint_id: std::option::Option<std::string::String>,
    /// <p>The type of constraint.</p>
    /// <ul>
    /// <li> <p> <code>LAUNCH</code> </p> </li>
    /// <li> <p> <code>NOTIFICATION</code> </p> </li>
    /// <li> <p>STACKSET</p> </li>
    /// <li> <p> <code>TEMPLATE</code> </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub r#type: std::option::Option<std::string::String>,
    /// <p>The description of the constraint.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The owner of the constraint.</p>
    #[doc(hidden)]
    pub owner: std::option::Option<std::string::String>,
    /// <p>The identifier of the product the constraint applies to. Note that a constraint applies to a specific instance of a product within a certain portfolio.</p>
    #[doc(hidden)]
    pub product_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the portfolio the product resides in. The constraint applies only to the instance of the product that lives within this portfolio.</p>
    #[doc(hidden)]
    pub portfolio_id: std::option::Option<std::string::String>,
}
impl ConstraintDetail {
    /// <p>The identifier of the constraint.</p>
    pub fn constraint_id(&self) -> std::option::Option<&str> {
        self.constraint_id.as_deref()
    }
    /// <p>The type of constraint.</p>
    /// <ul>
    /// <li> <p> <code>LAUNCH</code> </p> </li>
    /// <li> <p> <code>NOTIFICATION</code> </p> </li>
    /// <li> <p>STACKSET</p> </li>
    /// <li> <p> <code>TEMPLATE</code> </p> </li>
    /// </ul>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
    /// <p>The description of the constraint.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The owner of the constraint.</p>
    pub fn owner(&self) -> std::option::Option<&str> {
        self.owner.as_deref()
    }
    /// <p>The identifier of the product the constraint applies to. Note that a constraint applies to a specific instance of a product within a certain portfolio.</p>
    pub fn product_id(&self) -> std::option::Option<&str> {
        self.product_id.as_deref()
    }
    /// <p>The identifier of the portfolio the product resides in. The constraint applies only to the instance of the product that lives within this portfolio.</p>
    pub fn portfolio_id(&self) -> std::option::Option<&str> {
        self.portfolio_id.as_deref()
    }
}
impl ConstraintDetail {
    /// Creates a new builder-style object to manufacture [`ConstraintDetail`](crate::model::ConstraintDetail).
    pub fn builder() -> crate::model::constraint_detail::Builder {
        crate::model::constraint_detail::Builder::default()
    }
}

/// See [`ConstraintDetail`](crate::model::ConstraintDetail).
pub mod constraint_detail {

    /// A builder for [`ConstraintDetail`](crate::model::ConstraintDetail).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) constraint_id: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) owner: std::option::Option<std::string::String>,
        pub(crate) product_id: std::option::Option<std::string::String>,
        pub(crate) portfolio_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the constraint.</p>
        pub fn constraint_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.constraint_id = Some(input.into());
            self
        }
        /// <p>The identifier of the constraint.</p>
        pub fn set_constraint_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.constraint_id = input;
            self
        }
        /// <p>The type of constraint.</p>
        /// <ul>
        /// <li> <p> <code>LAUNCH</code> </p> </li>
        /// <li> <p> <code>NOTIFICATION</code> </p> </li>
        /// <li> <p>STACKSET</p> </li>
        /// <li> <p> <code>TEMPLATE</code> </p> </li>
        /// </ul>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The type of constraint.</p>
        /// <ul>
        /// <li> <p> <code>LAUNCH</code> </p> </li>
        /// <li> <p> <code>NOTIFICATION</code> </p> </li>
        /// <li> <p>STACKSET</p> </li>
        /// <li> <p> <code>TEMPLATE</code> </p> </li>
        /// </ul>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The description of the constraint.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the constraint.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The owner of the constraint.</p>
        pub fn owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner = Some(input.into());
            self
        }
        /// <p>The owner of the constraint.</p>
        pub fn set_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner = input;
            self
        }
        /// <p>The identifier of the product the constraint applies to. Note that a constraint applies to a specific instance of a product within a certain portfolio.</p>
        pub fn product_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.product_id = Some(input.into());
            self
        }
        /// <p>The identifier of the product the constraint applies to. Note that a constraint applies to a specific instance of a product within a certain portfolio.</p>
        pub fn set_product_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.product_id = input;
            self
        }
        /// <p>The identifier of the portfolio the product resides in. The constraint applies only to the instance of the product that lives within this portfolio.</p>
        pub fn portfolio_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.portfolio_id = Some(input.into());
            self
        }
        /// <p>The identifier of the portfolio the product resides in. The constraint applies only to the instance of the product that lives within this portfolio.</p>
        pub fn set_portfolio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.portfolio_id = input;
            self
        }
        /// Consumes the builder and constructs a [`ConstraintDetail`](crate::model::ConstraintDetail).
        pub fn build(self) -> crate::model::ConstraintDetail {
            crate::model::ConstraintDetail {
                constraint_id: self.constraint_id,
                r#type: self.r#type,
                description: self.description,
                owner: self.owner,
                product_id: self.product_id,
                portfolio_id: self.portfolio_id,
            }
        }
    }
}

/// <p>Information about a provisioned product.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ProvisionedProductAttribute {
    /// <p>The user-friendly name of the provisioned product.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The ARN of the provisioned product.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The type of provisioned product. The supported values are <code>CFN_STACK</code> and <code>CFN_STACKSET</code>.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<std::string::String>,
    /// <p>The identifier of the provisioned product.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The current status of the provisioned product.</p>
    /// <ul>
    /// <li> <p> <code>AVAILABLE</code> - Stable state, ready to perform any operation. The most recent operation succeeded and completed.</p> </li>
    /// <li> <p> <code>UNDER_CHANGE</code> - Transitive state. Operations performed might not have valid results. Wait for an <code>AVAILABLE</code> status before performing operations.</p> </li>
    /// <li> <p> <code>TAINTED</code> - Stable state, ready to perform any operation. The stack has completed the requested operation but is not exactly what was requested. For example, a request to update to a new version failed and the stack rolled back to the current version.</p> </li>
    /// <li> <p> <code>ERROR</code> - An unexpected error occurred. The provisioned product exists but the stack is not running. For example, CloudFormation received a parameter value that was not valid and could not launch the stack.</p> </li>
    /// <li> <p> <code>PLAN_IN_PROGRESS</code> - Transitive state. The plan operations were performed to provision a new product, but resources have not yet been created. After reviewing the list of resources to be created, execute the plan. Wait for an <code>AVAILABLE</code> status before performing operations.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::ProvisionedProductStatus>,
    /// <p>The current status message of the provisioned product.</p>
    #[doc(hidden)]
    pub status_message: std::option::Option<std::string::String>,
    /// <p>The UTC time stamp of the creation time.</p>
    #[doc(hidden)]
    pub created_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>A unique identifier that you provide to ensure idempotency. If multiple requests differ only by the idempotency token, the same response is returned for each repeated request.</p>
    #[doc(hidden)]
    pub idempotency_token: std::option::Option<std::string::String>,
    /// <p>The record identifier of the last request performed on this provisioned product.</p>
    #[doc(hidden)]
    pub last_record_id: std::option::Option<std::string::String>,
    /// <p>The record identifier of the last request performed on this provisioned product of the following types:</p>
    /// <ul>
    /// <li> <p> ProvisionedProduct </p> </li>
    /// <li> <p> UpdateProvisionedProduct </p> </li>
    /// <li> <p> ExecuteProvisionedProductPlan </p> </li>
    /// <li> <p> TerminateProvisionedProduct </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub last_provisioning_record_id: std::option::Option<std::string::String>,
    /// <p>The record identifier of the last successful request performed on this provisioned product of the following types:</p>
    /// <ul>
    /// <li> <p> ProvisionedProduct </p> </li>
    /// <li> <p> UpdateProvisionedProduct </p> </li>
    /// <li> <p> ExecuteProvisionedProductPlan </p> </li>
    /// <li> <p> TerminateProvisionedProduct </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub last_successful_provisioning_record_id: std::option::Option<std::string::String>,
    /// <p>One or more tags.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>The assigned identifier for the resource, such as an EC2 instance ID or an S3 bucket name.</p>
    #[doc(hidden)]
    pub physical_id: std::option::Option<std::string::String>,
    /// <p>The product identifier.</p>
    #[doc(hidden)]
    pub product_id: std::option::Option<std::string::String>,
    /// <p>The name of the product.</p>
    #[doc(hidden)]
    pub product_name: std::option::Option<std::string::String>,
    /// <p>The identifier of the provisioning artifact.</p>
    #[doc(hidden)]
    pub provisioning_artifact_id: std::option::Option<std::string::String>,
    /// <p>The name of the provisioning artifact.</p>
    #[doc(hidden)]
    pub provisioning_artifact_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the IAM user.</p>
    #[doc(hidden)]
    pub user_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of the IAM user in the session. This ARN might contain a session ID.</p>
    #[doc(hidden)]
    pub user_arn_session: std::option::Option<std::string::String>,
}
impl ProvisionedProductAttribute {
    /// <p>The user-friendly name of the provisioned product.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The ARN of the provisioned product.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The type of provisioned product. The supported values are <code>CFN_STACK</code> and <code>CFN_STACKSET</code>.</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
    /// <p>The identifier of the provisioned product.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The current status of the provisioned product.</p>
    /// <ul>
    /// <li> <p> <code>AVAILABLE</code> - Stable state, ready to perform any operation. The most recent operation succeeded and completed.</p> </li>
    /// <li> <p> <code>UNDER_CHANGE</code> - Transitive state. Operations performed might not have valid results. Wait for an <code>AVAILABLE</code> status before performing operations.</p> </li>
    /// <li> <p> <code>TAINTED</code> - Stable state, ready to perform any operation. The stack has completed the requested operation but is not exactly what was requested. For example, a request to update to a new version failed and the stack rolled back to the current version.</p> </li>
    /// <li> <p> <code>ERROR</code> - An unexpected error occurred. The provisioned product exists but the stack is not running. For example, CloudFormation received a parameter value that was not valid and could not launch the stack.</p> </li>
    /// <li> <p> <code>PLAN_IN_PROGRESS</code> - Transitive state. The plan operations were performed to provision a new product, but resources have not yet been created. After reviewing the list of resources to be created, execute the plan. Wait for an <code>AVAILABLE</code> status before performing operations.</p> </li>
    /// </ul>
    pub fn status(&self) -> std::option::Option<&crate::model::ProvisionedProductStatus> {
        self.status.as_ref()
    }
    /// <p>The current status message of the provisioned product.</p>
    pub fn status_message(&self) -> std::option::Option<&str> {
        self.status_message.as_deref()
    }
    /// <p>The UTC time stamp of the creation time.</p>
    pub fn created_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_time.as_ref()
    }
    /// <p>A unique identifier that you provide to ensure idempotency. If multiple requests differ only by the idempotency token, the same response is returned for each repeated request.</p>
    pub fn idempotency_token(&self) -> std::option::Option<&str> {
        self.idempotency_token.as_deref()
    }
    /// <p>The record identifier of the last request performed on this provisioned product.</p>
    pub fn last_record_id(&self) -> std::option::Option<&str> {
        self.last_record_id.as_deref()
    }
    /// <p>The record identifier of the last request performed on this provisioned product of the following types:</p>
    /// <ul>
    /// <li> <p> ProvisionedProduct </p> </li>
    /// <li> <p> UpdateProvisionedProduct </p> </li>
    /// <li> <p> ExecuteProvisionedProductPlan </p> </li>
    /// <li> <p> TerminateProvisionedProduct </p> </li>
    /// </ul>
    pub fn last_provisioning_record_id(&self) -> std::option::Option<&str> {
        self.last_provisioning_record_id.as_deref()
    }
    /// <p>The record identifier of the last successful request performed on this provisioned product of the following types:</p>
    /// <ul>
    /// <li> <p> ProvisionedProduct </p> </li>
    /// <li> <p> UpdateProvisionedProduct </p> </li>
    /// <li> <p> ExecuteProvisionedProductPlan </p> </li>
    /// <li> <p> TerminateProvisionedProduct </p> </li>
    /// </ul>
    pub fn last_successful_provisioning_record_id(&self) -> std::option::Option<&str> {
        self.last_successful_provisioning_record_id.as_deref()
    }
    /// <p>One or more tags.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
    /// <p>The assigned identifier for the resource, such as an EC2 instance ID or an S3 bucket name.</p>
    pub fn physical_id(&self) -> std::option::Option<&str> {
        self.physical_id.as_deref()
    }
    /// <p>The product identifier.</p>
    pub fn product_id(&self) -> std::option::Option<&str> {
        self.product_id.as_deref()
    }
    /// <p>The name of the product.</p>
    pub fn product_name(&self) -> std::option::Option<&str> {
        self.product_name.as_deref()
    }
    /// <p>The identifier of the provisioning artifact.</p>
    pub fn provisioning_artifact_id(&self) -> std::option::Option<&str> {
        self.provisioning_artifact_id.as_deref()
    }
    /// <p>The name of the provisioning artifact.</p>
    pub fn provisioning_artifact_name(&self) -> std::option::Option<&str> {
        self.provisioning_artifact_name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the IAM user.</p>
    pub fn user_arn(&self) -> std::option::Option<&str> {
        self.user_arn.as_deref()
    }
    /// <p>The ARN of the IAM user in the session. This ARN might contain a session ID.</p>
    pub fn user_arn_session(&self) -> std::option::Option<&str> {
        self.user_arn_session.as_deref()
    }
}
impl ProvisionedProductAttribute {
    /// Creates a new builder-style object to manufacture [`ProvisionedProductAttribute`](crate::model::ProvisionedProductAttribute).
    pub fn builder() -> crate::model::provisioned_product_attribute::Builder {
        crate::model::provisioned_product_attribute::Builder::default()
    }
}

/// See [`ProvisionedProductAttribute`](crate::model::ProvisionedProductAttribute).
pub mod provisioned_product_attribute {

    /// A builder for [`ProvisionedProductAttribute`](crate::model::ProvisionedProductAttribute).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::ProvisionedProductStatus>,
        pub(crate) status_message: std::option::Option<std::string::String>,
        pub(crate) created_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) idempotency_token: std::option::Option<std::string::String>,
        pub(crate) last_record_id: std::option::Option<std::string::String>,
        pub(crate) last_provisioning_record_id: std::option::Option<std::string::String>,
        pub(crate) last_successful_provisioning_record_id: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) physical_id: std::option::Option<std::string::String>,
        pub(crate) product_id: std::option::Option<std::string::String>,
        pub(crate) product_name: std::option::Option<std::string::String>,
        pub(crate) provisioning_artifact_id: std::option::Option<std::string::String>,
        pub(crate) provisioning_artifact_name: std::option::Option<std::string::String>,
        pub(crate) user_arn: std::option::Option<std::string::String>,
        pub(crate) user_arn_session: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The user-friendly name of the provisioned product.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The user-friendly name of the provisioned product.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The ARN of the provisioned product.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The ARN of the provisioned product.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The type of provisioned product. The supported values are <code>CFN_STACK</code> and <code>CFN_STACKSET</code>.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The type of provisioned product. The supported values are <code>CFN_STACK</code> and <code>CFN_STACKSET</code>.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The identifier of the provisioned product.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of the provisioned product.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The current status of the provisioned product.</p>
        /// <ul>
        /// <li> <p> <code>AVAILABLE</code> - Stable state, ready to perform any operation. The most recent operation succeeded and completed.</p> </li>
        /// <li> <p> <code>UNDER_CHANGE</code> - Transitive state. Operations performed might not have valid results. Wait for an <code>AVAILABLE</code> status before performing operations.</p> </li>
        /// <li> <p> <code>TAINTED</code> - Stable state, ready to perform any operation. The stack has completed the requested operation but is not exactly what was requested. For example, a request to update to a new version failed and the stack rolled back to the current version.</p> </li>
        /// <li> <p> <code>ERROR</code> - An unexpected error occurred. The provisioned product exists but the stack is not running. For example, CloudFormation received a parameter value that was not valid and could not launch the stack.</p> </li>
        /// <li> <p> <code>PLAN_IN_PROGRESS</code> - Transitive state. The plan operations were performed to provision a new product, but resources have not yet been created. After reviewing the list of resources to be created, execute the plan. Wait for an <code>AVAILABLE</code> status before performing operations.</p> </li>
        /// </ul>
        pub fn status(mut self, input: crate::model::ProvisionedProductStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The current status of the provisioned product.</p>
        /// <ul>
        /// <li> <p> <code>AVAILABLE</code> - Stable state, ready to perform any operation. The most recent operation succeeded and completed.</p> </li>
        /// <li> <p> <code>UNDER_CHANGE</code> - Transitive state. Operations performed might not have valid results. Wait for an <code>AVAILABLE</code> status before performing operations.</p> </li>
        /// <li> <p> <code>TAINTED</code> - Stable state, ready to perform any operation. The stack has completed the requested operation but is not exactly what was requested. For example, a request to update to a new version failed and the stack rolled back to the current version.</p> </li>
        /// <li> <p> <code>ERROR</code> - An unexpected error occurred. The provisioned product exists but the stack is not running. For example, CloudFormation received a parameter value that was not valid and could not launch the stack.</p> </li>
        /// <li> <p> <code>PLAN_IN_PROGRESS</code> - Transitive state. The plan operations were performed to provision a new product, but resources have not yet been created. After reviewing the list of resources to be created, execute the plan. Wait for an <code>AVAILABLE</code> status before performing operations.</p> </li>
        /// </ul>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ProvisionedProductStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The current status message of the provisioned product.</p>
        pub fn status_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_message = Some(input.into());
            self
        }
        /// <p>The current status message of the provisioned product.</p>
        pub fn set_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_message = input;
            self
        }
        /// <p>The UTC time stamp of the creation time.</p>
        pub fn created_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_time = Some(input);
            self
        }
        /// <p>The UTC time stamp of the creation time.</p>
        pub fn set_created_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_time = input;
            self
        }
        /// <p>A unique identifier that you provide to ensure idempotency. If multiple requests differ only by the idempotency token, the same response is returned for each repeated request.</p>
        pub fn idempotency_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.idempotency_token = Some(input.into());
            self
        }
        /// <p>A unique identifier that you provide to ensure idempotency. If multiple requests differ only by the idempotency token, the same response is returned for each repeated request.</p>
        pub fn set_idempotency_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.idempotency_token = input;
            self
        }
        /// <p>The record identifier of the last request performed on this provisioned product.</p>
        pub fn last_record_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_record_id = Some(input.into());
            self
        }
        /// <p>The record identifier of the last request performed on this provisioned product.</p>
        pub fn set_last_record_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_record_id = input;
            self
        }
        /// <p>The record identifier of the last request performed on this provisioned product of the following types:</p>
        /// <ul>
        /// <li> <p> ProvisionedProduct </p> </li>
        /// <li> <p> UpdateProvisionedProduct </p> </li>
        /// <li> <p> ExecuteProvisionedProductPlan </p> </li>
        /// <li> <p> TerminateProvisionedProduct </p> </li>
        /// </ul>
        pub fn last_provisioning_record_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.last_provisioning_record_id = Some(input.into());
            self
        }
        /// <p>The record identifier of the last request performed on this provisioned product of the following types:</p>
        /// <ul>
        /// <li> <p> ProvisionedProduct </p> </li>
        /// <li> <p> UpdateProvisionedProduct </p> </li>
        /// <li> <p> ExecuteProvisionedProductPlan </p> </li>
        /// <li> <p> TerminateProvisionedProduct </p> </li>
        /// </ul>
        pub fn set_last_provisioning_record_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_provisioning_record_id = input;
            self
        }
        /// <p>The record identifier of the last successful request performed on this provisioned product of the following types:</p>
        /// <ul>
        /// <li> <p> ProvisionedProduct </p> </li>
        /// <li> <p> UpdateProvisionedProduct </p> </li>
        /// <li> <p> ExecuteProvisionedProductPlan </p> </li>
        /// <li> <p> TerminateProvisionedProduct </p> </li>
        /// </ul>
        pub fn last_successful_provisioning_record_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.last_successful_provisioning_record_id = Some(input.into());
            self
        }
        /// <p>The record identifier of the last successful request performed on this provisioned product of the following types:</p>
        /// <ul>
        /// <li> <p> ProvisionedProduct </p> </li>
        /// <li> <p> UpdateProvisionedProduct </p> </li>
        /// <li> <p> ExecuteProvisionedProductPlan </p> </li>
        /// <li> <p> TerminateProvisionedProduct </p> </li>
        /// </ul>
        pub fn set_last_successful_provisioning_record_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_successful_provisioning_record_id = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>One or more tags.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>One or more tags.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The assigned identifier for the resource, such as an EC2 instance ID or an S3 bucket name.</p>
        pub fn physical_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.physical_id = Some(input.into());
            self
        }
        /// <p>The assigned identifier for the resource, such as an EC2 instance ID or an S3 bucket name.</p>
        pub fn set_physical_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.physical_id = input;
            self
        }
        /// <p>The product identifier.</p>
        pub fn product_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.product_id = Some(input.into());
            self
        }
        /// <p>The product identifier.</p>
        pub fn set_product_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.product_id = input;
            self
        }
        /// <p>The name of the product.</p>
        pub fn product_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.product_name = Some(input.into());
            self
        }
        /// <p>The name of the product.</p>
        pub fn set_product_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.product_name = input;
            self
        }
        /// <p>The identifier of the provisioning artifact.</p>
        pub fn provisioning_artifact_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.provisioning_artifact_id = Some(input.into());
            self
        }
        /// <p>The identifier of the provisioning artifact.</p>
        pub fn set_provisioning_artifact_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.provisioning_artifact_id = input;
            self
        }
        /// <p>The name of the provisioning artifact.</p>
        pub fn provisioning_artifact_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.provisioning_artifact_name = Some(input.into());
            self
        }
        /// <p>The name of the provisioning artifact.</p>
        pub fn set_provisioning_artifact_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.provisioning_artifact_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the IAM user.</p>
        pub fn user_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the IAM user.</p>
        pub fn set_user_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.user_arn = input;
            self
        }
        /// <p>The ARN of the IAM user in the session. This ARN might contain a session ID.</p>
        pub fn user_arn_session(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_arn_session = Some(input.into());
            self
        }
        /// <p>The ARN of the IAM user in the session. This ARN might contain a session ID.</p>
        pub fn set_user_arn_session(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.user_arn_session = input;
            self
        }
        /// Consumes the builder and constructs a [`ProvisionedProductAttribute`](crate::model::ProvisionedProductAttribute).
        pub fn build(self) -> crate::model::ProvisionedProductAttribute {
            crate::model::ProvisionedProductAttribute {
                name: self.name,
                arn: self.arn,
                r#type: self.r#type,
                id: self.id,
                status: self.status,
                status_message: self.status_message,
                created_time: self.created_time,
                idempotency_token: self.idempotency_token,
                last_record_id: self.last_record_id,
                last_provisioning_record_id: self.last_provisioning_record_id,
                last_successful_provisioning_record_id: self.last_successful_provisioning_record_id,
                tags: self.tags,
                physical_id: self.physical_id,
                product_id: self.product_id,
                product_name: self.product_name,
                provisioning_artifact_id: self.provisioning_artifact_id,
                provisioning_artifact_name: self.provisioning_artifact_name,
                user_arn: self.user_arn,
                user_arn_session: self.user_arn_session,
            }
        }
    }
}

/// When writing a match expression against `ProvisionedProductStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let provisionedproductstatus = unimplemented!();
/// match provisionedproductstatus {
///     ProvisionedProductStatus::Available => { /* ... */ },
///     ProvisionedProductStatus::Error => { /* ... */ },
///     ProvisionedProductStatus::PlanInProgress => { /* ... */ },
///     ProvisionedProductStatus::Tainted => { /* ... */ },
///     ProvisionedProductStatus::UnderChange => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `provisionedproductstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ProvisionedProductStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ProvisionedProductStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ProvisionedProductStatus::NewFeature` is defined.
/// Specifically, when `provisionedproductstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ProvisionedProductStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ProvisionedProductStatus {
    #[allow(missing_docs)] // documentation missing in model
    Available,
    #[allow(missing_docs)] // documentation missing in model
    Error,
    #[allow(missing_docs)] // documentation missing in model
    PlanInProgress,
    #[allow(missing_docs)] // documentation missing in model
    Tainted,
    #[allow(missing_docs)] // documentation missing in model
    UnderChange,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ProvisionedProductStatus {
    fn from(s: &str) -> Self {
        match s {
            "AVAILABLE" => ProvisionedProductStatus::Available,
            "ERROR" => ProvisionedProductStatus::Error,
            "PLAN_IN_PROGRESS" => ProvisionedProductStatus::PlanInProgress,
            "TAINTED" => ProvisionedProductStatus::Tainted,
            "UNDER_CHANGE" => ProvisionedProductStatus::UnderChange,
            other => ProvisionedProductStatus::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for ProvisionedProductStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ProvisionedProductStatus::from(s))
    }
}
impl ProvisionedProductStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ProvisionedProductStatus::Available => "AVAILABLE",
            ProvisionedProductStatus::Error => "ERROR",
            ProvisionedProductStatus::PlanInProgress => "PLAN_IN_PROGRESS",
            ProvisionedProductStatus::Tainted => "TAINTED",
            ProvisionedProductStatus::UnderChange => "UNDER_CHANGE",
            ProvisionedProductStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "AVAILABLE",
            "ERROR",
            "PLAN_IN_PROGRESS",
            "TAINTED",
            "UNDER_CHANGE",
        ]
    }
}
impl AsRef<str> for ProvisionedProductStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `SortOrder`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let sortorder = unimplemented!();
/// match sortorder {
///     SortOrder::Ascending => { /* ... */ },
///     SortOrder::Descending => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `sortorder` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SortOrder::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SortOrder::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SortOrder::NewFeature` is defined.
/// Specifically, when `sortorder` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SortOrder::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SortOrder {
    #[allow(missing_docs)] // documentation missing in model
    Ascending,
    #[allow(missing_docs)] // documentation missing in model
    Descending,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for SortOrder {
    fn from(s: &str) -> Self {
        match s {
            "ASCENDING" => SortOrder::Ascending,
            "DESCENDING" => SortOrder::Descending,
            other => SortOrder::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for SortOrder {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SortOrder::from(s))
    }
}
impl SortOrder {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SortOrder::Ascending => "ASCENDING",
            SortOrder::Descending => "DESCENDING",
            SortOrder::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ASCENDING", "DESCENDING"]
    }
}
impl AsRef<str> for SortOrder {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ProvisionedProductViewFilterBy`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let provisionedproductviewfilterby = unimplemented!();
/// match provisionedproductviewfilterby {
///     ProvisionedProductViewFilterBy::SearchQuery => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `provisionedproductviewfilterby` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ProvisionedProductViewFilterBy::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ProvisionedProductViewFilterBy::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ProvisionedProductViewFilterBy::NewFeature` is defined.
/// Specifically, when `provisionedproductviewfilterby` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ProvisionedProductViewFilterBy::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ProvisionedProductViewFilterBy {
    #[allow(missing_docs)] // documentation missing in model
    SearchQuery,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ProvisionedProductViewFilterBy {
    fn from(s: &str) -> Self {
        match s {
            "SearchQuery" => ProvisionedProductViewFilterBy::SearchQuery,
            other => ProvisionedProductViewFilterBy::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for ProvisionedProductViewFilterBy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ProvisionedProductViewFilterBy::from(s))
    }
}
impl ProvisionedProductViewFilterBy {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ProvisionedProductViewFilterBy::SearchQuery => "SearchQuery",
            ProvisionedProductViewFilterBy::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["SearchQuery"]
    }
}
impl AsRef<str> for ProvisionedProductViewFilterBy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The access level to use to filter results.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AccessLevelFilter {
    /// <p>The access level.</p>
    /// <ul>
    /// <li> <p> <code>Account</code> - Filter results based on the account.</p> </li>
    /// <li> <p> <code>Role</code> - Filter results based on the federated role of the specified user.</p> </li>
    /// <li> <p> <code>User</code> - Filter results based on the specified user.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub key: std::option::Option<crate::model::AccessLevelFilterKey>,
    /// <p>The user to which the access level applies. The only supported value is <code>Self</code>.</p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
}
impl AccessLevelFilter {
    /// <p>The access level.</p>
    /// <ul>
    /// <li> <p> <code>Account</code> - Filter results based on the account.</p> </li>
    /// <li> <p> <code>Role</code> - Filter results based on the federated role of the specified user.</p> </li>
    /// <li> <p> <code>User</code> - Filter results based on the specified user.</p> </li>
    /// </ul>
    pub fn key(&self) -> std::option::Option<&crate::model::AccessLevelFilterKey> {
        self.key.as_ref()
    }
    /// <p>The user to which the access level applies. The only supported value is <code>Self</code>.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
impl AccessLevelFilter {
    /// Creates a new builder-style object to manufacture [`AccessLevelFilter`](crate::model::AccessLevelFilter).
    pub fn builder() -> crate::model::access_level_filter::Builder {
        crate::model::access_level_filter::Builder::default()
    }
}

/// See [`AccessLevelFilter`](crate::model::AccessLevelFilter).
pub mod access_level_filter {

    /// A builder for [`AccessLevelFilter`](crate::model::AccessLevelFilter).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<crate::model::AccessLevelFilterKey>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The access level.</p>
        /// <ul>
        /// <li> <p> <code>Account</code> - Filter results based on the account.</p> </li>
        /// <li> <p> <code>Role</code> - Filter results based on the federated role of the specified user.</p> </li>
        /// <li> <p> <code>User</code> - Filter results based on the specified user.</p> </li>
        /// </ul>
        pub fn key(mut self, input: crate::model::AccessLevelFilterKey) -> Self {
            self.key = Some(input);
            self
        }
        /// <p>The access level.</p>
        /// <ul>
        /// <li> <p> <code>Account</code> - Filter results based on the account.</p> </li>
        /// <li> <p> <code>Role</code> - Filter results based on the federated role of the specified user.</p> </li>
        /// <li> <p> <code>User</code> - Filter results based on the specified user.</p> </li>
        /// </ul>
        pub fn set_key(
            mut self,
            input: std::option::Option<crate::model::AccessLevelFilterKey>,
        ) -> Self {
            self.key = input;
            self
        }
        /// <p>The user to which the access level applies. The only supported value is <code>Self</code>.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The user to which the access level applies. The only supported value is <code>Self</code>.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`AccessLevelFilter`](crate::model::AccessLevelFilter).
        pub fn build(self) -> crate::model::AccessLevelFilter {
            crate::model::AccessLevelFilter {
                key: self.key,
                value: self.value,
            }
        }
    }
}

/// When writing a match expression against `AccessLevelFilterKey`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let accesslevelfilterkey = unimplemented!();
/// match accesslevelfilterkey {
///     AccessLevelFilterKey::Account => { /* ... */ },
///     AccessLevelFilterKey::Role => { /* ... */ },
///     AccessLevelFilterKey::User => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `accesslevelfilterkey` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AccessLevelFilterKey::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AccessLevelFilterKey::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AccessLevelFilterKey::NewFeature` is defined.
/// Specifically, when `accesslevelfilterkey` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AccessLevelFilterKey::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AccessLevelFilterKey {
    #[allow(missing_docs)] // documentation missing in model
    Account,
    #[allow(missing_docs)] // documentation missing in model
    Role,
    #[allow(missing_docs)] // documentation missing in model
    User,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AccessLevelFilterKey {
    fn from(s: &str) -> Self {
        match s {
            "Account" => AccessLevelFilterKey::Account,
            "Role" => AccessLevelFilterKey::Role,
            "User" => AccessLevelFilterKey::User,
            other => {
                AccessLevelFilterKey::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for AccessLevelFilterKey {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AccessLevelFilterKey::from(s))
    }
}
impl AccessLevelFilterKey {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AccessLevelFilterKey::Account => "Account",
            AccessLevelFilterKey::Role => "Role",
            AccessLevelFilterKey::User => "User",
            AccessLevelFilterKey::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["Account", "Role", "User"]
    }
}
impl AsRef<str> for AccessLevelFilterKey {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ProductSource`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let productsource = unimplemented!();
/// match productsource {
///     ProductSource::Account => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `productsource` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ProductSource::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ProductSource::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ProductSource::NewFeature` is defined.
/// Specifically, when `productsource` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ProductSource::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ProductSource {
    #[allow(missing_docs)] // documentation missing in model
    Account,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ProductSource {
    fn from(s: &str) -> Self {
        match s {
            "ACCOUNT" => ProductSource::Account,
            other => ProductSource::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ProductSource {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ProductSource::from(s))
    }
}
impl ProductSource {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ProductSource::Account => "ACCOUNT",
            ProductSource::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ACCOUNT"]
    }
}
impl AsRef<str> for ProductSource {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ProductViewSortBy`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let productviewsortby = unimplemented!();
/// match productviewsortby {
///     ProductViewSortBy::CreationDate => { /* ... */ },
///     ProductViewSortBy::Title => { /* ... */ },
///     ProductViewSortBy::VersionCount => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `productviewsortby` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ProductViewSortBy::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ProductViewSortBy::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ProductViewSortBy::NewFeature` is defined.
/// Specifically, when `productviewsortby` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ProductViewSortBy::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ProductViewSortBy {
    #[allow(missing_docs)] // documentation missing in model
    CreationDate,
    #[allow(missing_docs)] // documentation missing in model
    Title,
    #[allow(missing_docs)] // documentation missing in model
    VersionCount,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ProductViewSortBy {
    fn from(s: &str) -> Self {
        match s {
            "CreationDate" => ProductViewSortBy::CreationDate,
            "Title" => ProductViewSortBy::Title,
            "VersionCount" => ProductViewSortBy::VersionCount,
            other => {
                ProductViewSortBy::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for ProductViewSortBy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ProductViewSortBy::from(s))
    }
}
impl ProductViewSortBy {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ProductViewSortBy::CreationDate => "CreationDate",
            ProductViewSortBy::Title => "Title",
            ProductViewSortBy::VersionCount => "VersionCount",
            ProductViewSortBy::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CreationDate", "Title", "VersionCount"]
    }
}
impl AsRef<str> for ProductViewSortBy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ProductViewFilterBy`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let productviewfilterby = unimplemented!();
/// match productviewfilterby {
///     ProductViewFilterBy::FullTextSearch => { /* ... */ },
///     ProductViewFilterBy::Owner => { /* ... */ },
///     ProductViewFilterBy::ProductType => { /* ... */ },
///     ProductViewFilterBy::SourceProductId => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `productviewfilterby` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ProductViewFilterBy::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ProductViewFilterBy::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ProductViewFilterBy::NewFeature` is defined.
/// Specifically, when `productviewfilterby` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ProductViewFilterBy::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ProductViewFilterBy {
    #[allow(missing_docs)] // documentation missing in model
    FullTextSearch,
    #[allow(missing_docs)] // documentation missing in model
    Owner,
    #[allow(missing_docs)] // documentation missing in model
    ProductType,
    #[allow(missing_docs)] // documentation missing in model
    SourceProductId,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ProductViewFilterBy {
    fn from(s: &str) -> Self {
        match s {
            "FullTextSearch" => ProductViewFilterBy::FullTextSearch,
            "Owner" => ProductViewFilterBy::Owner,
            "ProductType" => ProductViewFilterBy::ProductType,
            "SourceProductId" => ProductViewFilterBy::SourceProductId,
            other => {
                ProductViewFilterBy::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for ProductViewFilterBy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ProductViewFilterBy::from(s))
    }
}
impl ProductViewFilterBy {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ProductViewFilterBy::FullTextSearch => "FullTextSearch",
            ProductViewFilterBy::Owner => "Owner",
            ProductViewFilterBy::ProductType => "ProductType",
            ProductViewFilterBy::SourceProductId => "SourceProductId",
            ProductViewFilterBy::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["FullTextSearch", "Owner", "ProductType", "SourceProductId"]
    }
}
impl AsRef<str> for ProductViewFilterBy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A single product view aggregation value/count pair, containing metadata about each product to which the calling user has access.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ProductViewAggregationValue {
    /// <p>The value of the product view aggregation.</p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
    /// <p>An approximate count of the products that match the value.</p>
    #[doc(hidden)]
    pub approximate_count: i32,
}
impl ProductViewAggregationValue {
    /// <p>The value of the product view aggregation.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
    /// <p>An approximate count of the products that match the value.</p>
    pub fn approximate_count(&self) -> i32 {
        self.approximate_count
    }
}
impl ProductViewAggregationValue {
    /// Creates a new builder-style object to manufacture [`ProductViewAggregationValue`](crate::model::ProductViewAggregationValue).
    pub fn builder() -> crate::model::product_view_aggregation_value::Builder {
        crate::model::product_view_aggregation_value::Builder::default()
    }
}

/// See [`ProductViewAggregationValue`](crate::model::ProductViewAggregationValue).
pub mod product_view_aggregation_value {

    /// A builder for [`ProductViewAggregationValue`](crate::model::ProductViewAggregationValue).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) value: std::option::Option<std::string::String>,
        pub(crate) approximate_count: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The value of the product view aggregation.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The value of the product view aggregation.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// <p>An approximate count of the products that match the value.</p>
        pub fn approximate_count(mut self, input: i32) -> Self {
            self.approximate_count = Some(input);
            self
        }
        /// <p>An approximate count of the products that match the value.</p>
        pub fn set_approximate_count(mut self, input: std::option::Option<i32>) -> Self {
            self.approximate_count = input;
            self
        }
        /// Consumes the builder and constructs a [`ProductViewAggregationValue`](crate::model::ProductViewAggregationValue).
        pub fn build(self) -> crate::model::ProductViewAggregationValue {
            crate::model::ProductViewAggregationValue {
                value: self.value,
                approximate_count: self.approximate_count.unwrap_or_default(),
            }
        }
    }
}

/// <p>Information about a provisioned product.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ProvisionedProductDetail {
    /// <p>The user-friendly name of the provisioned product.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The ARN of the provisioned product.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The type of provisioned product. The supported values are <code>CFN_STACK</code> and <code>CFN_STACKSET</code>.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<std::string::String>,
    /// <p>The identifier of the provisioned product.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The current status of the provisioned product.</p>
    /// <ul>
    /// <li> <p> <code>AVAILABLE</code> - Stable state, ready to perform any operation. The most recent operation succeeded and completed.</p> </li>
    /// <li> <p> <code>UNDER_CHANGE</code> - Transitive state. Operations performed might not have valid results. Wait for an <code>AVAILABLE</code> status before performing operations.</p> </li>
    /// <li> <p> <code>TAINTED</code> - Stable state, ready to perform any operation. The stack has completed the requested operation but is not exactly what was requested. For example, a request to update to a new version failed and the stack rolled back to the current version.</p> </li>
    /// <li> <p> <code>ERROR</code> - An unexpected error occurred. The provisioned product exists but the stack is not running. For example, CloudFormation received a parameter value that was not valid and could not launch the stack.</p> </li>
    /// <li> <p> <code>PLAN_IN_PROGRESS</code> - Transitive state. The plan operations were performed to provision a new product, but resources have not yet been created. After reviewing the list of resources to be created, execute the plan. Wait for an <code>AVAILABLE</code> status before performing operations.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::ProvisionedProductStatus>,
    /// <p>The current status message of the provisioned product.</p>
    #[doc(hidden)]
    pub status_message: std::option::Option<std::string::String>,
    /// <p>The UTC time stamp of the creation time.</p>
    #[doc(hidden)]
    pub created_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>A unique identifier that you provide to ensure idempotency. If multiple requests differ only by the idempotency token, the same response is returned for each repeated request.</p>
    #[doc(hidden)]
    pub idempotency_token: std::option::Option<std::string::String>,
    /// <p>The record identifier of the last request performed on this provisioned product.</p>
    #[doc(hidden)]
    pub last_record_id: std::option::Option<std::string::String>,
    /// <p>The record identifier of the last request performed on this provisioned product of the following types:</p>
    /// <ul>
    /// <li> <p> ProvisionedProduct </p> </li>
    /// <li> <p> UpdateProvisionedProduct </p> </li>
    /// <li> <p> ExecuteProvisionedProductPlan </p> </li>
    /// <li> <p> TerminateProvisionedProduct </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub last_provisioning_record_id: std::option::Option<std::string::String>,
    /// <p>The record identifier of the last successful request performed on this provisioned product of the following types:</p>
    /// <ul>
    /// <li> <p> ProvisionedProduct </p> </li>
    /// <li> <p> UpdateProvisionedProduct </p> </li>
    /// <li> <p> ExecuteProvisionedProductPlan </p> </li>
    /// <li> <p> TerminateProvisionedProduct </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub last_successful_provisioning_record_id: std::option::Option<std::string::String>,
    /// <p>The product identifier. For example, <code>prod-abcdzk7xy33qa</code>.</p>
    #[doc(hidden)]
    pub product_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the provisioning artifact. For example, <code>pa-4abcdjnxjj6ne</code>.</p>
    #[doc(hidden)]
    pub provisioning_artifact_id: std::option::Option<std::string::String>,
    /// <p>The ARN of the launch role associated with the provisioned product.</p>
    #[doc(hidden)]
    pub launch_role_arn: std::option::Option<std::string::String>,
}
impl ProvisionedProductDetail {
    /// <p>The user-friendly name of the provisioned product.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The ARN of the provisioned product.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The type of provisioned product. The supported values are <code>CFN_STACK</code> and <code>CFN_STACKSET</code>.</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
    /// <p>The identifier of the provisioned product.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The current status of the provisioned product.</p>
    /// <ul>
    /// <li> <p> <code>AVAILABLE</code> - Stable state, ready to perform any operation. The most recent operation succeeded and completed.</p> </li>
    /// <li> <p> <code>UNDER_CHANGE</code> - Transitive state. Operations performed might not have valid results. Wait for an <code>AVAILABLE</code> status before performing operations.</p> </li>
    /// <li> <p> <code>TAINTED</code> - Stable state, ready to perform any operation. The stack has completed the requested operation but is not exactly what was requested. For example, a request to update to a new version failed and the stack rolled back to the current version.</p> </li>
    /// <li> <p> <code>ERROR</code> - An unexpected error occurred. The provisioned product exists but the stack is not running. For example, CloudFormation received a parameter value that was not valid and could not launch the stack.</p> </li>
    /// <li> <p> <code>PLAN_IN_PROGRESS</code> - Transitive state. The plan operations were performed to provision a new product, but resources have not yet been created. After reviewing the list of resources to be created, execute the plan. Wait for an <code>AVAILABLE</code> status before performing operations.</p> </li>
    /// </ul>
    pub fn status(&self) -> std::option::Option<&crate::model::ProvisionedProductStatus> {
        self.status.as_ref()
    }
    /// <p>The current status message of the provisioned product.</p>
    pub fn status_message(&self) -> std::option::Option<&str> {
        self.status_message.as_deref()
    }
    /// <p>The UTC time stamp of the creation time.</p>
    pub fn created_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_time.as_ref()
    }
    /// <p>A unique identifier that you provide to ensure idempotency. If multiple requests differ only by the idempotency token, the same response is returned for each repeated request.</p>
    pub fn idempotency_token(&self) -> std::option::Option<&str> {
        self.idempotency_token.as_deref()
    }
    /// <p>The record identifier of the last request performed on this provisioned product.</p>
    pub fn last_record_id(&self) -> std::option::Option<&str> {
        self.last_record_id.as_deref()
    }
    /// <p>The record identifier of the last request performed on this provisioned product of the following types:</p>
    /// <ul>
    /// <li> <p> ProvisionedProduct </p> </li>
    /// <li> <p> UpdateProvisionedProduct </p> </li>
    /// <li> <p> ExecuteProvisionedProductPlan </p> </li>
    /// <li> <p> TerminateProvisionedProduct </p> </li>
    /// </ul>
    pub fn last_provisioning_record_id(&self) -> std::option::Option<&str> {
        self.last_provisioning_record_id.as_deref()
    }
    /// <p>The record identifier of the last successful request performed on this provisioned product of the following types:</p>
    /// <ul>
    /// <li> <p> ProvisionedProduct </p> </li>
    /// <li> <p> UpdateProvisionedProduct </p> </li>
    /// <li> <p> ExecuteProvisionedProductPlan </p> </li>
    /// <li> <p> TerminateProvisionedProduct </p> </li>
    /// </ul>
    pub fn last_successful_provisioning_record_id(&self) -> std::option::Option<&str> {
        self.last_successful_provisioning_record_id.as_deref()
    }
    /// <p>The product identifier. For example, <code>prod-abcdzk7xy33qa</code>.</p>
    pub fn product_id(&self) -> std::option::Option<&str> {
        self.product_id.as_deref()
    }
    /// <p>The identifier of the provisioning artifact. For example, <code>pa-4abcdjnxjj6ne</code>.</p>
    pub fn provisioning_artifact_id(&self) -> std::option::Option<&str> {
        self.provisioning_artifact_id.as_deref()
    }
    /// <p>The ARN of the launch role associated with the provisioned product.</p>
    pub fn launch_role_arn(&self) -> std::option::Option<&str> {
        self.launch_role_arn.as_deref()
    }
}
impl ProvisionedProductDetail {
    /// Creates a new builder-style object to manufacture [`ProvisionedProductDetail`](crate::model::ProvisionedProductDetail).
    pub fn builder() -> crate::model::provisioned_product_detail::Builder {
        crate::model::provisioned_product_detail::Builder::default()
    }
}

/// See [`ProvisionedProductDetail`](crate::model::ProvisionedProductDetail).
pub mod provisioned_product_detail {

    /// A builder for [`ProvisionedProductDetail`](crate::model::ProvisionedProductDetail).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::ProvisionedProductStatus>,
        pub(crate) status_message: std::option::Option<std::string::String>,
        pub(crate) created_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) idempotency_token: std::option::Option<std::string::String>,
        pub(crate) last_record_id: std::option::Option<std::string::String>,
        pub(crate) last_provisioning_record_id: std::option::Option<std::string::String>,
        pub(crate) last_successful_provisioning_record_id: std::option::Option<std::string::String>,
        pub(crate) product_id: std::option::Option<std::string::String>,
        pub(crate) provisioning_artifact_id: std::option::Option<std::string::String>,
        pub(crate) launch_role_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The user-friendly name of the provisioned product.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The user-friendly name of the provisioned product.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The ARN of the provisioned product.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The ARN of the provisioned product.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The type of provisioned product. The supported values are <code>CFN_STACK</code> and <code>CFN_STACKSET</code>.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The type of provisioned product. The supported values are <code>CFN_STACK</code> and <code>CFN_STACKSET</code>.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The identifier of the provisioned product.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of the provisioned product.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The current status of the provisioned product.</p>
        /// <ul>
        /// <li> <p> <code>AVAILABLE</code> - Stable state, ready to perform any operation. The most recent operation succeeded and completed.</p> </li>
        /// <li> <p> <code>UNDER_CHANGE</code> - Transitive state. Operations performed might not have valid results. Wait for an <code>AVAILABLE</code> status before performing operations.</p> </li>
        /// <li> <p> <code>TAINTED</code> - Stable state, ready to perform any operation. The stack has completed the requested operation but is not exactly what was requested. For example, a request to update to a new version failed and the stack rolled back to the current version.</p> </li>
        /// <li> <p> <code>ERROR</code> - An unexpected error occurred. The provisioned product exists but the stack is not running. For example, CloudFormation received a parameter value that was not valid and could not launch the stack.</p> </li>
        /// <li> <p> <code>PLAN_IN_PROGRESS</code> - Transitive state. The plan operations were performed to provision a new product, but resources have not yet been created. After reviewing the list of resources to be created, execute the plan. Wait for an <code>AVAILABLE</code> status before performing operations.</p> </li>
        /// </ul>
        pub fn status(mut self, input: crate::model::ProvisionedProductStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The current status of the provisioned product.</p>
        /// <ul>
        /// <li> <p> <code>AVAILABLE</code> - Stable state, ready to perform any operation. The most recent operation succeeded and completed.</p> </li>
        /// <li> <p> <code>UNDER_CHANGE</code> - Transitive state. Operations performed might not have valid results. Wait for an <code>AVAILABLE</code> status before performing operations.</p> </li>
        /// <li> <p> <code>TAINTED</code> - Stable state, ready to perform any operation. The stack has completed the requested operation but is not exactly what was requested. For example, a request to update to a new version failed and the stack rolled back to the current version.</p> </li>
        /// <li> <p> <code>ERROR</code> - An unexpected error occurred. The provisioned product exists but the stack is not running. For example, CloudFormation received a parameter value that was not valid and could not launch the stack.</p> </li>
        /// <li> <p> <code>PLAN_IN_PROGRESS</code> - Transitive state. The plan operations were performed to provision a new product, but resources have not yet been created. After reviewing the list of resources to be created, execute the plan. Wait for an <code>AVAILABLE</code> status before performing operations.</p> </li>
        /// </ul>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ProvisionedProductStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The current status message of the provisioned product.</p>
        pub fn status_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_message = Some(input.into());
            self
        }
        /// <p>The current status message of the provisioned product.</p>
        pub fn set_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_message = input;
            self
        }
        /// <p>The UTC time stamp of the creation time.</p>
        pub fn created_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_time = Some(input);
            self
        }
        /// <p>The UTC time stamp of the creation time.</p>
        pub fn set_created_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_time = input;
            self
        }
        /// <p>A unique identifier that you provide to ensure idempotency. If multiple requests differ only by the idempotency token, the same response is returned for each repeated request.</p>
        pub fn idempotency_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.idempotency_token = Some(input.into());
            self
        }
        /// <p>A unique identifier that you provide to ensure idempotency. If multiple requests differ only by the idempotency token, the same response is returned for each repeated request.</p>
        pub fn set_idempotency_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.idempotency_token = input;
            self
        }
        /// <p>The record identifier of the last request performed on this provisioned product.</p>
        pub fn last_record_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_record_id = Some(input.into());
            self
        }
        /// <p>The record identifier of the last request performed on this provisioned product.</p>
        pub fn set_last_record_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_record_id = input;
            self
        }
        /// <p>The record identifier of the last request performed on this provisioned product of the following types:</p>
        /// <ul>
        /// <li> <p> ProvisionedProduct </p> </li>
        /// <li> <p> UpdateProvisionedProduct </p> </li>
        /// <li> <p> ExecuteProvisionedProductPlan </p> </li>
        /// <li> <p> TerminateProvisionedProduct </p> </li>
        /// </ul>
        pub fn last_provisioning_record_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.last_provisioning_record_id = Some(input.into());
            self
        }
        /// <p>The record identifier of the last request performed on this provisioned product of the following types:</p>
        /// <ul>
        /// <li> <p> ProvisionedProduct </p> </li>
        /// <li> <p> UpdateProvisionedProduct </p> </li>
        /// <li> <p> ExecuteProvisionedProductPlan </p> </li>
        /// <li> <p> TerminateProvisionedProduct </p> </li>
        /// </ul>
        pub fn set_last_provisioning_record_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_provisioning_record_id = input;
            self
        }
        /// <p>The record identifier of the last successful request performed on this provisioned product of the following types:</p>
        /// <ul>
        /// <li> <p> ProvisionedProduct </p> </li>
        /// <li> <p> UpdateProvisionedProduct </p> </li>
        /// <li> <p> ExecuteProvisionedProductPlan </p> </li>
        /// <li> <p> TerminateProvisionedProduct </p> </li>
        /// </ul>
        pub fn last_successful_provisioning_record_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.last_successful_provisioning_record_id = Some(input.into());
            self
        }
        /// <p>The record identifier of the last successful request performed on this provisioned product of the following types:</p>
        /// <ul>
        /// <li> <p> ProvisionedProduct </p> </li>
        /// <li> <p> UpdateProvisionedProduct </p> </li>
        /// <li> <p> ExecuteProvisionedProductPlan </p> </li>
        /// <li> <p> TerminateProvisionedProduct </p> </li>
        /// </ul>
        pub fn set_last_successful_provisioning_record_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_successful_provisioning_record_id = input;
            self
        }
        /// <p>The product identifier. For example, <code>prod-abcdzk7xy33qa</code>.</p>
        pub fn product_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.product_id = Some(input.into());
            self
        }
        /// <p>The product identifier. For example, <code>prod-abcdzk7xy33qa</code>.</p>
        pub fn set_product_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.product_id = input;
            self
        }
        /// <p>The identifier of the provisioning artifact. For example, <code>pa-4abcdjnxjj6ne</code>.</p>
        pub fn provisioning_artifact_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.provisioning_artifact_id = Some(input.into());
            self
        }
        /// <p>The identifier of the provisioning artifact. For example, <code>pa-4abcdjnxjj6ne</code>.</p>
        pub fn set_provisioning_artifact_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.provisioning_artifact_id = input;
            self
        }
        /// <p>The ARN of the launch role associated with the provisioned product.</p>
        pub fn launch_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.launch_role_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the launch role associated with the provisioned product.</p>
        pub fn set_launch_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.launch_role_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`ProvisionedProductDetail`](crate::model::ProvisionedProductDetail).
        pub fn build(self) -> crate::model::ProvisionedProductDetail {
            crate::model::ProvisionedProductDetail {
                name: self.name,
                arn: self.arn,
                r#type: self.r#type,
                id: self.id,
                status: self.status,
                status_message: self.status_message,
                created_time: self.created_time,
                idempotency_token: self.idempotency_token,
                last_record_id: self.last_record_id,
                last_provisioning_record_id: self.last_provisioning_record_id,
                last_successful_provisioning_record_id: self.last_successful_provisioning_record_id,
                product_id: self.product_id,
                provisioning_artifact_id: self.provisioning_artifact_id,
                launch_role_arn: self.launch_role_arn,
            }
        }
    }
}

/// When writing a match expression against `PortfolioShareType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let portfoliosharetype = unimplemented!();
/// match portfoliosharetype {
///     PortfolioShareType::AwsOrganizations => { /* ... */ },
///     PortfolioShareType::AwsServicecatalog => { /* ... */ },
///     PortfolioShareType::Imported => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `portfoliosharetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PortfolioShareType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PortfolioShareType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PortfolioShareType::NewFeature` is defined.
/// Specifically, when `portfoliosharetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PortfolioShareType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PortfolioShareType {
    #[allow(missing_docs)] // documentation missing in model
    AwsOrganizations,
    #[allow(missing_docs)] // documentation missing in model
    AwsServicecatalog,
    #[allow(missing_docs)] // documentation missing in model
    Imported,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PortfolioShareType {
    fn from(s: &str) -> Self {
        match s {
            "AWS_ORGANIZATIONS" => PortfolioShareType::AwsOrganizations,
            "AWS_SERVICECATALOG" => PortfolioShareType::AwsServicecatalog,
            "IMPORTED" => PortfolioShareType::Imported,
            other => {
                PortfolioShareType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for PortfolioShareType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PortfolioShareType::from(s))
    }
}
impl PortfolioShareType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PortfolioShareType::AwsOrganizations => "AWS_ORGANIZATIONS",
            PortfolioShareType::AwsServicecatalog => "AWS_SERVICECATALOG",
            PortfolioShareType::Imported => "IMPORTED",
            PortfolioShareType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["AWS_ORGANIZATIONS", "AWS_SERVICECATALOG", "IMPORTED"]
    }
}
impl AsRef<str> for PortfolioShareType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The user-defined preferences that will be applied when updating a provisioned product. Not all preferences are applicable to all provisioned product type</p>
/// <p>One or more Amazon Web Services accounts that will have access to the provisioned product.</p>
/// <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
/// <p>The Amazon Web Services accounts specified should be within the list of accounts in the <code>STACKSET</code> constraint. To get the list of accounts in the <code>STACKSET</code> constraint, use the <code>DescribeProvisioningParameters</code> operation.</p>
/// <p>If no values are specified, the default value is all accounts from the <code>STACKSET</code> constraint.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ProvisioningPreferences {
    /// <p>One or more Amazon Web Services accounts where the provisioned product will be available.</p>
    /// <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
    /// <p>The specified accounts should be within the list of accounts from the <code>STACKSET</code> constraint. To get the list of accounts in the <code>STACKSET</code> constraint, use the <code>DescribeProvisioningParameters</code> operation.</p>
    /// <p>If no values are specified, the default value is all acounts from the <code>STACKSET</code> constraint.</p>
    #[doc(hidden)]
    pub stack_set_accounts: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>One or more Amazon Web Services Regions where the provisioned product will be available.</p>
    /// <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
    /// <p>The specified Regions should be within the list of Regions from the <code>STACKSET</code> constraint. To get the list of Regions in the <code>STACKSET</code> constraint, use the <code>DescribeProvisioningParameters</code> operation.</p>
    /// <p>If no values are specified, the default value is all Regions from the <code>STACKSET</code> constraint.</p>
    #[doc(hidden)]
    pub stack_set_regions: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The number of accounts, per Region, for which this operation can fail before Service Catalog stops the operation in that Region. If the operation is stopped in a Region, Service Catalog doesn't attempt the operation in any subsequent Regions.</p>
    /// <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
    /// <p>Conditional: You must specify either <code>StackSetFailureToleranceCount</code> or <code>StackSetFailureTolerancePercentage</code>, but not both.</p>
    /// <p>The default value is <code>0</code> if no value is specified.</p>
    #[doc(hidden)]
    pub stack_set_failure_tolerance_count: std::option::Option<i32>,
    /// <p>The percentage of accounts, per Region, for which this stack operation can fail before Service Catalog stops the operation in that Region. If the operation is stopped in a Region, Service Catalog doesn't attempt the operation in any subsequent Regions.</p>
    /// <p>When calculating the number of accounts based on the specified percentage, Service Catalog rounds down to the next whole number.</p>
    /// <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
    /// <p>Conditional: You must specify either <code>StackSetFailureToleranceCount</code> or <code>StackSetFailureTolerancePercentage</code>, but not both.</p>
    #[doc(hidden)]
    pub stack_set_failure_tolerance_percentage: std::option::Option<i32>,
    /// <p>The maximum number of accounts in which to perform this operation at one time. This is dependent on the value of <code>StackSetFailureToleranceCount</code>. <code>StackSetMaxConcurrentCount</code> is at most one more than the <code>StackSetFailureToleranceCount</code>.</p>
    /// <p>Note that this setting lets you specify the maximum for operations. For large deployments, under certain circumstances the actual number of accounts acted upon concurrently may be lower due to service throttling.</p>
    /// <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
    /// <p>Conditional: You must specify either <code>StackSetMaxConcurrentCount</code> or <code>StackSetMaxConcurrentPercentage</code>, but not both.</p>
    #[doc(hidden)]
    pub stack_set_max_concurrency_count: std::option::Option<i32>,
    /// <p>The maximum percentage of accounts in which to perform this operation at one time.</p>
    /// <p>When calculating the number of accounts based on the specified percentage, Service Catalog rounds down to the next whole number. This is true except in cases where rounding down would result is zero. In this case, Service Catalog sets the number as <code>1</code> instead.</p>
    /// <p>Note that this setting lets you specify the maximum for operations. For large deployments, under certain circumstances the actual number of accounts acted upon concurrently may be lower due to service throttling.</p>
    /// <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
    /// <p>Conditional: You must specify either <code>StackSetMaxConcurrentCount</code> or <code>StackSetMaxConcurrentPercentage</code>, but not both.</p>
    #[doc(hidden)]
    pub stack_set_max_concurrency_percentage: std::option::Option<i32>,
}
impl ProvisioningPreferences {
    /// <p>One or more Amazon Web Services accounts where the provisioned product will be available.</p>
    /// <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
    /// <p>The specified accounts should be within the list of accounts from the <code>STACKSET</code> constraint. To get the list of accounts in the <code>STACKSET</code> constraint, use the <code>DescribeProvisioningParameters</code> operation.</p>
    /// <p>If no values are specified, the default value is all acounts from the <code>STACKSET</code> constraint.</p>
    pub fn stack_set_accounts(&self) -> std::option::Option<&[std::string::String]> {
        self.stack_set_accounts.as_deref()
    }
    /// <p>One or more Amazon Web Services Regions where the provisioned product will be available.</p>
    /// <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
    /// <p>The specified Regions should be within the list of Regions from the <code>STACKSET</code> constraint. To get the list of Regions in the <code>STACKSET</code> constraint, use the <code>DescribeProvisioningParameters</code> operation.</p>
    /// <p>If no values are specified, the default value is all Regions from the <code>STACKSET</code> constraint.</p>
    pub fn stack_set_regions(&self) -> std::option::Option<&[std::string::String]> {
        self.stack_set_regions.as_deref()
    }
    /// <p>The number of accounts, per Region, for which this operation can fail before Service Catalog stops the operation in that Region. If the operation is stopped in a Region, Service Catalog doesn't attempt the operation in any subsequent Regions.</p>
    /// <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
    /// <p>Conditional: You must specify either <code>StackSetFailureToleranceCount</code> or <code>StackSetFailureTolerancePercentage</code>, but not both.</p>
    /// <p>The default value is <code>0</code> if no value is specified.</p>
    pub fn stack_set_failure_tolerance_count(&self) -> std::option::Option<i32> {
        self.stack_set_failure_tolerance_count
    }
    /// <p>The percentage of accounts, per Region, for which this stack operation can fail before Service Catalog stops the operation in that Region. If the operation is stopped in a Region, Service Catalog doesn't attempt the operation in any subsequent Regions.</p>
    /// <p>When calculating the number of accounts based on the specified percentage, Service Catalog rounds down to the next whole number.</p>
    /// <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
    /// <p>Conditional: You must specify either <code>StackSetFailureToleranceCount</code> or <code>StackSetFailureTolerancePercentage</code>, but not both.</p>
    pub fn stack_set_failure_tolerance_percentage(&self) -> std::option::Option<i32> {
        self.stack_set_failure_tolerance_percentage
    }
    /// <p>The maximum number of accounts in which to perform this operation at one time. This is dependent on the value of <code>StackSetFailureToleranceCount</code>. <code>StackSetMaxConcurrentCount</code> is at most one more than the <code>StackSetFailureToleranceCount</code>.</p>
    /// <p>Note that this setting lets you specify the maximum for operations. For large deployments, under certain circumstances the actual number of accounts acted upon concurrently may be lower due to service throttling.</p>
    /// <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
    /// <p>Conditional: You must specify either <code>StackSetMaxConcurrentCount</code> or <code>StackSetMaxConcurrentPercentage</code>, but not both.</p>
    pub fn stack_set_max_concurrency_count(&self) -> std::option::Option<i32> {
        self.stack_set_max_concurrency_count
    }
    /// <p>The maximum percentage of accounts in which to perform this operation at one time.</p>
    /// <p>When calculating the number of accounts based on the specified percentage, Service Catalog rounds down to the next whole number. This is true except in cases where rounding down would result is zero. In this case, Service Catalog sets the number as <code>1</code> instead.</p>
    /// <p>Note that this setting lets you specify the maximum for operations. For large deployments, under certain circumstances the actual number of accounts acted upon concurrently may be lower due to service throttling.</p>
    /// <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
    /// <p>Conditional: You must specify either <code>StackSetMaxConcurrentCount</code> or <code>StackSetMaxConcurrentPercentage</code>, but not both.</p>
    pub fn stack_set_max_concurrency_percentage(&self) -> std::option::Option<i32> {
        self.stack_set_max_concurrency_percentage
    }
}
impl ProvisioningPreferences {
    /// Creates a new builder-style object to manufacture [`ProvisioningPreferences`](crate::model::ProvisioningPreferences).
    pub fn builder() -> crate::model::provisioning_preferences::Builder {
        crate::model::provisioning_preferences::Builder::default()
    }
}

/// See [`ProvisioningPreferences`](crate::model::ProvisioningPreferences).
pub mod provisioning_preferences {

    /// A builder for [`ProvisioningPreferences`](crate::model::ProvisioningPreferences).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) stack_set_accounts: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) stack_set_regions: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) stack_set_failure_tolerance_count: std::option::Option<i32>,
        pub(crate) stack_set_failure_tolerance_percentage: std::option::Option<i32>,
        pub(crate) stack_set_max_concurrency_count: std::option::Option<i32>,
        pub(crate) stack_set_max_concurrency_percentage: std::option::Option<i32>,
    }
    impl Builder {
        /// Appends an item to `stack_set_accounts`.
        ///
        /// To override the contents of this collection use [`set_stack_set_accounts`](Self::set_stack_set_accounts).
        ///
        /// <p>One or more Amazon Web Services accounts where the provisioned product will be available.</p>
        /// <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
        /// <p>The specified accounts should be within the list of accounts from the <code>STACKSET</code> constraint. To get the list of accounts in the <code>STACKSET</code> constraint, use the <code>DescribeProvisioningParameters</code> operation.</p>
        /// <p>If no values are specified, the default value is all acounts from the <code>STACKSET</code> constraint.</p>
        pub fn stack_set_accounts(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.stack_set_accounts.unwrap_or_default();
            v.push(input.into());
            self.stack_set_accounts = Some(v);
            self
        }
        /// <p>One or more Amazon Web Services accounts where the provisioned product will be available.</p>
        /// <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
        /// <p>The specified accounts should be within the list of accounts from the <code>STACKSET</code> constraint. To get the list of accounts in the <code>STACKSET</code> constraint, use the <code>DescribeProvisioningParameters</code> operation.</p>
        /// <p>If no values are specified, the default value is all acounts from the <code>STACKSET</code> constraint.</p>
        pub fn set_stack_set_accounts(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.stack_set_accounts = input;
            self
        }
        /// Appends an item to `stack_set_regions`.
        ///
        /// To override the contents of this collection use [`set_stack_set_regions`](Self::set_stack_set_regions).
        ///
        /// <p>One or more Amazon Web Services Regions where the provisioned product will be available.</p>
        /// <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
        /// <p>The specified Regions should be within the list of Regions from the <code>STACKSET</code> constraint. To get the list of Regions in the <code>STACKSET</code> constraint, use the <code>DescribeProvisioningParameters</code> operation.</p>
        /// <p>If no values are specified, the default value is all Regions from the <code>STACKSET</code> constraint.</p>
        pub fn stack_set_regions(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.stack_set_regions.unwrap_or_default();
            v.push(input.into());
            self.stack_set_regions = Some(v);
            self
        }
        /// <p>One or more Amazon Web Services Regions where the provisioned product will be available.</p>
        /// <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
        /// <p>The specified Regions should be within the list of Regions from the <code>STACKSET</code> constraint. To get the list of Regions in the <code>STACKSET</code> constraint, use the <code>DescribeProvisioningParameters</code> operation.</p>
        /// <p>If no values are specified, the default value is all Regions from the <code>STACKSET</code> constraint.</p>
        pub fn set_stack_set_regions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.stack_set_regions = input;
            self
        }
        /// <p>The number of accounts, per Region, for which this operation can fail before Service Catalog stops the operation in that Region. If the operation is stopped in a Region, Service Catalog doesn't attempt the operation in any subsequent Regions.</p>
        /// <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
        /// <p>Conditional: You must specify either <code>StackSetFailureToleranceCount</code> or <code>StackSetFailureTolerancePercentage</code>, but not both.</p>
        /// <p>The default value is <code>0</code> if no value is specified.</p>
        pub fn stack_set_failure_tolerance_count(mut self, input: i32) -> Self {
            self.stack_set_failure_tolerance_count = Some(input);
            self
        }
        /// <p>The number of accounts, per Region, for which this operation can fail before Service Catalog stops the operation in that Region. If the operation is stopped in a Region, Service Catalog doesn't attempt the operation in any subsequent Regions.</p>
        /// <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
        /// <p>Conditional: You must specify either <code>StackSetFailureToleranceCount</code> or <code>StackSetFailureTolerancePercentage</code>, but not both.</p>
        /// <p>The default value is <code>0</code> if no value is specified.</p>
        pub fn set_stack_set_failure_tolerance_count(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.stack_set_failure_tolerance_count = input;
            self
        }
        /// <p>The percentage of accounts, per Region, for which this stack operation can fail before Service Catalog stops the operation in that Region. If the operation is stopped in a Region, Service Catalog doesn't attempt the operation in any subsequent Regions.</p>
        /// <p>When calculating the number of accounts based on the specified percentage, Service Catalog rounds down to the next whole number.</p>
        /// <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
        /// <p>Conditional: You must specify either <code>StackSetFailureToleranceCount</code> or <code>StackSetFailureTolerancePercentage</code>, but not both.</p>
        pub fn stack_set_failure_tolerance_percentage(mut self, input: i32) -> Self {
            self.stack_set_failure_tolerance_percentage = Some(input);
            self
        }
        /// <p>The percentage of accounts, per Region, for which this stack operation can fail before Service Catalog stops the operation in that Region. If the operation is stopped in a Region, Service Catalog doesn't attempt the operation in any subsequent Regions.</p>
        /// <p>When calculating the number of accounts based on the specified percentage, Service Catalog rounds down to the next whole number.</p>
        /// <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
        /// <p>Conditional: You must specify either <code>StackSetFailureToleranceCount</code> or <code>StackSetFailureTolerancePercentage</code>, but not both.</p>
        pub fn set_stack_set_failure_tolerance_percentage(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.stack_set_failure_tolerance_percentage = input;
            self
        }
        /// <p>The maximum number of accounts in which to perform this operation at one time. This is dependent on the value of <code>StackSetFailureToleranceCount</code>. <code>StackSetMaxConcurrentCount</code> is at most one more than the <code>StackSetFailureToleranceCount</code>.</p>
        /// <p>Note that this setting lets you specify the maximum for operations. For large deployments, under certain circumstances the actual number of accounts acted upon concurrently may be lower due to service throttling.</p>
        /// <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
        /// <p>Conditional: You must specify either <code>StackSetMaxConcurrentCount</code> or <code>StackSetMaxConcurrentPercentage</code>, but not both.</p>
        pub fn stack_set_max_concurrency_count(mut self, input: i32) -> Self {
            self.stack_set_max_concurrency_count = Some(input);
            self
        }
        /// <p>The maximum number of accounts in which to perform this operation at one time. This is dependent on the value of <code>StackSetFailureToleranceCount</code>. <code>StackSetMaxConcurrentCount</code> is at most one more than the <code>StackSetFailureToleranceCount</code>.</p>
        /// <p>Note that this setting lets you specify the maximum for operations. For large deployments, under certain circumstances the actual number of accounts acted upon concurrently may be lower due to service throttling.</p>
        /// <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
        /// <p>Conditional: You must specify either <code>StackSetMaxConcurrentCount</code> or <code>StackSetMaxConcurrentPercentage</code>, but not both.</p>
        pub fn set_stack_set_max_concurrency_count(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.stack_set_max_concurrency_count = input;
            self
        }
        /// <p>The maximum percentage of accounts in which to perform this operation at one time.</p>
        /// <p>When calculating the number of accounts based on the specified percentage, Service Catalog rounds down to the next whole number. This is true except in cases where rounding down would result is zero. In this case, Service Catalog sets the number as <code>1</code> instead.</p>
        /// <p>Note that this setting lets you specify the maximum for operations. For large deployments, under certain circumstances the actual number of accounts acted upon concurrently may be lower due to service throttling.</p>
        /// <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
        /// <p>Conditional: You must specify either <code>StackSetMaxConcurrentCount</code> or <code>StackSetMaxConcurrentPercentage</code>, but not both.</p>
        pub fn stack_set_max_concurrency_percentage(mut self, input: i32) -> Self {
            self.stack_set_max_concurrency_percentage = Some(input);
            self
        }
        /// <p>The maximum percentage of accounts in which to perform this operation at one time.</p>
        /// <p>When calculating the number of accounts based on the specified percentage, Service Catalog rounds down to the next whole number. This is true except in cases where rounding down would result is zero. In this case, Service Catalog sets the number as <code>1</code> instead.</p>
        /// <p>Note that this setting lets you specify the maximum for operations. For large deployments, under certain circumstances the actual number of accounts acted upon concurrently may be lower due to service throttling.</p>
        /// <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
        /// <p>Conditional: You must specify either <code>StackSetMaxConcurrentCount</code> or <code>StackSetMaxConcurrentPercentage</code>, but not both.</p>
        pub fn set_stack_set_max_concurrency_percentage(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.stack_set_max_concurrency_percentage = input;
            self
        }
        /// Consumes the builder and constructs a [`ProvisioningPreferences`](crate::model::ProvisioningPreferences).
        pub fn build(self) -> crate::model::ProvisioningPreferences {
            crate::model::ProvisioningPreferences {
                stack_set_accounts: self.stack_set_accounts,
                stack_set_regions: self.stack_set_regions,
                stack_set_failure_tolerance_count: self.stack_set_failure_tolerance_count,
                stack_set_failure_tolerance_percentage: self.stack_set_failure_tolerance_percentage,
                stack_set_max_concurrency_count: self.stack_set_max_concurrency_count,
                stack_set_max_concurrency_percentage: self.stack_set_max_concurrency_percentage,
            }
        }
    }
}

/// <p>Information about a parameter used to provision a product.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ProvisioningParameter {
    /// <p>The parameter key.</p>
    #[doc(hidden)]
    pub key: std::option::Option<std::string::String>,
    /// <p>The parameter value.</p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
}
impl ProvisioningParameter {
    /// <p>The parameter key.</p>
    pub fn key(&self) -> std::option::Option<&str> {
        self.key.as_deref()
    }
    /// <p>The parameter value.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
impl ProvisioningParameter {
    /// Creates a new builder-style object to manufacture [`ProvisioningParameter`](crate::model::ProvisioningParameter).
    pub fn builder() -> crate::model::provisioning_parameter::Builder {
        crate::model::provisioning_parameter::Builder::default()
    }
}

/// See [`ProvisioningParameter`](crate::model::ProvisioningParameter).
pub mod provisioning_parameter {

    /// A builder for [`ProvisioningParameter`](crate::model::ProvisioningParameter).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The parameter key.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        /// <p>The parameter key.</p>
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The parameter value.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The parameter value.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`ProvisioningParameter`](crate::model::ProvisioningParameter).
        pub fn build(self) -> crate::model::ProvisioningParameter {
            crate::model::ProvisioningParameter {
                key: self.key,
                value: self.value,
            }
        }
    }
}

/// <p>Filters to use when listing TagOptions.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListTagOptionsFilters {
    /// <p>The TagOption key.</p>
    #[doc(hidden)]
    pub key: std::option::Option<std::string::String>,
    /// <p>The TagOption value.</p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
    /// <p>The active state.</p>
    #[doc(hidden)]
    pub active: std::option::Option<bool>,
}
impl ListTagOptionsFilters {
    /// <p>The TagOption key.</p>
    pub fn key(&self) -> std::option::Option<&str> {
        self.key.as_deref()
    }
    /// <p>The TagOption value.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
    /// <p>The active state.</p>
    pub fn active(&self) -> std::option::Option<bool> {
        self.active
    }
}
impl ListTagOptionsFilters {
    /// Creates a new builder-style object to manufacture [`ListTagOptionsFilters`](crate::model::ListTagOptionsFilters).
    pub fn builder() -> crate::model::list_tag_options_filters::Builder {
        crate::model::list_tag_options_filters::Builder::default()
    }
}

/// See [`ListTagOptionsFilters`](crate::model::ListTagOptionsFilters).
pub mod list_tag_options_filters {

    /// A builder for [`ListTagOptionsFilters`](crate::model::ListTagOptionsFilters).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
        pub(crate) active: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The TagOption key.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        /// <p>The TagOption key.</p>
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The TagOption value.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The TagOption value.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// <p>The active state.</p>
        pub fn active(mut self, input: bool) -> Self {
            self.active = Some(input);
            self
        }
        /// <p>The active state.</p>
        pub fn set_active(mut self, input: std::option::Option<bool>) -> Self {
            self.active = input;
            self
        }
        /// Consumes the builder and constructs a [`ListTagOptionsFilters`](crate::model::ListTagOptionsFilters).
        pub fn build(self) -> crate::model::ListTagOptionsFilters {
            crate::model::ListTagOptionsFilters {
                key: self.key,
                value: self.value,
                active: self.active,
            }
        }
    }
}

/// <p>An CloudFormation stack, in a specific account and Region, that's part of a stack set operation. A stack instance is a reference to an attempted or actual stack in a given account within a given Region. A stack instance can exist without a stack—for example, if the stack couldn't be created for some reason. A stack instance is associated with only one stack set. Each stack instance contains the ID of its associated stack set, as well as the ID of the actual stack and the stack status. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StackInstance {
    /// <p>The name of the Amazon Web Services account that the stack instance is associated with.</p>
    #[doc(hidden)]
    pub account: std::option::Option<std::string::String>,
    /// <p>The name of the Amazon Web Services Region that the stack instance is associated with.</p>
    #[doc(hidden)]
    pub region: std::option::Option<std::string::String>,
    /// <p>The status of the stack instance, in terms of its synchronization with its associated stack set. </p>
    /// <ul>
    /// <li> <p> <code>INOPERABLE</code>: A <code>DeleteStackInstances</code> operation has failed and left the stack in an unstable state. Stacks in this state are excluded from further <code>UpdateStackSet</code> operations. You might need to perform a <code>DeleteStackInstances</code> operation, with <code>RetainStacks</code> set to true, to delete the stack instance, and then delete the stack manually. </p> </li>
    /// <li> <p> <code>OUTDATED</code>: The stack isn't currently up to date with the stack set because either the associated stack failed during a <code>CreateStackSet</code> or <code>UpdateStackSet</code> operation, or the stack was part of a <code>CreateStackSet</code> or <code>UpdateStackSet</code> operation that failed or was stopped before the stack was created or updated.</p> </li>
    /// <li> <p> <code>CURRENT</code>: The stack is currently up to date with the stack set.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub stack_instance_status: std::option::Option<crate::model::StackInstanceStatus>,
}
impl StackInstance {
    /// <p>The name of the Amazon Web Services account that the stack instance is associated with.</p>
    pub fn account(&self) -> std::option::Option<&str> {
        self.account.as_deref()
    }
    /// <p>The name of the Amazon Web Services Region that the stack instance is associated with.</p>
    pub fn region(&self) -> std::option::Option<&str> {
        self.region.as_deref()
    }
    /// <p>The status of the stack instance, in terms of its synchronization with its associated stack set. </p>
    /// <ul>
    /// <li> <p> <code>INOPERABLE</code>: A <code>DeleteStackInstances</code> operation has failed and left the stack in an unstable state. Stacks in this state are excluded from further <code>UpdateStackSet</code> operations. You might need to perform a <code>DeleteStackInstances</code> operation, with <code>RetainStacks</code> set to true, to delete the stack instance, and then delete the stack manually. </p> </li>
    /// <li> <p> <code>OUTDATED</code>: The stack isn't currently up to date with the stack set because either the associated stack failed during a <code>CreateStackSet</code> or <code>UpdateStackSet</code> operation, or the stack was part of a <code>CreateStackSet</code> or <code>UpdateStackSet</code> operation that failed or was stopped before the stack was created or updated.</p> </li>
    /// <li> <p> <code>CURRENT</code>: The stack is currently up to date with the stack set.</p> </li>
    /// </ul>
    pub fn stack_instance_status(&self) -> std::option::Option<&crate::model::StackInstanceStatus> {
        self.stack_instance_status.as_ref()
    }
}
impl StackInstance {
    /// Creates a new builder-style object to manufacture [`StackInstance`](crate::model::StackInstance).
    pub fn builder() -> crate::model::stack_instance::Builder {
        crate::model::stack_instance::Builder::default()
    }
}

/// See [`StackInstance`](crate::model::StackInstance).
pub mod stack_instance {

    /// A builder for [`StackInstance`](crate::model::StackInstance).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account: std::option::Option<std::string::String>,
        pub(crate) region: std::option::Option<std::string::String>,
        pub(crate) stack_instance_status: std::option::Option<crate::model::StackInstanceStatus>,
    }
    impl Builder {
        /// <p>The name of the Amazon Web Services account that the stack instance is associated with.</p>
        pub fn account(mut self, input: impl Into<std::string::String>) -> Self {
            self.account = Some(input.into());
            self
        }
        /// <p>The name of the Amazon Web Services account that the stack instance is associated with.</p>
        pub fn set_account(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account = input;
            self
        }
        /// <p>The name of the Amazon Web Services Region that the stack instance is associated with.</p>
        pub fn region(mut self, input: impl Into<std::string::String>) -> Self {
            self.region = Some(input.into());
            self
        }
        /// <p>The name of the Amazon Web Services Region that the stack instance is associated with.</p>
        pub fn set_region(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.region = input;
            self
        }
        /// <p>The status of the stack instance, in terms of its synchronization with its associated stack set. </p>
        /// <ul>
        /// <li> <p> <code>INOPERABLE</code>: A <code>DeleteStackInstances</code> operation has failed and left the stack in an unstable state. Stacks in this state are excluded from further <code>UpdateStackSet</code> operations. You might need to perform a <code>DeleteStackInstances</code> operation, with <code>RetainStacks</code> set to true, to delete the stack instance, and then delete the stack manually. </p> </li>
        /// <li> <p> <code>OUTDATED</code>: The stack isn't currently up to date with the stack set because either the associated stack failed during a <code>CreateStackSet</code> or <code>UpdateStackSet</code> operation, or the stack was part of a <code>CreateStackSet</code> or <code>UpdateStackSet</code> operation that failed or was stopped before the stack was created or updated.</p> </li>
        /// <li> <p> <code>CURRENT</code>: The stack is currently up to date with the stack set.</p> </li>
        /// </ul>
        pub fn stack_instance_status(mut self, input: crate::model::StackInstanceStatus) -> Self {
            self.stack_instance_status = Some(input);
            self
        }
        /// <p>The status of the stack instance, in terms of its synchronization with its associated stack set. </p>
        /// <ul>
        /// <li> <p> <code>INOPERABLE</code>: A <code>DeleteStackInstances</code> operation has failed and left the stack in an unstable state. Stacks in this state are excluded from further <code>UpdateStackSet</code> operations. You might need to perform a <code>DeleteStackInstances</code> operation, with <code>RetainStacks</code> set to true, to delete the stack instance, and then delete the stack manually. </p> </li>
        /// <li> <p> <code>OUTDATED</code>: The stack isn't currently up to date with the stack set because either the associated stack failed during a <code>CreateStackSet</code> or <code>UpdateStackSet</code> operation, or the stack was part of a <code>CreateStackSet</code> or <code>UpdateStackSet</code> operation that failed or was stopped before the stack was created or updated.</p> </li>
        /// <li> <p> <code>CURRENT</code>: The stack is currently up to date with the stack set.</p> </li>
        /// </ul>
        pub fn set_stack_instance_status(
            mut self,
            input: std::option::Option<crate::model::StackInstanceStatus>,
        ) -> Self {
            self.stack_instance_status = input;
            self
        }
        /// Consumes the builder and constructs a [`StackInstance`](crate::model::StackInstance).
        pub fn build(self) -> crate::model::StackInstance {
            crate::model::StackInstance {
                account: self.account,
                region: self.region,
                stack_instance_status: self.stack_instance_status,
            }
        }
    }
}

/// When writing a match expression against `StackInstanceStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let stackinstancestatus = unimplemented!();
/// match stackinstancestatus {
///     StackInstanceStatus::Current => { /* ... */ },
///     StackInstanceStatus::Inoperable => { /* ... */ },
///     StackInstanceStatus::Outdated => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `stackinstancestatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `StackInstanceStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `StackInstanceStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `StackInstanceStatus::NewFeature` is defined.
/// Specifically, when `stackinstancestatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `StackInstanceStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StackInstanceStatus {
    #[allow(missing_docs)] // documentation missing in model
    Current,
    #[allow(missing_docs)] // documentation missing in model
    Inoperable,
    #[allow(missing_docs)] // documentation missing in model
    Outdated,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for StackInstanceStatus {
    fn from(s: &str) -> Self {
        match s {
            "CURRENT" => StackInstanceStatus::Current,
            "INOPERABLE" => StackInstanceStatus::Inoperable,
            "OUTDATED" => StackInstanceStatus::Outdated,
            other => {
                StackInstanceStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for StackInstanceStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StackInstanceStatus::from(s))
    }
}
impl StackInstanceStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            StackInstanceStatus::Current => "CURRENT",
            StackInstanceStatus::Inoperable => "INOPERABLE",
            StackInstanceStatus::Outdated => "OUTDATED",
            StackInstanceStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CURRENT", "INOPERABLE", "OUTDATED"]
    }
}
impl AsRef<str> for StackInstanceStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about a resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ResourceDetail {
    /// <p>The identifier of the resource.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The ARN of the resource.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The name of the resource.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The description of the resource.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The creation time of the resource.</p>
    #[doc(hidden)]
    pub created_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl ResourceDetail {
    /// <p>The identifier of the resource.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The ARN of the resource.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The name of the resource.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The description of the resource.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The creation time of the resource.</p>
    pub fn created_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_time.as_ref()
    }
}
impl ResourceDetail {
    /// Creates a new builder-style object to manufacture [`ResourceDetail`](crate::model::ResourceDetail).
    pub fn builder() -> crate::model::resource_detail::Builder {
        crate::model::resource_detail::Builder::default()
    }
}

/// See [`ResourceDetail`](crate::model::ResourceDetail).
pub mod resource_detail {

    /// A builder for [`ResourceDetail`](crate::model::ResourceDetail).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) created_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The identifier of the resource.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of the resource.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The ARN of the resource.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The ARN of the resource.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The name of the resource.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the resource.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The description of the resource.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the resource.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The creation time of the resource.</p>
        pub fn created_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_time = Some(input);
            self
        }
        /// <p>The creation time of the resource.</p>
        pub fn set_created_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_time = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceDetail`](crate::model::ResourceDetail).
        pub fn build(self) -> crate::model::ResourceDetail {
            crate::model::ResourceDetail {
                id: self.id,
                arn: self.arn,
                name: self.name,
                description: self.description,
                created_time: self.created_time,
            }
        }
    }
}

/// <p>The search filter to use when listing history records.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListRecordHistorySearchFilter {
    /// <p>The filter key.</p>
    /// <ul>
    /// <li> <p> <code>product</code> - Filter results based on the specified product identifier.</p> </li>
    /// <li> <p> <code>provisionedproduct</code> - Filter results based on the provisioned product identifier.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub key: std::option::Option<std::string::String>,
    /// <p>The filter value.</p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
}
impl ListRecordHistorySearchFilter {
    /// <p>The filter key.</p>
    /// <ul>
    /// <li> <p> <code>product</code> - Filter results based on the specified product identifier.</p> </li>
    /// <li> <p> <code>provisionedproduct</code> - Filter results based on the provisioned product identifier.</p> </li>
    /// </ul>
    pub fn key(&self) -> std::option::Option<&str> {
        self.key.as_deref()
    }
    /// <p>The filter value.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
impl ListRecordHistorySearchFilter {
    /// Creates a new builder-style object to manufacture [`ListRecordHistorySearchFilter`](crate::model::ListRecordHistorySearchFilter).
    pub fn builder() -> crate::model::list_record_history_search_filter::Builder {
        crate::model::list_record_history_search_filter::Builder::default()
    }
}

/// See [`ListRecordHistorySearchFilter`](crate::model::ListRecordHistorySearchFilter).
pub mod list_record_history_search_filter {

    /// A builder for [`ListRecordHistorySearchFilter`](crate::model::ListRecordHistorySearchFilter).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The filter key.</p>
        /// <ul>
        /// <li> <p> <code>product</code> - Filter results based on the specified product identifier.</p> </li>
        /// <li> <p> <code>provisionedproduct</code> - Filter results based on the provisioned product identifier.</p> </li>
        /// </ul>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        /// <p>The filter key.</p>
        /// <ul>
        /// <li> <p> <code>product</code> - Filter results based on the specified product identifier.</p> </li>
        /// <li> <p> <code>provisionedproduct</code> - Filter results based on the provisioned product identifier.</p> </li>
        /// </ul>
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The filter value.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The filter value.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`ListRecordHistorySearchFilter`](crate::model::ListRecordHistorySearchFilter).
        pub fn build(self) -> crate::model::ListRecordHistorySearchFilter {
            crate::model::ListRecordHistorySearchFilter {
                key: self.key,
                value: self.value,
            }
        }
    }
}

/// <p>An object that contains summary information about a product view and a provisioning artifact.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ProvisioningArtifactView {
    /// <p>Summary information about a product view.</p>
    #[doc(hidden)]
    pub product_view_summary: std::option::Option<crate::model::ProductViewSummary>,
    /// <p>Information about a provisioning artifact. A provisioning artifact is also known as a product version.</p>
    #[doc(hidden)]
    pub provisioning_artifact: std::option::Option<crate::model::ProvisioningArtifact>,
}
impl ProvisioningArtifactView {
    /// <p>Summary information about a product view.</p>
    pub fn product_view_summary(&self) -> std::option::Option<&crate::model::ProductViewSummary> {
        self.product_view_summary.as_ref()
    }
    /// <p>Information about a provisioning artifact. A provisioning artifact is also known as a product version.</p>
    pub fn provisioning_artifact(
        &self,
    ) -> std::option::Option<&crate::model::ProvisioningArtifact> {
        self.provisioning_artifact.as_ref()
    }
}
impl ProvisioningArtifactView {
    /// Creates a new builder-style object to manufacture [`ProvisioningArtifactView`](crate::model::ProvisioningArtifactView).
    pub fn builder() -> crate::model::provisioning_artifact_view::Builder {
        crate::model::provisioning_artifact_view::Builder::default()
    }
}

/// See [`ProvisioningArtifactView`](crate::model::ProvisioningArtifactView).
pub mod provisioning_artifact_view {

    /// A builder for [`ProvisioningArtifactView`](crate::model::ProvisioningArtifactView).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) product_view_summary: std::option::Option<crate::model::ProductViewSummary>,
        pub(crate) provisioning_artifact: std::option::Option<crate::model::ProvisioningArtifact>,
    }
    impl Builder {
        /// <p>Summary information about a product view.</p>
        pub fn product_view_summary(mut self, input: crate::model::ProductViewSummary) -> Self {
            self.product_view_summary = Some(input);
            self
        }
        /// <p>Summary information about a product view.</p>
        pub fn set_product_view_summary(
            mut self,
            input: std::option::Option<crate::model::ProductViewSummary>,
        ) -> Self {
            self.product_view_summary = input;
            self
        }
        /// <p>Information about a provisioning artifact. A provisioning artifact is also known as a product version.</p>
        pub fn provisioning_artifact(mut self, input: crate::model::ProvisioningArtifact) -> Self {
            self.provisioning_artifact = Some(input);
            self
        }
        /// <p>Information about a provisioning artifact. A provisioning artifact is also known as a product version.</p>
        pub fn set_provisioning_artifact(
            mut self,
            input: std::option::Option<crate::model::ProvisioningArtifact>,
        ) -> Self {
            self.provisioning_artifact = input;
            self
        }
        /// Consumes the builder and constructs a [`ProvisioningArtifactView`](crate::model::ProvisioningArtifactView).
        pub fn build(self) -> crate::model::ProvisioningArtifactView {
            crate::model::ProvisioningArtifactView {
                product_view_summary: self.product_view_summary,
                provisioning_artifact: self.provisioning_artifact,
            }
        }
    }
}

/// <p>Information about a provisioning artifact. A provisioning artifact is also known as a product version.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ProvisioningArtifact {
    /// <p>The identifier of the provisioning artifact.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The name of the provisioning artifact.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The description of the provisioning artifact.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The UTC time stamp of the creation time.</p>
    #[doc(hidden)]
    pub created_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Information set by the administrator to provide guidance to end users about which provisioning artifacts to use.</p>
    #[doc(hidden)]
    pub guidance: std::option::Option<crate::model::ProvisioningArtifactGuidance>,
}
impl ProvisioningArtifact {
    /// <p>The identifier of the provisioning artifact.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The name of the provisioning artifact.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The description of the provisioning artifact.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The UTC time stamp of the creation time.</p>
    pub fn created_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_time.as_ref()
    }
    /// <p>Information set by the administrator to provide guidance to end users about which provisioning artifacts to use.</p>
    pub fn guidance(&self) -> std::option::Option<&crate::model::ProvisioningArtifactGuidance> {
        self.guidance.as_ref()
    }
}
impl ProvisioningArtifact {
    /// Creates a new builder-style object to manufacture [`ProvisioningArtifact`](crate::model::ProvisioningArtifact).
    pub fn builder() -> crate::model::provisioning_artifact::Builder {
        crate::model::provisioning_artifact::Builder::default()
    }
}

/// See [`ProvisioningArtifact`](crate::model::ProvisioningArtifact).
pub mod provisioning_artifact {

    /// A builder for [`ProvisioningArtifact`](crate::model::ProvisioningArtifact).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) created_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) guidance: std::option::Option<crate::model::ProvisioningArtifactGuidance>,
    }
    impl Builder {
        /// <p>The identifier of the provisioning artifact.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of the provisioning artifact.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The name of the provisioning artifact.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the provisioning artifact.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The description of the provisioning artifact.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the provisioning artifact.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The UTC time stamp of the creation time.</p>
        pub fn created_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_time = Some(input);
            self
        }
        /// <p>The UTC time stamp of the creation time.</p>
        pub fn set_created_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_time = input;
            self
        }
        /// <p>Information set by the administrator to provide guidance to end users about which provisioning artifacts to use.</p>
        pub fn guidance(mut self, input: crate::model::ProvisioningArtifactGuidance) -> Self {
            self.guidance = Some(input);
            self
        }
        /// <p>Information set by the administrator to provide guidance to end users about which provisioning artifacts to use.</p>
        pub fn set_guidance(
            mut self,
            input: std::option::Option<crate::model::ProvisioningArtifactGuidance>,
        ) -> Self {
            self.guidance = input;
            self
        }
        /// Consumes the builder and constructs a [`ProvisioningArtifact`](crate::model::ProvisioningArtifact).
        pub fn build(self) -> crate::model::ProvisioningArtifact {
            crate::model::ProvisioningArtifact {
                id: self.id,
                name: self.name,
                description: self.description,
                created_time: self.created_time,
                guidance: self.guidance,
            }
        }
    }
}

/// <p>Summary information about a plan.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ProvisionedProductPlanSummary {
    /// <p>The name of the plan.</p>
    #[doc(hidden)]
    pub plan_name: std::option::Option<std::string::String>,
    /// <p>The plan identifier.</p>
    #[doc(hidden)]
    pub plan_id: std::option::Option<std::string::String>,
    /// <p>The product identifier.</p>
    #[doc(hidden)]
    pub provision_product_id: std::option::Option<std::string::String>,
    /// <p>The user-friendly name of the provisioned product.</p>
    #[doc(hidden)]
    pub provision_product_name: std::option::Option<std::string::String>,
    /// <p>The plan type.</p>
    #[doc(hidden)]
    pub plan_type: std::option::Option<crate::model::ProvisionedProductPlanType>,
    /// <p>The identifier of the provisioning artifact.</p>
    #[doc(hidden)]
    pub provisioning_artifact_id: std::option::Option<std::string::String>,
}
impl ProvisionedProductPlanSummary {
    /// <p>The name of the plan.</p>
    pub fn plan_name(&self) -> std::option::Option<&str> {
        self.plan_name.as_deref()
    }
    /// <p>The plan identifier.</p>
    pub fn plan_id(&self) -> std::option::Option<&str> {
        self.plan_id.as_deref()
    }
    /// <p>The product identifier.</p>
    pub fn provision_product_id(&self) -> std::option::Option<&str> {
        self.provision_product_id.as_deref()
    }
    /// <p>The user-friendly name of the provisioned product.</p>
    pub fn provision_product_name(&self) -> std::option::Option<&str> {
        self.provision_product_name.as_deref()
    }
    /// <p>The plan type.</p>
    pub fn plan_type(&self) -> std::option::Option<&crate::model::ProvisionedProductPlanType> {
        self.plan_type.as_ref()
    }
    /// <p>The identifier of the provisioning artifact.</p>
    pub fn provisioning_artifact_id(&self) -> std::option::Option<&str> {
        self.provisioning_artifact_id.as_deref()
    }
}
impl ProvisionedProductPlanSummary {
    /// Creates a new builder-style object to manufacture [`ProvisionedProductPlanSummary`](crate::model::ProvisionedProductPlanSummary).
    pub fn builder() -> crate::model::provisioned_product_plan_summary::Builder {
        crate::model::provisioned_product_plan_summary::Builder::default()
    }
}

/// See [`ProvisionedProductPlanSummary`](crate::model::ProvisionedProductPlanSummary).
pub mod provisioned_product_plan_summary {

    /// A builder for [`ProvisionedProductPlanSummary`](crate::model::ProvisionedProductPlanSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) plan_name: std::option::Option<std::string::String>,
        pub(crate) plan_id: std::option::Option<std::string::String>,
        pub(crate) provision_product_id: std::option::Option<std::string::String>,
        pub(crate) provision_product_name: std::option::Option<std::string::String>,
        pub(crate) plan_type: std::option::Option<crate::model::ProvisionedProductPlanType>,
        pub(crate) provisioning_artifact_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the plan.</p>
        pub fn plan_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.plan_name = Some(input.into());
            self
        }
        /// <p>The name of the plan.</p>
        pub fn set_plan_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.plan_name = input;
            self
        }
        /// <p>The plan identifier.</p>
        pub fn plan_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.plan_id = Some(input.into());
            self
        }
        /// <p>The plan identifier.</p>
        pub fn set_plan_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.plan_id = input;
            self
        }
        /// <p>The product identifier.</p>
        pub fn provision_product_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.provision_product_id = Some(input.into());
            self
        }
        /// <p>The product identifier.</p>
        pub fn set_provision_product_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.provision_product_id = input;
            self
        }
        /// <p>The user-friendly name of the provisioned product.</p>
        pub fn provision_product_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.provision_product_name = Some(input.into());
            self
        }
        /// <p>The user-friendly name of the provisioned product.</p>
        pub fn set_provision_product_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.provision_product_name = input;
            self
        }
        /// <p>The plan type.</p>
        pub fn plan_type(mut self, input: crate::model::ProvisionedProductPlanType) -> Self {
            self.plan_type = Some(input);
            self
        }
        /// <p>The plan type.</p>
        pub fn set_plan_type(
            mut self,
            input: std::option::Option<crate::model::ProvisionedProductPlanType>,
        ) -> Self {
            self.plan_type = input;
            self
        }
        /// <p>The identifier of the provisioning artifact.</p>
        pub fn provisioning_artifact_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.provisioning_artifact_id = Some(input.into());
            self
        }
        /// <p>The identifier of the provisioning artifact.</p>
        pub fn set_provisioning_artifact_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.provisioning_artifact_id = input;
            self
        }
        /// Consumes the builder and constructs a [`ProvisionedProductPlanSummary`](crate::model::ProvisionedProductPlanSummary).
        pub fn build(self) -> crate::model::ProvisionedProductPlanSummary {
            crate::model::ProvisionedProductPlanSummary {
                plan_name: self.plan_name,
                plan_id: self.plan_id,
                provision_product_id: self.provision_product_id,
                provision_product_name: self.provision_product_name,
                plan_type: self.plan_type,
                provisioning_artifact_id: self.provisioning_artifact_id,
            }
        }
    }
}

/// When writing a match expression against `ProvisionedProductPlanType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let provisionedproductplantype = unimplemented!();
/// match provisionedproductplantype {
///     ProvisionedProductPlanType::Cloudformation => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `provisionedproductplantype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ProvisionedProductPlanType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ProvisionedProductPlanType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ProvisionedProductPlanType::NewFeature` is defined.
/// Specifically, when `provisionedproductplantype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ProvisionedProductPlanType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ProvisionedProductPlanType {
    #[allow(missing_docs)] // documentation missing in model
    Cloudformation,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ProvisionedProductPlanType {
    fn from(s: &str) -> Self {
        match s {
            "CLOUDFORMATION" => ProvisionedProductPlanType::Cloudformation,
            other => ProvisionedProductPlanType::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for ProvisionedProductPlanType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ProvisionedProductPlanType::from(s))
    }
}
impl ProvisionedProductPlanType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ProvisionedProductPlanType::Cloudformation => "CLOUDFORMATION",
            ProvisionedProductPlanType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CLOUDFORMATION"]
    }
}
impl AsRef<str> for ProvisionedProductPlanType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about a principal.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Principal {
    /// <p>The ARN of the principal (IAM user, role, or group). This field allows for an ARN with no <code>accountID</code> if the <code>PrincipalType</code> is an <code>IAM_PATTERN</code>. </p>
    #[doc(hidden)]
    pub principal_arn: std::option::Option<std::string::String>,
    /// <p>The principal type. The supported value is <code>IAM</code> if you use a fully defined ARN, or <code>IAM_PATTERN</code> if you use an ARN with no <code>accountID</code>. </p>
    #[doc(hidden)]
    pub principal_type: std::option::Option<crate::model::PrincipalType>,
}
impl Principal {
    /// <p>The ARN of the principal (IAM user, role, or group). This field allows for an ARN with no <code>accountID</code> if the <code>PrincipalType</code> is an <code>IAM_PATTERN</code>. </p>
    pub fn principal_arn(&self) -> std::option::Option<&str> {
        self.principal_arn.as_deref()
    }
    /// <p>The principal type. The supported value is <code>IAM</code> if you use a fully defined ARN, or <code>IAM_PATTERN</code> if you use an ARN with no <code>accountID</code>. </p>
    pub fn principal_type(&self) -> std::option::Option<&crate::model::PrincipalType> {
        self.principal_type.as_ref()
    }
}
impl Principal {
    /// Creates a new builder-style object to manufacture [`Principal`](crate::model::Principal).
    pub fn builder() -> crate::model::principal::Builder {
        crate::model::principal::Builder::default()
    }
}

/// See [`Principal`](crate::model::Principal).
pub mod principal {

    /// A builder for [`Principal`](crate::model::Principal).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) principal_arn: std::option::Option<std::string::String>,
        pub(crate) principal_type: std::option::Option<crate::model::PrincipalType>,
    }
    impl Builder {
        /// <p>The ARN of the principal (IAM user, role, or group). This field allows for an ARN with no <code>accountID</code> if the <code>PrincipalType</code> is an <code>IAM_PATTERN</code>. </p>
        pub fn principal_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.principal_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the principal (IAM user, role, or group). This field allows for an ARN with no <code>accountID</code> if the <code>PrincipalType</code> is an <code>IAM_PATTERN</code>. </p>
        pub fn set_principal_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.principal_arn = input;
            self
        }
        /// <p>The principal type. The supported value is <code>IAM</code> if you use a fully defined ARN, or <code>IAM_PATTERN</code> if you use an ARN with no <code>accountID</code>. </p>
        pub fn principal_type(mut self, input: crate::model::PrincipalType) -> Self {
            self.principal_type = Some(input);
            self
        }
        /// <p>The principal type. The supported value is <code>IAM</code> if you use a fully defined ARN, or <code>IAM_PATTERN</code> if you use an ARN with no <code>accountID</code>. </p>
        pub fn set_principal_type(
            mut self,
            input: std::option::Option<crate::model::PrincipalType>,
        ) -> Self {
            self.principal_type = input;
            self
        }
        /// Consumes the builder and constructs a [`Principal`](crate::model::Principal).
        pub fn build(self) -> crate::model::Principal {
            crate::model::Principal {
                principal_arn: self.principal_arn,
                principal_type: self.principal_type,
            }
        }
    }
}

/// When writing a match expression against `PrincipalType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let principaltype = unimplemented!();
/// match principaltype {
///     PrincipalType::Iam => { /* ... */ },
///     PrincipalType::IamPattern => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `principaltype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PrincipalType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PrincipalType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PrincipalType::NewFeature` is defined.
/// Specifically, when `principaltype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PrincipalType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PrincipalType {
    #[allow(missing_docs)] // documentation missing in model
    Iam,
    #[allow(missing_docs)] // documentation missing in model
    IamPattern,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PrincipalType {
    fn from(s: &str) -> Self {
        match s {
            "IAM" => PrincipalType::Iam,
            "IAM_PATTERN" => PrincipalType::IamPattern,
            other => PrincipalType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for PrincipalType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PrincipalType::from(s))
    }
}
impl PrincipalType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PrincipalType::Iam => "IAM",
            PrincipalType::IamPattern => "IAM_PATTERN",
            PrincipalType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["IAM", "IAM_PATTERN"]
    }
}
impl AsRef<str> for PrincipalType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Summary information about a product path for a user.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LaunchPathSummary {
    /// <p>The identifier of the product path.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The constraints on the portfolio-product relationship.</p>
    #[doc(hidden)]
    pub constraint_summaries: std::option::Option<std::vec::Vec<crate::model::ConstraintSummary>>,
    /// <p>The tags associated with this product path.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>The name of the portfolio that contains the product. </p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
}
impl LaunchPathSummary {
    /// <p>The identifier of the product path.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The constraints on the portfolio-product relationship.</p>
    pub fn constraint_summaries(&self) -> std::option::Option<&[crate::model::ConstraintSummary]> {
        self.constraint_summaries.as_deref()
    }
    /// <p>The tags associated with this product path.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
    /// <p>The name of the portfolio that contains the product. </p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
}
impl LaunchPathSummary {
    /// Creates a new builder-style object to manufacture [`LaunchPathSummary`](crate::model::LaunchPathSummary).
    pub fn builder() -> crate::model::launch_path_summary::Builder {
        crate::model::launch_path_summary::Builder::default()
    }
}

/// See [`LaunchPathSummary`](crate::model::LaunchPathSummary).
pub mod launch_path_summary {

    /// A builder for [`LaunchPathSummary`](crate::model::LaunchPathSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) constraint_summaries:
            std::option::Option<std::vec::Vec<crate::model::ConstraintSummary>>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the product path.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of the product path.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// Appends an item to `constraint_summaries`.
        ///
        /// To override the contents of this collection use [`set_constraint_summaries`](Self::set_constraint_summaries).
        ///
        /// <p>The constraints on the portfolio-product relationship.</p>
        pub fn constraint_summaries(mut self, input: crate::model::ConstraintSummary) -> Self {
            let mut v = self.constraint_summaries.unwrap_or_default();
            v.push(input);
            self.constraint_summaries = Some(v);
            self
        }
        /// <p>The constraints on the portfolio-product relationship.</p>
        pub fn set_constraint_summaries(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ConstraintSummary>>,
        ) -> Self {
            self.constraint_summaries = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags associated with this product path.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>The tags associated with this product path.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The name of the portfolio that contains the product. </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the portfolio that contains the product. </p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`LaunchPathSummary`](crate::model::LaunchPathSummary).
        pub fn build(self) -> crate::model::LaunchPathSummary {
            crate::model::LaunchPathSummary {
                id: self.id,
                constraint_summaries: self.constraint_summaries,
                tags: self.tags,
                name: self.name,
            }
        }
    }
}

/// <p>Summary information about a constraint.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConstraintSummary {
    /// <p>The type of constraint.</p>
    /// <ul>
    /// <li> <p> <code>LAUNCH</code> </p> </li>
    /// <li> <p> <code>NOTIFICATION</code> </p> </li>
    /// <li> <p>STACKSET</p> </li>
    /// <li> <p> <code>TEMPLATE</code> </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub r#type: std::option::Option<std::string::String>,
    /// <p>The description of the constraint.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
}
impl ConstraintSummary {
    /// <p>The type of constraint.</p>
    /// <ul>
    /// <li> <p> <code>LAUNCH</code> </p> </li>
    /// <li> <p> <code>NOTIFICATION</code> </p> </li>
    /// <li> <p>STACKSET</p> </li>
    /// <li> <p> <code>TEMPLATE</code> </p> </li>
    /// </ul>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
    /// <p>The description of the constraint.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
}
impl ConstraintSummary {
    /// Creates a new builder-style object to manufacture [`ConstraintSummary`](crate::model::ConstraintSummary).
    pub fn builder() -> crate::model::constraint_summary::Builder {
        crate::model::constraint_summary::Builder::default()
    }
}

/// See [`ConstraintSummary`](crate::model::ConstraintSummary).
pub mod constraint_summary {

    /// A builder for [`ConstraintSummary`](crate::model::ConstraintSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The type of constraint.</p>
        /// <ul>
        /// <li> <p> <code>LAUNCH</code> </p> </li>
        /// <li> <p> <code>NOTIFICATION</code> </p> </li>
        /// <li> <p>STACKSET</p> </li>
        /// <li> <p> <code>TEMPLATE</code> </p> </li>
        /// </ul>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The type of constraint.</p>
        /// <ul>
        /// <li> <p> <code>LAUNCH</code> </p> </li>
        /// <li> <p> <code>NOTIFICATION</code> </p> </li>
        /// <li> <p>STACKSET</p> </li>
        /// <li> <p> <code>TEMPLATE</code> </p> </li>
        /// </ul>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The description of the constraint.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the constraint.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Consumes the builder and constructs a [`ConstraintSummary`](crate::model::ConstraintSummary).
        pub fn build(self) -> crate::model::ConstraintSummary {
            crate::model::ConstraintSummary {
                r#type: self.r#type,
                description: self.description,
            }
        }
    }
}

/// <p>Information about a budget.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BudgetDetail {
    /// <p>Name of the associated budget.</p>
    #[doc(hidden)]
    pub budget_name: std::option::Option<std::string::String>,
}
impl BudgetDetail {
    /// <p>Name of the associated budget.</p>
    pub fn budget_name(&self) -> std::option::Option<&str> {
        self.budget_name.as_deref()
    }
}
impl BudgetDetail {
    /// Creates a new builder-style object to manufacture [`BudgetDetail`](crate::model::BudgetDetail).
    pub fn builder() -> crate::model::budget_detail::Builder {
        crate::model::budget_detail::Builder::default()
    }
}

/// See [`BudgetDetail`](crate::model::BudgetDetail).
pub mod budget_detail {

    /// A builder for [`BudgetDetail`](crate::model::BudgetDetail).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) budget_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Name of the associated budget.</p>
        pub fn budget_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.budget_name = Some(input.into());
            self
        }
        /// <p>Name of the associated budget.</p>
        pub fn set_budget_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.budget_name = input;
            self
        }
        /// Consumes the builder and constructs a [`BudgetDetail`](crate::model::BudgetDetail).
        pub fn build(self) -> crate::model::BudgetDetail {
            crate::model::BudgetDetail {
                budget_name: self.budget_name,
            }
        }
    }
}

/// <p>The output for the product created as the result of a request. For example, the output for a CloudFormation-backed product that creates an S3 bucket would include the S3 bucket URL.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RecordOutput {
    /// <p>The output key.</p>
    #[doc(hidden)]
    pub output_key: std::option::Option<std::string::String>,
    /// <p>The output value.</p>
    #[doc(hidden)]
    pub output_value: std::option::Option<std::string::String>,
    /// <p>The description of the output.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
}
impl RecordOutput {
    /// <p>The output key.</p>
    pub fn output_key(&self) -> std::option::Option<&str> {
        self.output_key.as_deref()
    }
    /// <p>The output value.</p>
    pub fn output_value(&self) -> std::option::Option<&str> {
        self.output_value.as_deref()
    }
    /// <p>The description of the output.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
}
impl RecordOutput {
    /// Creates a new builder-style object to manufacture [`RecordOutput`](crate::model::RecordOutput).
    pub fn builder() -> crate::model::record_output::Builder {
        crate::model::record_output::Builder::default()
    }
}

/// See [`RecordOutput`](crate::model::RecordOutput).
pub mod record_output {

    /// A builder for [`RecordOutput`](crate::model::RecordOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) output_key: std::option::Option<std::string::String>,
        pub(crate) output_value: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The output key.</p>
        pub fn output_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.output_key = Some(input.into());
            self
        }
        /// <p>The output key.</p>
        pub fn set_output_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.output_key = input;
            self
        }
        /// <p>The output value.</p>
        pub fn output_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.output_value = Some(input.into());
            self
        }
        /// <p>The output value.</p>
        pub fn set_output_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.output_value = input;
            self
        }
        /// <p>The description of the output.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the output.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Consumes the builder and constructs a [`RecordOutput`](crate::model::RecordOutput).
        pub fn build(self) -> crate::model::RecordOutput {
            crate::model::RecordOutput {
                output_key: self.output_key,
                output_value: self.output_value,
                description: self.description,
            }
        }
    }
}

/// When writing a match expression against `AccessStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let accessstatus = unimplemented!();
/// match accessstatus {
///     AccessStatus::Disabled => { /* ... */ },
///     AccessStatus::Enabled => { /* ... */ },
///     AccessStatus::UnderChange => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `accessstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AccessStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AccessStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AccessStatus::NewFeature` is defined.
/// Specifically, when `accessstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AccessStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AccessStatus {
    #[allow(missing_docs)] // documentation missing in model
    Disabled,
    #[allow(missing_docs)] // documentation missing in model
    Enabled,
    #[allow(missing_docs)] // documentation missing in model
    UnderChange,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AccessStatus {
    fn from(s: &str) -> Self {
        match s {
            "DISABLED" => AccessStatus::Disabled,
            "ENABLED" => AccessStatus::Enabled,
            "UNDER_CHANGE" => AccessStatus::UnderChange,
            other => AccessStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for AccessStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AccessStatus::from(s))
    }
}
impl AccessStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AccessStatus::Disabled => "DISABLED",
            AccessStatus::Enabled => "ENABLED",
            AccessStatus::UnderChange => "UNDER_CHANGE",
            AccessStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DISABLED", "ENABLED", "UNDER_CHANGE"]
    }
}
impl AsRef<str> for AccessStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Details of an execution parameter value that is passed to a self-service action when executed on a provisioned product.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ExecutionParameter {
    /// <p>The name of the execution parameter.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The execution parameter type.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<std::string::String>,
    /// <p>The default values for the execution parameter.</p>
    #[doc(hidden)]
    pub default_values: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl ExecutionParameter {
    /// <p>The name of the execution parameter.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The execution parameter type.</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
    /// <p>The default values for the execution parameter.</p>
    pub fn default_values(&self) -> std::option::Option<&[std::string::String]> {
        self.default_values.as_deref()
    }
}
impl ExecutionParameter {
    /// Creates a new builder-style object to manufacture [`ExecutionParameter`](crate::model::ExecutionParameter).
    pub fn builder() -> crate::model::execution_parameter::Builder {
        crate::model::execution_parameter::Builder::default()
    }
}

/// See [`ExecutionParameter`](crate::model::ExecutionParameter).
pub mod execution_parameter {

    /// A builder for [`ExecutionParameter`](crate::model::ExecutionParameter).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) default_values: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The name of the execution parameter.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the execution parameter.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The execution parameter type.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The execution parameter type.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// Appends an item to `default_values`.
        ///
        /// To override the contents of this collection use [`set_default_values`](Self::set_default_values).
        ///
        /// <p>The default values for the execution parameter.</p>
        pub fn default_values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.default_values.unwrap_or_default();
            v.push(input.into());
            self.default_values = Some(v);
            self
        }
        /// <p>The default values for the execution parameter.</p>
        pub fn set_default_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.default_values = input;
            self
        }
        /// Consumes the builder and constructs a [`ExecutionParameter`](crate::model::ExecutionParameter).
        pub fn build(self) -> crate::model::ExecutionParameter {
            crate::model::ExecutionParameter {
                name: self.name,
                r#type: self.r#type,
                default_values: self.default_values,
            }
        }
    }
}

/// <p>Provisioning artifact output.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ProvisioningArtifactOutput {
    /// <p>The provisioning artifact output key.</p>
    #[doc(hidden)]
    pub key: std::option::Option<std::string::String>,
    /// <p>Description of the provisioning artifact output key.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
}
impl ProvisioningArtifactOutput {
    /// <p>The provisioning artifact output key.</p>
    pub fn key(&self) -> std::option::Option<&str> {
        self.key.as_deref()
    }
    /// <p>Description of the provisioning artifact output key.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
}
impl ProvisioningArtifactOutput {
    /// Creates a new builder-style object to manufacture [`ProvisioningArtifactOutput`](crate::model::ProvisioningArtifactOutput).
    pub fn builder() -> crate::model::provisioning_artifact_output::Builder {
        crate::model::provisioning_artifact_output::Builder::default()
    }
}

/// See [`ProvisioningArtifactOutput`](crate::model::ProvisioningArtifactOutput).
pub mod provisioning_artifact_output {

    /// A builder for [`ProvisioningArtifactOutput`](crate::model::ProvisioningArtifactOutput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The provisioning artifact output key.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        /// <p>The provisioning artifact output key.</p>
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>Description of the provisioning artifact output key.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>Description of the provisioning artifact output key.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Consumes the builder and constructs a [`ProvisioningArtifactOutput`](crate::model::ProvisioningArtifactOutput).
        pub fn build(self) -> crate::model::ProvisioningArtifactOutput {
            crate::model::ProvisioningArtifactOutput {
                key: self.key,
                description: self.description,
            }
        }
    }
}

/// <p>The user-defined preferences that will be applied during product provisioning, unless overridden by <code>ProvisioningPreferences</code> or <code>UpdateProvisioningPreferences</code>.</p>
/// <p>For more information on maximum concurrent accounts and failure tolerance, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacksets-concepts.html#stackset-ops-options">Stack set operation options</a> in the <i>CloudFormation User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ProvisioningArtifactPreferences {
    /// <p>One or more Amazon Web Services accounts where stack instances are deployed from the stack set. These accounts can be scoped in <code>ProvisioningPreferences$StackSetAccounts</code> and <code>UpdateProvisioningPreferences$StackSetAccounts</code>.</p>
    /// <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
    #[doc(hidden)]
    pub stack_set_accounts: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>One or more Amazon Web Services Regions where stack instances are deployed from the stack set. These Regions can be scoped in <code>ProvisioningPreferences$StackSetRegions</code> and <code>UpdateProvisioningPreferences$StackSetRegions</code>.</p>
    /// <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
    #[doc(hidden)]
    pub stack_set_regions: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl ProvisioningArtifactPreferences {
    /// <p>One or more Amazon Web Services accounts where stack instances are deployed from the stack set. These accounts can be scoped in <code>ProvisioningPreferences$StackSetAccounts</code> and <code>UpdateProvisioningPreferences$StackSetAccounts</code>.</p>
    /// <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
    pub fn stack_set_accounts(&self) -> std::option::Option<&[std::string::String]> {
        self.stack_set_accounts.as_deref()
    }
    /// <p>One or more Amazon Web Services Regions where stack instances are deployed from the stack set. These Regions can be scoped in <code>ProvisioningPreferences$StackSetRegions</code> and <code>UpdateProvisioningPreferences$StackSetRegions</code>.</p>
    /// <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
    pub fn stack_set_regions(&self) -> std::option::Option<&[std::string::String]> {
        self.stack_set_regions.as_deref()
    }
}
impl ProvisioningArtifactPreferences {
    /// Creates a new builder-style object to manufacture [`ProvisioningArtifactPreferences`](crate::model::ProvisioningArtifactPreferences).
    pub fn builder() -> crate::model::provisioning_artifact_preferences::Builder {
        crate::model::provisioning_artifact_preferences::Builder::default()
    }
}

/// See [`ProvisioningArtifactPreferences`](crate::model::ProvisioningArtifactPreferences).
pub mod provisioning_artifact_preferences {

    /// A builder for [`ProvisioningArtifactPreferences`](crate::model::ProvisioningArtifactPreferences).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) stack_set_accounts: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) stack_set_regions: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// Appends an item to `stack_set_accounts`.
        ///
        /// To override the contents of this collection use [`set_stack_set_accounts`](Self::set_stack_set_accounts).
        ///
        /// <p>One or more Amazon Web Services accounts where stack instances are deployed from the stack set. These accounts can be scoped in <code>ProvisioningPreferences$StackSetAccounts</code> and <code>UpdateProvisioningPreferences$StackSetAccounts</code>.</p>
        /// <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
        pub fn stack_set_accounts(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.stack_set_accounts.unwrap_or_default();
            v.push(input.into());
            self.stack_set_accounts = Some(v);
            self
        }
        /// <p>One or more Amazon Web Services accounts where stack instances are deployed from the stack set. These accounts can be scoped in <code>ProvisioningPreferences$StackSetAccounts</code> and <code>UpdateProvisioningPreferences$StackSetAccounts</code>.</p>
        /// <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
        pub fn set_stack_set_accounts(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.stack_set_accounts = input;
            self
        }
        /// Appends an item to `stack_set_regions`.
        ///
        /// To override the contents of this collection use [`set_stack_set_regions`](Self::set_stack_set_regions).
        ///
        /// <p>One or more Amazon Web Services Regions where stack instances are deployed from the stack set. These Regions can be scoped in <code>ProvisioningPreferences$StackSetRegions</code> and <code>UpdateProvisioningPreferences$StackSetRegions</code>.</p>
        /// <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
        pub fn stack_set_regions(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.stack_set_regions.unwrap_or_default();
            v.push(input.into());
            self.stack_set_regions = Some(v);
            self
        }
        /// <p>One or more Amazon Web Services Regions where stack instances are deployed from the stack set. These Regions can be scoped in <code>ProvisioningPreferences$StackSetRegions</code> and <code>UpdateProvisioningPreferences$StackSetRegions</code>.</p>
        /// <p>Applicable only to a <code>CFN_STACKSET</code> provisioned product type.</p>
        pub fn set_stack_set_regions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.stack_set_regions = input;
            self
        }
        /// Consumes the builder and constructs a [`ProvisioningArtifactPreferences`](crate::model::ProvisioningArtifactPreferences).
        pub fn build(self) -> crate::model::ProvisioningArtifactPreferences {
            crate::model::ProvisioningArtifactPreferences {
                stack_set_accounts: self.stack_set_accounts,
                stack_set_regions: self.stack_set_regions,
            }
        }
    }
}

/// <p>Summary information about a TagOption.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TagOptionSummary {
    /// <p>The TagOption key.</p>
    #[doc(hidden)]
    pub key: std::option::Option<std::string::String>,
    /// <p>The TagOption value.</p>
    #[doc(hidden)]
    pub values: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl TagOptionSummary {
    /// <p>The TagOption key.</p>
    pub fn key(&self) -> std::option::Option<&str> {
        self.key.as_deref()
    }
    /// <p>The TagOption value.</p>
    pub fn values(&self) -> std::option::Option<&[std::string::String]> {
        self.values.as_deref()
    }
}
impl TagOptionSummary {
    /// Creates a new builder-style object to manufacture [`TagOptionSummary`](crate::model::TagOptionSummary).
    pub fn builder() -> crate::model::tag_option_summary::Builder {
        crate::model::tag_option_summary::Builder::default()
    }
}

/// See [`TagOptionSummary`](crate::model::TagOptionSummary).
pub mod tag_option_summary {

    /// A builder for [`TagOptionSummary`](crate::model::TagOptionSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) values: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The TagOption key.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        /// <p>The TagOption key.</p>
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// Appends an item to `values`.
        ///
        /// To override the contents of this collection use [`set_values`](Self::set_values).
        ///
        /// <p>The TagOption value.</p>
        pub fn values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input.into());
            self.values = Some(v);
            self
        }
        /// <p>The TagOption value.</p>
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// Consumes the builder and constructs a [`TagOptionSummary`](crate::model::TagOptionSummary).
        pub fn build(self) -> crate::model::TagOptionSummary {
            crate::model::TagOptionSummary {
                key: self.key,
                values: self.values,
            }
        }
    }
}

/// <p>Additional information provided by the administrator.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UsageInstruction {
    /// <p>The usage instruction type for the value.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<std::string::String>,
    /// <p>The usage instruction value for this type.</p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
}
impl UsageInstruction {
    /// <p>The usage instruction type for the value.</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
    /// <p>The usage instruction value for this type.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
impl UsageInstruction {
    /// Creates a new builder-style object to manufacture [`UsageInstruction`](crate::model::UsageInstruction).
    pub fn builder() -> crate::model::usage_instruction::Builder {
        crate::model::usage_instruction::Builder::default()
    }
}

/// See [`UsageInstruction`](crate::model::UsageInstruction).
pub mod usage_instruction {

    /// A builder for [`UsageInstruction`](crate::model::UsageInstruction).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The usage instruction type for the value.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The usage instruction type for the value.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The usage instruction value for this type.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The usage instruction value for this type.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`UsageInstruction`](crate::model::UsageInstruction).
        pub fn build(self) -> crate::model::UsageInstruction {
            crate::model::UsageInstruction {
                r#type: self.r#type,
                value: self.value,
            }
        }
    }
}

/// <p>Information about a parameter used to provision a product.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ProvisioningArtifactParameter {
    /// <p>The parameter key.</p>
    #[doc(hidden)]
    pub parameter_key: std::option::Option<std::string::String>,
    /// <p>The default value.</p>
    #[doc(hidden)]
    pub default_value: std::option::Option<std::string::String>,
    /// <p>The parameter type.</p>
    #[doc(hidden)]
    pub parameter_type: std::option::Option<std::string::String>,
    /// <p>If this value is true, the value for this parameter is obfuscated from view when the parameter is retrieved. This parameter is used to hide sensitive information.</p>
    #[doc(hidden)]
    pub is_no_echo: bool,
    /// <p>The description of the parameter.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>Constraints that the administrator has put on a parameter.</p>
    #[doc(hidden)]
    pub parameter_constraints: std::option::Option<crate::model::ParameterConstraints>,
}
impl ProvisioningArtifactParameter {
    /// <p>The parameter key.</p>
    pub fn parameter_key(&self) -> std::option::Option<&str> {
        self.parameter_key.as_deref()
    }
    /// <p>The default value.</p>
    pub fn default_value(&self) -> std::option::Option<&str> {
        self.default_value.as_deref()
    }
    /// <p>The parameter type.</p>
    pub fn parameter_type(&self) -> std::option::Option<&str> {
        self.parameter_type.as_deref()
    }
    /// <p>If this value is true, the value for this parameter is obfuscated from view when the parameter is retrieved. This parameter is used to hide sensitive information.</p>
    pub fn is_no_echo(&self) -> bool {
        self.is_no_echo
    }
    /// <p>The description of the parameter.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>Constraints that the administrator has put on a parameter.</p>
    pub fn parameter_constraints(
        &self,
    ) -> std::option::Option<&crate::model::ParameterConstraints> {
        self.parameter_constraints.as_ref()
    }
}
impl ProvisioningArtifactParameter {
    /// Creates a new builder-style object to manufacture [`ProvisioningArtifactParameter`](crate::model::ProvisioningArtifactParameter).
    pub fn builder() -> crate::model::provisioning_artifact_parameter::Builder {
        crate::model::provisioning_artifact_parameter::Builder::default()
    }
}

/// See [`ProvisioningArtifactParameter`](crate::model::ProvisioningArtifactParameter).
pub mod provisioning_artifact_parameter {

    /// A builder for [`ProvisioningArtifactParameter`](crate::model::ProvisioningArtifactParameter).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) parameter_key: std::option::Option<std::string::String>,
        pub(crate) default_value: std::option::Option<std::string::String>,
        pub(crate) parameter_type: std::option::Option<std::string::String>,
        pub(crate) is_no_echo: std::option::Option<bool>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) parameter_constraints: std::option::Option<crate::model::ParameterConstraints>,
    }
    impl Builder {
        /// <p>The parameter key.</p>
        pub fn parameter_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.parameter_key = Some(input.into());
            self
        }
        /// <p>The parameter key.</p>
        pub fn set_parameter_key(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.parameter_key = input;
            self
        }
        /// <p>The default value.</p>
        pub fn default_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.default_value = Some(input.into());
            self
        }
        /// <p>The default value.</p>
        pub fn set_default_value(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.default_value = input;
            self
        }
        /// <p>The parameter type.</p>
        pub fn parameter_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.parameter_type = Some(input.into());
            self
        }
        /// <p>The parameter type.</p>
        pub fn set_parameter_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.parameter_type = input;
            self
        }
        /// <p>If this value is true, the value for this parameter is obfuscated from view when the parameter is retrieved. This parameter is used to hide sensitive information.</p>
        pub fn is_no_echo(mut self, input: bool) -> Self {
            self.is_no_echo = Some(input);
            self
        }
        /// <p>If this value is true, the value for this parameter is obfuscated from view when the parameter is retrieved. This parameter is used to hide sensitive information.</p>
        pub fn set_is_no_echo(mut self, input: std::option::Option<bool>) -> Self {
            self.is_no_echo = input;
            self
        }
        /// <p>The description of the parameter.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the parameter.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>Constraints that the administrator has put on a parameter.</p>
        pub fn parameter_constraints(mut self, input: crate::model::ParameterConstraints) -> Self {
            self.parameter_constraints = Some(input);
            self
        }
        /// <p>Constraints that the administrator has put on a parameter.</p>
        pub fn set_parameter_constraints(
            mut self,
            input: std::option::Option<crate::model::ParameterConstraints>,
        ) -> Self {
            self.parameter_constraints = input;
            self
        }
        /// Consumes the builder and constructs a [`ProvisioningArtifactParameter`](crate::model::ProvisioningArtifactParameter).
        pub fn build(self) -> crate::model::ProvisioningArtifactParameter {
            crate::model::ProvisioningArtifactParameter {
                parameter_key: self.parameter_key,
                default_value: self.default_value,
                parameter_type: self.parameter_type,
                is_no_echo: self.is_no_echo.unwrap_or_default(),
                description: self.description,
                parameter_constraints: self.parameter_constraints,
            }
        }
    }
}

/// <p>The constraints that the administrator has put on the parameter.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ParameterConstraints {
    /// <p>The values that the administrator has allowed for the parameter.</p>
    #[doc(hidden)]
    pub allowed_values: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A regular expression that represents the patterns that allow for <code>String</code> types. The pattern must match the entire parameter value provided.</p>
    #[doc(hidden)]
    pub allowed_pattern: std::option::Option<std::string::String>,
    /// <p>A string that explains a constraint when the constraint is violated. For example, without a constraint description, a parameter that has an allowed pattern of <code>[A-Za-z0-9]+</code> displays the following error message when the user specifies an invalid value:</p>
    /// <p> <code>Malformed input-Parameter MyParameter must match pattern [A-Za-z0-9]+</code> </p>
    /// <p>By adding a constraint description, such as must only contain letters (uppercase and lowercase) and numbers, you can display the following customized error message:</p>
    /// <p> <code>Malformed input-Parameter MyParameter must only contain uppercase and lowercase letters and numbers.</code> </p>
    #[doc(hidden)]
    pub constraint_description: std::option::Option<std::string::String>,
    /// <p>An integer value that determines the largest number of characters you want to allow for <code>String</code> types. </p>
    #[doc(hidden)]
    pub max_length: std::option::Option<std::string::String>,
    /// <p>An integer value that determines the smallest number of characters you want to allow for <code>String</code> types.</p>
    #[doc(hidden)]
    pub min_length: std::option::Option<std::string::String>,
    /// <p>A numeric value that determines the largest numeric value you want to allow for <code>Number</code> types.</p>
    #[doc(hidden)]
    pub max_value: std::option::Option<std::string::String>,
    /// <p>A numeric value that determines the smallest numeric value you want to allow for <code>Number</code> types. </p>
    #[doc(hidden)]
    pub min_value: std::option::Option<std::string::String>,
}
impl ParameterConstraints {
    /// <p>The values that the administrator has allowed for the parameter.</p>
    pub fn allowed_values(&self) -> std::option::Option<&[std::string::String]> {
        self.allowed_values.as_deref()
    }
    /// <p>A regular expression that represents the patterns that allow for <code>String</code> types. The pattern must match the entire parameter value provided.</p>
    pub fn allowed_pattern(&self) -> std::option::Option<&str> {
        self.allowed_pattern.as_deref()
    }
    /// <p>A string that explains a constraint when the constraint is violated. For example, without a constraint description, a parameter that has an allowed pattern of <code>[A-Za-z0-9]+</code> displays the following error message when the user specifies an invalid value:</p>
    /// <p> <code>Malformed input-Parameter MyParameter must match pattern [A-Za-z0-9]+</code> </p>
    /// <p>By adding a constraint description, such as must only contain letters (uppercase and lowercase) and numbers, you can display the following customized error message:</p>
    /// <p> <code>Malformed input-Parameter MyParameter must only contain uppercase and lowercase letters and numbers.</code> </p>
    pub fn constraint_description(&self) -> std::option::Option<&str> {
        self.constraint_description.as_deref()
    }
    /// <p>An integer value that determines the largest number of characters you want to allow for <code>String</code> types. </p>
    pub fn max_length(&self) -> std::option::Option<&str> {
        self.max_length.as_deref()
    }
    /// <p>An integer value that determines the smallest number of characters you want to allow for <code>String</code> types.</p>
    pub fn min_length(&self) -> std::option::Option<&str> {
        self.min_length.as_deref()
    }
    /// <p>A numeric value that determines the largest numeric value you want to allow for <code>Number</code> types.</p>
    pub fn max_value(&self) -> std::option::Option<&str> {
        self.max_value.as_deref()
    }
    /// <p>A numeric value that determines the smallest numeric value you want to allow for <code>Number</code> types. </p>
    pub fn min_value(&self) -> std::option::Option<&str> {
        self.min_value.as_deref()
    }
}
impl ParameterConstraints {
    /// Creates a new builder-style object to manufacture [`ParameterConstraints`](crate::model::ParameterConstraints).
    pub fn builder() -> crate::model::parameter_constraints::Builder {
        crate::model::parameter_constraints::Builder::default()
    }
}

/// See [`ParameterConstraints`](crate::model::ParameterConstraints).
pub mod parameter_constraints {

    /// A builder for [`ParameterConstraints`](crate::model::ParameterConstraints).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) allowed_values: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) allowed_pattern: std::option::Option<std::string::String>,
        pub(crate) constraint_description: std::option::Option<std::string::String>,
        pub(crate) max_length: std::option::Option<std::string::String>,
        pub(crate) min_length: std::option::Option<std::string::String>,
        pub(crate) max_value: std::option::Option<std::string::String>,
        pub(crate) min_value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `allowed_values`.
        ///
        /// To override the contents of this collection use [`set_allowed_values`](Self::set_allowed_values).
        ///
        /// <p>The values that the administrator has allowed for the parameter.</p>
        pub fn allowed_values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.allowed_values.unwrap_or_default();
            v.push(input.into());
            self.allowed_values = Some(v);
            self
        }
        /// <p>The values that the administrator has allowed for the parameter.</p>
        pub fn set_allowed_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.allowed_values = input;
            self
        }
        /// <p>A regular expression that represents the patterns that allow for <code>String</code> types. The pattern must match the entire parameter value provided.</p>
        pub fn allowed_pattern(mut self, input: impl Into<std::string::String>) -> Self {
            self.allowed_pattern = Some(input.into());
            self
        }
        /// <p>A regular expression that represents the patterns that allow for <code>String</code> types. The pattern must match the entire parameter value provided.</p>
        pub fn set_allowed_pattern(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.allowed_pattern = input;
            self
        }
        /// <p>A string that explains a constraint when the constraint is violated. For example, without a constraint description, a parameter that has an allowed pattern of <code>[A-Za-z0-9]+</code> displays the following error message when the user specifies an invalid value:</p>
        /// <p> <code>Malformed input-Parameter MyParameter must match pattern [A-Za-z0-9]+</code> </p>
        /// <p>By adding a constraint description, such as must only contain letters (uppercase and lowercase) and numbers, you can display the following customized error message:</p>
        /// <p> <code>Malformed input-Parameter MyParameter must only contain uppercase and lowercase letters and numbers.</code> </p>
        pub fn constraint_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.constraint_description = Some(input.into());
            self
        }
        /// <p>A string that explains a constraint when the constraint is violated. For example, without a constraint description, a parameter that has an allowed pattern of <code>[A-Za-z0-9]+</code> displays the following error message when the user specifies an invalid value:</p>
        /// <p> <code>Malformed input-Parameter MyParameter must match pattern [A-Za-z0-9]+</code> </p>
        /// <p>By adding a constraint description, such as must only contain letters (uppercase and lowercase) and numbers, you can display the following customized error message:</p>
        /// <p> <code>Malformed input-Parameter MyParameter must only contain uppercase and lowercase letters and numbers.</code> </p>
        pub fn set_constraint_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.constraint_description = input;
            self
        }
        /// <p>An integer value that determines the largest number of characters you want to allow for <code>String</code> types. </p>
        pub fn max_length(mut self, input: impl Into<std::string::String>) -> Self {
            self.max_length = Some(input.into());
            self
        }
        /// <p>An integer value that determines the largest number of characters you want to allow for <code>String</code> types. </p>
        pub fn set_max_length(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.max_length = input;
            self
        }
        /// <p>An integer value that determines the smallest number of characters you want to allow for <code>String</code> types.</p>
        pub fn min_length(mut self, input: impl Into<std::string::String>) -> Self {
            self.min_length = Some(input.into());
            self
        }
        /// <p>An integer value that determines the smallest number of characters you want to allow for <code>String</code> types.</p>
        pub fn set_min_length(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.min_length = input;
            self
        }
        /// <p>A numeric value that determines the largest numeric value you want to allow for <code>Number</code> types.</p>
        pub fn max_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.max_value = Some(input.into());
            self
        }
        /// <p>A numeric value that determines the largest numeric value you want to allow for <code>Number</code> types.</p>
        pub fn set_max_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.max_value = input;
            self
        }
        /// <p>A numeric value that determines the smallest numeric value you want to allow for <code>Number</code> types. </p>
        pub fn min_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.min_value = Some(input.into());
            self
        }
        /// <p>A numeric value that determines the smallest numeric value you want to allow for <code>Number</code> types. </p>
        pub fn set_min_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.min_value = input;
            self
        }
        /// Consumes the builder and constructs a [`ParameterConstraints`](crate::model::ParameterConstraints).
        pub fn build(self) -> crate::model::ParameterConstraints {
            crate::model::ParameterConstraints {
                allowed_values: self.allowed_values,
                allowed_pattern: self.allowed_pattern,
                constraint_description: self.constraint_description,
                max_length: self.max_length,
                min_length: self.min_length,
                max_value: self.max_value,
                min_value: self.min_value,
            }
        }
    }
}

/// <p>Information about a resource change that will occur when a plan is executed.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ResourceChange {
    /// <p>The change action.</p>
    #[doc(hidden)]
    pub action: std::option::Option<crate::model::ChangeAction>,
    /// <p>The ID of the resource, as defined in the CloudFormation template.</p>
    #[doc(hidden)]
    pub logical_resource_id: std::option::Option<std::string::String>,
    /// <p>The ID of the resource, if it was already created.</p>
    #[doc(hidden)]
    pub physical_resource_id: std::option::Option<std::string::String>,
    /// <p>The type of resource.</p>
    #[doc(hidden)]
    pub resource_type: std::option::Option<std::string::String>,
    /// <p>If the change type is <code>Modify</code>, indicates whether the existing resource is deleted and replaced with a new one.</p>
    #[doc(hidden)]
    pub replacement: std::option::Option<crate::model::Replacement>,
    /// <p>The change scope.</p>
    #[doc(hidden)]
    pub scope: std::option::Option<std::vec::Vec<crate::model::ResourceAttribute>>,
    /// <p>Information about the resource changes.</p>
    #[doc(hidden)]
    pub details: std::option::Option<std::vec::Vec<crate::model::ResourceChangeDetail>>,
}
impl ResourceChange {
    /// <p>The change action.</p>
    pub fn action(&self) -> std::option::Option<&crate::model::ChangeAction> {
        self.action.as_ref()
    }
    /// <p>The ID of the resource, as defined in the CloudFormation template.</p>
    pub fn logical_resource_id(&self) -> std::option::Option<&str> {
        self.logical_resource_id.as_deref()
    }
    /// <p>The ID of the resource, if it was already created.</p>
    pub fn physical_resource_id(&self) -> std::option::Option<&str> {
        self.physical_resource_id.as_deref()
    }
    /// <p>The type of resource.</p>
    pub fn resource_type(&self) -> std::option::Option<&str> {
        self.resource_type.as_deref()
    }
    /// <p>If the change type is <code>Modify</code>, indicates whether the existing resource is deleted and replaced with a new one.</p>
    pub fn replacement(&self) -> std::option::Option<&crate::model::Replacement> {
        self.replacement.as_ref()
    }
    /// <p>The change scope.</p>
    pub fn scope(&self) -> std::option::Option<&[crate::model::ResourceAttribute]> {
        self.scope.as_deref()
    }
    /// <p>Information about the resource changes.</p>
    pub fn details(&self) -> std::option::Option<&[crate::model::ResourceChangeDetail]> {
        self.details.as_deref()
    }
}
impl ResourceChange {
    /// Creates a new builder-style object to manufacture [`ResourceChange`](crate::model::ResourceChange).
    pub fn builder() -> crate::model::resource_change::Builder {
        crate::model::resource_change::Builder::default()
    }
}

/// See [`ResourceChange`](crate::model::ResourceChange).
pub mod resource_change {

    /// A builder for [`ResourceChange`](crate::model::ResourceChange).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) action: std::option::Option<crate::model::ChangeAction>,
        pub(crate) logical_resource_id: std::option::Option<std::string::String>,
        pub(crate) physical_resource_id: std::option::Option<std::string::String>,
        pub(crate) resource_type: std::option::Option<std::string::String>,
        pub(crate) replacement: std::option::Option<crate::model::Replacement>,
        pub(crate) scope: std::option::Option<std::vec::Vec<crate::model::ResourceAttribute>>,
        pub(crate) details: std::option::Option<std::vec::Vec<crate::model::ResourceChangeDetail>>,
    }
    impl Builder {
        /// <p>The change action.</p>
        pub fn action(mut self, input: crate::model::ChangeAction) -> Self {
            self.action = Some(input);
            self
        }
        /// <p>The change action.</p>
        pub fn set_action(
            mut self,
            input: std::option::Option<crate::model::ChangeAction>,
        ) -> Self {
            self.action = input;
            self
        }
        /// <p>The ID of the resource, as defined in the CloudFormation template.</p>
        pub fn logical_resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.logical_resource_id = Some(input.into());
            self
        }
        /// <p>The ID of the resource, as defined in the CloudFormation template.</p>
        pub fn set_logical_resource_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.logical_resource_id = input;
            self
        }
        /// <p>The ID of the resource, if it was already created.</p>
        pub fn physical_resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.physical_resource_id = Some(input.into());
            self
        }
        /// <p>The ID of the resource, if it was already created.</p>
        pub fn set_physical_resource_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.physical_resource_id = input;
            self
        }
        /// <p>The type of resource.</p>
        pub fn resource_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_type = Some(input.into());
            self
        }
        /// <p>The type of resource.</p>
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// <p>If the change type is <code>Modify</code>, indicates whether the existing resource is deleted and replaced with a new one.</p>
        pub fn replacement(mut self, input: crate::model::Replacement) -> Self {
            self.replacement = Some(input);
            self
        }
        /// <p>If the change type is <code>Modify</code>, indicates whether the existing resource is deleted and replaced with a new one.</p>
        pub fn set_replacement(
            mut self,
            input: std::option::Option<crate::model::Replacement>,
        ) -> Self {
            self.replacement = input;
            self
        }
        /// Appends an item to `scope`.
        ///
        /// To override the contents of this collection use [`set_scope`](Self::set_scope).
        ///
        /// <p>The change scope.</p>
        pub fn scope(mut self, input: crate::model::ResourceAttribute) -> Self {
            let mut v = self.scope.unwrap_or_default();
            v.push(input);
            self.scope = Some(v);
            self
        }
        /// <p>The change scope.</p>
        pub fn set_scope(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ResourceAttribute>>,
        ) -> Self {
            self.scope = input;
            self
        }
        /// Appends an item to `details`.
        ///
        /// To override the contents of this collection use [`set_details`](Self::set_details).
        ///
        /// <p>Information about the resource changes.</p>
        pub fn details(mut self, input: crate::model::ResourceChangeDetail) -> Self {
            let mut v = self.details.unwrap_or_default();
            v.push(input);
            self.details = Some(v);
            self
        }
        /// <p>Information about the resource changes.</p>
        pub fn set_details(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ResourceChangeDetail>>,
        ) -> Self {
            self.details = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceChange`](crate::model::ResourceChange).
        pub fn build(self) -> crate::model::ResourceChange {
            crate::model::ResourceChange {
                action: self.action,
                logical_resource_id: self.logical_resource_id,
                physical_resource_id: self.physical_resource_id,
                resource_type: self.resource_type,
                replacement: self.replacement,
                scope: self.scope,
                details: self.details,
            }
        }
    }
}

/// <p>Information about a change to a resource attribute.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ResourceChangeDetail {
    /// <p>Information about the resource attribute to be modified.</p>
    #[doc(hidden)]
    pub target: std::option::Option<crate::model::ResourceTargetDefinition>,
    /// <p>For static evaluations, the value of the resource attribute will change and the new value is known. For dynamic evaluations, the value might change, and any new value will be determined when the plan is updated.</p>
    #[doc(hidden)]
    pub evaluation: std::option::Option<crate::model::EvaluationType>,
    /// <p>The ID of the entity that caused the change.</p>
    #[doc(hidden)]
    pub causing_entity: std::option::Option<std::string::String>,
}
impl ResourceChangeDetail {
    /// <p>Information about the resource attribute to be modified.</p>
    pub fn target(&self) -> std::option::Option<&crate::model::ResourceTargetDefinition> {
        self.target.as_ref()
    }
    /// <p>For static evaluations, the value of the resource attribute will change and the new value is known. For dynamic evaluations, the value might change, and any new value will be determined when the plan is updated.</p>
    pub fn evaluation(&self) -> std::option::Option<&crate::model::EvaluationType> {
        self.evaluation.as_ref()
    }
    /// <p>The ID of the entity that caused the change.</p>
    pub fn causing_entity(&self) -> std::option::Option<&str> {
        self.causing_entity.as_deref()
    }
}
impl ResourceChangeDetail {
    /// Creates a new builder-style object to manufacture [`ResourceChangeDetail`](crate::model::ResourceChangeDetail).
    pub fn builder() -> crate::model::resource_change_detail::Builder {
        crate::model::resource_change_detail::Builder::default()
    }
}

/// See [`ResourceChangeDetail`](crate::model::ResourceChangeDetail).
pub mod resource_change_detail {

    /// A builder for [`ResourceChangeDetail`](crate::model::ResourceChangeDetail).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) target: std::option::Option<crate::model::ResourceTargetDefinition>,
        pub(crate) evaluation: std::option::Option<crate::model::EvaluationType>,
        pub(crate) causing_entity: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Information about the resource attribute to be modified.</p>
        pub fn target(mut self, input: crate::model::ResourceTargetDefinition) -> Self {
            self.target = Some(input);
            self
        }
        /// <p>Information about the resource attribute to be modified.</p>
        pub fn set_target(
            mut self,
            input: std::option::Option<crate::model::ResourceTargetDefinition>,
        ) -> Self {
            self.target = input;
            self
        }
        /// <p>For static evaluations, the value of the resource attribute will change and the new value is known. For dynamic evaluations, the value might change, and any new value will be determined when the plan is updated.</p>
        pub fn evaluation(mut self, input: crate::model::EvaluationType) -> Self {
            self.evaluation = Some(input);
            self
        }
        /// <p>For static evaluations, the value of the resource attribute will change and the new value is known. For dynamic evaluations, the value might change, and any new value will be determined when the plan is updated.</p>
        pub fn set_evaluation(
            mut self,
            input: std::option::Option<crate::model::EvaluationType>,
        ) -> Self {
            self.evaluation = input;
            self
        }
        /// <p>The ID of the entity that caused the change.</p>
        pub fn causing_entity(mut self, input: impl Into<std::string::String>) -> Self {
            self.causing_entity = Some(input.into());
            self
        }
        /// <p>The ID of the entity that caused the change.</p>
        pub fn set_causing_entity(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.causing_entity = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceChangeDetail`](crate::model::ResourceChangeDetail).
        pub fn build(self) -> crate::model::ResourceChangeDetail {
            crate::model::ResourceChangeDetail {
                target: self.target,
                evaluation: self.evaluation,
                causing_entity: self.causing_entity,
            }
        }
    }
}

/// When writing a match expression against `EvaluationType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let evaluationtype = unimplemented!();
/// match evaluationtype {
///     EvaluationType::Dynamic => { /* ... */ },
///     EvaluationType::Static => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `evaluationtype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `EvaluationType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `EvaluationType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `EvaluationType::NewFeature` is defined.
/// Specifically, when `evaluationtype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `EvaluationType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum EvaluationType {
    #[allow(missing_docs)] // documentation missing in model
    Dynamic,
    #[allow(missing_docs)] // documentation missing in model
    Static,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for EvaluationType {
    fn from(s: &str) -> Self {
        match s {
            "DYNAMIC" => EvaluationType::Dynamic,
            "STATIC" => EvaluationType::Static,
            other => EvaluationType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for EvaluationType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(EvaluationType::from(s))
    }
}
impl EvaluationType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            EvaluationType::Dynamic => "DYNAMIC",
            EvaluationType::Static => "STATIC",
            EvaluationType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DYNAMIC", "STATIC"]
    }
}
impl AsRef<str> for EvaluationType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about a change to a resource attribute.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ResourceTargetDefinition {
    /// <p>The attribute to be changed.</p>
    #[doc(hidden)]
    pub attribute: std::option::Option<crate::model::ResourceAttribute>,
    /// <p>If the attribute is <code>Properties</code>, the value is the name of the property. Otherwise, the value is null.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>If the attribute is <code>Properties</code>, indicates whether a change to this property causes the resource to be re-created.</p>
    #[doc(hidden)]
    pub requires_recreation: std::option::Option<crate::model::RequiresRecreation>,
}
impl ResourceTargetDefinition {
    /// <p>The attribute to be changed.</p>
    pub fn attribute(&self) -> std::option::Option<&crate::model::ResourceAttribute> {
        self.attribute.as_ref()
    }
    /// <p>If the attribute is <code>Properties</code>, the value is the name of the property. Otherwise, the value is null.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>If the attribute is <code>Properties</code>, indicates whether a change to this property causes the resource to be re-created.</p>
    pub fn requires_recreation(&self) -> std::option::Option<&crate::model::RequiresRecreation> {
        self.requires_recreation.as_ref()
    }
}
impl ResourceTargetDefinition {
    /// Creates a new builder-style object to manufacture [`ResourceTargetDefinition`](crate::model::ResourceTargetDefinition).
    pub fn builder() -> crate::model::resource_target_definition::Builder {
        crate::model::resource_target_definition::Builder::default()
    }
}

/// See [`ResourceTargetDefinition`](crate::model::ResourceTargetDefinition).
pub mod resource_target_definition {

    /// A builder for [`ResourceTargetDefinition`](crate::model::ResourceTargetDefinition).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attribute: std::option::Option<crate::model::ResourceAttribute>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) requires_recreation: std::option::Option<crate::model::RequiresRecreation>,
    }
    impl Builder {
        /// <p>The attribute to be changed.</p>
        pub fn attribute(mut self, input: crate::model::ResourceAttribute) -> Self {
            self.attribute = Some(input);
            self
        }
        /// <p>The attribute to be changed.</p>
        pub fn set_attribute(
            mut self,
            input: std::option::Option<crate::model::ResourceAttribute>,
        ) -> Self {
            self.attribute = input;
            self
        }
        /// <p>If the attribute is <code>Properties</code>, the value is the name of the property. Otherwise, the value is null.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>If the attribute is <code>Properties</code>, the value is the name of the property. Otherwise, the value is null.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>If the attribute is <code>Properties</code>, indicates whether a change to this property causes the resource to be re-created.</p>
        pub fn requires_recreation(mut self, input: crate::model::RequiresRecreation) -> Self {
            self.requires_recreation = Some(input);
            self
        }
        /// <p>If the attribute is <code>Properties</code>, indicates whether a change to this property causes the resource to be re-created.</p>
        pub fn set_requires_recreation(
            mut self,
            input: std::option::Option<crate::model::RequiresRecreation>,
        ) -> Self {
            self.requires_recreation = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceTargetDefinition`](crate::model::ResourceTargetDefinition).
        pub fn build(self) -> crate::model::ResourceTargetDefinition {
            crate::model::ResourceTargetDefinition {
                attribute: self.attribute,
                name: self.name,
                requires_recreation: self.requires_recreation,
            }
        }
    }
}

/// When writing a match expression against `RequiresRecreation`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let requiresrecreation = unimplemented!();
/// match requiresrecreation {
///     RequiresRecreation::Always => { /* ... */ },
///     RequiresRecreation::Conditionally => { /* ... */ },
///     RequiresRecreation::Never => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `requiresrecreation` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `RequiresRecreation::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `RequiresRecreation::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `RequiresRecreation::NewFeature` is defined.
/// Specifically, when `requiresrecreation` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `RequiresRecreation::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RequiresRecreation {
    #[allow(missing_docs)] // documentation missing in model
    Always,
    #[allow(missing_docs)] // documentation missing in model
    Conditionally,
    #[allow(missing_docs)] // documentation missing in model
    Never,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for RequiresRecreation {
    fn from(s: &str) -> Self {
        match s {
            "ALWAYS" => RequiresRecreation::Always,
            "CONDITIONALLY" => RequiresRecreation::Conditionally,
            "NEVER" => RequiresRecreation::Never,
            other => {
                RequiresRecreation::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for RequiresRecreation {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RequiresRecreation::from(s))
    }
}
impl RequiresRecreation {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            RequiresRecreation::Always => "ALWAYS",
            RequiresRecreation::Conditionally => "CONDITIONALLY",
            RequiresRecreation::Never => "NEVER",
            RequiresRecreation::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ALWAYS", "CONDITIONALLY", "NEVER"]
    }
}
impl AsRef<str> for RequiresRecreation {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ResourceAttribute`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let resourceattribute = unimplemented!();
/// match resourceattribute {
///     ResourceAttribute::Creationpolicy => { /* ... */ },
///     ResourceAttribute::Deletionpolicy => { /* ... */ },
///     ResourceAttribute::Metadata => { /* ... */ },
///     ResourceAttribute::Properties => { /* ... */ },
///     ResourceAttribute::Tags => { /* ... */ },
///     ResourceAttribute::Updatepolicy => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `resourceattribute` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ResourceAttribute::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ResourceAttribute::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ResourceAttribute::NewFeature` is defined.
/// Specifically, when `resourceattribute` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ResourceAttribute::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ResourceAttribute {
    #[allow(missing_docs)] // documentation missing in model
    Creationpolicy,
    #[allow(missing_docs)] // documentation missing in model
    Deletionpolicy,
    #[allow(missing_docs)] // documentation missing in model
    Metadata,
    #[allow(missing_docs)] // documentation missing in model
    Properties,
    #[allow(missing_docs)] // documentation missing in model
    Tags,
    #[allow(missing_docs)] // documentation missing in model
    Updatepolicy,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ResourceAttribute {
    fn from(s: &str) -> Self {
        match s {
            "CREATIONPOLICY" => ResourceAttribute::Creationpolicy,
            "DELETIONPOLICY" => ResourceAttribute::Deletionpolicy,
            "METADATA" => ResourceAttribute::Metadata,
            "PROPERTIES" => ResourceAttribute::Properties,
            "TAGS" => ResourceAttribute::Tags,
            "UPDATEPOLICY" => ResourceAttribute::Updatepolicy,
            other => {
                ResourceAttribute::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for ResourceAttribute {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ResourceAttribute::from(s))
    }
}
impl ResourceAttribute {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ResourceAttribute::Creationpolicy => "CREATIONPOLICY",
            ResourceAttribute::Deletionpolicy => "DELETIONPOLICY",
            ResourceAttribute::Metadata => "METADATA",
            ResourceAttribute::Properties => "PROPERTIES",
            ResourceAttribute::Tags => "TAGS",
            ResourceAttribute::Updatepolicy => "UPDATEPOLICY",
            ResourceAttribute::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CREATIONPOLICY",
            "DELETIONPOLICY",
            "METADATA",
            "PROPERTIES",
            "TAGS",
            "UPDATEPOLICY",
        ]
    }
}
impl AsRef<str> for ResourceAttribute {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `Replacement`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let replacement = unimplemented!();
/// match replacement {
///     Replacement::Conditional => { /* ... */ },
///     Replacement::False => { /* ... */ },
///     Replacement::True => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `replacement` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Replacement::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Replacement::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Replacement::NewFeature` is defined.
/// Specifically, when `replacement` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Replacement::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Replacement {
    #[allow(missing_docs)] // documentation missing in model
    Conditional,
    #[allow(missing_docs)] // documentation missing in model
    False,
    #[allow(missing_docs)] // documentation missing in model
    True,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Replacement {
    fn from(s: &str) -> Self {
        match s {
            "CONDITIONAL" => Replacement::Conditional,
            "FALSE" => Replacement::False,
            "TRUE" => Replacement::True,
            other => Replacement::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Replacement {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Replacement::from(s))
    }
}
impl Replacement {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Replacement::Conditional => "CONDITIONAL",
            Replacement::False => "FALSE",
            Replacement::True => "TRUE",
            Replacement::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CONDITIONAL", "FALSE", "TRUE"]
    }
}
impl AsRef<str> for Replacement {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ChangeAction`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let changeaction = unimplemented!();
/// match changeaction {
///     ChangeAction::Add => { /* ... */ },
///     ChangeAction::Modify => { /* ... */ },
///     ChangeAction::Remove => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `changeaction` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ChangeAction::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ChangeAction::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ChangeAction::NewFeature` is defined.
/// Specifically, when `changeaction` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ChangeAction::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ChangeAction {
    #[allow(missing_docs)] // documentation missing in model
    Add,
    #[allow(missing_docs)] // documentation missing in model
    Modify,
    #[allow(missing_docs)] // documentation missing in model
    Remove,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ChangeAction {
    fn from(s: &str) -> Self {
        match s {
            "ADD" => ChangeAction::Add,
            "MODIFY" => ChangeAction::Modify,
            "REMOVE" => ChangeAction::Remove,
            other => ChangeAction::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ChangeAction {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ChangeAction::from(s))
    }
}
impl ChangeAction {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ChangeAction::Add => "ADD",
            ChangeAction::Modify => "MODIFY",
            ChangeAction::Remove => "REMOVE",
            ChangeAction::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ADD", "MODIFY", "REMOVE"]
    }
}
impl AsRef<str> for ChangeAction {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about a plan.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ProvisionedProductPlanDetails {
    /// <p>The UTC time stamp of the creation time.</p>
    #[doc(hidden)]
    pub created_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The path identifier of the product. This value is optional if the product has a default path, and required if the product has more than one path. To list the paths for a product, use <code>ListLaunchPaths</code>.</p>
    #[doc(hidden)]
    pub path_id: std::option::Option<std::string::String>,
    /// <p>The product identifier.</p>
    #[doc(hidden)]
    pub product_id: std::option::Option<std::string::String>,
    /// <p>The name of the plan.</p>
    #[doc(hidden)]
    pub plan_name: std::option::Option<std::string::String>,
    /// <p>The plan identifier.</p>
    #[doc(hidden)]
    pub plan_id: std::option::Option<std::string::String>,
    /// <p>The product identifier.</p>
    #[doc(hidden)]
    pub provision_product_id: std::option::Option<std::string::String>,
    /// <p>The user-friendly name of the provisioned product.</p>
    #[doc(hidden)]
    pub provision_product_name: std::option::Option<std::string::String>,
    /// <p>The plan type.</p>
    #[doc(hidden)]
    pub plan_type: std::option::Option<crate::model::ProvisionedProductPlanType>,
    /// <p>The identifier of the provisioning artifact.</p>
    #[doc(hidden)]
    pub provisioning_artifact_id: std::option::Option<std::string::String>,
    /// <p>The status.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::ProvisionedProductPlanStatus>,
    /// <p>The UTC time stamp when the plan was last updated.</p>
    #[doc(hidden)]
    pub updated_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Passed to CloudFormation. The SNS topic ARNs to which to publish stack-related events.</p>
    #[doc(hidden)]
    pub notification_arns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Parameters specified by the administrator that are required for provisioning the product.</p>
    #[doc(hidden)]
    pub provisioning_parameters:
        std::option::Option<std::vec::Vec<crate::model::UpdateProvisioningParameter>>,
    /// <p>One or more tags.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>The status message.</p>
    #[doc(hidden)]
    pub status_message: std::option::Option<std::string::String>,
}
impl ProvisionedProductPlanDetails {
    /// <p>The UTC time stamp of the creation time.</p>
    pub fn created_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_time.as_ref()
    }
    /// <p>The path identifier of the product. This value is optional if the product has a default path, and required if the product has more than one path. To list the paths for a product, use <code>ListLaunchPaths</code>.</p>
    pub fn path_id(&self) -> std::option::Option<&str> {
        self.path_id.as_deref()
    }
    /// <p>The product identifier.</p>
    pub fn product_id(&self) -> std::option::Option<&str> {
        self.product_id.as_deref()
    }
    /// <p>The name of the plan.</p>
    pub fn plan_name(&self) -> std::option::Option<&str> {
        self.plan_name.as_deref()
    }
    /// <p>The plan identifier.</p>
    pub fn plan_id(&self) -> std::option::Option<&str> {
        self.plan_id.as_deref()
    }
    /// <p>The product identifier.</p>
    pub fn provision_product_id(&self) -> std::option::Option<&str> {
        self.provision_product_id.as_deref()
    }
    /// <p>The user-friendly name of the provisioned product.</p>
    pub fn provision_product_name(&self) -> std::option::Option<&str> {
        self.provision_product_name.as_deref()
    }
    /// <p>The plan type.</p>
    pub fn plan_type(&self) -> std::option::Option<&crate::model::ProvisionedProductPlanType> {
        self.plan_type.as_ref()
    }
    /// <p>The identifier of the provisioning artifact.</p>
    pub fn provisioning_artifact_id(&self) -> std::option::Option<&str> {
        self.provisioning_artifact_id.as_deref()
    }
    /// <p>The status.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::ProvisionedProductPlanStatus> {
        self.status.as_ref()
    }
    /// <p>The UTC time stamp when the plan was last updated.</p>
    pub fn updated_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.updated_time.as_ref()
    }
    /// <p>Passed to CloudFormation. The SNS topic ARNs to which to publish stack-related events.</p>
    pub fn notification_arns(&self) -> std::option::Option<&[std::string::String]> {
        self.notification_arns.as_deref()
    }
    /// <p>Parameters specified by the administrator that are required for provisioning the product.</p>
    pub fn provisioning_parameters(
        &self,
    ) -> std::option::Option<&[crate::model::UpdateProvisioningParameter]> {
        self.provisioning_parameters.as_deref()
    }
    /// <p>One or more tags.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
    /// <p>The status message.</p>
    pub fn status_message(&self) -> std::option::Option<&str> {
        self.status_message.as_deref()
    }
}
impl ProvisionedProductPlanDetails {
    /// Creates a new builder-style object to manufacture [`ProvisionedProductPlanDetails`](crate::model::ProvisionedProductPlanDetails).
    pub fn builder() -> crate::model::provisioned_product_plan_details::Builder {
        crate::model::provisioned_product_plan_details::Builder::default()
    }
}

/// See [`ProvisionedProductPlanDetails`](crate::model::ProvisionedProductPlanDetails).
pub mod provisioned_product_plan_details {

    /// A builder for [`ProvisionedProductPlanDetails`](crate::model::ProvisionedProductPlanDetails).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) created_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) path_id: std::option::Option<std::string::String>,
        pub(crate) product_id: std::option::Option<std::string::String>,
        pub(crate) plan_name: std::option::Option<std::string::String>,
        pub(crate) plan_id: std::option::Option<std::string::String>,
        pub(crate) provision_product_id: std::option::Option<std::string::String>,
        pub(crate) provision_product_name: std::option::Option<std::string::String>,
        pub(crate) plan_type: std::option::Option<crate::model::ProvisionedProductPlanType>,
        pub(crate) provisioning_artifact_id: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::ProvisionedProductPlanStatus>,
        pub(crate) updated_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) notification_arns: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) provisioning_parameters:
            std::option::Option<std::vec::Vec<crate::model::UpdateProvisioningParameter>>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) status_message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The UTC time stamp of the creation time.</p>
        pub fn created_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_time = Some(input);
            self
        }
        /// <p>The UTC time stamp of the creation time.</p>
        pub fn set_created_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_time = input;
            self
        }
        /// <p>The path identifier of the product. This value is optional if the product has a default path, and required if the product has more than one path. To list the paths for a product, use <code>ListLaunchPaths</code>.</p>
        pub fn path_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.path_id = Some(input.into());
            self
        }
        /// <p>The path identifier of the product. This value is optional if the product has a default path, and required if the product has more than one path. To list the paths for a product, use <code>ListLaunchPaths</code>.</p>
        pub fn set_path_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.path_id = input;
            self
        }
        /// <p>The product identifier.</p>
        pub fn product_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.product_id = Some(input.into());
            self
        }
        /// <p>The product identifier.</p>
        pub fn set_product_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.product_id = input;
            self
        }
        /// <p>The name of the plan.</p>
        pub fn plan_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.plan_name = Some(input.into());
            self
        }
        /// <p>The name of the plan.</p>
        pub fn set_plan_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.plan_name = input;
            self
        }
        /// <p>The plan identifier.</p>
        pub fn plan_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.plan_id = Some(input.into());
            self
        }
        /// <p>The plan identifier.</p>
        pub fn set_plan_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.plan_id = input;
            self
        }
        /// <p>The product identifier.</p>
        pub fn provision_product_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.provision_product_id = Some(input.into());
            self
        }
        /// <p>The product identifier.</p>
        pub fn set_provision_product_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.provision_product_id = input;
            self
        }
        /// <p>The user-friendly name of the provisioned product.</p>
        pub fn provision_product_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.provision_product_name = Some(input.into());
            self
        }
        /// <p>The user-friendly name of the provisioned product.</p>
        pub fn set_provision_product_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.provision_product_name = input;
            self
        }
        /// <p>The plan type.</p>
        pub fn plan_type(mut self, input: crate::model::ProvisionedProductPlanType) -> Self {
            self.plan_type = Some(input);
            self
        }
        /// <p>The plan type.</p>
        pub fn set_plan_type(
            mut self,
            input: std::option::Option<crate::model::ProvisionedProductPlanType>,
        ) -> Self {
            self.plan_type = input;
            self
        }
        /// <p>The identifier of the provisioning artifact.</p>
        pub fn provisioning_artifact_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.provisioning_artifact_id = Some(input.into());
            self
        }
        /// <p>The identifier of the provisioning artifact.</p>
        pub fn set_provisioning_artifact_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.provisioning_artifact_id = input;
            self
        }
        /// <p>The status.</p>
        pub fn status(mut self, input: crate::model::ProvisionedProductPlanStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ProvisionedProductPlanStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The UTC time stamp when the plan was last updated.</p>
        pub fn updated_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.updated_time = Some(input);
            self
        }
        /// <p>The UTC time stamp when the plan was last updated.</p>
        pub fn set_updated_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.updated_time = input;
            self
        }
        /// Appends an item to `notification_arns`.
        ///
        /// To override the contents of this collection use [`set_notification_arns`](Self::set_notification_arns).
        ///
        /// <p>Passed to CloudFormation. The SNS topic ARNs to which to publish stack-related events.</p>
        pub fn notification_arns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.notification_arns.unwrap_or_default();
            v.push(input.into());
            self.notification_arns = Some(v);
            self
        }
        /// <p>Passed to CloudFormation. The SNS topic ARNs to which to publish stack-related events.</p>
        pub fn set_notification_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.notification_arns = input;
            self
        }
        /// Appends an item to `provisioning_parameters`.
        ///
        /// To override the contents of this collection use [`set_provisioning_parameters`](Self::set_provisioning_parameters).
        ///
        /// <p>Parameters specified by the administrator that are required for provisioning the product.</p>
        pub fn provisioning_parameters(
            mut self,
            input: crate::model::UpdateProvisioningParameter,
        ) -> Self {
            let mut v = self.provisioning_parameters.unwrap_or_default();
            v.push(input);
            self.provisioning_parameters = Some(v);
            self
        }
        /// <p>Parameters specified by the administrator that are required for provisioning the product.</p>
        pub fn set_provisioning_parameters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::UpdateProvisioningParameter>>,
        ) -> Self {
            self.provisioning_parameters = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>One or more tags.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>One or more tags.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The status message.</p>
        pub fn status_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_message = Some(input.into());
            self
        }
        /// <p>The status message.</p>
        pub fn set_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_message = input;
            self
        }
        /// Consumes the builder and constructs a [`ProvisionedProductPlanDetails`](crate::model::ProvisionedProductPlanDetails).
        pub fn build(self) -> crate::model::ProvisionedProductPlanDetails {
            crate::model::ProvisionedProductPlanDetails {
                created_time: self.created_time,
                path_id: self.path_id,
                product_id: self.product_id,
                plan_name: self.plan_name,
                plan_id: self.plan_id,
                provision_product_id: self.provision_product_id,
                provision_product_name: self.provision_product_name,
                plan_type: self.plan_type,
                provisioning_artifact_id: self.provisioning_artifact_id,
                status: self.status,
                updated_time: self.updated_time,
                notification_arns: self.notification_arns,
                provisioning_parameters: self.provisioning_parameters,
                tags: self.tags,
                status_message: self.status_message,
            }
        }
    }
}

/// When writing a match expression against `ProvisionedProductPlanStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let provisionedproductplanstatus = unimplemented!();
/// match provisionedproductplanstatus {
///     ProvisionedProductPlanStatus::CreateFailed => { /* ... */ },
///     ProvisionedProductPlanStatus::CreateInProgress => { /* ... */ },
///     ProvisionedProductPlanStatus::CreateSuccess => { /* ... */ },
///     ProvisionedProductPlanStatus::ExecuteFailed => { /* ... */ },
///     ProvisionedProductPlanStatus::ExecuteInProgress => { /* ... */ },
///     ProvisionedProductPlanStatus::ExecuteSuccess => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `provisionedproductplanstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ProvisionedProductPlanStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ProvisionedProductPlanStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ProvisionedProductPlanStatus::NewFeature` is defined.
/// Specifically, when `provisionedproductplanstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ProvisionedProductPlanStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ProvisionedProductPlanStatus {
    #[allow(missing_docs)] // documentation missing in model
    CreateFailed,
    #[allow(missing_docs)] // documentation missing in model
    CreateInProgress,
    #[allow(missing_docs)] // documentation missing in model
    CreateSuccess,
    #[allow(missing_docs)] // documentation missing in model
    ExecuteFailed,
    #[allow(missing_docs)] // documentation missing in model
    ExecuteInProgress,
    #[allow(missing_docs)] // documentation missing in model
    ExecuteSuccess,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ProvisionedProductPlanStatus {
    fn from(s: &str) -> Self {
        match s {
            "CREATE_FAILED" => ProvisionedProductPlanStatus::CreateFailed,
            "CREATE_IN_PROGRESS" => ProvisionedProductPlanStatus::CreateInProgress,
            "CREATE_SUCCESS" => ProvisionedProductPlanStatus::CreateSuccess,
            "EXECUTE_FAILED" => ProvisionedProductPlanStatus::ExecuteFailed,
            "EXECUTE_IN_PROGRESS" => ProvisionedProductPlanStatus::ExecuteInProgress,
            "EXECUTE_SUCCESS" => ProvisionedProductPlanStatus::ExecuteSuccess,
            other => ProvisionedProductPlanStatus::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for ProvisionedProductPlanStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ProvisionedProductPlanStatus::from(s))
    }
}
impl ProvisionedProductPlanStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ProvisionedProductPlanStatus::CreateFailed => "CREATE_FAILED",
            ProvisionedProductPlanStatus::CreateInProgress => "CREATE_IN_PROGRESS",
            ProvisionedProductPlanStatus::CreateSuccess => "CREATE_SUCCESS",
            ProvisionedProductPlanStatus::ExecuteFailed => "EXECUTE_FAILED",
            ProvisionedProductPlanStatus::ExecuteInProgress => "EXECUTE_IN_PROGRESS",
            ProvisionedProductPlanStatus::ExecuteSuccess => "EXECUTE_SUCCESS",
            ProvisionedProductPlanStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CREATE_FAILED",
            "CREATE_IN_PROGRESS",
            "CREATE_SUCCESS",
            "EXECUTE_FAILED",
            "EXECUTE_IN_PROGRESS",
            "EXECUTE_SUCCESS",
        ]
    }
}
impl AsRef<str> for ProvisionedProductPlanStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about a CloudWatch dashboard.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CloudWatchDashboard {
    /// <p>The name of the CloudWatch dashboard.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
}
impl CloudWatchDashboard {
    /// <p>The name of the CloudWatch dashboard.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
}
impl CloudWatchDashboard {
    /// Creates a new builder-style object to manufacture [`CloudWatchDashboard`](crate::model::CloudWatchDashboard).
    pub fn builder() -> crate::model::cloud_watch_dashboard::Builder {
        crate::model::cloud_watch_dashboard::Builder::default()
    }
}

/// See [`CloudWatchDashboard`](crate::model::CloudWatchDashboard).
pub mod cloud_watch_dashboard {

    /// A builder for [`CloudWatchDashboard`](crate::model::CloudWatchDashboard).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the CloudWatch dashboard.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the CloudWatch dashboard.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`CloudWatchDashboard`](crate::model::CloudWatchDashboard).
        pub fn build(self) -> crate::model::CloudWatchDashboard {
            crate::model::CloudWatchDashboard { name: self.name }
        }
    }
}

/// <p>Summary information about a provisioning artifact (also known as a version) for a product.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ProvisioningArtifactSummary {
    /// <p>The identifier of the provisioning artifact.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The name of the provisioning artifact.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The description of the provisioning artifact.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The UTC time stamp of the creation time.</p>
    #[doc(hidden)]
    pub created_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The metadata for the provisioning artifact. This is used with Amazon Web Services Marketplace products.</p>
    #[doc(hidden)]
    pub provisioning_artifact_metadata:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl ProvisioningArtifactSummary {
    /// <p>The identifier of the provisioning artifact.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The name of the provisioning artifact.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The description of the provisioning artifact.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The UTC time stamp of the creation time.</p>
    pub fn created_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_time.as_ref()
    }
    /// <p>The metadata for the provisioning artifact. This is used with Amazon Web Services Marketplace products.</p>
    pub fn provisioning_artifact_metadata(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.provisioning_artifact_metadata.as_ref()
    }
}
impl ProvisioningArtifactSummary {
    /// Creates a new builder-style object to manufacture [`ProvisioningArtifactSummary`](crate::model::ProvisioningArtifactSummary).
    pub fn builder() -> crate::model::provisioning_artifact_summary::Builder {
        crate::model::provisioning_artifact_summary::Builder::default()
    }
}

/// See [`ProvisioningArtifactSummary`](crate::model::ProvisioningArtifactSummary).
pub mod provisioning_artifact_summary {

    /// A builder for [`ProvisioningArtifactSummary`](crate::model::ProvisioningArtifactSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) created_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) provisioning_artifact_metadata: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The identifier of the provisioning artifact.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of the provisioning artifact.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The name of the provisioning artifact.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the provisioning artifact.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The description of the provisioning artifact.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the provisioning artifact.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The UTC time stamp of the creation time.</p>
        pub fn created_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_time = Some(input);
            self
        }
        /// <p>The UTC time stamp of the creation time.</p>
        pub fn set_created_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_time = input;
            self
        }
        /// Adds a key-value pair to `provisioning_artifact_metadata`.
        ///
        /// To override the contents of this collection use [`set_provisioning_artifact_metadata`](Self::set_provisioning_artifact_metadata).
        ///
        /// <p>The metadata for the provisioning artifact. This is used with Amazon Web Services Marketplace products.</p>
        pub fn provisioning_artifact_metadata(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.provisioning_artifact_metadata.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.provisioning_artifact_metadata = Some(hash_map);
            self
        }
        /// <p>The metadata for the provisioning artifact. This is used with Amazon Web Services Marketplace products.</p>
        pub fn set_provisioning_artifact_metadata(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.provisioning_artifact_metadata = input;
            self
        }
        /// Consumes the builder and constructs a [`ProvisioningArtifactSummary`](crate::model::ProvisioningArtifactSummary).
        pub fn build(self) -> crate::model::ProvisioningArtifactSummary {
            crate::model::ProvisioningArtifactSummary {
                id: self.id,
                name: self.name,
                description: self.description,
                created_time: self.created_time,
                provisioning_artifact_metadata: self.provisioning_artifact_metadata,
            }
        }
    }
}

/// <p>A launch path object.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LaunchPath {
    /// <p>The identifier of the launch path.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The name of the launch path.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
}
impl LaunchPath {
    /// <p>The identifier of the launch path.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The name of the launch path.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
}
impl LaunchPath {
    /// Creates a new builder-style object to manufacture [`LaunchPath`](crate::model::LaunchPath).
    pub fn builder() -> crate::model::launch_path::Builder {
        crate::model::launch_path::Builder::default()
    }
}

/// See [`LaunchPath`](crate::model::LaunchPath).
pub mod launch_path {

    /// A builder for [`LaunchPath`](crate::model::LaunchPath).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the launch path.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of the launch path.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The name of the launch path.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the launch path.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`LaunchPath`](crate::model::LaunchPath).
        pub fn build(self) -> crate::model::LaunchPath {
            crate::model::LaunchPath {
                id: self.id,
                name: self.name,
            }
        }
    }
}

/// <p>Information about the portfolio share operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ShareDetails {
    /// <p>List of accounts for whom the operation succeeded.</p>
    #[doc(hidden)]
    pub successful_shares: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>List of errors.</p>
    #[doc(hidden)]
    pub share_errors: std::option::Option<std::vec::Vec<crate::model::ShareError>>,
}
impl ShareDetails {
    /// <p>List of accounts for whom the operation succeeded.</p>
    pub fn successful_shares(&self) -> std::option::Option<&[std::string::String]> {
        self.successful_shares.as_deref()
    }
    /// <p>List of errors.</p>
    pub fn share_errors(&self) -> std::option::Option<&[crate::model::ShareError]> {
        self.share_errors.as_deref()
    }
}
impl ShareDetails {
    /// Creates a new builder-style object to manufacture [`ShareDetails`](crate::model::ShareDetails).
    pub fn builder() -> crate::model::share_details::Builder {
        crate::model::share_details::Builder::default()
    }
}

/// See [`ShareDetails`](crate::model::ShareDetails).
pub mod share_details {

    /// A builder for [`ShareDetails`](crate::model::ShareDetails).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) successful_shares: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) share_errors: std::option::Option<std::vec::Vec<crate::model::ShareError>>,
    }
    impl Builder {
        /// Appends an item to `successful_shares`.
        ///
        /// To override the contents of this collection use [`set_successful_shares`](Self::set_successful_shares).
        ///
        /// <p>List of accounts for whom the operation succeeded.</p>
        pub fn successful_shares(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.successful_shares.unwrap_or_default();
            v.push(input.into());
            self.successful_shares = Some(v);
            self
        }
        /// <p>List of accounts for whom the operation succeeded.</p>
        pub fn set_successful_shares(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.successful_shares = input;
            self
        }
        /// Appends an item to `share_errors`.
        ///
        /// To override the contents of this collection use [`set_share_errors`](Self::set_share_errors).
        ///
        /// <p>List of errors.</p>
        pub fn share_errors(mut self, input: crate::model::ShareError) -> Self {
            let mut v = self.share_errors.unwrap_or_default();
            v.push(input);
            self.share_errors = Some(v);
            self
        }
        /// <p>List of errors.</p>
        pub fn set_share_errors(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ShareError>>,
        ) -> Self {
            self.share_errors = input;
            self
        }
        /// Consumes the builder and constructs a [`ShareDetails`](crate::model::ShareDetails).
        pub fn build(self) -> crate::model::ShareDetails {
            crate::model::ShareDetails {
                successful_shares: self.successful_shares,
                share_errors: self.share_errors,
            }
        }
    }
}

/// <p>Errors that occurred during the portfolio share operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ShareError {
    /// <p>List of accounts impacted by the error.</p>
    #[doc(hidden)]
    pub accounts: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Information about the error.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>Error type that happened when processing the operation.</p>
    #[doc(hidden)]
    pub error: std::option::Option<std::string::String>,
}
impl ShareError {
    /// <p>List of accounts impacted by the error.</p>
    pub fn accounts(&self) -> std::option::Option<&[std::string::String]> {
        self.accounts.as_deref()
    }
    /// <p>Information about the error.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
    /// <p>Error type that happened when processing the operation.</p>
    pub fn error(&self) -> std::option::Option<&str> {
        self.error.as_deref()
    }
}
impl ShareError {
    /// Creates a new builder-style object to manufacture [`ShareError`](crate::model::ShareError).
    pub fn builder() -> crate::model::share_error::Builder {
        crate::model::share_error::Builder::default()
    }
}

/// See [`ShareError`](crate::model::ShareError).
pub mod share_error {

    /// A builder for [`ShareError`](crate::model::ShareError).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) accounts: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) error: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `accounts`.
        ///
        /// To override the contents of this collection use [`set_accounts`](Self::set_accounts).
        ///
        /// <p>List of accounts impacted by the error.</p>
        pub fn accounts(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.accounts.unwrap_or_default();
            v.push(input.into());
            self.accounts = Some(v);
            self
        }
        /// <p>List of accounts impacted by the error.</p>
        pub fn set_accounts(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.accounts = input;
            self
        }
        /// <p>Information about the error.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Information about the error.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>Error type that happened when processing the operation.</p>
        pub fn error(mut self, input: impl Into<std::string::String>) -> Self {
            self.error = Some(input.into());
            self
        }
        /// <p>Error type that happened when processing the operation.</p>
        pub fn set_error(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.error = input;
            self
        }
        /// Consumes the builder and constructs a [`ShareError`](crate::model::ShareError).
        pub fn build(self) -> crate::model::ShareError {
            crate::model::ShareError {
                accounts: self.accounts,
                message: self.message,
                error: self.error,
            }
        }
    }
}

/// <p>Information about the portfolio share.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PortfolioShareDetail {
    /// <p>The identifier of the recipient entity that received the portfolio share. The recipient entity can be one of the following:</p>
    /// <p>1. An external account.</p>
    /// <p>2. An organziation member account.</p>
    /// <p>3. An organzational unit (OU).</p>
    /// <p>4. The organization itself. (This shares with every account in the organization).</p>
    #[doc(hidden)]
    pub principal_id: std::option::Option<std::string::String>,
    /// <p>The type of the portfolio share.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::DescribePortfolioShareType>,
    /// <p>Indicates whether the shared portfolio is imported by the recipient account. If the recipient is in an organization node, the share is automatically imported, and the field is always set to true.</p>
    #[doc(hidden)]
    pub accepted: bool,
    /// <p>Indicates whether TagOptions sharing is enabled or disabled for the portfolio share.</p>
    #[doc(hidden)]
    pub share_tag_options: bool,
    /// <p>Indicates if <code>Principal</code> sharing is enabled or disabled for the portfolio share. </p>
    #[doc(hidden)]
    pub share_principals: bool,
}
impl PortfolioShareDetail {
    /// <p>The identifier of the recipient entity that received the portfolio share. The recipient entity can be one of the following:</p>
    /// <p>1. An external account.</p>
    /// <p>2. An organziation member account.</p>
    /// <p>3. An organzational unit (OU).</p>
    /// <p>4. The organization itself. (This shares with every account in the organization).</p>
    pub fn principal_id(&self) -> std::option::Option<&str> {
        self.principal_id.as_deref()
    }
    /// <p>The type of the portfolio share.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::DescribePortfolioShareType> {
        self.r#type.as_ref()
    }
    /// <p>Indicates whether the shared portfolio is imported by the recipient account. If the recipient is in an organization node, the share is automatically imported, and the field is always set to true.</p>
    pub fn accepted(&self) -> bool {
        self.accepted
    }
    /// <p>Indicates whether TagOptions sharing is enabled or disabled for the portfolio share.</p>
    pub fn share_tag_options(&self) -> bool {
        self.share_tag_options
    }
    /// <p>Indicates if <code>Principal</code> sharing is enabled or disabled for the portfolio share. </p>
    pub fn share_principals(&self) -> bool {
        self.share_principals
    }
}
impl PortfolioShareDetail {
    /// Creates a new builder-style object to manufacture [`PortfolioShareDetail`](crate::model::PortfolioShareDetail).
    pub fn builder() -> crate::model::portfolio_share_detail::Builder {
        crate::model::portfolio_share_detail::Builder::default()
    }
}

/// See [`PortfolioShareDetail`](crate::model::PortfolioShareDetail).
pub mod portfolio_share_detail {

    /// A builder for [`PortfolioShareDetail`](crate::model::PortfolioShareDetail).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) principal_id: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::DescribePortfolioShareType>,
        pub(crate) accepted: std::option::Option<bool>,
        pub(crate) share_tag_options: std::option::Option<bool>,
        pub(crate) share_principals: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The identifier of the recipient entity that received the portfolio share. The recipient entity can be one of the following:</p>
        /// <p>1. An external account.</p>
        /// <p>2. An organziation member account.</p>
        /// <p>3. An organzational unit (OU).</p>
        /// <p>4. The organization itself. (This shares with every account in the organization).</p>
        pub fn principal_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.principal_id = Some(input.into());
            self
        }
        /// <p>The identifier of the recipient entity that received the portfolio share. The recipient entity can be one of the following:</p>
        /// <p>1. An external account.</p>
        /// <p>2. An organziation member account.</p>
        /// <p>3. An organzational unit (OU).</p>
        /// <p>4. The organization itself. (This shares with every account in the organization).</p>
        pub fn set_principal_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.principal_id = input;
            self
        }
        /// <p>The type of the portfolio share.</p>
        pub fn r#type(mut self, input: crate::model::DescribePortfolioShareType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of the portfolio share.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::DescribePortfolioShareType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>Indicates whether the shared portfolio is imported by the recipient account. If the recipient is in an organization node, the share is automatically imported, and the field is always set to true.</p>
        pub fn accepted(mut self, input: bool) -> Self {
            self.accepted = Some(input);
            self
        }
        /// <p>Indicates whether the shared portfolio is imported by the recipient account. If the recipient is in an organization node, the share is automatically imported, and the field is always set to true.</p>
        pub fn set_accepted(mut self, input: std::option::Option<bool>) -> Self {
            self.accepted = input;
            self
        }
        /// <p>Indicates whether TagOptions sharing is enabled or disabled for the portfolio share.</p>
        pub fn share_tag_options(mut self, input: bool) -> Self {
            self.share_tag_options = Some(input);
            self
        }
        /// <p>Indicates whether TagOptions sharing is enabled or disabled for the portfolio share.</p>
        pub fn set_share_tag_options(mut self, input: std::option::Option<bool>) -> Self {
            self.share_tag_options = input;
            self
        }
        /// <p>Indicates if <code>Principal</code> sharing is enabled or disabled for the portfolio share. </p>
        pub fn share_principals(mut self, input: bool) -> Self {
            self.share_principals = Some(input);
            self
        }
        /// <p>Indicates if <code>Principal</code> sharing is enabled or disabled for the portfolio share. </p>
        pub fn set_share_principals(mut self, input: std::option::Option<bool>) -> Self {
            self.share_principals = input;
            self
        }
        /// Consumes the builder and constructs a [`PortfolioShareDetail`](crate::model::PortfolioShareDetail).
        pub fn build(self) -> crate::model::PortfolioShareDetail {
            crate::model::PortfolioShareDetail {
                principal_id: self.principal_id,
                r#type: self.r#type,
                accepted: self.accepted.unwrap_or_default(),
                share_tag_options: self.share_tag_options.unwrap_or_default(),
                share_principals: self.share_principals.unwrap_or_default(),
            }
        }
    }
}

/// When writing a match expression against `DescribePortfolioShareType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let describeportfoliosharetype = unimplemented!();
/// match describeportfoliosharetype {
///     DescribePortfolioShareType::Account => { /* ... */ },
///     DescribePortfolioShareType::Organization => { /* ... */ },
///     DescribePortfolioShareType::OrganizationalUnit => { /* ... */ },
///     DescribePortfolioShareType::OrganizationMemberAccount => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `describeportfoliosharetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DescribePortfolioShareType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DescribePortfolioShareType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DescribePortfolioShareType::NewFeature` is defined.
/// Specifically, when `describeportfoliosharetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DescribePortfolioShareType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DescribePortfolioShareType {
    #[allow(missing_docs)] // documentation missing in model
    Account,
    #[allow(missing_docs)] // documentation missing in model
    Organization,
    #[allow(missing_docs)] // documentation missing in model
    OrganizationalUnit,
    #[allow(missing_docs)] // documentation missing in model
    OrganizationMemberAccount,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DescribePortfolioShareType {
    fn from(s: &str) -> Self {
        match s {
            "ACCOUNT" => DescribePortfolioShareType::Account,
            "ORGANIZATION" => DescribePortfolioShareType::Organization,
            "ORGANIZATIONAL_UNIT" => DescribePortfolioShareType::OrganizationalUnit,
            "ORGANIZATION_MEMBER_ACCOUNT" => DescribePortfolioShareType::OrganizationMemberAccount,
            other => DescribePortfolioShareType::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for DescribePortfolioShareType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DescribePortfolioShareType::from(s))
    }
}
impl DescribePortfolioShareType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DescribePortfolioShareType::Account => "ACCOUNT",
            DescribePortfolioShareType::Organization => "ORGANIZATION",
            DescribePortfolioShareType::OrganizationalUnit => "ORGANIZATIONAL_UNIT",
            DescribePortfolioShareType::OrganizationMemberAccount => "ORGANIZATION_MEMBER_ACCOUNT",
            DescribePortfolioShareType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ACCOUNT",
            "ORGANIZATION",
            "ORGANIZATIONAL_UNIT",
            "ORGANIZATION_MEMBER_ACCOUNT",
        ]
    }
}
impl AsRef<str> for DescribePortfolioShareType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `CopyProductStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let copyproductstatus = unimplemented!();
/// match copyproductstatus {
///     CopyProductStatus::Failed => { /* ... */ },
///     CopyProductStatus::InProgress => { /* ... */ },
///     CopyProductStatus::Succeeded => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `copyproductstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `CopyProductStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `CopyProductStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `CopyProductStatus::NewFeature` is defined.
/// Specifically, when `copyproductstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `CopyProductStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CopyProductStatus {
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    #[allow(missing_docs)] // documentation missing in model
    Succeeded,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for CopyProductStatus {
    fn from(s: &str) -> Self {
        match s {
            "FAILED" => CopyProductStatus::Failed,
            "IN_PROGRESS" => CopyProductStatus::InProgress,
            "SUCCEEDED" => CopyProductStatus::Succeeded,
            other => {
                CopyProductStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for CopyProductStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CopyProductStatus::from(s))
    }
}
impl CopyProductStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            CopyProductStatus::Failed => "FAILED",
            CopyProductStatus::InProgress => "IN_PROGRESS",
            CopyProductStatus::Succeeded => "SUCCEEDED",
            CopyProductStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["FAILED", "IN_PROGRESS", "SUCCEEDED"]
    }
}
impl AsRef<str> for CopyProductStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about a provisioning artifact (also known as a version) for a product.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ProvisioningArtifactProperties {
    /// <p>The name of the provisioning artifact (for example, v1 v2beta). No spaces are allowed.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The description of the provisioning artifact, including how it differs from the previous provisioning artifact.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>Specify the template source with one of the following options, but not both. Keys accepted: [ <code>LoadTemplateFromURL</code>, <code>ImportFromPhysicalId</code> ]</p>
    /// <p>The URL of the CloudFormation template in Amazon S3 or GitHub in JSON format. Specify the URL in JSON format as follows:</p>
    /// <p> <code>"LoadTemplateFromURL": "https://s3.amazonaws.com/cf-templates-ozkq9d3hgiq2-us-east-1/..."</code> </p>
    /// <p> <code>ImportFromPhysicalId</code>: The physical id of the resource that contains the template. Currently only supports CloudFormation stack arn. Specify the physical id in JSON format as follows: <code>ImportFromPhysicalId: “arn:aws:cloudformation:[us-east-1]:[accountId]:stack/[StackName]/[resourceId]</code> </p>
    #[doc(hidden)]
    pub info:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The type of provisioning artifact.</p>
    /// <ul>
    /// <li> <p> <code>CLOUD_FORMATION_TEMPLATE</code> - CloudFormation template</p> </li>
    /// <li> <p> <code>MARKETPLACE_AMI</code> - Amazon Web Services Marketplace AMI</p> </li>
    /// <li> <p> <code>MARKETPLACE_CAR</code> - Amazon Web Services Marketplace Clusters and Amazon Web Services Resources</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::ProvisioningArtifactType>,
    /// <p>If set to true, Service Catalog stops validating the specified provisioning artifact even if it is invalid.</p>
    #[doc(hidden)]
    pub disable_template_validation: bool,
}
impl ProvisioningArtifactProperties {
    /// <p>The name of the provisioning artifact (for example, v1 v2beta). No spaces are allowed.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The description of the provisioning artifact, including how it differs from the previous provisioning artifact.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>Specify the template source with one of the following options, but not both. Keys accepted: [ <code>LoadTemplateFromURL</code>, <code>ImportFromPhysicalId</code> ]</p>
    /// <p>The URL of the CloudFormation template in Amazon S3 or GitHub in JSON format. Specify the URL in JSON format as follows:</p>
    /// <p> <code>"LoadTemplateFromURL": "https://s3.amazonaws.com/cf-templates-ozkq9d3hgiq2-us-east-1/..."</code> </p>
    /// <p> <code>ImportFromPhysicalId</code>: The physical id of the resource that contains the template. Currently only supports CloudFormation stack arn. Specify the physical id in JSON format as follows: <code>ImportFromPhysicalId: “arn:aws:cloudformation:[us-east-1]:[accountId]:stack/[StackName]/[resourceId]</code> </p>
    pub fn info(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.info.as_ref()
    }
    /// <p>The type of provisioning artifact.</p>
    /// <ul>
    /// <li> <p> <code>CLOUD_FORMATION_TEMPLATE</code> - CloudFormation template</p> </li>
    /// <li> <p> <code>MARKETPLACE_AMI</code> - Amazon Web Services Marketplace AMI</p> </li>
    /// <li> <p> <code>MARKETPLACE_CAR</code> - Amazon Web Services Marketplace Clusters and Amazon Web Services Resources</p> </li>
    /// </ul>
    pub fn r#type(&self) -> std::option::Option<&crate::model::ProvisioningArtifactType> {
        self.r#type.as_ref()
    }
    /// <p>If set to true, Service Catalog stops validating the specified provisioning artifact even if it is invalid.</p>
    pub fn disable_template_validation(&self) -> bool {
        self.disable_template_validation
    }
}
impl ProvisioningArtifactProperties {
    /// Creates a new builder-style object to manufacture [`ProvisioningArtifactProperties`](crate::model::ProvisioningArtifactProperties).
    pub fn builder() -> crate::model::provisioning_artifact_properties::Builder {
        crate::model::provisioning_artifact_properties::Builder::default()
    }
}

/// See [`ProvisioningArtifactProperties`](crate::model::ProvisioningArtifactProperties).
pub mod provisioning_artifact_properties {

    /// A builder for [`ProvisioningArtifactProperties`](crate::model::ProvisioningArtifactProperties).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) info: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) r#type: std::option::Option<crate::model::ProvisioningArtifactType>,
        pub(crate) disable_template_validation: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The name of the provisioning artifact (for example, v1 v2beta). No spaces are allowed.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the provisioning artifact (for example, v1 v2beta). No spaces are allowed.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The description of the provisioning artifact, including how it differs from the previous provisioning artifact.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the provisioning artifact, including how it differs from the previous provisioning artifact.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Adds a key-value pair to `info`.
        ///
        /// To override the contents of this collection use [`set_info`](Self::set_info).
        ///
        /// <p>Specify the template source with one of the following options, but not both. Keys accepted: [ <code>LoadTemplateFromURL</code>, <code>ImportFromPhysicalId</code> ]</p>
        /// <p>The URL of the CloudFormation template in Amazon S3 or GitHub in JSON format. Specify the URL in JSON format as follows:</p>
        /// <p> <code>"LoadTemplateFromURL": "https://s3.amazonaws.com/cf-templates-ozkq9d3hgiq2-us-east-1/..."</code> </p>
        /// <p> <code>ImportFromPhysicalId</code>: The physical id of the resource that contains the template. Currently only supports CloudFormation stack arn. Specify the physical id in JSON format as follows: <code>ImportFromPhysicalId: “arn:aws:cloudformation:[us-east-1]:[accountId]:stack/[StackName]/[resourceId]</code> </p>
        pub fn info(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.info.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.info = Some(hash_map);
            self
        }
        /// <p>Specify the template source with one of the following options, but not both. Keys accepted: [ <code>LoadTemplateFromURL</code>, <code>ImportFromPhysicalId</code> ]</p>
        /// <p>The URL of the CloudFormation template in Amazon S3 or GitHub in JSON format. Specify the URL in JSON format as follows:</p>
        /// <p> <code>"LoadTemplateFromURL": "https://s3.amazonaws.com/cf-templates-ozkq9d3hgiq2-us-east-1/..."</code> </p>
        /// <p> <code>ImportFromPhysicalId</code>: The physical id of the resource that contains the template. Currently only supports CloudFormation stack arn. Specify the physical id in JSON format as follows: <code>ImportFromPhysicalId: “arn:aws:cloudformation:[us-east-1]:[accountId]:stack/[StackName]/[resourceId]</code> </p>
        pub fn set_info(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.info = input;
            self
        }
        /// <p>The type of provisioning artifact.</p>
        /// <ul>
        /// <li> <p> <code>CLOUD_FORMATION_TEMPLATE</code> - CloudFormation template</p> </li>
        /// <li> <p> <code>MARKETPLACE_AMI</code> - Amazon Web Services Marketplace AMI</p> </li>
        /// <li> <p> <code>MARKETPLACE_CAR</code> - Amazon Web Services Marketplace Clusters and Amazon Web Services Resources</p> </li>
        /// </ul>
        pub fn r#type(mut self, input: crate::model::ProvisioningArtifactType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of provisioning artifact.</p>
        /// <ul>
        /// <li> <p> <code>CLOUD_FORMATION_TEMPLATE</code> - CloudFormation template</p> </li>
        /// <li> <p> <code>MARKETPLACE_AMI</code> - Amazon Web Services Marketplace AMI</p> </li>
        /// <li> <p> <code>MARKETPLACE_CAR</code> - Amazon Web Services Marketplace Clusters and Amazon Web Services Resources</p> </li>
        /// </ul>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::ProvisioningArtifactType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>If set to true, Service Catalog stops validating the specified provisioning artifact even if it is invalid.</p>
        pub fn disable_template_validation(mut self, input: bool) -> Self {
            self.disable_template_validation = Some(input);
            self
        }
        /// <p>If set to true, Service Catalog stops validating the specified provisioning artifact even if it is invalid.</p>
        pub fn set_disable_template_validation(mut self, input: std::option::Option<bool>) -> Self {
            self.disable_template_validation = input;
            self
        }
        /// Consumes the builder and constructs a [`ProvisioningArtifactProperties`](crate::model::ProvisioningArtifactProperties).
        pub fn build(self) -> crate::model::ProvisioningArtifactProperties {
            crate::model::ProvisioningArtifactProperties {
                name: self.name,
                description: self.description,
                info: self.info,
                r#type: self.r#type,
                disable_template_validation: self.disable_template_validation.unwrap_or_default(),
            }
        }
    }
}

/// When writing a match expression against `CopyOption`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let copyoption = unimplemented!();
/// match copyoption {
///     CopyOption::CopyTags => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `copyoption` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `CopyOption::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `CopyOption::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `CopyOption::NewFeature` is defined.
/// Specifically, when `copyoption` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `CopyOption::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CopyOption {
    #[allow(missing_docs)] // documentation missing in model
    CopyTags,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for CopyOption {
    fn from(s: &str) -> Self {
        match s {
            "CopyTags" => CopyOption::CopyTags,
            other => CopyOption::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for CopyOption {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CopyOption::from(s))
    }
}
impl CopyOption {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            CopyOption::CopyTags => "CopyTags",
            CopyOption::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CopyTags"]
    }
}
impl AsRef<str> for CopyOption {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ProvisioningArtifactPropertyName`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let provisioningartifactpropertyname = unimplemented!();
/// match provisioningartifactpropertyname {
///     ProvisioningArtifactPropertyName::Id => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `provisioningartifactpropertyname` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ProvisioningArtifactPropertyName::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ProvisioningArtifactPropertyName::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ProvisioningArtifactPropertyName::NewFeature` is defined.
/// Specifically, when `provisioningartifactpropertyname` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ProvisioningArtifactPropertyName::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ProvisioningArtifactPropertyName {
    #[allow(missing_docs)] // documentation missing in model
    Id,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ProvisioningArtifactPropertyName {
    fn from(s: &str) -> Self {
        match s {
            "Id" => ProvisioningArtifactPropertyName::Id,
            other => ProvisioningArtifactPropertyName::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for ProvisioningArtifactPropertyName {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ProvisioningArtifactPropertyName::from(s))
    }
}
impl ProvisioningArtifactPropertyName {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ProvisioningArtifactPropertyName::Id => "Id",
            ProvisioningArtifactPropertyName::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["Id"]
    }
}
impl AsRef<str> for ProvisioningArtifactPropertyName {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>An object containing information about the error, along with identifying information about the self-service action and its associations.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FailedServiceActionAssociation {
    /// <p>The self-service action identifier. For example, <code>act-fs7abcd89wxyz</code>.</p>
    #[doc(hidden)]
    pub service_action_id: std::option::Option<std::string::String>,
    /// <p>The product identifier. For example, <code>prod-abcdzk7xy33qa</code>.</p>
    #[doc(hidden)]
    pub product_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the provisioning artifact. For example, <code>pa-4abcdjnxjj6ne</code>.</p>
    #[doc(hidden)]
    pub provisioning_artifact_id: std::option::Option<std::string::String>,
    /// <p>The error code. Valid values are listed below.</p>
    #[doc(hidden)]
    pub error_code: std::option::Option<crate::model::ServiceActionAssociationErrorCode>,
    /// <p>A text description of the error.</p>
    #[doc(hidden)]
    pub error_message: std::option::Option<std::string::String>,
}
impl FailedServiceActionAssociation {
    /// <p>The self-service action identifier. For example, <code>act-fs7abcd89wxyz</code>.</p>
    pub fn service_action_id(&self) -> std::option::Option<&str> {
        self.service_action_id.as_deref()
    }
    /// <p>The product identifier. For example, <code>prod-abcdzk7xy33qa</code>.</p>
    pub fn product_id(&self) -> std::option::Option<&str> {
        self.product_id.as_deref()
    }
    /// <p>The identifier of the provisioning artifact. For example, <code>pa-4abcdjnxjj6ne</code>.</p>
    pub fn provisioning_artifact_id(&self) -> std::option::Option<&str> {
        self.provisioning_artifact_id.as_deref()
    }
    /// <p>The error code. Valid values are listed below.</p>
    pub fn error_code(
        &self,
    ) -> std::option::Option<&crate::model::ServiceActionAssociationErrorCode> {
        self.error_code.as_ref()
    }
    /// <p>A text description of the error.</p>
    pub fn error_message(&self) -> std::option::Option<&str> {
        self.error_message.as_deref()
    }
}
impl FailedServiceActionAssociation {
    /// Creates a new builder-style object to manufacture [`FailedServiceActionAssociation`](crate::model::FailedServiceActionAssociation).
    pub fn builder() -> crate::model::failed_service_action_association::Builder {
        crate::model::failed_service_action_association::Builder::default()
    }
}

/// See [`FailedServiceActionAssociation`](crate::model::FailedServiceActionAssociation).
pub mod failed_service_action_association {

    /// A builder for [`FailedServiceActionAssociation`](crate::model::FailedServiceActionAssociation).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) service_action_id: std::option::Option<std::string::String>,
        pub(crate) product_id: std::option::Option<std::string::String>,
        pub(crate) provisioning_artifact_id: std::option::Option<std::string::String>,
        pub(crate) error_code: std::option::Option<crate::model::ServiceActionAssociationErrorCode>,
        pub(crate) error_message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The self-service action identifier. For example, <code>act-fs7abcd89wxyz</code>.</p>
        pub fn service_action_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.service_action_id = Some(input.into());
            self
        }
        /// <p>The self-service action identifier. For example, <code>act-fs7abcd89wxyz</code>.</p>
        pub fn set_service_action_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.service_action_id = input;
            self
        }
        /// <p>The product identifier. For example, <code>prod-abcdzk7xy33qa</code>.</p>
        pub fn product_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.product_id = Some(input.into());
            self
        }
        /// <p>The product identifier. For example, <code>prod-abcdzk7xy33qa</code>.</p>
        pub fn set_product_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.product_id = input;
            self
        }
        /// <p>The identifier of the provisioning artifact. For example, <code>pa-4abcdjnxjj6ne</code>.</p>
        pub fn provisioning_artifact_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.provisioning_artifact_id = Some(input.into());
            self
        }
        /// <p>The identifier of the provisioning artifact. For example, <code>pa-4abcdjnxjj6ne</code>.</p>
        pub fn set_provisioning_artifact_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.provisioning_artifact_id = input;
            self
        }
        /// <p>The error code. Valid values are listed below.</p>
        pub fn error_code(
            mut self,
            input: crate::model::ServiceActionAssociationErrorCode,
        ) -> Self {
            self.error_code = Some(input);
            self
        }
        /// <p>The error code. Valid values are listed below.</p>
        pub fn set_error_code(
            mut self,
            input: std::option::Option<crate::model::ServiceActionAssociationErrorCode>,
        ) -> Self {
            self.error_code = input;
            self
        }
        /// <p>A text description of the error.</p>
        pub fn error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_message = Some(input.into());
            self
        }
        /// <p>A text description of the error.</p>
        pub fn set_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_message = input;
            self
        }
        /// Consumes the builder and constructs a [`FailedServiceActionAssociation`](crate::model::FailedServiceActionAssociation).
        pub fn build(self) -> crate::model::FailedServiceActionAssociation {
            crate::model::FailedServiceActionAssociation {
                service_action_id: self.service_action_id,
                product_id: self.product_id,
                provisioning_artifact_id: self.provisioning_artifact_id,
                error_code: self.error_code,
                error_message: self.error_message,
            }
        }
    }
}

/// When writing a match expression against `ServiceActionAssociationErrorCode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let serviceactionassociationerrorcode = unimplemented!();
/// match serviceactionassociationerrorcode {
///     ServiceActionAssociationErrorCode::DuplicateResourceException => { /* ... */ },
///     ServiceActionAssociationErrorCode::InternalFailure => { /* ... */ },
///     ServiceActionAssociationErrorCode::LimitExceededException => { /* ... */ },
///     ServiceActionAssociationErrorCode::ResourceNotFoundException => { /* ... */ },
///     ServiceActionAssociationErrorCode::ThrottlingException => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `serviceactionassociationerrorcode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ServiceActionAssociationErrorCode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ServiceActionAssociationErrorCode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ServiceActionAssociationErrorCode::NewFeature` is defined.
/// Specifically, when `serviceactionassociationerrorcode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ServiceActionAssociationErrorCode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ServiceActionAssociationErrorCode {
    #[allow(missing_docs)] // documentation missing in model
    DuplicateResourceException,
    #[allow(missing_docs)] // documentation missing in model
    InternalFailure,
    #[allow(missing_docs)] // documentation missing in model
    LimitExceededException,
    #[allow(missing_docs)] // documentation missing in model
    ResourceNotFoundException,
    #[allow(missing_docs)] // documentation missing in model
    ThrottlingException,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ServiceActionAssociationErrorCode {
    fn from(s: &str) -> Self {
        match s {
            "DUPLICATE_RESOURCE" => ServiceActionAssociationErrorCode::DuplicateResourceException,
            "INTERNAL_FAILURE" => ServiceActionAssociationErrorCode::InternalFailure,
            "LIMIT_EXCEEDED" => ServiceActionAssociationErrorCode::LimitExceededException,
            "RESOURCE_NOT_FOUND" => ServiceActionAssociationErrorCode::ResourceNotFoundException,
            "THROTTLING" => ServiceActionAssociationErrorCode::ThrottlingException,
            other => ServiceActionAssociationErrorCode::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for ServiceActionAssociationErrorCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ServiceActionAssociationErrorCode::from(s))
    }
}
impl ServiceActionAssociationErrorCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ServiceActionAssociationErrorCode::DuplicateResourceException => "DUPLICATE_RESOURCE",
            ServiceActionAssociationErrorCode::InternalFailure => "INTERNAL_FAILURE",
            ServiceActionAssociationErrorCode::LimitExceededException => "LIMIT_EXCEEDED",
            ServiceActionAssociationErrorCode::ResourceNotFoundException => "RESOURCE_NOT_FOUND",
            ServiceActionAssociationErrorCode::ThrottlingException => "THROTTLING",
            ServiceActionAssociationErrorCode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "DUPLICATE_RESOURCE",
            "INTERNAL_FAILURE",
            "LIMIT_EXCEEDED",
            "RESOURCE_NOT_FOUND",
            "THROTTLING",
        ]
    }
}
impl AsRef<str> for ServiceActionAssociationErrorCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A self-service action association consisting of the Action ID, the Product ID, and the Provisioning Artifact ID.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ServiceActionAssociation {
    /// <p>The self-service action identifier. For example, <code>act-fs7abcd89wxyz</code>.</p>
    #[doc(hidden)]
    pub service_action_id: std::option::Option<std::string::String>,
    /// <p>The product identifier. For example, <code>prod-abcdzk7xy33qa</code>.</p>
    #[doc(hidden)]
    pub product_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the provisioning artifact. For example, <code>pa-4abcdjnxjj6ne</code>.</p>
    #[doc(hidden)]
    pub provisioning_artifact_id: std::option::Option<std::string::String>,
}
impl ServiceActionAssociation {
    /// <p>The self-service action identifier. For example, <code>act-fs7abcd89wxyz</code>.</p>
    pub fn service_action_id(&self) -> std::option::Option<&str> {
        self.service_action_id.as_deref()
    }
    /// <p>The product identifier. For example, <code>prod-abcdzk7xy33qa</code>.</p>
    pub fn product_id(&self) -> std::option::Option<&str> {
        self.product_id.as_deref()
    }
    /// <p>The identifier of the provisioning artifact. For example, <code>pa-4abcdjnxjj6ne</code>.</p>
    pub fn provisioning_artifact_id(&self) -> std::option::Option<&str> {
        self.provisioning_artifact_id.as_deref()
    }
}
impl ServiceActionAssociation {
    /// Creates a new builder-style object to manufacture [`ServiceActionAssociation`](crate::model::ServiceActionAssociation).
    pub fn builder() -> crate::model::service_action_association::Builder {
        crate::model::service_action_association::Builder::default()
    }
}

/// See [`ServiceActionAssociation`](crate::model::ServiceActionAssociation).
pub mod service_action_association {

    /// A builder for [`ServiceActionAssociation`](crate::model::ServiceActionAssociation).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) service_action_id: std::option::Option<std::string::String>,
        pub(crate) product_id: std::option::Option<std::string::String>,
        pub(crate) provisioning_artifact_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The self-service action identifier. For example, <code>act-fs7abcd89wxyz</code>.</p>
        pub fn service_action_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.service_action_id = Some(input.into());
            self
        }
        /// <p>The self-service action identifier. For example, <code>act-fs7abcd89wxyz</code>.</p>
        pub fn set_service_action_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.service_action_id = input;
            self
        }
        /// <p>The product identifier. For example, <code>prod-abcdzk7xy33qa</code>.</p>
        pub fn product_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.product_id = Some(input.into());
            self
        }
        /// <p>The product identifier. For example, <code>prod-abcdzk7xy33qa</code>.</p>
        pub fn set_product_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.product_id = input;
            self
        }
        /// <p>The identifier of the provisioning artifact. For example, <code>pa-4abcdjnxjj6ne</code>.</p>
        pub fn provisioning_artifact_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.provisioning_artifact_id = Some(input.into());
            self
        }
        /// <p>The identifier of the provisioning artifact. For example, <code>pa-4abcdjnxjj6ne</code>.</p>
        pub fn set_provisioning_artifact_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.provisioning_artifact_id = input;
            self
        }
        /// Consumes the builder and constructs a [`ServiceActionAssociation`](crate::model::ServiceActionAssociation).
        pub fn build(self) -> crate::model::ServiceActionAssociation {
            crate::model::ServiceActionAssociation {
                service_action_id: self.service_action_id,
                product_id: self.product_id,
                provisioning_artifact_id: self.provisioning_artifact_id,
            }
        }
    }
}
