// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub use crate::operation::terminate_provisioned_product::_terminate_provisioned_product_output::TerminateProvisionedProductOutputBuilder;

pub use crate::operation::terminate_provisioned_product::_terminate_provisioned_product_input::TerminateProvisionedProductInputBuilder;

impl TerminateProvisionedProductInputBuilder {
    /// Sends a request with this input using the given client.
    pub async fn send_with(
        self,
        client: &crate::Client,
    ) -> ::std::result::Result<
        crate::operation::terminate_provisioned_product::TerminateProvisionedProductOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::terminate_provisioned_product::TerminateProvisionedProductError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let mut fluent_builder = client.terminate_provisioned_product();
        fluent_builder.inner = self;
        fluent_builder.send().await
    }
}
/// Fluent builder constructing a request to `TerminateProvisionedProduct`.
///
/// <p>Terminates the specified provisioned product.</p>
/// <p>This operation does not delete any records associated with the provisioned product.</p>
/// <p>You can check the status of this request using <code>DescribeRecord</code>.</p>
#[derive(::std::clone::Clone, ::std::fmt::Debug)]
pub struct TerminateProvisionedProductFluentBuilder {
    handle: ::std::sync::Arc<crate::client::Handle>,
    inner: crate::operation::terminate_provisioned_product::builders::TerminateProvisionedProductInputBuilder,
    config_override: ::std::option::Option<crate::config::Builder>,
}
impl
    crate::client::customize::internal::CustomizableSend<
        crate::operation::terminate_provisioned_product::TerminateProvisionedProductOutput,
        crate::operation::terminate_provisioned_product::TerminateProvisionedProductError,
    > for TerminateProvisionedProductFluentBuilder
{
    fn send(
        self,
        config_override: crate::config::Builder,
    ) -> crate::client::customize::internal::BoxFuture<
        crate::client::customize::internal::SendResult<
            crate::operation::terminate_provisioned_product::TerminateProvisionedProductOutput,
            crate::operation::terminate_provisioned_product::TerminateProvisionedProductError,
        >,
    > {
        ::std::boxed::Box::pin(async move { self.config_override(config_override).send().await })
    }
}
impl TerminateProvisionedProductFluentBuilder {
    /// Creates a new `TerminateProvisionedProduct`.
    pub(crate) fn new(handle: ::std::sync::Arc<crate::client::Handle>) -> Self {
        Self {
            handle,
            inner: ::std::default::Default::default(),
            config_override: ::std::option::Option::None,
        }
    }
    /// Access the TerminateProvisionedProduct as a reference.
    pub fn as_input(&self) -> &crate::operation::terminate_provisioned_product::builders::TerminateProvisionedProductInputBuilder {
        &self.inner
    }
    /// Sends the request and returns the response.
    ///
    /// If an error occurs, an `SdkError` will be returned with additional details that
    /// can be matched against.
    ///
    /// By default, any retryable failures will be retried twice. Retry behavior
    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
    /// set when configuring the client.
    pub async fn send(
        self,
    ) -> ::std::result::Result<
        crate::operation::terminate_provisioned_product::TerminateProvisionedProductOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::terminate_provisioned_product::TerminateProvisionedProductError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let input = self
            .inner
            .build()
            .map_err(::aws_smithy_runtime_api::client::result::SdkError::construction_failure)?;
        let runtime_plugins = crate::operation::terminate_provisioned_product::TerminateProvisionedProduct::operation_runtime_plugins(
            self.handle.runtime_plugins.clone(),
            &self.handle.conf,
            self.config_override,
        );
        crate::operation::terminate_provisioned_product::TerminateProvisionedProduct::orchestrate(&runtime_plugins, input).await
    }

    /// Consumes this builder, creating a customizable operation that can be modified before being sent.
    pub fn customize(
        self,
    ) -> crate::client::customize::CustomizableOperation<
        crate::operation::terminate_provisioned_product::TerminateProvisionedProductOutput,
        crate::operation::terminate_provisioned_product::TerminateProvisionedProductError,
        Self,
    > {
        crate::client::customize::CustomizableOperation::new(self)
    }
    pub(crate) fn config_override(mut self, config_override: impl Into<crate::config::Builder>) -> Self {
        self.set_config_override(Some(config_override.into()));
        self
    }

    pub(crate) fn set_config_override(&mut self, config_override: Option<crate::config::Builder>) -> &mut Self {
        self.config_override = config_override;
        self
    }
    /// <p>The name of the provisioned product. You cannot specify both <code>ProvisionedProductName</code> and <code>ProvisionedProductId</code>.</p>
    pub fn provisioned_product_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.provisioned_product_name(input.into());
        self
    }
    /// <p>The name of the provisioned product. You cannot specify both <code>ProvisionedProductName</code> and <code>ProvisionedProductId</code>.</p>
    pub fn set_provisioned_product_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_provisioned_product_name(input);
        self
    }
    /// <p>The name of the provisioned product. You cannot specify both <code>ProvisionedProductName</code> and <code>ProvisionedProductId</code>.</p>
    pub fn get_provisioned_product_name(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_provisioned_product_name()
    }
    /// <p>The identifier of the provisioned product. You cannot specify both <code>ProvisionedProductName</code> and <code>ProvisionedProductId</code>.</p>
    pub fn provisioned_product_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.provisioned_product_id(input.into());
        self
    }
    /// <p>The identifier of the provisioned product. You cannot specify both <code>ProvisionedProductName</code> and <code>ProvisionedProductId</code>.</p>
    pub fn set_provisioned_product_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_provisioned_product_id(input);
        self
    }
    /// <p>The identifier of the provisioned product. You cannot specify both <code>ProvisionedProductName</code> and <code>ProvisionedProductId</code>.</p>
    pub fn get_provisioned_product_id(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_provisioned_product_id()
    }
    /// <p>An idempotency token that uniquely identifies the termination request. This token is only valid during the termination process. After the provisioned product is terminated, subsequent requests to terminate the same provisioned product always return <b>ResourceNotFound</b>.</p>
    pub fn terminate_token(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.terminate_token(input.into());
        self
    }
    /// <p>An idempotency token that uniquely identifies the termination request. This token is only valid during the termination process. After the provisioned product is terminated, subsequent requests to terminate the same provisioned product always return <b>ResourceNotFound</b>.</p>
    pub fn set_terminate_token(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_terminate_token(input);
        self
    }
    /// <p>An idempotency token that uniquely identifies the termination request. This token is only valid during the termination process. After the provisioned product is terminated, subsequent requests to terminate the same provisioned product always return <b>ResourceNotFound</b>.</p>
    pub fn get_terminate_token(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_terminate_token()
    }
    /// <p>If set to true, Service Catalog stops managing the specified provisioned product even if it cannot delete the underlying resources.</p>
    pub fn ignore_errors(mut self, input: bool) -> Self {
        self.inner = self.inner.ignore_errors(input);
        self
    }
    /// <p>If set to true, Service Catalog stops managing the specified provisioned product even if it cannot delete the underlying resources.</p>
    pub fn set_ignore_errors(mut self, input: ::std::option::Option<bool>) -> Self {
        self.inner = self.inner.set_ignore_errors(input);
        self
    }
    /// <p>If set to true, Service Catalog stops managing the specified provisioned product even if it cannot delete the underlying resources.</p>
    pub fn get_ignore_errors(&self) -> &::std::option::Option<bool> {
        self.inner.get_ignore_errors()
    }
    /// <p>The language code.</p>
    /// <ul>
    /// <li>
    /// <p><code>jp</code> - Japanese</p></li>
    /// <li>
    /// <p><code>zh</code> - Chinese</p></li>
    /// </ul>
    pub fn accept_language(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.accept_language(input.into());
        self
    }
    /// <p>The language code.</p>
    /// <ul>
    /// <li>
    /// <p><code>jp</code> - Japanese</p></li>
    /// <li>
    /// <p><code>zh</code> - Chinese</p></li>
    /// </ul>
    pub fn set_accept_language(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_accept_language(input);
        self
    }
    /// <p>The language code.</p>
    /// <ul>
    /// <li>
    /// <p><code>jp</code> - Japanese</p></li>
    /// <li>
    /// <p><code>zh</code> - Chinese</p></li>
    /// </ul>
    pub fn get_accept_language(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_accept_language()
    }
    /// <p>When this boolean parameter is set to true, the <code>TerminateProvisionedProduct</code> API deletes the Service Catalog provisioned product. However, it does not remove the CloudFormation stack, stack set, or the underlying resources of the deleted provisioned product. The default value is false.</p>
    pub fn retain_physical_resources(mut self, input: bool) -> Self {
        self.inner = self.inner.retain_physical_resources(input);
        self
    }
    /// <p>When this boolean parameter is set to true, the <code>TerminateProvisionedProduct</code> API deletes the Service Catalog provisioned product. However, it does not remove the CloudFormation stack, stack set, or the underlying resources of the deleted provisioned product. The default value is false.</p>
    pub fn set_retain_physical_resources(mut self, input: ::std::option::Option<bool>) -> Self {
        self.inner = self.inner.set_retain_physical_resources(input);
        self
    }
    /// <p>When this boolean parameter is set to true, the <code>TerminateProvisionedProduct</code> API deletes the Service Catalog provisioned product. However, it does not remove the CloudFormation stack, stack set, or the underlying resources of the deleted provisioned product. The default value is false.</p>
    pub fn get_retain_physical_resources(&self) -> &::std::option::Option<bool> {
        self.inner.get_retain_physical_resources()
    }
}
