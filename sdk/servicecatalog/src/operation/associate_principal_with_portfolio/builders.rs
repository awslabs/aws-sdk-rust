// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub use crate::operation::associate_principal_with_portfolio::_associate_principal_with_portfolio_output::AssociatePrincipalWithPortfolioOutputBuilder;

pub use crate::operation::associate_principal_with_portfolio::_associate_principal_with_portfolio_input::AssociatePrincipalWithPortfolioInputBuilder;

impl AssociatePrincipalWithPortfolioInputBuilder {
    /// Sends a request with this input using the given client.
    pub async fn send_with(
        self,
        client: &crate::Client,
    ) -> ::std::result::Result<
        crate::operation::associate_principal_with_portfolio::AssociatePrincipalWithPortfolioOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::associate_principal_with_portfolio::AssociatePrincipalWithPortfolioError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let mut fluent_builder = client.associate_principal_with_portfolio();
        fluent_builder.inner = self;
        fluent_builder.send().await
    }
}
/// Fluent builder constructing a request to `AssociatePrincipalWithPortfolio`.
///
/// <p>Associates the specified principal ARN with the specified portfolio.</p>
/// <p>If you share the portfolio with principal name sharing enabled, the <code>PrincipalARN</code> association is included in the share.</p>
/// <p>The <code>PortfolioID</code>, <code>PrincipalARN</code>, and <code>PrincipalType</code> parameters are required.</p>
/// <p>You can associate a maximum of 10 Principals with a portfolio using <code>PrincipalType</code> as <code>IAM_PATTERN</code>.</p><note>
/// <p>When you associate a principal with portfolio, a potential privilege escalation path may occur when that portfolio is then shared with other accounts. For a user in a recipient account who is <i>not</i> an Service Catalog Admin, but still has the ability to create Principals (Users/Groups/Roles), that user could create a role that matches a principal name association for the portfolio. Although this user may not know which principal names are associated through Service Catalog, they may be able to guess the user. If this potential escalation path is a concern, then Service Catalog recommends using <code>PrincipalType</code> as <code>IAM</code>. With this configuration, the <code>PrincipalARN</code> must already exist in the recipient account before it can be associated.</p>
/// </note>
#[derive(::std::clone::Clone, ::std::fmt::Debug)]
pub struct AssociatePrincipalWithPortfolioFluentBuilder {
    handle: ::std::sync::Arc<crate::client::Handle>,
    inner: crate::operation::associate_principal_with_portfolio::builders::AssociatePrincipalWithPortfolioInputBuilder,
    config_override: ::std::option::Option<crate::config::Builder>,
}
impl
    crate::client::customize::internal::CustomizableSend<
        crate::operation::associate_principal_with_portfolio::AssociatePrincipalWithPortfolioOutput,
        crate::operation::associate_principal_with_portfolio::AssociatePrincipalWithPortfolioError,
    > for AssociatePrincipalWithPortfolioFluentBuilder
{
    fn send(
        self,
        config_override: crate::config::Builder,
    ) -> crate::client::customize::internal::BoxFuture<
        crate::client::customize::internal::SendResult<
            crate::operation::associate_principal_with_portfolio::AssociatePrincipalWithPortfolioOutput,
            crate::operation::associate_principal_with_portfolio::AssociatePrincipalWithPortfolioError,
        >,
    > {
        ::std::boxed::Box::pin(async move { self.config_override(config_override).send().await })
    }
}
impl AssociatePrincipalWithPortfolioFluentBuilder {
    /// Creates a new `AssociatePrincipalWithPortfolio`.
    pub(crate) fn new(handle: ::std::sync::Arc<crate::client::Handle>) -> Self {
        Self {
            handle,
            inner: ::std::default::Default::default(),
            config_override: ::std::option::Option::None,
        }
    }
    /// Access the AssociatePrincipalWithPortfolio as a reference.
    pub fn as_input(&self) -> &crate::operation::associate_principal_with_portfolio::builders::AssociatePrincipalWithPortfolioInputBuilder {
        &self.inner
    }
    /// Sends the request and returns the response.
    ///
    /// If an error occurs, an `SdkError` will be returned with additional details that
    /// can be matched against.
    ///
    /// By default, any retryable failures will be retried twice. Retry behavior
    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
    /// set when configuring the client.
    pub async fn send(
        self,
    ) -> ::std::result::Result<
        crate::operation::associate_principal_with_portfolio::AssociatePrincipalWithPortfolioOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::associate_principal_with_portfolio::AssociatePrincipalWithPortfolioError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let input = self
            .inner
            .build()
            .map_err(::aws_smithy_runtime_api::client::result::SdkError::construction_failure)?;
        let runtime_plugins = crate::operation::associate_principal_with_portfolio::AssociatePrincipalWithPortfolio::operation_runtime_plugins(
            self.handle.runtime_plugins.clone(),
            &self.handle.conf,
            self.config_override,
        );
        crate::operation::associate_principal_with_portfolio::AssociatePrincipalWithPortfolio::orchestrate(&runtime_plugins, input).await
    }

    /// Consumes this builder, creating a customizable operation that can be modified before being sent.
    pub fn customize(
        self,
    ) -> crate::client::customize::CustomizableOperation<
        crate::operation::associate_principal_with_portfolio::AssociatePrincipalWithPortfolioOutput,
        crate::operation::associate_principal_with_portfolio::AssociatePrincipalWithPortfolioError,
        Self,
    > {
        crate::client::customize::CustomizableOperation::new(self)
    }
    pub(crate) fn config_override(mut self, config_override: impl Into<crate::config::Builder>) -> Self {
        self.set_config_override(Some(config_override.into()));
        self
    }

    pub(crate) fn set_config_override(&mut self, config_override: Option<crate::config::Builder>) -> &mut Self {
        self.config_override = config_override;
        self
    }
    /// <p>The language code.</p>
    /// <ul>
    /// <li>
    /// <p><code>jp</code> - Japanese</p></li>
    /// <li>
    /// <p><code>zh</code> - Chinese</p></li>
    /// </ul>
    pub fn accept_language(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.accept_language(input.into());
        self
    }
    /// <p>The language code.</p>
    /// <ul>
    /// <li>
    /// <p><code>jp</code> - Japanese</p></li>
    /// <li>
    /// <p><code>zh</code> - Chinese</p></li>
    /// </ul>
    pub fn set_accept_language(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_accept_language(input);
        self
    }
    /// <p>The language code.</p>
    /// <ul>
    /// <li>
    /// <p><code>jp</code> - Japanese</p></li>
    /// <li>
    /// <p><code>zh</code> - Chinese</p></li>
    /// </ul>
    pub fn get_accept_language(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_accept_language()
    }
    /// <p>The portfolio identifier.</p>
    pub fn portfolio_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.portfolio_id(input.into());
        self
    }
    /// <p>The portfolio identifier.</p>
    pub fn set_portfolio_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_portfolio_id(input);
        self
    }
    /// <p>The portfolio identifier.</p>
    pub fn get_portfolio_id(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_portfolio_id()
    }
    /// <p>The ARN of the principal (user, role, or group). If the <code>PrincipalType</code> is <code>IAM</code>, the supported value is a fully defined <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html#identifiers-arns">IAM Amazon Resource Name (ARN)</a>. If the <code>PrincipalType</code> is <code>IAM_PATTERN</code>, the supported value is an <code>IAM</code> ARN <i>without an AccountID</i> in the following format:</p>
    /// <p><i>arn:partition:iam:::resource-type/resource-id</i></p>
    /// <p>The ARN resource-id can be either:</p>
    /// <ul>
    /// <li>
    /// <p>A fully formed resource-id. For example, <i>arn:aws:iam:::role/resource-name</i> or <i>arn:aws:iam:::role/resource-path/resource-name</i></p></li>
    /// <li>
    /// <p>A wildcard ARN. The wildcard ARN accepts <code>IAM_PATTERN</code> values with a "*" or "?" in the resource-id segment of the ARN. For example <i>arn:partition:service:::resource-type/resource-path/resource-name</i>. The new symbols are exclusive to the <b>resource-path</b> and <b>resource-name</b> and cannot replace the <b>resource-type</b> or other ARN values.</p>
    /// <p>The ARN path and principal name allow unlimited wildcard characters.</p></li>
    /// </ul>
    /// <p>Examples of an <b>acceptable</b> wildcard ARN:</p>
    /// <ul>
    /// <li>
    /// <p>arn:aws:iam:::role/ResourceName_*</p></li>
    /// <li>
    /// <p>arn:aws:iam:::role/*/ResourceName_?</p></li>
    /// </ul>
    /// <p>Examples of an <b>unacceptable</b> wildcard ARN:</p>
    /// <ul>
    /// <li>
    /// <p>arn:aws:iam:::*/ResourceName</p></li>
    /// </ul>
    /// <p>You can associate multiple <code>IAM_PATTERN</code>s even if the account has no principal with that name.</p>
    /// <p>The "?" wildcard character matches zero or one of any character. This is similar to ".?" in regular regex context. The "*" wildcard character matches any number of any characters. This is similar to ".*" in regular regex context.</p>
    /// <p>In the IAM Principal ARN format (<i>arn:partition:iam:::resource-type/resource-path/resource-name</i>), valid resource-type values include <b>user/</b>, <b>group/</b>, or <b>role/</b>. The "?" and "*" characters are allowed only after the resource-type in the resource-id segment. You can use special characters anywhere within the resource-id.</p>
    /// <p>The "*" character also matches the "/" character, allowing paths to be formed <i>within</i> the resource-id. For example, <i>arn:aws:iam:::role/<b>*</b>/ResourceName_?</i> matches both <i>arn:aws:iam:::role/pathA/pathB/ResourceName_1</i> and <i>arn:aws:iam:::role/pathA/ResourceName_1</i>.</p>
    pub fn principal_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.principal_arn(input.into());
        self
    }
    /// <p>The ARN of the principal (user, role, or group). If the <code>PrincipalType</code> is <code>IAM</code>, the supported value is a fully defined <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html#identifiers-arns">IAM Amazon Resource Name (ARN)</a>. If the <code>PrincipalType</code> is <code>IAM_PATTERN</code>, the supported value is an <code>IAM</code> ARN <i>without an AccountID</i> in the following format:</p>
    /// <p><i>arn:partition:iam:::resource-type/resource-id</i></p>
    /// <p>The ARN resource-id can be either:</p>
    /// <ul>
    /// <li>
    /// <p>A fully formed resource-id. For example, <i>arn:aws:iam:::role/resource-name</i> or <i>arn:aws:iam:::role/resource-path/resource-name</i></p></li>
    /// <li>
    /// <p>A wildcard ARN. The wildcard ARN accepts <code>IAM_PATTERN</code> values with a "*" or "?" in the resource-id segment of the ARN. For example <i>arn:partition:service:::resource-type/resource-path/resource-name</i>. The new symbols are exclusive to the <b>resource-path</b> and <b>resource-name</b> and cannot replace the <b>resource-type</b> or other ARN values.</p>
    /// <p>The ARN path and principal name allow unlimited wildcard characters.</p></li>
    /// </ul>
    /// <p>Examples of an <b>acceptable</b> wildcard ARN:</p>
    /// <ul>
    /// <li>
    /// <p>arn:aws:iam:::role/ResourceName_*</p></li>
    /// <li>
    /// <p>arn:aws:iam:::role/*/ResourceName_?</p></li>
    /// </ul>
    /// <p>Examples of an <b>unacceptable</b> wildcard ARN:</p>
    /// <ul>
    /// <li>
    /// <p>arn:aws:iam:::*/ResourceName</p></li>
    /// </ul>
    /// <p>You can associate multiple <code>IAM_PATTERN</code>s even if the account has no principal with that name.</p>
    /// <p>The "?" wildcard character matches zero or one of any character. This is similar to ".?" in regular regex context. The "*" wildcard character matches any number of any characters. This is similar to ".*" in regular regex context.</p>
    /// <p>In the IAM Principal ARN format (<i>arn:partition:iam:::resource-type/resource-path/resource-name</i>), valid resource-type values include <b>user/</b>, <b>group/</b>, or <b>role/</b>. The "?" and "*" characters are allowed only after the resource-type in the resource-id segment. You can use special characters anywhere within the resource-id.</p>
    /// <p>The "*" character also matches the "/" character, allowing paths to be formed <i>within</i> the resource-id. For example, <i>arn:aws:iam:::role/<b>*</b>/ResourceName_?</i> matches both <i>arn:aws:iam:::role/pathA/pathB/ResourceName_1</i> and <i>arn:aws:iam:::role/pathA/ResourceName_1</i>.</p>
    pub fn set_principal_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_principal_arn(input);
        self
    }
    /// <p>The ARN of the principal (user, role, or group). If the <code>PrincipalType</code> is <code>IAM</code>, the supported value is a fully defined <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html#identifiers-arns">IAM Amazon Resource Name (ARN)</a>. If the <code>PrincipalType</code> is <code>IAM_PATTERN</code>, the supported value is an <code>IAM</code> ARN <i>without an AccountID</i> in the following format:</p>
    /// <p><i>arn:partition:iam:::resource-type/resource-id</i></p>
    /// <p>The ARN resource-id can be either:</p>
    /// <ul>
    /// <li>
    /// <p>A fully formed resource-id. For example, <i>arn:aws:iam:::role/resource-name</i> or <i>arn:aws:iam:::role/resource-path/resource-name</i></p></li>
    /// <li>
    /// <p>A wildcard ARN. The wildcard ARN accepts <code>IAM_PATTERN</code> values with a "*" or "?" in the resource-id segment of the ARN. For example <i>arn:partition:service:::resource-type/resource-path/resource-name</i>. The new symbols are exclusive to the <b>resource-path</b> and <b>resource-name</b> and cannot replace the <b>resource-type</b> or other ARN values.</p>
    /// <p>The ARN path and principal name allow unlimited wildcard characters.</p></li>
    /// </ul>
    /// <p>Examples of an <b>acceptable</b> wildcard ARN:</p>
    /// <ul>
    /// <li>
    /// <p>arn:aws:iam:::role/ResourceName_*</p></li>
    /// <li>
    /// <p>arn:aws:iam:::role/*/ResourceName_?</p></li>
    /// </ul>
    /// <p>Examples of an <b>unacceptable</b> wildcard ARN:</p>
    /// <ul>
    /// <li>
    /// <p>arn:aws:iam:::*/ResourceName</p></li>
    /// </ul>
    /// <p>You can associate multiple <code>IAM_PATTERN</code>s even if the account has no principal with that name.</p>
    /// <p>The "?" wildcard character matches zero or one of any character. This is similar to ".?" in regular regex context. The "*" wildcard character matches any number of any characters. This is similar to ".*" in regular regex context.</p>
    /// <p>In the IAM Principal ARN format (<i>arn:partition:iam:::resource-type/resource-path/resource-name</i>), valid resource-type values include <b>user/</b>, <b>group/</b>, or <b>role/</b>. The "?" and "*" characters are allowed only after the resource-type in the resource-id segment. You can use special characters anywhere within the resource-id.</p>
    /// <p>The "*" character also matches the "/" character, allowing paths to be formed <i>within</i> the resource-id. For example, <i>arn:aws:iam:::role/<b>*</b>/ResourceName_?</i> matches both <i>arn:aws:iam:::role/pathA/pathB/ResourceName_1</i> and <i>arn:aws:iam:::role/pathA/ResourceName_1</i>.</p>
    pub fn get_principal_arn(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_principal_arn()
    }
    /// <p>The principal type. The supported value is <code>IAM</code> if you use a fully defined Amazon Resource Name (ARN), or <code>IAM_PATTERN</code> if you use an ARN with no <code>accountID</code>, with or without wildcard characters.</p>
    pub fn principal_type(mut self, input: crate::types::PrincipalType) -> Self {
        self.inner = self.inner.principal_type(input);
        self
    }
    /// <p>The principal type. The supported value is <code>IAM</code> if you use a fully defined Amazon Resource Name (ARN), or <code>IAM_PATTERN</code> if you use an ARN with no <code>accountID</code>, with or without wildcard characters.</p>
    pub fn set_principal_type(mut self, input: ::std::option::Option<crate::types::PrincipalType>) -> Self {
        self.inner = self.inner.set_principal_type(input);
        self
    }
    /// <p>The principal type. The supported value is <code>IAM</code> if you use a fully defined Amazon Resource Name (ARN), or <code>IAM_PATTERN</code> if you use an ARN with no <code>accountID</code>, with or without wildcard characters.</p>
    pub fn get_principal_type(&self) -> &::std::option::Option<crate::types::PrincipalType> {
        self.inner.get_principal_type()
    }
}
