// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>For a resource with <code>Modify</code> as the action, the <code>ResourceChange</code> structure describes the changes CloudFormation will make to that resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ResourceChangeDetail {
    /// <p>A <code>ResourceTargetDefinition</code> structure that describes the field that CloudFormation will change and whether the resource will be recreated.</p>
    #[doc(hidden)]
    pub target: std::option::Option<crate::types::ResourceTargetDefinition>,
    /// <p>Indicates whether CloudFormation can determine the target value, and whether the target value will change before you execute a change set.</p>
    /// <p>For <code>Static</code> evaluations, CloudFormation can determine that the target value will change, and its value. For example, if you directly modify the <code>InstanceType</code> property of an EC2 instance, CloudFormation knows that this property value will change, and its value, so this is a <code>Static</code> evaluation.</p>
    /// <p>For <code>Dynamic</code> evaluations, can't determine the target value because it depends on the result of an intrinsic function, such as a <code>Ref</code> or <code>Fn::GetAtt</code> intrinsic function, when the stack is updated. For example, if your template includes a reference to a resource that's conditionally recreated, the value of the reference (the physical ID of the resource) might change, depending on if the resource is recreated. If the resource is recreated, it will have a new physical ID, so all references to that resource will also be updated.</p>
    #[doc(hidden)]
    pub evaluation: std::option::Option<crate::types::EvaluationType>,
    /// <p>The group to which the <code>CausingEntity</code> value belongs. There are five entity groups:</p>
    /// <ul>
    /// <li> <p> <code>ResourceReference</code> entities are <code>Ref</code> intrinsic functions that refer to resources in the template, such as <code>{ "Ref" : "MyEC2InstanceResource" }</code>.</p> </li>
    /// <li> <p> <code>ParameterReference</code> entities are <code>Ref</code> intrinsic functions that get template parameter values, such as <code>{ "Ref" : "MyPasswordParameter" }</code>.</p> </li>
    /// <li> <p> <code>ResourceAttribute</code> entities are <code>Fn::GetAtt</code> intrinsic functions that get resource attribute values, such as <code>{ "Fn::GetAtt" : [ "MyEC2InstanceResource", "PublicDnsName" ] }</code>.</p> </li>
    /// <li> <p> <code>DirectModification</code> entities are changes that are made directly to the template.</p> </li>
    /// <li> <p> <code>Automatic</code> entities are <code>AWS::CloudFormation::Stack</code> resource types, which are also known as nested stacks. If you made no changes to the <code>AWS::CloudFormation::Stack</code> resource, CloudFormation sets the <code>ChangeSource</code> to <code>Automatic</code> because the nested stack's template might have changed. Changes to a nested stack's template aren't visible to CloudFormation until you run an update on the parent stack.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub change_source: std::option::Option<crate::types::ChangeSource>,
    /// <p>The identity of the entity that triggered this change. This entity is a member of the group that's specified by the <code>ChangeSource</code> field. For example, if you modified the value of the <code>KeyPairName</code> parameter, the <code>CausingEntity</code> is the name of the parameter (<code>KeyPairName</code>).</p>
    /// <p>If the <code>ChangeSource</code> value is <code>DirectModification</code>, no value is given for <code>CausingEntity</code>.</p>
    #[doc(hidden)]
    pub causing_entity: std::option::Option<std::string::String>,
}
impl ResourceChangeDetail {
    /// <p>A <code>ResourceTargetDefinition</code> structure that describes the field that CloudFormation will change and whether the resource will be recreated.</p>
    pub fn target(&self) -> std::option::Option<&crate::types::ResourceTargetDefinition> {
        self.target.as_ref()
    }
    /// <p>Indicates whether CloudFormation can determine the target value, and whether the target value will change before you execute a change set.</p>
    /// <p>For <code>Static</code> evaluations, CloudFormation can determine that the target value will change, and its value. For example, if you directly modify the <code>InstanceType</code> property of an EC2 instance, CloudFormation knows that this property value will change, and its value, so this is a <code>Static</code> evaluation.</p>
    /// <p>For <code>Dynamic</code> evaluations, can't determine the target value because it depends on the result of an intrinsic function, such as a <code>Ref</code> or <code>Fn::GetAtt</code> intrinsic function, when the stack is updated. For example, if your template includes a reference to a resource that's conditionally recreated, the value of the reference (the physical ID of the resource) might change, depending on if the resource is recreated. If the resource is recreated, it will have a new physical ID, so all references to that resource will also be updated.</p>
    pub fn evaluation(&self) -> std::option::Option<&crate::types::EvaluationType> {
        self.evaluation.as_ref()
    }
    /// <p>The group to which the <code>CausingEntity</code> value belongs. There are five entity groups:</p>
    /// <ul>
    /// <li> <p> <code>ResourceReference</code> entities are <code>Ref</code> intrinsic functions that refer to resources in the template, such as <code>{ "Ref" : "MyEC2InstanceResource" }</code>.</p> </li>
    /// <li> <p> <code>ParameterReference</code> entities are <code>Ref</code> intrinsic functions that get template parameter values, such as <code>{ "Ref" : "MyPasswordParameter" }</code>.</p> </li>
    /// <li> <p> <code>ResourceAttribute</code> entities are <code>Fn::GetAtt</code> intrinsic functions that get resource attribute values, such as <code>{ "Fn::GetAtt" : [ "MyEC2InstanceResource", "PublicDnsName" ] }</code>.</p> </li>
    /// <li> <p> <code>DirectModification</code> entities are changes that are made directly to the template.</p> </li>
    /// <li> <p> <code>Automatic</code> entities are <code>AWS::CloudFormation::Stack</code> resource types, which are also known as nested stacks. If you made no changes to the <code>AWS::CloudFormation::Stack</code> resource, CloudFormation sets the <code>ChangeSource</code> to <code>Automatic</code> because the nested stack's template might have changed. Changes to a nested stack's template aren't visible to CloudFormation until you run an update on the parent stack.</p> </li>
    /// </ul>
    pub fn change_source(&self) -> std::option::Option<&crate::types::ChangeSource> {
        self.change_source.as_ref()
    }
    /// <p>The identity of the entity that triggered this change. This entity is a member of the group that's specified by the <code>ChangeSource</code> field. For example, if you modified the value of the <code>KeyPairName</code> parameter, the <code>CausingEntity</code> is the name of the parameter (<code>KeyPairName</code>).</p>
    /// <p>If the <code>ChangeSource</code> value is <code>DirectModification</code>, no value is given for <code>CausingEntity</code>.</p>
    pub fn causing_entity(&self) -> std::option::Option<&str> {
        self.causing_entity.as_deref()
    }
}
impl ResourceChangeDetail {
    /// Creates a new builder-style object to manufacture [`ResourceChangeDetail`](crate::types::ResourceChangeDetail).
    pub fn builder() -> crate::types::builders::ResourceChangeDetailBuilder {
        crate::types::builders::ResourceChangeDetailBuilder::default()
    }
}

/// A builder for [`ResourceChangeDetail`](crate::types::ResourceChangeDetail).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct ResourceChangeDetailBuilder {
    pub(crate) target: std::option::Option<crate::types::ResourceTargetDefinition>,
    pub(crate) evaluation: std::option::Option<crate::types::EvaluationType>,
    pub(crate) change_source: std::option::Option<crate::types::ChangeSource>,
    pub(crate) causing_entity: std::option::Option<std::string::String>,
}
impl ResourceChangeDetailBuilder {
    /// <p>A <code>ResourceTargetDefinition</code> structure that describes the field that CloudFormation will change and whether the resource will be recreated.</p>
    pub fn target(mut self, input: crate::types::ResourceTargetDefinition) -> Self {
        self.target = Some(input);
        self
    }
    /// <p>A <code>ResourceTargetDefinition</code> structure that describes the field that CloudFormation will change and whether the resource will be recreated.</p>
    pub fn set_target(
        mut self,
        input: std::option::Option<crate::types::ResourceTargetDefinition>,
    ) -> Self {
        self.target = input;
        self
    }
    /// <p>Indicates whether CloudFormation can determine the target value, and whether the target value will change before you execute a change set.</p>
    /// <p>For <code>Static</code> evaluations, CloudFormation can determine that the target value will change, and its value. For example, if you directly modify the <code>InstanceType</code> property of an EC2 instance, CloudFormation knows that this property value will change, and its value, so this is a <code>Static</code> evaluation.</p>
    /// <p>For <code>Dynamic</code> evaluations, can't determine the target value because it depends on the result of an intrinsic function, such as a <code>Ref</code> or <code>Fn::GetAtt</code> intrinsic function, when the stack is updated. For example, if your template includes a reference to a resource that's conditionally recreated, the value of the reference (the physical ID of the resource) might change, depending on if the resource is recreated. If the resource is recreated, it will have a new physical ID, so all references to that resource will also be updated.</p>
    pub fn evaluation(mut self, input: crate::types::EvaluationType) -> Self {
        self.evaluation = Some(input);
        self
    }
    /// <p>Indicates whether CloudFormation can determine the target value, and whether the target value will change before you execute a change set.</p>
    /// <p>For <code>Static</code> evaluations, CloudFormation can determine that the target value will change, and its value. For example, if you directly modify the <code>InstanceType</code> property of an EC2 instance, CloudFormation knows that this property value will change, and its value, so this is a <code>Static</code> evaluation.</p>
    /// <p>For <code>Dynamic</code> evaluations, can't determine the target value because it depends on the result of an intrinsic function, such as a <code>Ref</code> or <code>Fn::GetAtt</code> intrinsic function, when the stack is updated. For example, if your template includes a reference to a resource that's conditionally recreated, the value of the reference (the physical ID of the resource) might change, depending on if the resource is recreated. If the resource is recreated, it will have a new physical ID, so all references to that resource will also be updated.</p>
    pub fn set_evaluation(
        mut self,
        input: std::option::Option<crate::types::EvaluationType>,
    ) -> Self {
        self.evaluation = input;
        self
    }
    /// <p>The group to which the <code>CausingEntity</code> value belongs. There are five entity groups:</p>
    /// <ul>
    /// <li> <p> <code>ResourceReference</code> entities are <code>Ref</code> intrinsic functions that refer to resources in the template, such as <code>{ "Ref" : "MyEC2InstanceResource" }</code>.</p> </li>
    /// <li> <p> <code>ParameterReference</code> entities are <code>Ref</code> intrinsic functions that get template parameter values, such as <code>{ "Ref" : "MyPasswordParameter" }</code>.</p> </li>
    /// <li> <p> <code>ResourceAttribute</code> entities are <code>Fn::GetAtt</code> intrinsic functions that get resource attribute values, such as <code>{ "Fn::GetAtt" : [ "MyEC2InstanceResource", "PublicDnsName" ] }</code>.</p> </li>
    /// <li> <p> <code>DirectModification</code> entities are changes that are made directly to the template.</p> </li>
    /// <li> <p> <code>Automatic</code> entities are <code>AWS::CloudFormation::Stack</code> resource types, which are also known as nested stacks. If you made no changes to the <code>AWS::CloudFormation::Stack</code> resource, CloudFormation sets the <code>ChangeSource</code> to <code>Automatic</code> because the nested stack's template might have changed. Changes to a nested stack's template aren't visible to CloudFormation until you run an update on the parent stack.</p> </li>
    /// </ul>
    pub fn change_source(mut self, input: crate::types::ChangeSource) -> Self {
        self.change_source = Some(input);
        self
    }
    /// <p>The group to which the <code>CausingEntity</code> value belongs. There are five entity groups:</p>
    /// <ul>
    /// <li> <p> <code>ResourceReference</code> entities are <code>Ref</code> intrinsic functions that refer to resources in the template, such as <code>{ "Ref" : "MyEC2InstanceResource" }</code>.</p> </li>
    /// <li> <p> <code>ParameterReference</code> entities are <code>Ref</code> intrinsic functions that get template parameter values, such as <code>{ "Ref" : "MyPasswordParameter" }</code>.</p> </li>
    /// <li> <p> <code>ResourceAttribute</code> entities are <code>Fn::GetAtt</code> intrinsic functions that get resource attribute values, such as <code>{ "Fn::GetAtt" : [ "MyEC2InstanceResource", "PublicDnsName" ] }</code>.</p> </li>
    /// <li> <p> <code>DirectModification</code> entities are changes that are made directly to the template.</p> </li>
    /// <li> <p> <code>Automatic</code> entities are <code>AWS::CloudFormation::Stack</code> resource types, which are also known as nested stacks. If you made no changes to the <code>AWS::CloudFormation::Stack</code> resource, CloudFormation sets the <code>ChangeSource</code> to <code>Automatic</code> because the nested stack's template might have changed. Changes to a nested stack's template aren't visible to CloudFormation until you run an update on the parent stack.</p> </li>
    /// </ul>
    pub fn set_change_source(
        mut self,
        input: std::option::Option<crate::types::ChangeSource>,
    ) -> Self {
        self.change_source = input;
        self
    }
    /// <p>The identity of the entity that triggered this change. This entity is a member of the group that's specified by the <code>ChangeSource</code> field. For example, if you modified the value of the <code>KeyPairName</code> parameter, the <code>CausingEntity</code> is the name of the parameter (<code>KeyPairName</code>).</p>
    /// <p>If the <code>ChangeSource</code> value is <code>DirectModification</code>, no value is given for <code>CausingEntity</code>.</p>
    pub fn causing_entity(mut self, input: impl Into<std::string::String>) -> Self {
        self.causing_entity = Some(input.into());
        self
    }
    /// <p>The identity of the entity that triggered this change. This entity is a member of the group that's specified by the <code>ChangeSource</code> field. For example, if you modified the value of the <code>KeyPairName</code> parameter, the <code>CausingEntity</code> is the name of the parameter (<code>KeyPairName</code>).</p>
    /// <p>If the <code>ChangeSource</code> value is <code>DirectModification</code>, no value is given for <code>CausingEntity</code>.</p>
    pub fn set_causing_entity(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.causing_entity = input;
        self
    }
    /// Consumes the builder and constructs a [`ResourceChangeDetail`](crate::types::ResourceChangeDetail).
    pub fn build(self) -> crate::types::ResourceChangeDetail {
        crate::types::ResourceChangeDetail {
            target: self.target,
            evaluation: self.evaluation,
            change_source: self.change_source,
            causing_entity: self.causing_entity,
        }
    }
}
