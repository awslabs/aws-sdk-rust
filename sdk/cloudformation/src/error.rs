// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CancelUpdateStackError {
    pub kind: CancelUpdateStackErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CancelUpdateStackErrorKind {
    TokenAlreadyExistsError(crate::error::TokenAlreadyExistsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CancelUpdateStackError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CancelUpdateStackErrorKind::TokenAlreadyExistsError(_inner) => _inner.fmt(f),
            CancelUpdateStackErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CancelUpdateStackError {
    fn code(&self) -> Option<&str> {
        CancelUpdateStackError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CancelUpdateStackError {
    pub fn new(kind: CancelUpdateStackErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CancelUpdateStackErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CancelUpdateStackErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_token_already_exists_error(&self) -> bool {
        matches!(
            &self.kind,
            CancelUpdateStackErrorKind::TokenAlreadyExistsError(_)
        )
    }
}
impl std::error::Error for CancelUpdateStackError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CancelUpdateStackErrorKind::TokenAlreadyExistsError(_inner) => Some(_inner),
            CancelUpdateStackErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ContinueUpdateRollbackError {
    pub kind: ContinueUpdateRollbackErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ContinueUpdateRollbackErrorKind {
    TokenAlreadyExistsError(crate::error::TokenAlreadyExistsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ContinueUpdateRollbackError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ContinueUpdateRollbackErrorKind::TokenAlreadyExistsError(_inner) => _inner.fmt(f),
            ContinueUpdateRollbackErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ContinueUpdateRollbackError {
    fn code(&self) -> Option<&str> {
        ContinueUpdateRollbackError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ContinueUpdateRollbackError {
    pub fn new(kind: ContinueUpdateRollbackErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ContinueUpdateRollbackErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ContinueUpdateRollbackErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_token_already_exists_error(&self) -> bool {
        matches!(
            &self.kind,
            ContinueUpdateRollbackErrorKind::TokenAlreadyExistsError(_)
        )
    }
}
impl std::error::Error for ContinueUpdateRollbackError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ContinueUpdateRollbackErrorKind::TokenAlreadyExistsError(_inner) => Some(_inner),
            ContinueUpdateRollbackErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateChangeSetError {
    pub kind: CreateChangeSetErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateChangeSetErrorKind {
    AlreadyExistsError(crate::error::AlreadyExistsError),
    InsufficientCapabilitiesError(crate::error::InsufficientCapabilitiesError),
    LimitExceededError(crate::error::LimitExceededError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateChangeSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateChangeSetErrorKind::AlreadyExistsError(_inner) => _inner.fmt(f),
            CreateChangeSetErrorKind::InsufficientCapabilitiesError(_inner) => _inner.fmt(f),
            CreateChangeSetErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            CreateChangeSetErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateChangeSetError {
    fn code(&self) -> Option<&str> {
        CreateChangeSetError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateChangeSetError {
    pub fn new(kind: CreateChangeSetErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateChangeSetErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateChangeSetErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_already_exists_error(&self) -> bool {
        matches!(&self.kind, CreateChangeSetErrorKind::AlreadyExistsError(_))
    }
    pub fn is_insufficient_capabilities_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateChangeSetErrorKind::InsufficientCapabilitiesError(_)
        )
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(&self.kind, CreateChangeSetErrorKind::LimitExceededError(_))
    }
}
impl std::error::Error for CreateChangeSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateChangeSetErrorKind::AlreadyExistsError(_inner) => Some(_inner),
            CreateChangeSetErrorKind::InsufficientCapabilitiesError(_inner) => Some(_inner),
            CreateChangeSetErrorKind::LimitExceededError(_inner) => Some(_inner),
            CreateChangeSetErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateStackError {
    pub kind: CreateStackErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateStackErrorKind {
    AlreadyExistsError(crate::error::AlreadyExistsError),
    InsufficientCapabilitiesError(crate::error::InsufficientCapabilitiesError),
    LimitExceededError(crate::error::LimitExceededError),
    TokenAlreadyExistsError(crate::error::TokenAlreadyExistsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateStackError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateStackErrorKind::AlreadyExistsError(_inner) => _inner.fmt(f),
            CreateStackErrorKind::InsufficientCapabilitiesError(_inner) => _inner.fmt(f),
            CreateStackErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            CreateStackErrorKind::TokenAlreadyExistsError(_inner) => _inner.fmt(f),
            CreateStackErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateStackError {
    fn code(&self) -> Option<&str> {
        CreateStackError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateStackError {
    pub fn new(kind: CreateStackErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateStackErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateStackErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_already_exists_error(&self) -> bool {
        matches!(&self.kind, CreateStackErrorKind::AlreadyExistsError(_))
    }
    pub fn is_insufficient_capabilities_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateStackErrorKind::InsufficientCapabilitiesError(_)
        )
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(&self.kind, CreateStackErrorKind::LimitExceededError(_))
    }
    pub fn is_token_already_exists_error(&self) -> bool {
        matches!(&self.kind, CreateStackErrorKind::TokenAlreadyExistsError(_))
    }
}
impl std::error::Error for CreateStackError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateStackErrorKind::AlreadyExistsError(_inner) => Some(_inner),
            CreateStackErrorKind::InsufficientCapabilitiesError(_inner) => Some(_inner),
            CreateStackErrorKind::LimitExceededError(_inner) => Some(_inner),
            CreateStackErrorKind::TokenAlreadyExistsError(_inner) => Some(_inner),
            CreateStackErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateStackInstancesError {
    pub kind: CreateStackInstancesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateStackInstancesErrorKind {
    InvalidOperationError(crate::error::InvalidOperationError),
    LimitExceededError(crate::error::LimitExceededError),
    OperationIdAlreadyExistsError(crate::error::OperationIdAlreadyExistsError),
    OperationInProgressError(crate::error::OperationInProgressError),
    StackSetNotFoundError(crate::error::StackSetNotFoundError),
    StaleRequestError(crate::error::StaleRequestError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateStackInstancesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateStackInstancesErrorKind::InvalidOperationError(_inner) => _inner.fmt(f),
            CreateStackInstancesErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            CreateStackInstancesErrorKind::OperationIdAlreadyExistsError(_inner) => _inner.fmt(f),
            CreateStackInstancesErrorKind::OperationInProgressError(_inner) => _inner.fmt(f),
            CreateStackInstancesErrorKind::StackSetNotFoundError(_inner) => _inner.fmt(f),
            CreateStackInstancesErrorKind::StaleRequestError(_inner) => _inner.fmt(f),
            CreateStackInstancesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateStackInstancesError {
    fn code(&self) -> Option<&str> {
        CreateStackInstancesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateStackInstancesError {
    pub fn new(kind: CreateStackInstancesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateStackInstancesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateStackInstancesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_operation_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateStackInstancesErrorKind::InvalidOperationError(_)
        )
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateStackInstancesErrorKind::LimitExceededError(_)
        )
    }
    pub fn is_operation_id_already_exists_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateStackInstancesErrorKind::OperationIdAlreadyExistsError(_)
        )
    }
    pub fn is_operation_in_progress_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateStackInstancesErrorKind::OperationInProgressError(_)
        )
    }
    pub fn is_stack_set_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateStackInstancesErrorKind::StackSetNotFoundError(_)
        )
    }
    pub fn is_stale_request_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateStackInstancesErrorKind::StaleRequestError(_)
        )
    }
}
impl std::error::Error for CreateStackInstancesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateStackInstancesErrorKind::InvalidOperationError(_inner) => Some(_inner),
            CreateStackInstancesErrorKind::LimitExceededError(_inner) => Some(_inner),
            CreateStackInstancesErrorKind::OperationIdAlreadyExistsError(_inner) => Some(_inner),
            CreateStackInstancesErrorKind::OperationInProgressError(_inner) => Some(_inner),
            CreateStackInstancesErrorKind::StackSetNotFoundError(_inner) => Some(_inner),
            CreateStackInstancesErrorKind::StaleRequestError(_inner) => Some(_inner),
            CreateStackInstancesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateStackSetError {
    pub kind: CreateStackSetErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateStackSetErrorKind {
    CreatedButModifiedError(crate::error::CreatedButModifiedError),
    LimitExceededError(crate::error::LimitExceededError),
    NameAlreadyExistsError(crate::error::NameAlreadyExistsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateStackSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateStackSetErrorKind::CreatedButModifiedError(_inner) => _inner.fmt(f),
            CreateStackSetErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            CreateStackSetErrorKind::NameAlreadyExistsError(_inner) => _inner.fmt(f),
            CreateStackSetErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateStackSetError {
    fn code(&self) -> Option<&str> {
        CreateStackSetError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateStackSetError {
    pub fn new(kind: CreateStackSetErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateStackSetErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateStackSetErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_created_but_modified_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateStackSetErrorKind::CreatedButModifiedError(_)
        )
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(&self.kind, CreateStackSetErrorKind::LimitExceededError(_))
    }
    pub fn is_name_already_exists_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateStackSetErrorKind::NameAlreadyExistsError(_)
        )
    }
}
impl std::error::Error for CreateStackSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateStackSetErrorKind::CreatedButModifiedError(_inner) => Some(_inner),
            CreateStackSetErrorKind::LimitExceededError(_inner) => Some(_inner),
            CreateStackSetErrorKind::NameAlreadyExistsError(_inner) => Some(_inner),
            CreateStackSetErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteChangeSetError {
    pub kind: DeleteChangeSetErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteChangeSetErrorKind {
    InvalidChangeSetStatusError(crate::error::InvalidChangeSetStatusError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteChangeSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteChangeSetErrorKind::InvalidChangeSetStatusError(_inner) => _inner.fmt(f),
            DeleteChangeSetErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteChangeSetError {
    fn code(&self) -> Option<&str> {
        DeleteChangeSetError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteChangeSetError {
    pub fn new(kind: DeleteChangeSetErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteChangeSetErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteChangeSetErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_change_set_status_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteChangeSetErrorKind::InvalidChangeSetStatusError(_)
        )
    }
}
impl std::error::Error for DeleteChangeSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteChangeSetErrorKind::InvalidChangeSetStatusError(_inner) => Some(_inner),
            DeleteChangeSetErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteStackError {
    pub kind: DeleteStackErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteStackErrorKind {
    TokenAlreadyExistsError(crate::error::TokenAlreadyExistsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteStackError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteStackErrorKind::TokenAlreadyExistsError(_inner) => _inner.fmt(f),
            DeleteStackErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteStackError {
    fn code(&self) -> Option<&str> {
        DeleteStackError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteStackError {
    pub fn new(kind: DeleteStackErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteStackErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteStackErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_token_already_exists_error(&self) -> bool {
        matches!(&self.kind, DeleteStackErrorKind::TokenAlreadyExistsError(_))
    }
}
impl std::error::Error for DeleteStackError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteStackErrorKind::TokenAlreadyExistsError(_inner) => Some(_inner),
            DeleteStackErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteStackInstancesError {
    pub kind: DeleteStackInstancesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteStackInstancesErrorKind {
    InvalidOperationError(crate::error::InvalidOperationError),
    OperationIdAlreadyExistsError(crate::error::OperationIdAlreadyExistsError),
    OperationInProgressError(crate::error::OperationInProgressError),
    StackSetNotFoundError(crate::error::StackSetNotFoundError),
    StaleRequestError(crate::error::StaleRequestError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteStackInstancesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteStackInstancesErrorKind::InvalidOperationError(_inner) => _inner.fmt(f),
            DeleteStackInstancesErrorKind::OperationIdAlreadyExistsError(_inner) => _inner.fmt(f),
            DeleteStackInstancesErrorKind::OperationInProgressError(_inner) => _inner.fmt(f),
            DeleteStackInstancesErrorKind::StackSetNotFoundError(_inner) => _inner.fmt(f),
            DeleteStackInstancesErrorKind::StaleRequestError(_inner) => _inner.fmt(f),
            DeleteStackInstancesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteStackInstancesError {
    fn code(&self) -> Option<&str> {
        DeleteStackInstancesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteStackInstancesError {
    pub fn new(kind: DeleteStackInstancesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteStackInstancesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteStackInstancesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_operation_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteStackInstancesErrorKind::InvalidOperationError(_)
        )
    }
    pub fn is_operation_id_already_exists_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteStackInstancesErrorKind::OperationIdAlreadyExistsError(_)
        )
    }
    pub fn is_operation_in_progress_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteStackInstancesErrorKind::OperationInProgressError(_)
        )
    }
    pub fn is_stack_set_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteStackInstancesErrorKind::StackSetNotFoundError(_)
        )
    }
    pub fn is_stale_request_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteStackInstancesErrorKind::StaleRequestError(_)
        )
    }
}
impl std::error::Error for DeleteStackInstancesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteStackInstancesErrorKind::InvalidOperationError(_inner) => Some(_inner),
            DeleteStackInstancesErrorKind::OperationIdAlreadyExistsError(_inner) => Some(_inner),
            DeleteStackInstancesErrorKind::OperationInProgressError(_inner) => Some(_inner),
            DeleteStackInstancesErrorKind::StackSetNotFoundError(_inner) => Some(_inner),
            DeleteStackInstancesErrorKind::StaleRequestError(_inner) => Some(_inner),
            DeleteStackInstancesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteStackSetError {
    pub kind: DeleteStackSetErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteStackSetErrorKind {
    OperationInProgressError(crate::error::OperationInProgressError),
    StackSetNotEmptyError(crate::error::StackSetNotEmptyError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteStackSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteStackSetErrorKind::OperationInProgressError(_inner) => _inner.fmt(f),
            DeleteStackSetErrorKind::StackSetNotEmptyError(_inner) => _inner.fmt(f),
            DeleteStackSetErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteStackSetError {
    fn code(&self) -> Option<&str> {
        DeleteStackSetError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteStackSetError {
    pub fn new(kind: DeleteStackSetErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteStackSetErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteStackSetErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_operation_in_progress_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteStackSetErrorKind::OperationInProgressError(_)
        )
    }
    pub fn is_stack_set_not_empty_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteStackSetErrorKind::StackSetNotEmptyError(_)
        )
    }
}
impl std::error::Error for DeleteStackSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteStackSetErrorKind::OperationInProgressError(_inner) => Some(_inner),
            DeleteStackSetErrorKind::StackSetNotEmptyError(_inner) => Some(_inner),
            DeleteStackSetErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeregisterTypeError {
    pub kind: DeregisterTypeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeregisterTypeErrorKind {
    CFNRegistryError(crate::error::CFNRegistryError),
    TypeNotFoundError(crate::error::TypeNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeregisterTypeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeregisterTypeErrorKind::CFNRegistryError(_inner) => _inner.fmt(f),
            DeregisterTypeErrorKind::TypeNotFoundError(_inner) => _inner.fmt(f),
            DeregisterTypeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeregisterTypeError {
    fn code(&self) -> Option<&str> {
        DeregisterTypeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeregisterTypeError {
    pub fn new(kind: DeregisterTypeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeregisterTypeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeregisterTypeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_cfn_registry_error(&self) -> bool {
        matches!(&self.kind, DeregisterTypeErrorKind::CFNRegistryError(_))
    }
    pub fn is_type_not_found_error(&self) -> bool {
        matches!(&self.kind, DeregisterTypeErrorKind::TypeNotFoundError(_))
    }
}
impl std::error::Error for DeregisterTypeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeregisterTypeErrorKind::CFNRegistryError(_inner) => Some(_inner),
            DeregisterTypeErrorKind::TypeNotFoundError(_inner) => Some(_inner),
            DeregisterTypeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeAccountLimitsError {
    pub kind: DescribeAccountLimitsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeAccountLimitsErrorKind {
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeAccountLimitsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeAccountLimitsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeAccountLimitsError {
    fn code(&self) -> Option<&str> {
        DescribeAccountLimitsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeAccountLimitsError {
    pub fn new(kind: DescribeAccountLimitsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeAccountLimitsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeAccountLimitsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for DescribeAccountLimitsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeAccountLimitsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeChangeSetError {
    pub kind: DescribeChangeSetErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeChangeSetErrorKind {
    ChangeSetNotFoundError(crate::error::ChangeSetNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeChangeSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeChangeSetErrorKind::ChangeSetNotFoundError(_inner) => _inner.fmt(f),
            DescribeChangeSetErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeChangeSetError {
    fn code(&self) -> Option<&str> {
        DescribeChangeSetError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeChangeSetError {
    pub fn new(kind: DescribeChangeSetErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeChangeSetErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeChangeSetErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_change_set_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeChangeSetErrorKind::ChangeSetNotFoundError(_)
        )
    }
}
impl std::error::Error for DescribeChangeSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeChangeSetErrorKind::ChangeSetNotFoundError(_inner) => Some(_inner),
            DescribeChangeSetErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeStackDriftDetectionStatusError {
    pub kind: DescribeStackDriftDetectionStatusErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeStackDriftDetectionStatusErrorKind {
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeStackDriftDetectionStatusError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeStackDriftDetectionStatusErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeStackDriftDetectionStatusError {
    fn code(&self) -> Option<&str> {
        DescribeStackDriftDetectionStatusError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeStackDriftDetectionStatusError {
    pub fn new(
        kind: DescribeStackDriftDetectionStatusErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeStackDriftDetectionStatusErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeStackDriftDetectionStatusErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for DescribeStackDriftDetectionStatusError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeStackDriftDetectionStatusErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeStackEventsError {
    pub kind: DescribeStackEventsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeStackEventsErrorKind {
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeStackEventsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeStackEventsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeStackEventsError {
    fn code(&self) -> Option<&str> {
        DescribeStackEventsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeStackEventsError {
    pub fn new(kind: DescribeStackEventsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeStackEventsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeStackEventsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for DescribeStackEventsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeStackEventsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeStackInstanceError {
    pub kind: DescribeStackInstanceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeStackInstanceErrorKind {
    StackInstanceNotFoundError(crate::error::StackInstanceNotFoundError),
    StackSetNotFoundError(crate::error::StackSetNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeStackInstanceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeStackInstanceErrorKind::StackInstanceNotFoundError(_inner) => _inner.fmt(f),
            DescribeStackInstanceErrorKind::StackSetNotFoundError(_inner) => _inner.fmt(f),
            DescribeStackInstanceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeStackInstanceError {
    fn code(&self) -> Option<&str> {
        DescribeStackInstanceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeStackInstanceError {
    pub fn new(kind: DescribeStackInstanceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeStackInstanceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeStackInstanceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_stack_instance_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeStackInstanceErrorKind::StackInstanceNotFoundError(_)
        )
    }
    pub fn is_stack_set_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeStackInstanceErrorKind::StackSetNotFoundError(_)
        )
    }
}
impl std::error::Error for DescribeStackInstanceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeStackInstanceErrorKind::StackInstanceNotFoundError(_inner) => Some(_inner),
            DescribeStackInstanceErrorKind::StackSetNotFoundError(_inner) => Some(_inner),
            DescribeStackInstanceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeStackResourceError {
    pub kind: DescribeStackResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeStackResourceErrorKind {
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeStackResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeStackResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeStackResourceError {
    fn code(&self) -> Option<&str> {
        DescribeStackResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeStackResourceError {
    pub fn new(kind: DescribeStackResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeStackResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeStackResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for DescribeStackResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeStackResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeStackResourceDriftsError {
    pub kind: DescribeStackResourceDriftsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeStackResourceDriftsErrorKind {
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeStackResourceDriftsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeStackResourceDriftsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeStackResourceDriftsError {
    fn code(&self) -> Option<&str> {
        DescribeStackResourceDriftsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeStackResourceDriftsError {
    pub fn new(kind: DescribeStackResourceDriftsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeStackResourceDriftsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeStackResourceDriftsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for DescribeStackResourceDriftsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeStackResourceDriftsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeStackResourcesError {
    pub kind: DescribeStackResourcesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeStackResourcesErrorKind {
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeStackResourcesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeStackResourcesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeStackResourcesError {
    fn code(&self) -> Option<&str> {
        DescribeStackResourcesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeStackResourcesError {
    pub fn new(kind: DescribeStackResourcesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeStackResourcesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeStackResourcesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for DescribeStackResourcesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeStackResourcesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeStacksError {
    pub kind: DescribeStacksErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeStacksErrorKind {
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeStacksError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeStacksErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeStacksError {
    fn code(&self) -> Option<&str> {
        DescribeStacksError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeStacksError {
    pub fn new(kind: DescribeStacksErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeStacksErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeStacksErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for DescribeStacksError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeStacksErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeStackSetError {
    pub kind: DescribeStackSetErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeStackSetErrorKind {
    StackSetNotFoundError(crate::error::StackSetNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeStackSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeStackSetErrorKind::StackSetNotFoundError(_inner) => _inner.fmt(f),
            DescribeStackSetErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeStackSetError {
    fn code(&self) -> Option<&str> {
        DescribeStackSetError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeStackSetError {
    pub fn new(kind: DescribeStackSetErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeStackSetErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeStackSetErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_stack_set_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeStackSetErrorKind::StackSetNotFoundError(_)
        )
    }
}
impl std::error::Error for DescribeStackSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeStackSetErrorKind::StackSetNotFoundError(_inner) => Some(_inner),
            DescribeStackSetErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeStackSetOperationError {
    pub kind: DescribeStackSetOperationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeStackSetOperationErrorKind {
    OperationNotFoundError(crate::error::OperationNotFoundError),
    StackSetNotFoundError(crate::error::StackSetNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeStackSetOperationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeStackSetOperationErrorKind::OperationNotFoundError(_inner) => _inner.fmt(f),
            DescribeStackSetOperationErrorKind::StackSetNotFoundError(_inner) => _inner.fmt(f),
            DescribeStackSetOperationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeStackSetOperationError {
    fn code(&self) -> Option<&str> {
        DescribeStackSetOperationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeStackSetOperationError {
    pub fn new(kind: DescribeStackSetOperationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeStackSetOperationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeStackSetOperationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_operation_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeStackSetOperationErrorKind::OperationNotFoundError(_)
        )
    }
    pub fn is_stack_set_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeStackSetOperationErrorKind::StackSetNotFoundError(_)
        )
    }
}
impl std::error::Error for DescribeStackSetOperationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeStackSetOperationErrorKind::OperationNotFoundError(_inner) => Some(_inner),
            DescribeStackSetOperationErrorKind::StackSetNotFoundError(_inner) => Some(_inner),
            DescribeStackSetOperationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeTypeError {
    pub kind: DescribeTypeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeTypeErrorKind {
    CFNRegistryError(crate::error::CFNRegistryError),
    TypeNotFoundError(crate::error::TypeNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeTypeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeTypeErrorKind::CFNRegistryError(_inner) => _inner.fmt(f),
            DescribeTypeErrorKind::TypeNotFoundError(_inner) => _inner.fmt(f),
            DescribeTypeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeTypeError {
    fn code(&self) -> Option<&str> {
        DescribeTypeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeTypeError {
    pub fn new(kind: DescribeTypeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeTypeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeTypeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_cfn_registry_error(&self) -> bool {
        matches!(&self.kind, DescribeTypeErrorKind::CFNRegistryError(_))
    }
    pub fn is_type_not_found_error(&self) -> bool {
        matches!(&self.kind, DescribeTypeErrorKind::TypeNotFoundError(_))
    }
}
impl std::error::Error for DescribeTypeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeTypeErrorKind::CFNRegistryError(_inner) => Some(_inner),
            DescribeTypeErrorKind::TypeNotFoundError(_inner) => Some(_inner),
            DescribeTypeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeTypeRegistrationError {
    pub kind: DescribeTypeRegistrationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeTypeRegistrationErrorKind {
    CFNRegistryError(crate::error::CFNRegistryError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeTypeRegistrationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeTypeRegistrationErrorKind::CFNRegistryError(_inner) => _inner.fmt(f),
            DescribeTypeRegistrationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeTypeRegistrationError {
    fn code(&self) -> Option<&str> {
        DescribeTypeRegistrationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeTypeRegistrationError {
    pub fn new(kind: DescribeTypeRegistrationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeTypeRegistrationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeTypeRegistrationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_cfn_registry_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeTypeRegistrationErrorKind::CFNRegistryError(_)
        )
    }
}
impl std::error::Error for DescribeTypeRegistrationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeTypeRegistrationErrorKind::CFNRegistryError(_inner) => Some(_inner),
            DescribeTypeRegistrationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DetectStackDriftError {
    pub kind: DetectStackDriftErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DetectStackDriftErrorKind {
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DetectStackDriftError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DetectStackDriftErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DetectStackDriftError {
    fn code(&self) -> Option<&str> {
        DetectStackDriftError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DetectStackDriftError {
    pub fn new(kind: DetectStackDriftErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DetectStackDriftErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DetectStackDriftErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for DetectStackDriftError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DetectStackDriftErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DetectStackResourceDriftError {
    pub kind: DetectStackResourceDriftErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DetectStackResourceDriftErrorKind {
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DetectStackResourceDriftError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DetectStackResourceDriftErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DetectStackResourceDriftError {
    fn code(&self) -> Option<&str> {
        DetectStackResourceDriftError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DetectStackResourceDriftError {
    pub fn new(kind: DetectStackResourceDriftErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DetectStackResourceDriftErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DetectStackResourceDriftErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for DetectStackResourceDriftError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DetectStackResourceDriftErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DetectStackSetDriftError {
    pub kind: DetectStackSetDriftErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DetectStackSetDriftErrorKind {
    InvalidOperationError(crate::error::InvalidOperationError),
    OperationInProgressError(crate::error::OperationInProgressError),
    StackSetNotFoundError(crate::error::StackSetNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DetectStackSetDriftError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DetectStackSetDriftErrorKind::InvalidOperationError(_inner) => _inner.fmt(f),
            DetectStackSetDriftErrorKind::OperationInProgressError(_inner) => _inner.fmt(f),
            DetectStackSetDriftErrorKind::StackSetNotFoundError(_inner) => _inner.fmt(f),
            DetectStackSetDriftErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DetectStackSetDriftError {
    fn code(&self) -> Option<&str> {
        DetectStackSetDriftError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DetectStackSetDriftError {
    pub fn new(kind: DetectStackSetDriftErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DetectStackSetDriftErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DetectStackSetDriftErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_operation_error(&self) -> bool {
        matches!(
            &self.kind,
            DetectStackSetDriftErrorKind::InvalidOperationError(_)
        )
    }
    pub fn is_operation_in_progress_error(&self) -> bool {
        matches!(
            &self.kind,
            DetectStackSetDriftErrorKind::OperationInProgressError(_)
        )
    }
    pub fn is_stack_set_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            DetectStackSetDriftErrorKind::StackSetNotFoundError(_)
        )
    }
}
impl std::error::Error for DetectStackSetDriftError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DetectStackSetDriftErrorKind::InvalidOperationError(_inner) => Some(_inner),
            DetectStackSetDriftErrorKind::OperationInProgressError(_inner) => Some(_inner),
            DetectStackSetDriftErrorKind::StackSetNotFoundError(_inner) => Some(_inner),
            DetectStackSetDriftErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct EstimateTemplateCostError {
    pub kind: EstimateTemplateCostErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum EstimateTemplateCostErrorKind {
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for EstimateTemplateCostError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            EstimateTemplateCostErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for EstimateTemplateCostError {
    fn code(&self) -> Option<&str> {
        EstimateTemplateCostError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl EstimateTemplateCostError {
    pub fn new(kind: EstimateTemplateCostErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: EstimateTemplateCostErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: EstimateTemplateCostErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for EstimateTemplateCostError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            EstimateTemplateCostErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ExecuteChangeSetError {
    pub kind: ExecuteChangeSetErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ExecuteChangeSetErrorKind {
    ChangeSetNotFoundError(crate::error::ChangeSetNotFoundError),
    InsufficientCapabilitiesError(crate::error::InsufficientCapabilitiesError),
    InvalidChangeSetStatusError(crate::error::InvalidChangeSetStatusError),
    TokenAlreadyExistsError(crate::error::TokenAlreadyExistsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ExecuteChangeSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ExecuteChangeSetErrorKind::ChangeSetNotFoundError(_inner) => _inner.fmt(f),
            ExecuteChangeSetErrorKind::InsufficientCapabilitiesError(_inner) => _inner.fmt(f),
            ExecuteChangeSetErrorKind::InvalidChangeSetStatusError(_inner) => _inner.fmt(f),
            ExecuteChangeSetErrorKind::TokenAlreadyExistsError(_inner) => _inner.fmt(f),
            ExecuteChangeSetErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ExecuteChangeSetError {
    fn code(&self) -> Option<&str> {
        ExecuteChangeSetError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ExecuteChangeSetError {
    pub fn new(kind: ExecuteChangeSetErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ExecuteChangeSetErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ExecuteChangeSetErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_change_set_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            ExecuteChangeSetErrorKind::ChangeSetNotFoundError(_)
        )
    }
    pub fn is_insufficient_capabilities_error(&self) -> bool {
        matches!(
            &self.kind,
            ExecuteChangeSetErrorKind::InsufficientCapabilitiesError(_)
        )
    }
    pub fn is_invalid_change_set_status_error(&self) -> bool {
        matches!(
            &self.kind,
            ExecuteChangeSetErrorKind::InvalidChangeSetStatusError(_)
        )
    }
    pub fn is_token_already_exists_error(&self) -> bool {
        matches!(
            &self.kind,
            ExecuteChangeSetErrorKind::TokenAlreadyExistsError(_)
        )
    }
}
impl std::error::Error for ExecuteChangeSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ExecuteChangeSetErrorKind::ChangeSetNotFoundError(_inner) => Some(_inner),
            ExecuteChangeSetErrorKind::InsufficientCapabilitiesError(_inner) => Some(_inner),
            ExecuteChangeSetErrorKind::InvalidChangeSetStatusError(_inner) => Some(_inner),
            ExecuteChangeSetErrorKind::TokenAlreadyExistsError(_inner) => Some(_inner),
            ExecuteChangeSetErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetStackPolicyError {
    pub kind: GetStackPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetStackPolicyErrorKind {
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetStackPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetStackPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetStackPolicyError {
    fn code(&self) -> Option<&str> {
        GetStackPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetStackPolicyError {
    pub fn new(kind: GetStackPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetStackPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetStackPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for GetStackPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetStackPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetTemplateError {
    pub kind: GetTemplateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetTemplateErrorKind {
    ChangeSetNotFoundError(crate::error::ChangeSetNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetTemplateErrorKind::ChangeSetNotFoundError(_inner) => _inner.fmt(f),
            GetTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetTemplateError {
    fn code(&self) -> Option<&str> {
        GetTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetTemplateError {
    pub fn new(kind: GetTemplateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_change_set_not_found_error(&self) -> bool {
        matches!(&self.kind, GetTemplateErrorKind::ChangeSetNotFoundError(_))
    }
}
impl std::error::Error for GetTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetTemplateErrorKind::ChangeSetNotFoundError(_inner) => Some(_inner),
            GetTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetTemplateSummaryError {
    pub kind: GetTemplateSummaryErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetTemplateSummaryErrorKind {
    StackSetNotFoundError(crate::error::StackSetNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetTemplateSummaryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetTemplateSummaryErrorKind::StackSetNotFoundError(_inner) => _inner.fmt(f),
            GetTemplateSummaryErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetTemplateSummaryError {
    fn code(&self) -> Option<&str> {
        GetTemplateSummaryError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetTemplateSummaryError {
    pub fn new(kind: GetTemplateSummaryErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetTemplateSummaryErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetTemplateSummaryErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_stack_set_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            GetTemplateSummaryErrorKind::StackSetNotFoundError(_)
        )
    }
}
impl std::error::Error for GetTemplateSummaryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetTemplateSummaryErrorKind::StackSetNotFoundError(_inner) => Some(_inner),
            GetTemplateSummaryErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListChangeSetsError {
    pub kind: ListChangeSetsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListChangeSetsErrorKind {
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListChangeSetsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListChangeSetsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListChangeSetsError {
    fn code(&self) -> Option<&str> {
        ListChangeSetsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListChangeSetsError {
    pub fn new(kind: ListChangeSetsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListChangeSetsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListChangeSetsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for ListChangeSetsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListChangeSetsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListExportsError {
    pub kind: ListExportsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListExportsErrorKind {
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListExportsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListExportsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListExportsError {
    fn code(&self) -> Option<&str> {
        ListExportsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListExportsError {
    pub fn new(kind: ListExportsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListExportsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListExportsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for ListExportsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListExportsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListImportsError {
    pub kind: ListImportsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListImportsErrorKind {
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListImportsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListImportsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListImportsError {
    fn code(&self) -> Option<&str> {
        ListImportsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListImportsError {
    pub fn new(kind: ListImportsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListImportsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListImportsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for ListImportsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListImportsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListStackInstancesError {
    pub kind: ListStackInstancesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListStackInstancesErrorKind {
    StackSetNotFoundError(crate::error::StackSetNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListStackInstancesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListStackInstancesErrorKind::StackSetNotFoundError(_inner) => _inner.fmt(f),
            ListStackInstancesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListStackInstancesError {
    fn code(&self) -> Option<&str> {
        ListStackInstancesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListStackInstancesError {
    pub fn new(kind: ListStackInstancesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListStackInstancesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListStackInstancesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_stack_set_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            ListStackInstancesErrorKind::StackSetNotFoundError(_)
        )
    }
}
impl std::error::Error for ListStackInstancesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListStackInstancesErrorKind::StackSetNotFoundError(_inner) => Some(_inner),
            ListStackInstancesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListStackResourcesError {
    pub kind: ListStackResourcesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListStackResourcesErrorKind {
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListStackResourcesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListStackResourcesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListStackResourcesError {
    fn code(&self) -> Option<&str> {
        ListStackResourcesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListStackResourcesError {
    pub fn new(kind: ListStackResourcesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListStackResourcesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListStackResourcesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for ListStackResourcesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListStackResourcesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListStacksError {
    pub kind: ListStacksErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListStacksErrorKind {
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListStacksError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListStacksErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListStacksError {
    fn code(&self) -> Option<&str> {
        ListStacksError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListStacksError {
    pub fn new(kind: ListStacksErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListStacksErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListStacksErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for ListStacksError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListStacksErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListStackSetOperationResultsError {
    pub kind: ListStackSetOperationResultsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListStackSetOperationResultsErrorKind {
    OperationNotFoundError(crate::error::OperationNotFoundError),
    StackSetNotFoundError(crate::error::StackSetNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListStackSetOperationResultsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListStackSetOperationResultsErrorKind::OperationNotFoundError(_inner) => _inner.fmt(f),
            ListStackSetOperationResultsErrorKind::StackSetNotFoundError(_inner) => _inner.fmt(f),
            ListStackSetOperationResultsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListStackSetOperationResultsError {
    fn code(&self) -> Option<&str> {
        ListStackSetOperationResultsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListStackSetOperationResultsError {
    pub fn new(kind: ListStackSetOperationResultsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListStackSetOperationResultsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListStackSetOperationResultsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_operation_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            ListStackSetOperationResultsErrorKind::OperationNotFoundError(_)
        )
    }
    pub fn is_stack_set_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            ListStackSetOperationResultsErrorKind::StackSetNotFoundError(_)
        )
    }
}
impl std::error::Error for ListStackSetOperationResultsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListStackSetOperationResultsErrorKind::OperationNotFoundError(_inner) => Some(_inner),
            ListStackSetOperationResultsErrorKind::StackSetNotFoundError(_inner) => Some(_inner),
            ListStackSetOperationResultsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListStackSetOperationsError {
    pub kind: ListStackSetOperationsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListStackSetOperationsErrorKind {
    StackSetNotFoundError(crate::error::StackSetNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListStackSetOperationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListStackSetOperationsErrorKind::StackSetNotFoundError(_inner) => _inner.fmt(f),
            ListStackSetOperationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListStackSetOperationsError {
    fn code(&self) -> Option<&str> {
        ListStackSetOperationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListStackSetOperationsError {
    pub fn new(kind: ListStackSetOperationsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListStackSetOperationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListStackSetOperationsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_stack_set_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            ListStackSetOperationsErrorKind::StackSetNotFoundError(_)
        )
    }
}
impl std::error::Error for ListStackSetOperationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListStackSetOperationsErrorKind::StackSetNotFoundError(_inner) => Some(_inner),
            ListStackSetOperationsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListStackSetsError {
    pub kind: ListStackSetsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListStackSetsErrorKind {
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListStackSetsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListStackSetsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListStackSetsError {
    fn code(&self) -> Option<&str> {
        ListStackSetsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListStackSetsError {
    pub fn new(kind: ListStackSetsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListStackSetsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListStackSetsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for ListStackSetsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListStackSetsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTypeRegistrationsError {
    pub kind: ListTypeRegistrationsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTypeRegistrationsErrorKind {
    CFNRegistryError(crate::error::CFNRegistryError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTypeRegistrationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTypeRegistrationsErrorKind::CFNRegistryError(_inner) => _inner.fmt(f),
            ListTypeRegistrationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTypeRegistrationsError {
    fn code(&self) -> Option<&str> {
        ListTypeRegistrationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTypeRegistrationsError {
    pub fn new(kind: ListTypeRegistrationsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTypeRegistrationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTypeRegistrationsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_cfn_registry_error(&self) -> bool {
        matches!(
            &self.kind,
            ListTypeRegistrationsErrorKind::CFNRegistryError(_)
        )
    }
}
impl std::error::Error for ListTypeRegistrationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTypeRegistrationsErrorKind::CFNRegistryError(_inner) => Some(_inner),
            ListTypeRegistrationsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTypesError {
    pub kind: ListTypesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTypesErrorKind {
    CFNRegistryError(crate::error::CFNRegistryError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTypesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTypesErrorKind::CFNRegistryError(_inner) => _inner.fmt(f),
            ListTypesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTypesError {
    fn code(&self) -> Option<&str> {
        ListTypesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTypesError {
    pub fn new(kind: ListTypesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTypesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTypesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_cfn_registry_error(&self) -> bool {
        matches!(&self.kind, ListTypesErrorKind::CFNRegistryError(_))
    }
}
impl std::error::Error for ListTypesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTypesErrorKind::CFNRegistryError(_inner) => Some(_inner),
            ListTypesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTypeVersionsError {
    pub kind: ListTypeVersionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTypeVersionsErrorKind {
    CFNRegistryError(crate::error::CFNRegistryError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTypeVersionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTypeVersionsErrorKind::CFNRegistryError(_inner) => _inner.fmt(f),
            ListTypeVersionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTypeVersionsError {
    fn code(&self) -> Option<&str> {
        ListTypeVersionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTypeVersionsError {
    pub fn new(kind: ListTypeVersionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTypeVersionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTypeVersionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_cfn_registry_error(&self) -> bool {
        matches!(&self.kind, ListTypeVersionsErrorKind::CFNRegistryError(_))
    }
}
impl std::error::Error for ListTypeVersionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTypeVersionsErrorKind::CFNRegistryError(_inner) => Some(_inner),
            ListTypeVersionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RecordHandlerProgressError {
    pub kind: RecordHandlerProgressErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RecordHandlerProgressErrorKind {
    InvalidStateTransitionError(crate::error::InvalidStateTransitionError),
    OperationStatusCheckFailedError(crate::error::OperationStatusCheckFailedError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RecordHandlerProgressError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RecordHandlerProgressErrorKind::InvalidStateTransitionError(_inner) => _inner.fmt(f),
            RecordHandlerProgressErrorKind::OperationStatusCheckFailedError(_inner) => {
                _inner.fmt(f)
            }
            RecordHandlerProgressErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RecordHandlerProgressError {
    fn code(&self) -> Option<&str> {
        RecordHandlerProgressError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RecordHandlerProgressError {
    pub fn new(kind: RecordHandlerProgressErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RecordHandlerProgressErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RecordHandlerProgressErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_state_transition_error(&self) -> bool {
        matches!(
            &self.kind,
            RecordHandlerProgressErrorKind::InvalidStateTransitionError(_)
        )
    }
    pub fn is_operation_status_check_failed_error(&self) -> bool {
        matches!(
            &self.kind,
            RecordHandlerProgressErrorKind::OperationStatusCheckFailedError(_)
        )
    }
}
impl std::error::Error for RecordHandlerProgressError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RecordHandlerProgressErrorKind::InvalidStateTransitionError(_inner) => Some(_inner),
            RecordHandlerProgressErrorKind::OperationStatusCheckFailedError(_inner) => Some(_inner),
            RecordHandlerProgressErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RegisterTypeError {
    pub kind: RegisterTypeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RegisterTypeErrorKind {
    CFNRegistryError(crate::error::CFNRegistryError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RegisterTypeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RegisterTypeErrorKind::CFNRegistryError(_inner) => _inner.fmt(f),
            RegisterTypeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RegisterTypeError {
    fn code(&self) -> Option<&str> {
        RegisterTypeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RegisterTypeError {
    pub fn new(kind: RegisterTypeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RegisterTypeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RegisterTypeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_cfn_registry_error(&self) -> bool {
        matches!(&self.kind, RegisterTypeErrorKind::CFNRegistryError(_))
    }
}
impl std::error::Error for RegisterTypeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RegisterTypeErrorKind::CFNRegistryError(_inner) => Some(_inner),
            RegisterTypeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SetStackPolicyError {
    pub kind: SetStackPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SetStackPolicyErrorKind {
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SetStackPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SetStackPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for SetStackPolicyError {
    fn code(&self) -> Option<&str> {
        SetStackPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl SetStackPolicyError {
    pub fn new(kind: SetStackPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SetStackPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SetStackPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for SetStackPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SetStackPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SetTypeDefaultVersionError {
    pub kind: SetTypeDefaultVersionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SetTypeDefaultVersionErrorKind {
    CFNRegistryError(crate::error::CFNRegistryError),
    TypeNotFoundError(crate::error::TypeNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SetTypeDefaultVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SetTypeDefaultVersionErrorKind::CFNRegistryError(_inner) => _inner.fmt(f),
            SetTypeDefaultVersionErrorKind::TypeNotFoundError(_inner) => _inner.fmt(f),
            SetTypeDefaultVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for SetTypeDefaultVersionError {
    fn code(&self) -> Option<&str> {
        SetTypeDefaultVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl SetTypeDefaultVersionError {
    pub fn new(kind: SetTypeDefaultVersionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SetTypeDefaultVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SetTypeDefaultVersionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_cfn_registry_error(&self) -> bool {
        matches!(
            &self.kind,
            SetTypeDefaultVersionErrorKind::CFNRegistryError(_)
        )
    }
    pub fn is_type_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            SetTypeDefaultVersionErrorKind::TypeNotFoundError(_)
        )
    }
}
impl std::error::Error for SetTypeDefaultVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SetTypeDefaultVersionErrorKind::CFNRegistryError(_inner) => Some(_inner),
            SetTypeDefaultVersionErrorKind::TypeNotFoundError(_inner) => Some(_inner),
            SetTypeDefaultVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SignalResourceError {
    pub kind: SignalResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SignalResourceErrorKind {
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SignalResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SignalResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for SignalResourceError {
    fn code(&self) -> Option<&str> {
        SignalResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl SignalResourceError {
    pub fn new(kind: SignalResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SignalResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SignalResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for SignalResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SignalResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StopStackSetOperationError {
    pub kind: StopStackSetOperationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StopStackSetOperationErrorKind {
    InvalidOperationError(crate::error::InvalidOperationError),
    OperationNotFoundError(crate::error::OperationNotFoundError),
    StackSetNotFoundError(crate::error::StackSetNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StopStackSetOperationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StopStackSetOperationErrorKind::InvalidOperationError(_inner) => _inner.fmt(f),
            StopStackSetOperationErrorKind::OperationNotFoundError(_inner) => _inner.fmt(f),
            StopStackSetOperationErrorKind::StackSetNotFoundError(_inner) => _inner.fmt(f),
            StopStackSetOperationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StopStackSetOperationError {
    fn code(&self) -> Option<&str> {
        StopStackSetOperationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StopStackSetOperationError {
    pub fn new(kind: StopStackSetOperationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StopStackSetOperationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StopStackSetOperationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_operation_error(&self) -> bool {
        matches!(
            &self.kind,
            StopStackSetOperationErrorKind::InvalidOperationError(_)
        )
    }
    pub fn is_operation_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            StopStackSetOperationErrorKind::OperationNotFoundError(_)
        )
    }
    pub fn is_stack_set_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            StopStackSetOperationErrorKind::StackSetNotFoundError(_)
        )
    }
}
impl std::error::Error for StopStackSetOperationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StopStackSetOperationErrorKind::InvalidOperationError(_inner) => Some(_inner),
            StopStackSetOperationErrorKind::OperationNotFoundError(_inner) => Some(_inner),
            StopStackSetOperationErrorKind::StackSetNotFoundError(_inner) => Some(_inner),
            StopStackSetOperationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateStackError {
    pub kind: UpdateStackErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateStackErrorKind {
    InsufficientCapabilitiesError(crate::error::InsufficientCapabilitiesError),
    TokenAlreadyExistsError(crate::error::TokenAlreadyExistsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateStackError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateStackErrorKind::InsufficientCapabilitiesError(_inner) => _inner.fmt(f),
            UpdateStackErrorKind::TokenAlreadyExistsError(_inner) => _inner.fmt(f),
            UpdateStackErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateStackError {
    fn code(&self) -> Option<&str> {
        UpdateStackError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateStackError {
    pub fn new(kind: UpdateStackErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateStackErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateStackErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_insufficient_capabilities_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateStackErrorKind::InsufficientCapabilitiesError(_)
        )
    }
    pub fn is_token_already_exists_error(&self) -> bool {
        matches!(&self.kind, UpdateStackErrorKind::TokenAlreadyExistsError(_))
    }
}
impl std::error::Error for UpdateStackError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateStackErrorKind::InsufficientCapabilitiesError(_inner) => Some(_inner),
            UpdateStackErrorKind::TokenAlreadyExistsError(_inner) => Some(_inner),
            UpdateStackErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateStackInstancesError {
    pub kind: UpdateStackInstancesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateStackInstancesErrorKind {
    InvalidOperationError(crate::error::InvalidOperationError),
    OperationIdAlreadyExistsError(crate::error::OperationIdAlreadyExistsError),
    OperationInProgressError(crate::error::OperationInProgressError),
    StackInstanceNotFoundError(crate::error::StackInstanceNotFoundError),
    StackSetNotFoundError(crate::error::StackSetNotFoundError),
    StaleRequestError(crate::error::StaleRequestError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateStackInstancesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateStackInstancesErrorKind::InvalidOperationError(_inner) => _inner.fmt(f),
            UpdateStackInstancesErrorKind::OperationIdAlreadyExistsError(_inner) => _inner.fmt(f),
            UpdateStackInstancesErrorKind::OperationInProgressError(_inner) => _inner.fmt(f),
            UpdateStackInstancesErrorKind::StackInstanceNotFoundError(_inner) => _inner.fmt(f),
            UpdateStackInstancesErrorKind::StackSetNotFoundError(_inner) => _inner.fmt(f),
            UpdateStackInstancesErrorKind::StaleRequestError(_inner) => _inner.fmt(f),
            UpdateStackInstancesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateStackInstancesError {
    fn code(&self) -> Option<&str> {
        UpdateStackInstancesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateStackInstancesError {
    pub fn new(kind: UpdateStackInstancesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateStackInstancesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateStackInstancesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_operation_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateStackInstancesErrorKind::InvalidOperationError(_)
        )
    }
    pub fn is_operation_id_already_exists_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateStackInstancesErrorKind::OperationIdAlreadyExistsError(_)
        )
    }
    pub fn is_operation_in_progress_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateStackInstancesErrorKind::OperationInProgressError(_)
        )
    }
    pub fn is_stack_instance_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateStackInstancesErrorKind::StackInstanceNotFoundError(_)
        )
    }
    pub fn is_stack_set_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateStackInstancesErrorKind::StackSetNotFoundError(_)
        )
    }
    pub fn is_stale_request_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateStackInstancesErrorKind::StaleRequestError(_)
        )
    }
}
impl std::error::Error for UpdateStackInstancesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateStackInstancesErrorKind::InvalidOperationError(_inner) => Some(_inner),
            UpdateStackInstancesErrorKind::OperationIdAlreadyExistsError(_inner) => Some(_inner),
            UpdateStackInstancesErrorKind::OperationInProgressError(_inner) => Some(_inner),
            UpdateStackInstancesErrorKind::StackInstanceNotFoundError(_inner) => Some(_inner),
            UpdateStackInstancesErrorKind::StackSetNotFoundError(_inner) => Some(_inner),
            UpdateStackInstancesErrorKind::StaleRequestError(_inner) => Some(_inner),
            UpdateStackInstancesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateStackSetError {
    pub kind: UpdateStackSetErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateStackSetErrorKind {
    InvalidOperationError(crate::error::InvalidOperationError),
    OperationIdAlreadyExistsError(crate::error::OperationIdAlreadyExistsError),
    OperationInProgressError(crate::error::OperationInProgressError),
    StackInstanceNotFoundError(crate::error::StackInstanceNotFoundError),
    StackSetNotFoundError(crate::error::StackSetNotFoundError),
    StaleRequestError(crate::error::StaleRequestError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateStackSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateStackSetErrorKind::InvalidOperationError(_inner) => _inner.fmt(f),
            UpdateStackSetErrorKind::OperationIdAlreadyExistsError(_inner) => _inner.fmt(f),
            UpdateStackSetErrorKind::OperationInProgressError(_inner) => _inner.fmt(f),
            UpdateStackSetErrorKind::StackInstanceNotFoundError(_inner) => _inner.fmt(f),
            UpdateStackSetErrorKind::StackSetNotFoundError(_inner) => _inner.fmt(f),
            UpdateStackSetErrorKind::StaleRequestError(_inner) => _inner.fmt(f),
            UpdateStackSetErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateStackSetError {
    fn code(&self) -> Option<&str> {
        UpdateStackSetError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateStackSetError {
    pub fn new(kind: UpdateStackSetErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateStackSetErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateStackSetErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_operation_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateStackSetErrorKind::InvalidOperationError(_)
        )
    }
    pub fn is_operation_id_already_exists_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateStackSetErrorKind::OperationIdAlreadyExistsError(_)
        )
    }
    pub fn is_operation_in_progress_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateStackSetErrorKind::OperationInProgressError(_)
        )
    }
    pub fn is_stack_instance_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateStackSetErrorKind::StackInstanceNotFoundError(_)
        )
    }
    pub fn is_stack_set_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateStackSetErrorKind::StackSetNotFoundError(_)
        )
    }
    pub fn is_stale_request_error(&self) -> bool {
        matches!(&self.kind, UpdateStackSetErrorKind::StaleRequestError(_))
    }
}
impl std::error::Error for UpdateStackSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateStackSetErrorKind::InvalidOperationError(_inner) => Some(_inner),
            UpdateStackSetErrorKind::OperationIdAlreadyExistsError(_inner) => Some(_inner),
            UpdateStackSetErrorKind::OperationInProgressError(_inner) => Some(_inner),
            UpdateStackSetErrorKind::StackInstanceNotFoundError(_inner) => Some(_inner),
            UpdateStackSetErrorKind::StackSetNotFoundError(_inner) => Some(_inner),
            UpdateStackSetErrorKind::StaleRequestError(_inner) => Some(_inner),
            UpdateStackSetErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateTerminationProtectionError {
    pub kind: UpdateTerminationProtectionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateTerminationProtectionErrorKind {
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateTerminationProtectionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateTerminationProtectionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateTerminationProtectionError {
    fn code(&self) -> Option<&str> {
        UpdateTerminationProtectionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateTerminationProtectionError {
    pub fn new(kind: UpdateTerminationProtectionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateTerminationProtectionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateTerminationProtectionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for UpdateTerminationProtectionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateTerminationProtectionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ValidateTemplateError {
    pub kind: ValidateTemplateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ValidateTemplateErrorKind {
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ValidateTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ValidateTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ValidateTemplateError {
    fn code(&self) -> Option<&str> {
        ValidateTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ValidateTemplateError {
    pub fn new(kind: ValidateTemplateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ValidateTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ValidateTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for ValidateTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ValidateTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// <p>Another operation has been performed on this stack set since the specified operation
/// was performed. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StaleRequestError {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for StaleRequestError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StaleRequestError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl StaleRequestError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for StaleRequestError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "StaleRequestError [StaleRequestException]")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for StaleRequestError {}
/// See [`StaleRequestError`](crate::error::StaleRequestError)
pub mod stale_request_error {
    /// A builder for [`StaleRequestError`](crate::error::StaleRequestError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`StaleRequestError`](crate::error::StaleRequestError)
        pub fn build(self) -> crate::error::StaleRequestError {
            crate::error::StaleRequestError {
                message: self.message,
            }
        }
    }
}
impl StaleRequestError {
    /// Creates a new builder-style object to manufacture [`StaleRequestError`](crate::error::StaleRequestError)
    pub fn builder() -> crate::error::stale_request_error::Builder {
        crate::error::stale_request_error::Builder::default()
    }
}

/// <p>The specified stack set doesn't exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StackSetNotFoundError {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for StackSetNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StackSetNotFoundError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl StackSetNotFoundError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for StackSetNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "StackSetNotFoundError [StackSetNotFoundException]")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for StackSetNotFoundError {}
/// See [`StackSetNotFoundError`](crate::error::StackSetNotFoundError)
pub mod stack_set_not_found_error {
    /// A builder for [`StackSetNotFoundError`](crate::error::StackSetNotFoundError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`StackSetNotFoundError`](crate::error::StackSetNotFoundError)
        pub fn build(self) -> crate::error::StackSetNotFoundError {
            crate::error::StackSetNotFoundError {
                message: self.message,
            }
        }
    }
}
impl StackSetNotFoundError {
    /// Creates a new builder-style object to manufacture [`StackSetNotFoundError`](crate::error::StackSetNotFoundError)
    pub fn builder() -> crate::error::stack_set_not_found_error::Builder {
        crate::error::stack_set_not_found_error::Builder::default()
    }
}

/// <p>The specified stack instance doesn't exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StackInstanceNotFoundError {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for StackInstanceNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StackInstanceNotFoundError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl StackInstanceNotFoundError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for StackInstanceNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "StackInstanceNotFoundError [StackInstanceNotFoundException]"
        )?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for StackInstanceNotFoundError {}
/// See [`StackInstanceNotFoundError`](crate::error::StackInstanceNotFoundError)
pub mod stack_instance_not_found_error {
    /// A builder for [`StackInstanceNotFoundError`](crate::error::StackInstanceNotFoundError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`StackInstanceNotFoundError`](crate::error::StackInstanceNotFoundError)
        pub fn build(self) -> crate::error::StackInstanceNotFoundError {
            crate::error::StackInstanceNotFoundError {
                message: self.message,
            }
        }
    }
}
impl StackInstanceNotFoundError {
    /// Creates a new builder-style object to manufacture [`StackInstanceNotFoundError`](crate::error::StackInstanceNotFoundError)
    pub fn builder() -> crate::error::stack_instance_not_found_error::Builder {
        crate::error::stack_instance_not_found_error::Builder::default()
    }
}

/// <p>Another operation is currently in progress for this stack set. Only one operation can
/// be performed for a stack set at a given time.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct OperationInProgressError {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for OperationInProgressError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OperationInProgressError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl OperationInProgressError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for OperationInProgressError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "OperationInProgressError [OperationInProgressException]")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for OperationInProgressError {}
/// See [`OperationInProgressError`](crate::error::OperationInProgressError)
pub mod operation_in_progress_error {
    /// A builder for [`OperationInProgressError`](crate::error::OperationInProgressError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`OperationInProgressError`](crate::error::OperationInProgressError)
        pub fn build(self) -> crate::error::OperationInProgressError {
            crate::error::OperationInProgressError {
                message: self.message,
            }
        }
    }
}
impl OperationInProgressError {
    /// Creates a new builder-style object to manufacture [`OperationInProgressError`](crate::error::OperationInProgressError)
    pub fn builder() -> crate::error::operation_in_progress_error::Builder {
        crate::error::operation_in_progress_error::Builder::default()
    }
}

/// <p>The specified operation ID already exists.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct OperationIdAlreadyExistsError {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for OperationIdAlreadyExistsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OperationIdAlreadyExistsError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl OperationIdAlreadyExistsError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for OperationIdAlreadyExistsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "OperationIdAlreadyExistsError [OperationIdAlreadyExistsException]"
        )?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for OperationIdAlreadyExistsError {}
/// See [`OperationIdAlreadyExistsError`](crate::error::OperationIdAlreadyExistsError)
pub mod operation_id_already_exists_error {
    /// A builder for [`OperationIdAlreadyExistsError`](crate::error::OperationIdAlreadyExistsError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`OperationIdAlreadyExistsError`](crate::error::OperationIdAlreadyExistsError)
        pub fn build(self) -> crate::error::OperationIdAlreadyExistsError {
            crate::error::OperationIdAlreadyExistsError {
                message: self.message,
            }
        }
    }
}
impl OperationIdAlreadyExistsError {
    /// Creates a new builder-style object to manufacture [`OperationIdAlreadyExistsError`](crate::error::OperationIdAlreadyExistsError)
    pub fn builder() -> crate::error::operation_id_already_exists_error::Builder {
        crate::error::operation_id_already_exists_error::Builder::default()
    }
}

/// <p>The specified operation isn't valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidOperationError {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidOperationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidOperationError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidOperationError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidOperationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidOperationError [InvalidOperationException]")?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidOperationError {}
/// See [`InvalidOperationError`](crate::error::InvalidOperationError)
pub mod invalid_operation_error {
    /// A builder for [`InvalidOperationError`](crate::error::InvalidOperationError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidOperationError`](crate::error::InvalidOperationError)
        pub fn build(self) -> crate::error::InvalidOperationError {
            crate::error::InvalidOperationError {
                message: self.message,
            }
        }
    }
}
impl InvalidOperationError {
    /// Creates a new builder-style object to manufacture [`InvalidOperationError`](crate::error::InvalidOperationError)
    pub fn builder() -> crate::error::invalid_operation_error::Builder {
        crate::error::invalid_operation_error::Builder::default()
    }
}

/// <p>A client request token already exists.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TokenAlreadyExistsError {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TokenAlreadyExistsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TokenAlreadyExistsError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TokenAlreadyExistsError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TokenAlreadyExistsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TokenAlreadyExistsError [TokenAlreadyExistsException]")?;
        if let Some(inner_7) = &self.message {
            write!(f, ": {}", inner_7)?;
        }
        Ok(())
    }
}
impl std::error::Error for TokenAlreadyExistsError {}
/// See [`TokenAlreadyExistsError`](crate::error::TokenAlreadyExistsError)
pub mod token_already_exists_error {
    /// A builder for [`TokenAlreadyExistsError`](crate::error::TokenAlreadyExistsError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`TokenAlreadyExistsError`](crate::error::TokenAlreadyExistsError)
        pub fn build(self) -> crate::error::TokenAlreadyExistsError {
            crate::error::TokenAlreadyExistsError {
                message: self.message,
            }
        }
    }
}
impl TokenAlreadyExistsError {
    /// Creates a new builder-style object to manufacture [`TokenAlreadyExistsError`](crate::error::TokenAlreadyExistsError)
    pub fn builder() -> crate::error::token_already_exists_error::Builder {
        crate::error::token_already_exists_error::Builder::default()
    }
}

/// <p>The template contains resources with capabilities that weren't specified in the
/// Capabilities parameter.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InsufficientCapabilitiesError {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InsufficientCapabilitiesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InsufficientCapabilitiesError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InsufficientCapabilitiesError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InsufficientCapabilitiesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "InsufficientCapabilitiesError [InsufficientCapabilitiesException]"
        )?;
        if let Some(inner_8) = &self.message {
            write!(f, ": {}", inner_8)?;
        }
        Ok(())
    }
}
impl std::error::Error for InsufficientCapabilitiesError {}
/// See [`InsufficientCapabilitiesError`](crate::error::InsufficientCapabilitiesError)
pub mod insufficient_capabilities_error {
    /// A builder for [`InsufficientCapabilitiesError`](crate::error::InsufficientCapabilitiesError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InsufficientCapabilitiesError`](crate::error::InsufficientCapabilitiesError)
        pub fn build(self) -> crate::error::InsufficientCapabilitiesError {
            crate::error::InsufficientCapabilitiesError {
                message: self.message,
            }
        }
    }
}
impl InsufficientCapabilitiesError {
    /// Creates a new builder-style object to manufacture [`InsufficientCapabilitiesError`](crate::error::InsufficientCapabilitiesError)
    pub fn builder() -> crate::error::insufficient_capabilities_error::Builder {
        crate::error::insufficient_capabilities_error::Builder::default()
    }
}

/// <p>The specified ID refers to an operation that doesn't exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct OperationNotFoundError {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for OperationNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OperationNotFoundError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl OperationNotFoundError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for OperationNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "OperationNotFoundError [OperationNotFoundException]")?;
        if let Some(inner_9) = &self.message {
            write!(f, ": {}", inner_9)?;
        }
        Ok(())
    }
}
impl std::error::Error for OperationNotFoundError {}
/// See [`OperationNotFoundError`](crate::error::OperationNotFoundError)
pub mod operation_not_found_error {
    /// A builder for [`OperationNotFoundError`](crate::error::OperationNotFoundError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`OperationNotFoundError`](crate::error::OperationNotFoundError)
        pub fn build(self) -> crate::error::OperationNotFoundError {
            crate::error::OperationNotFoundError {
                message: self.message,
            }
        }
    }
}
impl OperationNotFoundError {
    /// Creates a new builder-style object to manufacture [`OperationNotFoundError`](crate::error::OperationNotFoundError)
    pub fn builder() -> crate::error::operation_not_found_error::Builder {
        crate::error::operation_not_found_error::Builder::default()
    }
}

/// <p>The specified type does not exist in the CloudFormation registry.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TypeNotFoundError {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TypeNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TypeNotFoundError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TypeNotFoundError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TypeNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TypeNotFoundError [TypeNotFoundException]")?;
        if let Some(inner_10) = &self.message {
            write!(f, ": {}", inner_10)?;
        }
        Ok(())
    }
}
impl std::error::Error for TypeNotFoundError {}
/// See [`TypeNotFoundError`](crate::error::TypeNotFoundError)
pub mod type_not_found_error {
    /// A builder for [`TypeNotFoundError`](crate::error::TypeNotFoundError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`TypeNotFoundError`](crate::error::TypeNotFoundError)
        pub fn build(self) -> crate::error::TypeNotFoundError {
            crate::error::TypeNotFoundError {
                message: self.message,
            }
        }
    }
}
impl TypeNotFoundError {
    /// Creates a new builder-style object to manufacture [`TypeNotFoundError`](crate::error::TypeNotFoundError)
    pub fn builder() -> crate::error::type_not_found_error::Builder {
        crate::error::type_not_found_error::Builder::default()
    }
}

/// <p>An error occurred during a CloudFormation registry operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CFNRegistryError {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CFNRegistryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CFNRegistryError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CFNRegistryError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CFNRegistryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CFNRegistryError [CFNRegistryException]")?;
        if let Some(inner_11) = &self.message {
            write!(f, ": {}", inner_11)?;
        }
        Ok(())
    }
}
impl std::error::Error for CFNRegistryError {}
/// See [`CFNRegistryError`](crate::error::CFNRegistryError)
pub mod cfn_registry_error {
    /// A builder for [`CFNRegistryError`](crate::error::CFNRegistryError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CFNRegistryError`](crate::error::CFNRegistryError)
        pub fn build(self) -> crate::error::CFNRegistryError {
            crate::error::CFNRegistryError {
                message: self.message,
            }
        }
    }
}
impl CFNRegistryError {
    /// Creates a new builder-style object to manufacture [`CFNRegistryError`](crate::error::CFNRegistryError)
    pub fn builder() -> crate::error::cfn_registry_error::Builder {
        crate::error::cfn_registry_error::Builder::default()
    }
}

/// <p>Error reserved for use by the <a href="https://docs.aws.amazon.com/cloudformation-cli/latest/userguide/what-is-cloudformation-cli.html">CloudFormation CLI</a>. CloudFormation does not return this error to users.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct OperationStatusCheckFailedError {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for OperationStatusCheckFailedError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OperationStatusCheckFailedError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl OperationStatusCheckFailedError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for OperationStatusCheckFailedError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "OperationStatusCheckFailedError [OperationStatusCheckFailedException]"
        )?;
        if let Some(inner_12) = &self.message {
            write!(f, ": {}", inner_12)?;
        }
        Ok(())
    }
}
impl std::error::Error for OperationStatusCheckFailedError {}
/// See [`OperationStatusCheckFailedError`](crate::error::OperationStatusCheckFailedError)
pub mod operation_status_check_failed_error {
    /// A builder for [`OperationStatusCheckFailedError`](crate::error::OperationStatusCheckFailedError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`OperationStatusCheckFailedError`](crate::error::OperationStatusCheckFailedError)
        pub fn build(self) -> crate::error::OperationStatusCheckFailedError {
            crate::error::OperationStatusCheckFailedError {
                message: self.message,
            }
        }
    }
}
impl OperationStatusCheckFailedError {
    /// Creates a new builder-style object to manufacture [`OperationStatusCheckFailedError`](crate::error::OperationStatusCheckFailedError)
    pub fn builder() -> crate::error::operation_status_check_failed_error::Builder {
        crate::error::operation_status_check_failed_error::Builder::default()
    }
}

/// <p>Error reserved for use by the <a href="https://docs.aws.amazon.com/cloudformation-cli/latest/userguide/what-is-cloudformation-cli.html">CloudFormation CLI</a>. CloudFormation does not return this error to users.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidStateTransitionError {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidStateTransitionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidStateTransitionError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidStateTransitionError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidStateTransitionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "InvalidStateTransitionError [InvalidStateTransitionException]"
        )?;
        if let Some(inner_13) = &self.message {
            write!(f, ": {}", inner_13)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidStateTransitionError {}
/// See [`InvalidStateTransitionError`](crate::error::InvalidStateTransitionError)
pub mod invalid_state_transition_error {
    /// A builder for [`InvalidStateTransitionError`](crate::error::InvalidStateTransitionError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidStateTransitionError`](crate::error::InvalidStateTransitionError)
        pub fn build(self) -> crate::error::InvalidStateTransitionError {
            crate::error::InvalidStateTransitionError {
                message: self.message,
            }
        }
    }
}
impl InvalidStateTransitionError {
    /// Creates a new builder-style object to manufacture [`InvalidStateTransitionError`](crate::error::InvalidStateTransitionError)
    pub fn builder() -> crate::error::invalid_state_transition_error::Builder {
        crate::error::invalid_state_transition_error::Builder::default()
    }
}

/// <p>The specified change set name or ID doesn't exit. To view valid change sets for a
/// stack, use the <code>ListChangeSets</code> action.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ChangeSetNotFoundError {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ChangeSetNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ChangeSetNotFoundError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ChangeSetNotFoundError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ChangeSetNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ChangeSetNotFoundError [ChangeSetNotFoundException]")?;
        if let Some(inner_14) = &self.message {
            write!(f, ": {}", inner_14)?;
        }
        Ok(())
    }
}
impl std::error::Error for ChangeSetNotFoundError {}
/// See [`ChangeSetNotFoundError`](crate::error::ChangeSetNotFoundError)
pub mod change_set_not_found_error {
    /// A builder for [`ChangeSetNotFoundError`](crate::error::ChangeSetNotFoundError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ChangeSetNotFoundError`](crate::error::ChangeSetNotFoundError)
        pub fn build(self) -> crate::error::ChangeSetNotFoundError {
            crate::error::ChangeSetNotFoundError {
                message: self.message,
            }
        }
    }
}
impl ChangeSetNotFoundError {
    /// Creates a new builder-style object to manufacture [`ChangeSetNotFoundError`](crate::error::ChangeSetNotFoundError)
    pub fn builder() -> crate::error::change_set_not_found_error::Builder {
        crate::error::change_set_not_found_error::Builder::default()
    }
}

/// <p>The specified change set can't be used to update the stack. For example, the change
/// set status might be <code>CREATE_IN_PROGRESS</code>, or the stack status might be
/// <code>UPDATE_IN_PROGRESS</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidChangeSetStatusError {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidChangeSetStatusError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidChangeSetStatusError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidChangeSetStatusError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidChangeSetStatusError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "InvalidChangeSetStatusError [InvalidChangeSetStatusException]"
        )?;
        if let Some(inner_15) = &self.message {
            write!(f, ": {}", inner_15)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidChangeSetStatusError {}
/// See [`InvalidChangeSetStatusError`](crate::error::InvalidChangeSetStatusError)
pub mod invalid_change_set_status_error {
    /// A builder for [`InvalidChangeSetStatusError`](crate::error::InvalidChangeSetStatusError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidChangeSetStatusError`](crate::error::InvalidChangeSetStatusError)
        pub fn build(self) -> crate::error::InvalidChangeSetStatusError {
            crate::error::InvalidChangeSetStatusError {
                message: self.message,
            }
        }
    }
}
impl InvalidChangeSetStatusError {
    /// Creates a new builder-style object to manufacture [`InvalidChangeSetStatusError`](crate::error::InvalidChangeSetStatusError)
    pub fn builder() -> crate::error::invalid_change_set_status_error::Builder {
        crate::error::invalid_change_set_status_error::Builder::default()
    }
}

/// <p>You can't yet delete this stack set, because it still contains one or more stack
/// instances. Delete all stack instances from the stack set before deleting the stack
/// set.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StackSetNotEmptyError {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for StackSetNotEmptyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StackSetNotEmptyError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl StackSetNotEmptyError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for StackSetNotEmptyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "StackSetNotEmptyError [StackSetNotEmptyException]")?;
        if let Some(inner_16) = &self.message {
            write!(f, ": {}", inner_16)?;
        }
        Ok(())
    }
}
impl std::error::Error for StackSetNotEmptyError {}
/// See [`StackSetNotEmptyError`](crate::error::StackSetNotEmptyError)
pub mod stack_set_not_empty_error {
    /// A builder for [`StackSetNotEmptyError`](crate::error::StackSetNotEmptyError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`StackSetNotEmptyError`](crate::error::StackSetNotEmptyError)
        pub fn build(self) -> crate::error::StackSetNotEmptyError {
            crate::error::StackSetNotEmptyError {
                message: self.message,
            }
        }
    }
}
impl StackSetNotEmptyError {
    /// Creates a new builder-style object to manufacture [`StackSetNotEmptyError`](crate::error::StackSetNotEmptyError)
    pub fn builder() -> crate::error::stack_set_not_empty_error::Builder {
        crate::error::stack_set_not_empty_error::Builder::default()
    }
}

/// <p>The specified name is already in use.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NameAlreadyExistsError {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NameAlreadyExistsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NameAlreadyExistsError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl NameAlreadyExistsError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NameAlreadyExistsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NameAlreadyExistsError [NameAlreadyExistsException]")?;
        if let Some(inner_17) = &self.message {
            write!(f, ": {}", inner_17)?;
        }
        Ok(())
    }
}
impl std::error::Error for NameAlreadyExistsError {}
/// See [`NameAlreadyExistsError`](crate::error::NameAlreadyExistsError)
pub mod name_already_exists_error {
    /// A builder for [`NameAlreadyExistsError`](crate::error::NameAlreadyExistsError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`NameAlreadyExistsError`](crate::error::NameAlreadyExistsError)
        pub fn build(self) -> crate::error::NameAlreadyExistsError {
            crate::error::NameAlreadyExistsError {
                message: self.message,
            }
        }
    }
}
impl NameAlreadyExistsError {
    /// Creates a new builder-style object to manufacture [`NameAlreadyExistsError`](crate::error::NameAlreadyExistsError)
    pub fn builder() -> crate::error::name_already_exists_error::Builder {
        crate::error::name_already_exists_error::Builder::default()
    }
}

/// <p>The quota for the resource has already been reached.</p>
/// <p>For information on resource and stack limitations, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/cloudformation-limits.html">Limits</a> in
/// the <i>AWS CloudFormation User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LimitExceededError {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LimitExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LimitExceededError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl LimitExceededError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for LimitExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "LimitExceededError [LimitExceededException]")?;
        if let Some(inner_18) = &self.message {
            write!(f, ": {}", inner_18)?;
        }
        Ok(())
    }
}
impl std::error::Error for LimitExceededError {}
/// See [`LimitExceededError`](crate::error::LimitExceededError)
pub mod limit_exceeded_error {
    /// A builder for [`LimitExceededError`](crate::error::LimitExceededError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`LimitExceededError`](crate::error::LimitExceededError)
        pub fn build(self) -> crate::error::LimitExceededError {
            crate::error::LimitExceededError {
                message: self.message,
            }
        }
    }
}
impl LimitExceededError {
    /// Creates a new builder-style object to manufacture [`LimitExceededError`](crate::error::LimitExceededError)
    pub fn builder() -> crate::error::limit_exceeded_error::Builder {
        crate::error::limit_exceeded_error::Builder::default()
    }
}

/// <p>The specified resource exists, but has been changed.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreatedButModifiedError {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreatedButModifiedError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreatedButModifiedError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CreatedButModifiedError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CreatedButModifiedError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CreatedButModifiedError [CreatedButModifiedException]")?;
        if let Some(inner_19) = &self.message {
            write!(f, ": {}", inner_19)?;
        }
        Ok(())
    }
}
impl std::error::Error for CreatedButModifiedError {}
/// See [`CreatedButModifiedError`](crate::error::CreatedButModifiedError)
pub mod created_but_modified_error {
    /// A builder for [`CreatedButModifiedError`](crate::error::CreatedButModifiedError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CreatedButModifiedError`](crate::error::CreatedButModifiedError)
        pub fn build(self) -> crate::error::CreatedButModifiedError {
            crate::error::CreatedButModifiedError {
                message: self.message,
            }
        }
    }
}
impl CreatedButModifiedError {
    /// Creates a new builder-style object to manufacture [`CreatedButModifiedError`](crate::error::CreatedButModifiedError)
    pub fn builder() -> crate::error::created_but_modified_error::Builder {
        crate::error::created_but_modified_error::Builder::default()
    }
}

/// <p>The resource with the name requested already exists.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AlreadyExistsError {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AlreadyExistsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AlreadyExistsError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl AlreadyExistsError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AlreadyExistsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AlreadyExistsError [AlreadyExistsException]")?;
        if let Some(inner_20) = &self.message {
            write!(f, ": {}", inner_20)?;
        }
        Ok(())
    }
}
impl std::error::Error for AlreadyExistsError {}
/// See [`AlreadyExistsError`](crate::error::AlreadyExistsError)
pub mod already_exists_error {
    /// A builder for [`AlreadyExistsError`](crate::error::AlreadyExistsError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`AlreadyExistsError`](crate::error::AlreadyExistsError)
        pub fn build(self) -> crate::error::AlreadyExistsError {
            crate::error::AlreadyExistsError {
                message: self.message,
            }
        }
    }
}
impl AlreadyExistsError {
    /// Creates a new builder-style object to manufacture [`AlreadyExistsError`](crate::error::AlreadyExistsError)
    pub fn builder() -> crate::error::already_exists_error::Builder {
        crate::error::already_exists_error::Builder::default()
    }
}
