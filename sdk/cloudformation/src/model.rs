// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Capability {
    CapabilityAutoExpand,
    CapabilityIam,
    CapabilityNamedIam,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for Capability {
    fn from(s: &str) -> Self {
        match s {
            "CAPABILITY_AUTO_EXPAND" => Capability::CapabilityAutoExpand,
            "CAPABILITY_IAM" => Capability::CapabilityIam,
            "CAPABILITY_NAMED_IAM" => Capability::CapabilityNamedIam,
            other => Capability::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for Capability {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(Capability::from(s))
    }
}
impl Capability {
    pub fn as_str(&self) -> &str {
        match self {
            Capability::CapabilityAutoExpand => "CAPABILITY_AUTO_EXPAND",
            Capability::CapabilityIam => "CAPABILITY_IAM",
            Capability::CapabilityNamedIam => "CAPABILITY_NAMED_IAM",
            Capability::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for Capability {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for Capability {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>The TemplateParameter data type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TemplateParameter {
    /// <p>The name associated with the parameter.</p>
    pub parameter_key: std::option::Option<std::string::String>,
    /// <p>The default value associated with the parameter.</p>
    pub default_value: std::option::Option<std::string::String>,
    /// <p>Flag indicating whether the parameter should be displayed as plain text in logs and
    /// UIs.</p>
    pub no_echo: std::option::Option<bool>,
    /// <p>User defined description associated with the parameter.</p>
    pub description: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TemplateParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TemplateParameter");
        formatter.field("parameter_key", &self.parameter_key);
        formatter.field("default_value", &self.default_value);
        formatter.field("no_echo", &self.no_echo);
        formatter.field("description", &self.description);
        formatter.finish()
    }
}
/// See [`TemplateParameter`](crate::model::TemplateParameter)
pub mod template_parameter {
    /// A builder for [`TemplateParameter`](crate::model::TemplateParameter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) parameter_key: std::option::Option<std::string::String>,
        pub(crate) default_value: std::option::Option<std::string::String>,
        pub(crate) no_echo: std::option::Option<bool>,
        pub(crate) description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name associated with the parameter.</p>
        pub fn parameter_key(mut self, inp: impl Into<std::string::String>) -> Self {
            self.parameter_key = Some(inp.into());
            self
        }
        pub fn set_parameter_key(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.parameter_key = inp;
            self
        }
        /// <p>The default value associated with the parameter.</p>
        pub fn default_value(mut self, inp: impl Into<std::string::String>) -> Self {
            self.default_value = Some(inp.into());
            self
        }
        pub fn set_default_value(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.default_value = inp;
            self
        }
        /// <p>Flag indicating whether the parameter should be displayed as plain text in logs and
        /// UIs.</p>
        pub fn no_echo(mut self, inp: bool) -> Self {
            self.no_echo = Some(inp);
            self
        }
        pub fn set_no_echo(mut self, inp: std::option::Option<bool>) -> Self {
            self.no_echo = inp;
            self
        }
        /// <p>User defined description associated with the parameter.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.description = Some(inp.into());
            self
        }
        pub fn set_description(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.description = inp;
            self
        }
        /// Consumes the builder and constructs a [`TemplateParameter`](crate::model::TemplateParameter)
        pub fn build(self) -> crate::model::TemplateParameter {
            crate::model::TemplateParameter {
                parameter_key: self.parameter_key,
                default_value: self.default_value,
                no_echo: self.no_echo,
                description: self.description,
            }
        }
    }
}
impl TemplateParameter {
    /// Creates a new builder-style object to manufacture [`TemplateParameter`](crate::model::TemplateParameter)
    pub fn builder() -> crate::model::template_parameter::Builder {
        crate::model::template_parameter::Builder::default()
    }
}

/// **NOTE:** `CallAs::Self` has been renamed to `::SelfValue`.
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CallAs {
    DelegatedAdmin,
    /// **NOTE:** `::Self` has been renamed to `::SelfValue`.
    SelfValue,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for CallAs {
    fn from(s: &str) -> Self {
        match s {
            "DELEGATED_ADMIN" => CallAs::DelegatedAdmin,
            "SELF" => CallAs::SelfValue,
            other => CallAs::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for CallAs {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(CallAs::from(s))
    }
}
impl CallAs {
    pub fn as_str(&self) -> &str {
        match self {
            CallAs::DelegatedAdmin => "DELEGATED_ADMIN",
            CallAs::SelfValue => "SELF",
            CallAs::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for CallAs {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for CallAs {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>[Service-managed permissions] Describes whether StackSets automatically deploys to AWS Organizations accounts that are added to a target organization or organizational unit (OU).</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AutoDeployment {
    /// <p>If set to <code>true</code>, StackSets automatically deploys additional stack instances to AWS Organizations accounts that are added to a target organization or organizational unit (OU) in the specified Regions. If an account is removed from a target organization or OU, StackSets deletes stack instances from the account in the specified Regions.</p>
    pub enabled: std::option::Option<bool>,
    /// <p>If set to <code>true</code>, stack resources are retained when an account is removed from a target organization or OU. If set to <code>false</code>, stack resources are deleted. Specify only if <code>Enabled</code> is set to <code>True</code>.</p>
    pub retain_stacks_on_account_removal: std::option::Option<bool>,
}
impl std::fmt::Debug for AutoDeployment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AutoDeployment");
        formatter.field("enabled", &self.enabled);
        formatter.field(
            "retain_stacks_on_account_removal",
            &self.retain_stacks_on_account_removal,
        );
        formatter.finish()
    }
}
/// See [`AutoDeployment`](crate::model::AutoDeployment)
pub mod auto_deployment {
    /// A builder for [`AutoDeployment`](crate::model::AutoDeployment)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enabled: std::option::Option<bool>,
        pub(crate) retain_stacks_on_account_removal: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>If set to <code>true</code>, StackSets automatically deploys additional stack instances to AWS Organizations accounts that are added to a target organization or organizational unit (OU) in the specified Regions. If an account is removed from a target organization or OU, StackSets deletes stack instances from the account in the specified Regions.</p>
        pub fn enabled(mut self, inp: bool) -> Self {
            self.enabled = Some(inp);
            self
        }
        pub fn set_enabled(mut self, inp: std::option::Option<bool>) -> Self {
            self.enabled = inp;
            self
        }
        /// <p>If set to <code>true</code>, stack resources are retained when an account is removed from a target organization or OU. If set to <code>false</code>, stack resources are deleted. Specify only if <code>Enabled</code> is set to <code>True</code>.</p>
        pub fn retain_stacks_on_account_removal(mut self, inp: bool) -> Self {
            self.retain_stacks_on_account_removal = Some(inp);
            self
        }
        pub fn set_retain_stacks_on_account_removal(
            mut self,
            inp: std::option::Option<bool>,
        ) -> Self {
            self.retain_stacks_on_account_removal = inp;
            self
        }
        /// Consumes the builder and constructs a [`AutoDeployment`](crate::model::AutoDeployment)
        pub fn build(self) -> crate::model::AutoDeployment {
            crate::model::AutoDeployment {
                enabled: self.enabled,
                retain_stacks_on_account_removal: self.retain_stacks_on_account_removal,
            }
        }
    }
}
impl AutoDeployment {
    /// Creates a new builder-style object to manufacture [`AutoDeployment`](crate::model::AutoDeployment)
    pub fn builder() -> crate::model::auto_deployment::Builder {
        crate::model::auto_deployment::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PermissionModels {
    SelfManaged,
    ServiceManaged,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for PermissionModels {
    fn from(s: &str) -> Self {
        match s {
            "SELF_MANAGED" => PermissionModels::SelfManaged,
            "SERVICE_MANAGED" => PermissionModels::ServiceManaged,
            other => PermissionModels::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for PermissionModels {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(PermissionModels::from(s))
    }
}
impl PermissionModels {
    pub fn as_str(&self) -> &str {
        match self {
            PermissionModels::SelfManaged => "SELF_MANAGED",
            PermissionModels::ServiceManaged => "SERVICE_MANAGED",
            PermissionModels::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for PermissionModels {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for PermissionModels {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>[Service-managed permissions] The AWS Organizations accounts to which StackSets deploys. StackSets does not deploy stack instances to the organization management account, even if the organization management account is in your organization or in an OU in your organization.</p>
/// <p>For update operations, you can specify either <code>Accounts</code> or <code>OrganizationalUnitIds</code>. For create and delete operations, specify <code>OrganizationalUnitIds</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeploymentTargets {
    /// <p>The names of one or more AWS accounts for which you want to deploy stack set updates.</p>
    pub accounts: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Returns the value of the AccountsUrl property.</p>
    pub accounts_url: std::option::Option<std::string::String>,
    /// <p>The organization root ID or organizational unit (OU) IDs to which StackSets deploys.</p>
    pub organizational_unit_ids: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for DeploymentTargets {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeploymentTargets");
        formatter.field("accounts", &self.accounts);
        formatter.field("accounts_url", &self.accounts_url);
        formatter.field("organizational_unit_ids", &self.organizational_unit_ids);
        formatter.finish()
    }
}
/// See [`DeploymentTargets`](crate::model::DeploymentTargets)
pub mod deployment_targets {
    /// A builder for [`DeploymentTargets`](crate::model::DeploymentTargets)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) accounts: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) accounts_url: std::option::Option<std::string::String>,
        pub(crate) organizational_unit_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        pub fn accounts(mut self, inp: impl Into<std::string::String>) -> Self {
            let mut v = self.accounts.unwrap_or_default();
            v.push(inp.into());
            self.accounts = Some(v);
            self
        }
        pub fn set_accounts(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.accounts = inp;
            self
        }
        /// <p>Returns the value of the AccountsUrl property.</p>
        pub fn accounts_url(mut self, inp: impl Into<std::string::String>) -> Self {
            self.accounts_url = Some(inp.into());
            self
        }
        pub fn set_accounts_url(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.accounts_url = inp;
            self
        }
        pub fn organizational_unit_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            let mut v = self.organizational_unit_ids.unwrap_or_default();
            v.push(inp.into());
            self.organizational_unit_ids = Some(v);
            self
        }
        pub fn set_organizational_unit_ids(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.organizational_unit_ids = inp;
            self
        }
        /// Consumes the builder and constructs a [`DeploymentTargets`](crate::model::DeploymentTargets)
        pub fn build(self) -> crate::model::DeploymentTargets {
            crate::model::DeploymentTargets {
                accounts: self.accounts,
                accounts_url: self.accounts_url,
                organizational_unit_ids: self.organizational_unit_ids,
            }
        }
    }
}
impl DeploymentTargets {
    /// Creates a new builder-style object to manufacture [`DeploymentTargets`](crate::model::DeploymentTargets)
    pub fn builder() -> crate::model::deployment_targets::Builder {
        crate::model::deployment_targets::Builder::default()
    }
}

/// <p>The user-specified preferences for how AWS CloudFormation performs a stack set
/// operation. </p>
/// <p>For more information on maximum concurrent accounts and failure tolerance, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacksets-concepts.html#stackset-ops-options">Stack set operation options</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StackSetOperationPreferences {
    /// <p>The concurrency type of deploying StackSets operations in regions, could be in parallel or one region at a time.</p>
    pub region_concurrency_type: std::option::Option<crate::model::RegionConcurrencyType>,
    /// <p>The order of the Regions in where you want to perform the stack operation.</p>
    pub region_order: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The number of accounts, per Region, for which this operation can fail before AWS
    /// CloudFormation stops the operation in that Region. If the operation is stopped in a Region,
    /// AWS CloudFormation doesn't attempt the operation in any subsequent Regions.</p>
    /// <p>Conditional: You must specify either <code>FailureToleranceCount</code> or
    /// <code>FailureTolerancePercentage</code> (but not both).</p>
    pub failure_tolerance_count: std::option::Option<i32>,
    /// <p>The percentage of accounts, per Region, for which this stack operation can fail
    /// before AWS CloudFormation stops the operation in that Region. If the operation is stopped
    /// in a Region, AWS CloudFormation doesn't attempt the operation in any subsequent
    /// Regions.</p>
    /// <p>When calculating the number of accounts based on the specified percentage, AWS
    /// CloudFormation rounds <i>down</i> to the next whole number.</p>
    /// <p>Conditional: You must specify either <code>FailureToleranceCount</code> or
    /// <code>FailureTolerancePercentage</code>, but not both.</p>
    pub failure_tolerance_percentage: std::option::Option<i32>,
    /// <p>The maximum number of accounts in which to perform this operation at one time. This
    /// is dependent on the value of
    /// <code>FailureToleranceCount</code>. <code>MaxConcurrentCount</code> is at most one more
    /// than the <code>FailureToleranceCount</code>.</p>
    /// <p>Note that this setting lets you specify the <i>maximum</i> for
    /// operations. For large deployments, under certain circumstances the actual number of
    /// accounts acted upon concurrently may be lower due to service throttling.</p>
    /// <p>Conditional: You must specify either <code>MaxConcurrentCount</code> or
    /// <code>MaxConcurrentPercentage</code>, but not both.</p>
    pub max_concurrent_count: std::option::Option<i32>,
    /// <p>The maximum percentage of accounts in which to perform this operation at one
    /// time.</p>
    /// <p>When calculating the number of accounts based on the specified percentage, AWS
    /// CloudFormation rounds down to the next whole number. This is true except in cases where
    /// rounding down would result is zero. In this case, CloudFormation sets the number as one
    /// instead.</p>
    /// <p>Note that this setting lets you specify the <i>maximum</i> for
    /// operations. For large deployments, under certain circumstances the actual number of
    /// accounts acted upon concurrently may be lower due to service throttling.</p>
    /// <p>Conditional: You must specify either <code>MaxConcurrentCount</code> or
    /// <code>MaxConcurrentPercentage</code>, but not both.</p>
    pub max_concurrent_percentage: std::option::Option<i32>,
}
impl std::fmt::Debug for StackSetOperationPreferences {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StackSetOperationPreferences");
        formatter.field("region_concurrency_type", &self.region_concurrency_type);
        formatter.field("region_order", &self.region_order);
        formatter.field("failure_tolerance_count", &self.failure_tolerance_count);
        formatter.field(
            "failure_tolerance_percentage",
            &self.failure_tolerance_percentage,
        );
        formatter.field("max_concurrent_count", &self.max_concurrent_count);
        formatter.field("max_concurrent_percentage", &self.max_concurrent_percentage);
        formatter.finish()
    }
}
/// See [`StackSetOperationPreferences`](crate::model::StackSetOperationPreferences)
pub mod stack_set_operation_preferences {
    /// A builder for [`StackSetOperationPreferences`](crate::model::StackSetOperationPreferences)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) region_concurrency_type:
            std::option::Option<crate::model::RegionConcurrencyType>,
        pub(crate) region_order: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) failure_tolerance_count: std::option::Option<i32>,
        pub(crate) failure_tolerance_percentage: std::option::Option<i32>,
        pub(crate) max_concurrent_count: std::option::Option<i32>,
        pub(crate) max_concurrent_percentage: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The concurrency type of deploying StackSets operations in regions, could be in parallel or one region at a time.</p>
        pub fn region_concurrency_type(mut self, inp: crate::model::RegionConcurrencyType) -> Self {
            self.region_concurrency_type = Some(inp);
            self
        }
        pub fn set_region_concurrency_type(
            mut self,
            inp: std::option::Option<crate::model::RegionConcurrencyType>,
        ) -> Self {
            self.region_concurrency_type = inp;
            self
        }
        pub fn region_order(mut self, inp: impl Into<std::string::String>) -> Self {
            let mut v = self.region_order.unwrap_or_default();
            v.push(inp.into());
            self.region_order = Some(v);
            self
        }
        pub fn set_region_order(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.region_order = inp;
            self
        }
        /// <p>The number of accounts, per Region, for which this operation can fail before AWS
        /// CloudFormation stops the operation in that Region. If the operation is stopped in a Region,
        /// AWS CloudFormation doesn't attempt the operation in any subsequent Regions.</p>
        /// <p>Conditional: You must specify either <code>FailureToleranceCount</code> or
        /// <code>FailureTolerancePercentage</code> (but not both).</p>
        pub fn failure_tolerance_count(mut self, inp: i32) -> Self {
            self.failure_tolerance_count = Some(inp);
            self
        }
        pub fn set_failure_tolerance_count(mut self, inp: std::option::Option<i32>) -> Self {
            self.failure_tolerance_count = inp;
            self
        }
        /// <p>The percentage of accounts, per Region, for which this stack operation can fail
        /// before AWS CloudFormation stops the operation in that Region. If the operation is stopped
        /// in a Region, AWS CloudFormation doesn't attempt the operation in any subsequent
        /// Regions.</p>
        /// <p>When calculating the number of accounts based on the specified percentage, AWS
        /// CloudFormation rounds <i>down</i> to the next whole number.</p>
        /// <p>Conditional: You must specify either <code>FailureToleranceCount</code> or
        /// <code>FailureTolerancePercentage</code>, but not both.</p>
        pub fn failure_tolerance_percentage(mut self, inp: i32) -> Self {
            self.failure_tolerance_percentage = Some(inp);
            self
        }
        pub fn set_failure_tolerance_percentage(mut self, inp: std::option::Option<i32>) -> Self {
            self.failure_tolerance_percentage = inp;
            self
        }
        /// <p>The maximum number of accounts in which to perform this operation at one time. This
        /// is dependent on the value of
        /// <code>FailureToleranceCount</code>. <code>MaxConcurrentCount</code> is at most one more
        /// than the <code>FailureToleranceCount</code>.</p>
        /// <p>Note that this setting lets you specify the <i>maximum</i> for
        /// operations. For large deployments, under certain circumstances the actual number of
        /// accounts acted upon concurrently may be lower due to service throttling.</p>
        /// <p>Conditional: You must specify either <code>MaxConcurrentCount</code> or
        /// <code>MaxConcurrentPercentage</code>, but not both.</p>
        pub fn max_concurrent_count(mut self, inp: i32) -> Self {
            self.max_concurrent_count = Some(inp);
            self
        }
        pub fn set_max_concurrent_count(mut self, inp: std::option::Option<i32>) -> Self {
            self.max_concurrent_count = inp;
            self
        }
        /// <p>The maximum percentage of accounts in which to perform this operation at one
        /// time.</p>
        /// <p>When calculating the number of accounts based on the specified percentage, AWS
        /// CloudFormation rounds down to the next whole number. This is true except in cases where
        /// rounding down would result is zero. In this case, CloudFormation sets the number as one
        /// instead.</p>
        /// <p>Note that this setting lets you specify the <i>maximum</i> for
        /// operations. For large deployments, under certain circumstances the actual number of
        /// accounts acted upon concurrently may be lower due to service throttling.</p>
        /// <p>Conditional: You must specify either <code>MaxConcurrentCount</code> or
        /// <code>MaxConcurrentPercentage</code>, but not both.</p>
        pub fn max_concurrent_percentage(mut self, inp: i32) -> Self {
            self.max_concurrent_percentage = Some(inp);
            self
        }
        pub fn set_max_concurrent_percentage(mut self, inp: std::option::Option<i32>) -> Self {
            self.max_concurrent_percentage = inp;
            self
        }
        /// Consumes the builder and constructs a [`StackSetOperationPreferences`](crate::model::StackSetOperationPreferences)
        pub fn build(self) -> crate::model::StackSetOperationPreferences {
            crate::model::StackSetOperationPreferences {
                region_concurrency_type: self.region_concurrency_type,
                region_order: self.region_order,
                failure_tolerance_count: self.failure_tolerance_count,
                failure_tolerance_percentage: self.failure_tolerance_percentage,
                max_concurrent_count: self.max_concurrent_count,
                max_concurrent_percentage: self.max_concurrent_percentage,
            }
        }
    }
}
impl StackSetOperationPreferences {
    /// Creates a new builder-style object to manufacture [`StackSetOperationPreferences`](crate::model::StackSetOperationPreferences)
    pub fn builder() -> crate::model::stack_set_operation_preferences::Builder {
        crate::model::stack_set_operation_preferences::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RegionConcurrencyType {
    Parallel,
    Sequential,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for RegionConcurrencyType {
    fn from(s: &str) -> Self {
        match s {
            "PARALLEL" => RegionConcurrencyType::Parallel,
            "SEQUENTIAL" => RegionConcurrencyType::Sequential,
            other => RegionConcurrencyType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for RegionConcurrencyType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(RegionConcurrencyType::from(s))
    }
}
impl RegionConcurrencyType {
    pub fn as_str(&self) -> &str {
        match self {
            RegionConcurrencyType::Parallel => "PARALLEL",
            RegionConcurrencyType::Sequential => "SEQUENTIAL",
            RegionConcurrencyType::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for RegionConcurrencyType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for RegionConcurrencyType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>The Tag type enables you to specify a key-value pair that can be used to store
/// information about an AWS CloudFormation stack.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Tag {
    /// <p>
    /// <i>Required</i>. A string used to identify this tag. You can specify a
    /// maximum of 128 characters for a tag key. Tags owned by Amazon Web Services (AWS) have the
    /// reserved prefix: <code>aws:</code>.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>
    /// <i>Required</i>. A string containing the value for this tag. You can specify
    /// a maximum of 256 characters for a tag value.</p>
    pub value: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Tag {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Tag");
        formatter.field("key", &self.key);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`Tag`](crate::model::Tag)
pub mod tag {
    /// A builder for [`Tag`](crate::model::Tag)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>
        /// <i>Required</i>. A string used to identify this tag. You can specify a
        /// maximum of 128 characters for a tag key. Tags owned by Amazon Web Services (AWS) have the
        /// reserved prefix: <code>aws:</code>.</p>
        pub fn key(mut self, inp: impl Into<std::string::String>) -> Self {
            self.key = Some(inp.into());
            self
        }
        pub fn set_key(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.key = inp;
            self
        }
        /// <p>
        /// <i>Required</i>. A string containing the value for this tag. You can specify
        /// a maximum of 256 characters for a tag value.</p>
        pub fn value(mut self, inp: impl Into<std::string::String>) -> Self {
            self.value = Some(inp.into());
            self
        }
        pub fn set_value(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.value = inp;
            self
        }
        /// Consumes the builder and constructs a [`Tag`](crate::model::Tag)
        pub fn build(self) -> crate::model::Tag {
            crate::model::Tag {
                key: self.key,
                value: self.value,
            }
        }
    }
}
impl Tag {
    /// Creates a new builder-style object to manufacture [`Tag`](crate::model::Tag)
    pub fn builder() -> crate::model::tag::Builder {
        crate::model::tag::Builder::default()
    }
}

/// <p>The Parameter data type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Parameter {
    /// <p>The key associated with the parameter. If you don't specify a key and value for a
    /// particular parameter, AWS CloudFormation uses the default value that is specified in your
    /// template.</p>
    pub parameter_key: std::option::Option<std::string::String>,
    /// <p>The input value associated with the parameter.</p>
    pub parameter_value: std::option::Option<std::string::String>,
    /// <p>During a stack update, use the existing parameter value that the stack is using for a
    /// given parameter key. If you specify <code>true</code>, do not specify a parameter
    /// value.</p>
    pub use_previous_value: std::option::Option<bool>,
    /// <p>Read-only. The value that corresponds to a Systems Manager parameter key. This field
    /// is returned only for <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/parameters-section-structure.html#aws-ssm-parameter-types">
    /// <code>SSM</code> parameter types</a> in the template.</p>
    pub resolved_value: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Parameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Parameter");
        formatter.field("parameter_key", &self.parameter_key);
        formatter.field("parameter_value", &self.parameter_value);
        formatter.field("use_previous_value", &self.use_previous_value);
        formatter.field("resolved_value", &self.resolved_value);
        formatter.finish()
    }
}
/// See [`Parameter`](crate::model::Parameter)
pub mod parameter {
    /// A builder for [`Parameter`](crate::model::Parameter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) parameter_key: std::option::Option<std::string::String>,
        pub(crate) parameter_value: std::option::Option<std::string::String>,
        pub(crate) use_previous_value: std::option::Option<bool>,
        pub(crate) resolved_value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The key associated with the parameter. If you don't specify a key and value for a
        /// particular parameter, AWS CloudFormation uses the default value that is specified in your
        /// template.</p>
        pub fn parameter_key(mut self, inp: impl Into<std::string::String>) -> Self {
            self.parameter_key = Some(inp.into());
            self
        }
        pub fn set_parameter_key(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.parameter_key = inp;
            self
        }
        /// <p>The input value associated with the parameter.</p>
        pub fn parameter_value(mut self, inp: impl Into<std::string::String>) -> Self {
            self.parameter_value = Some(inp.into());
            self
        }
        pub fn set_parameter_value(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.parameter_value = inp;
            self
        }
        /// <p>During a stack update, use the existing parameter value that the stack is using for a
        /// given parameter key. If you specify <code>true</code>, do not specify a parameter
        /// value.</p>
        pub fn use_previous_value(mut self, inp: bool) -> Self {
            self.use_previous_value = Some(inp);
            self
        }
        pub fn set_use_previous_value(mut self, inp: std::option::Option<bool>) -> Self {
            self.use_previous_value = inp;
            self
        }
        /// <p>Read-only. The value that corresponds to a Systems Manager parameter key. This field
        /// is returned only for <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/parameters-section-structure.html#aws-ssm-parameter-types">
        /// <code>SSM</code> parameter types</a> in the template.</p>
        pub fn resolved_value(mut self, inp: impl Into<std::string::String>) -> Self {
            self.resolved_value = Some(inp.into());
            self
        }
        pub fn set_resolved_value(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.resolved_value = inp;
            self
        }
        /// Consumes the builder and constructs a [`Parameter`](crate::model::Parameter)
        pub fn build(self) -> crate::model::Parameter {
            crate::model::Parameter {
                parameter_key: self.parameter_key,
                parameter_value: self.parameter_value,
                use_previous_value: self.use_previous_value,
                resolved_value: self.resolved_value,
            }
        }
    }
}
impl Parameter {
    /// Creates a new builder-style object to manufacture [`Parameter`](crate::model::Parameter)
    pub fn builder() -> crate::model::parameter::Builder {
        crate::model::parameter::Builder::default()
    }
}

/// <p>Structure containing the rollback triggers for AWS CloudFormation to monitor during stack creation
/// and updating operations, and for the specified monitoring period afterwards.</p>
/// <p>Rollback triggers enable you to have AWS CloudFormation monitor the state of your application
/// during stack creation and updating, and to roll back that operation if the application
/// breaches the threshold of any of the alarms you've specified. For more information, see
/// <a href="http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-rollback-triggers.html">Monitor and Roll Back Stack
/// Operations</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RollbackConfiguration {
    /// <p>The triggers to monitor during stack creation or update actions. </p>
    /// <p>By default, AWS CloudFormation saves the rollback triggers specified for a stack and applies them
    /// to any subsequent update operations for the stack, unless you specify otherwise. If you do
    /// specify rollback triggers for this parameter, those triggers replace any list of triggers
    /// previously specified for the stack. This means:</p>
    /// <ul>
    /// <li>
    /// <p>To use the rollback triggers previously specified for this stack, if any, don't
    /// specify this parameter.</p>
    /// </li>
    /// <li>
    /// <p>To specify new or updated rollback triggers, you must specify
    /// <i>all</i> the triggers that you want used for this stack, even
    /// triggers you've specifed before (for example, when creating the stack or during a
    /// previous stack update). Any triggers that you don't include in the updated list of
    /// triggers are no longer applied to the stack.</p>
    /// </li>
    /// <li>
    /// <p>To remove all currently specified triggers, specify an empty list for this
    /// parameter.</p>
    /// </li>
    /// </ul>
    /// <p>If a specified trigger is missing, the entire stack operation fails and is rolled
    /// back. </p>
    pub rollback_triggers: std::option::Option<std::vec::Vec<crate::model::RollbackTrigger>>,
    /// <p>The amount of time, in minutes, during which CloudFormation should monitor all the
    /// rollback triggers after the stack creation or update operation deploys all necessary
    /// resources.</p>
    /// <p>The default is 0 minutes.</p>
    /// <p>If you specify a monitoring period but do not specify any rollback triggers,
    /// CloudFormation still waits the specified period of time before cleaning up old resources
    /// after update operations. You can use this monitoring period to perform any manual stack
    /// validation desired, and manually cancel the stack creation or update (using <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/APIReference/API_CancelUpdateStack.html">CancelUpdateStack</a>, for example) as necessary.</p>
    /// <p>If you specify 0 for this parameter, CloudFormation still monitors the specified
    /// rollback triggers during stack creation and update operations. Then, for update operations,
    /// it begins disposing of old resources immediately once the operation completes.</p>
    pub monitoring_time_in_minutes: std::option::Option<i32>,
}
impl std::fmt::Debug for RollbackConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RollbackConfiguration");
        formatter.field("rollback_triggers", &self.rollback_triggers);
        formatter.field(
            "monitoring_time_in_minutes",
            &self.monitoring_time_in_minutes,
        );
        formatter.finish()
    }
}
/// See [`RollbackConfiguration`](crate::model::RollbackConfiguration)
pub mod rollback_configuration {
    /// A builder for [`RollbackConfiguration`](crate::model::RollbackConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) rollback_triggers:
            std::option::Option<std::vec::Vec<crate::model::RollbackTrigger>>,
        pub(crate) monitoring_time_in_minutes: std::option::Option<i32>,
    }
    impl Builder {
        pub fn rollback_triggers(mut self, inp: impl Into<crate::model::RollbackTrigger>) -> Self {
            let mut v = self.rollback_triggers.unwrap_or_default();
            v.push(inp.into());
            self.rollback_triggers = Some(v);
            self
        }
        pub fn set_rollback_triggers(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::RollbackTrigger>>,
        ) -> Self {
            self.rollback_triggers = inp;
            self
        }
        /// <p>The amount of time, in minutes, during which CloudFormation should monitor all the
        /// rollback triggers after the stack creation or update operation deploys all necessary
        /// resources.</p>
        /// <p>The default is 0 minutes.</p>
        /// <p>If you specify a monitoring period but do not specify any rollback triggers,
        /// CloudFormation still waits the specified period of time before cleaning up old resources
        /// after update operations. You can use this monitoring period to perform any manual stack
        /// validation desired, and manually cancel the stack creation or update (using <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/APIReference/API_CancelUpdateStack.html">CancelUpdateStack</a>, for example) as necessary.</p>
        /// <p>If you specify 0 for this parameter, CloudFormation still monitors the specified
        /// rollback triggers during stack creation and update operations. Then, for update operations,
        /// it begins disposing of old resources immediately once the operation completes.</p>
        pub fn monitoring_time_in_minutes(mut self, inp: i32) -> Self {
            self.monitoring_time_in_minutes = Some(inp);
            self
        }
        pub fn set_monitoring_time_in_minutes(mut self, inp: std::option::Option<i32>) -> Self {
            self.monitoring_time_in_minutes = inp;
            self
        }
        /// Consumes the builder and constructs a [`RollbackConfiguration`](crate::model::RollbackConfiguration)
        pub fn build(self) -> crate::model::RollbackConfiguration {
            crate::model::RollbackConfiguration {
                rollback_triggers: self.rollback_triggers,
                monitoring_time_in_minutes: self.monitoring_time_in_minutes,
            }
        }
    }
}
impl RollbackConfiguration {
    /// Creates a new builder-style object to manufacture [`RollbackConfiguration`](crate::model::RollbackConfiguration)
    pub fn builder() -> crate::model::rollback_configuration::Builder {
        crate::model::rollback_configuration::Builder::default()
    }
}

/// <p>A rollback trigger AWS CloudFormation monitors during creation and updating of stacks. If any of
/// the alarms you specify goes to ALARM state during the stack operation or within the
/// specified monitoring period afterwards, CloudFormation rolls back the entire stack
/// operation. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RollbackTrigger {
    /// <p>The Amazon Resource Name (ARN) of the rollback trigger.</p>
    /// <p>If a specified trigger is missing, the entire stack operation fails and is rolled
    /// back. </p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The resource type of the rollback trigger. Currently, <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cw-alarm.html">AWS::CloudWatch::Alarm</a> is the only supported resource type.</p>
    pub r#type: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for RollbackTrigger {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RollbackTrigger");
        formatter.field("arn", &self.arn);
        formatter.field("r#type", &self.r#type);
        formatter.finish()
    }
}
/// See [`RollbackTrigger`](crate::model::RollbackTrigger)
pub mod rollback_trigger {
    /// A builder for [`RollbackTrigger`](crate::model::RollbackTrigger)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the rollback trigger.</p>
        /// <p>If a specified trigger is missing, the entire stack operation fails and is rolled
        /// back. </p>
        pub fn arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.arn = Some(inp.into());
            self
        }
        pub fn set_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.arn = inp;
            self
        }
        /// <p>The resource type of the rollback trigger. Currently, <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cw-alarm.html">AWS::CloudWatch::Alarm</a> is the only supported resource type.</p>
        pub fn r#type(mut self, inp: impl Into<std::string::String>) -> Self {
            self.r#type = Some(inp.into());
            self
        }
        pub fn set_type(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.r#type = inp;
            self
        }
        /// Consumes the builder and constructs a [`RollbackTrigger`](crate::model::RollbackTrigger)
        pub fn build(self) -> crate::model::RollbackTrigger {
            crate::model::RollbackTrigger {
                arn: self.arn,
                r#type: self.r#type,
            }
        }
    }
}
impl RollbackTrigger {
    /// Creates a new builder-style object to manufacture [`RollbackTrigger`](crate::model::RollbackTrigger)
    pub fn builder() -> crate::model::rollback_trigger::Builder {
        crate::model::rollback_trigger::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ResourceSignalStatus {
    Failure,
    Success,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ResourceSignalStatus {
    fn from(s: &str) -> Self {
        match s {
            "FAILURE" => ResourceSignalStatus::Failure,
            "SUCCESS" => ResourceSignalStatus::Success,
            other => ResourceSignalStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ResourceSignalStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(ResourceSignalStatus::from(s))
    }
}
impl ResourceSignalStatus {
    pub fn as_str(&self) -> &str {
        match self {
            ResourceSignalStatus::Failure => "FAILURE",
            ResourceSignalStatus::Success => "SUCCESS",
            ResourceSignalStatus::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for ResourceSignalStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for ResourceSignalStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RegistryType {
    Module,
    Resource,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for RegistryType {
    fn from(s: &str) -> Self {
        match s {
            "MODULE" => RegistryType::Module,
            "RESOURCE" => RegistryType::Resource,
            other => RegistryType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for RegistryType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(RegistryType::from(s))
    }
}
impl RegistryType {
    pub fn as_str(&self) -> &str {
        match self {
            RegistryType::Module => "MODULE",
            RegistryType::Resource => "RESOURCE",
            RegistryType::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for RegistryType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for RegistryType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>Contains logging configuration information for a type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LoggingConfig {
    /// <p>The ARN of the role that CloudFormation should assume when sending log entries to CloudWatch logs.</p>
    pub log_role_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon CloudWatch log group to which CloudFormation sends error logging information when invoking the type's handlers.</p>
    pub log_group_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LoggingConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LoggingConfig");
        formatter.field("log_role_arn", &self.log_role_arn);
        formatter.field("log_group_name", &self.log_group_name);
        formatter.finish()
    }
}
/// See [`LoggingConfig`](crate::model::LoggingConfig)
pub mod logging_config {
    /// A builder for [`LoggingConfig`](crate::model::LoggingConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) log_role_arn: std::option::Option<std::string::String>,
        pub(crate) log_group_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the role that CloudFormation should assume when sending log entries to CloudWatch logs.</p>
        pub fn log_role_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.log_role_arn = Some(inp.into());
            self
        }
        pub fn set_log_role_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.log_role_arn = inp;
            self
        }
        /// <p>The Amazon CloudWatch log group to which CloudFormation sends error logging information when invoking the type's handlers.</p>
        pub fn log_group_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.log_group_name = Some(inp.into());
            self
        }
        pub fn set_log_group_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.log_group_name = inp;
            self
        }
        /// Consumes the builder and constructs a [`LoggingConfig`](crate::model::LoggingConfig)
        pub fn build(self) -> crate::model::LoggingConfig {
            crate::model::LoggingConfig {
                log_role_arn: self.log_role_arn,
                log_group_name: self.log_group_name,
            }
        }
    }
}
impl LoggingConfig {
    /// Creates a new builder-style object to manufacture [`LoggingConfig`](crate::model::LoggingConfig)
    pub fn builder() -> crate::model::logging_config::Builder {
        crate::model::logging_config::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum HandlerErrorCode {
    AccessDenied,
    AlreadyExists,
    GeneralServiceException,
    InternalFailure,
    InvalidCredentials,
    InvalidRequest,
    NetworkFailure,
    NotFound,
    ServiceTimeout,
    NotUpdatable,
    ResourceConflict,
    ServiceInternalError,
    ServiceLimitExceeded,
    Throttling,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for HandlerErrorCode {
    fn from(s: &str) -> Self {
        match s {
            "AccessDenied" => HandlerErrorCode::AccessDenied,
            "AlreadyExists" => HandlerErrorCode::AlreadyExists,
            "GeneralServiceException" => HandlerErrorCode::GeneralServiceException,
            "InternalFailure" => HandlerErrorCode::InternalFailure,
            "InvalidCredentials" => HandlerErrorCode::InvalidCredentials,
            "InvalidRequest" => HandlerErrorCode::InvalidRequest,
            "NetworkFailure" => HandlerErrorCode::NetworkFailure,
            "NotFound" => HandlerErrorCode::NotFound,
            "NotStabilized" => HandlerErrorCode::ServiceTimeout,
            "NotUpdatable" => HandlerErrorCode::NotUpdatable,
            "ResourceConflict" => HandlerErrorCode::ResourceConflict,
            "ServiceInternalError" => HandlerErrorCode::ServiceInternalError,
            "ServiceLimitExceeded" => HandlerErrorCode::ServiceLimitExceeded,
            "Throttling" => HandlerErrorCode::Throttling,
            other => HandlerErrorCode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for HandlerErrorCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(HandlerErrorCode::from(s))
    }
}
impl HandlerErrorCode {
    pub fn as_str(&self) -> &str {
        match self {
            HandlerErrorCode::AccessDenied => "AccessDenied",
            HandlerErrorCode::AlreadyExists => "AlreadyExists",
            HandlerErrorCode::GeneralServiceException => "GeneralServiceException",
            HandlerErrorCode::InternalFailure => "InternalFailure",
            HandlerErrorCode::InvalidCredentials => "InvalidCredentials",
            HandlerErrorCode::InvalidRequest => "InvalidRequest",
            HandlerErrorCode::NetworkFailure => "NetworkFailure",
            HandlerErrorCode::NotFound => "NotFound",
            HandlerErrorCode::ServiceTimeout => "NotStabilized",
            HandlerErrorCode::NotUpdatable => "NotUpdatable",
            HandlerErrorCode::ResourceConflict => "ResourceConflict",
            HandlerErrorCode::ServiceInternalError => "ServiceInternalError",
            HandlerErrorCode::ServiceLimitExceeded => "ServiceLimitExceeded",
            HandlerErrorCode::Throttling => "Throttling",
            HandlerErrorCode::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for HandlerErrorCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for HandlerErrorCode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum OperationStatus {
    Failed,
    InProgress,
    Pending,
    Success,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for OperationStatus {
    fn from(s: &str) -> Self {
        match s {
            "FAILED" => OperationStatus::Failed,
            "IN_PROGRESS" => OperationStatus::InProgress,
            "PENDING" => OperationStatus::Pending,
            "SUCCESS" => OperationStatus::Success,
            other => OperationStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for OperationStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(OperationStatus::from(s))
    }
}
impl OperationStatus {
    pub fn as_str(&self) -> &str {
        match self {
            OperationStatus::Failed => "FAILED",
            OperationStatus::InProgress => "IN_PROGRESS",
            OperationStatus::Pending => "PENDING",
            OperationStatus::Success => "SUCCESS",
            OperationStatus::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for OperationStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for OperationStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>Contains summary information about a specific version of a CloudFormation type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TypeVersionSummary {
    /// <p>The kind of type.</p>
    pub r#type: std::option::Option<crate::model::RegistryType>,
    /// <p>The name of the type.</p>
    pub type_name: std::option::Option<std::string::String>,
    /// <p>The ID of a specific version of the type. The version ID is the value at the end of the Amazon Resource Name (ARN) assigned to the type version when it is registered.</p>
    pub version_id: std::option::Option<std::string::String>,
    /// <p>Whether the specified type version is set as the default version.</p>
    pub is_default_version: std::option::Option<bool>,
    /// <p>The Amazon Resource Name (ARN) of the type version.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>When the version was registered.</p>
    pub time_created: std::option::Option<smithy_types::Instant>,
    /// <p>The description of the type version.</p>
    pub description: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TypeVersionSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TypeVersionSummary");
        formatter.field("r#type", &self.r#type);
        formatter.field("type_name", &self.type_name);
        formatter.field("version_id", &self.version_id);
        formatter.field("is_default_version", &self.is_default_version);
        formatter.field("arn", &self.arn);
        formatter.field("time_created", &self.time_created);
        formatter.field("description", &self.description);
        formatter.finish()
    }
}
/// See [`TypeVersionSummary`](crate::model::TypeVersionSummary)
pub mod type_version_summary {
    /// A builder for [`TypeVersionSummary`](crate::model::TypeVersionSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<crate::model::RegistryType>,
        pub(crate) type_name: std::option::Option<std::string::String>,
        pub(crate) version_id: std::option::Option<std::string::String>,
        pub(crate) is_default_version: std::option::Option<bool>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) time_created: std::option::Option<smithy_types::Instant>,
        pub(crate) description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The kind of type.</p>
        pub fn r#type(mut self, inp: crate::model::RegistryType) -> Self {
            self.r#type = Some(inp);
            self
        }
        pub fn set_type(mut self, inp: std::option::Option<crate::model::RegistryType>) -> Self {
            self.r#type = inp;
            self
        }
        /// <p>The name of the type.</p>
        pub fn type_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.type_name = Some(inp.into());
            self
        }
        pub fn set_type_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.type_name = inp;
            self
        }
        /// <p>The ID of a specific version of the type. The version ID is the value at the end of the Amazon Resource Name (ARN) assigned to the type version when it is registered.</p>
        pub fn version_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.version_id = Some(inp.into());
            self
        }
        pub fn set_version_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.version_id = inp;
            self
        }
        /// <p>Whether the specified type version is set as the default version.</p>
        pub fn is_default_version(mut self, inp: bool) -> Self {
            self.is_default_version = Some(inp);
            self
        }
        pub fn set_is_default_version(mut self, inp: std::option::Option<bool>) -> Self {
            self.is_default_version = inp;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the type version.</p>
        pub fn arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.arn = Some(inp.into());
            self
        }
        pub fn set_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.arn = inp;
            self
        }
        /// <p>When the version was registered.</p>
        pub fn time_created(mut self, inp: smithy_types::Instant) -> Self {
            self.time_created = Some(inp);
            self
        }
        pub fn set_time_created(mut self, inp: std::option::Option<smithy_types::Instant>) -> Self {
            self.time_created = inp;
            self
        }
        /// <p>The description of the type version.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.description = Some(inp.into());
            self
        }
        pub fn set_description(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.description = inp;
            self
        }
        /// Consumes the builder and constructs a [`TypeVersionSummary`](crate::model::TypeVersionSummary)
        pub fn build(self) -> crate::model::TypeVersionSummary {
            crate::model::TypeVersionSummary {
                r#type: self.r#type,
                type_name: self.type_name,
                version_id: self.version_id,
                is_default_version: self.is_default_version,
                arn: self.arn,
                time_created: self.time_created,
                description: self.description,
            }
        }
    }
}
impl TypeVersionSummary {
    /// Creates a new builder-style object to manufacture [`TypeVersionSummary`](crate::model::TypeVersionSummary)
    pub fn builder() -> crate::model::type_version_summary::Builder {
        crate::model::type_version_summary::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DeprecatedStatus {
    Deprecated,
    Live,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for DeprecatedStatus {
    fn from(s: &str) -> Self {
        match s {
            "DEPRECATED" => DeprecatedStatus::Deprecated,
            "LIVE" => DeprecatedStatus::Live,
            other => DeprecatedStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for DeprecatedStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(DeprecatedStatus::from(s))
    }
}
impl DeprecatedStatus {
    pub fn as_str(&self) -> &str {
        match self {
            DeprecatedStatus::Deprecated => "DEPRECATED",
            DeprecatedStatus::Live => "LIVE",
            DeprecatedStatus::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for DeprecatedStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for DeprecatedStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>Contains summary information about the specified CloudFormation type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TypeSummary {
    /// <p>The kind of type.</p>
    pub r#type: std::option::Option<crate::model::RegistryType>,
    /// <p>The name of the type.</p>
    pub type_name: std::option::Option<std::string::String>,
    /// <p>The ID of the default version of the type. The default version is used when the type version is not specified.</p>
    /// <p>To set the default version of a type, use <code>
    /// <a>SetTypeDefaultVersion</a>
    /// </code>. </p>
    pub default_version_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the type.</p>
    pub type_arn: std::option::Option<std::string::String>,
    /// <p>When the current default version of the type was registered.</p>
    pub last_updated: std::option::Option<smithy_types::Instant>,
    /// <p>The description of the type.</p>
    pub description: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TypeSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TypeSummary");
        formatter.field("r#type", &self.r#type);
        formatter.field("type_name", &self.type_name);
        formatter.field("default_version_id", &self.default_version_id);
        formatter.field("type_arn", &self.type_arn);
        formatter.field("last_updated", &self.last_updated);
        formatter.field("description", &self.description);
        formatter.finish()
    }
}
/// See [`TypeSummary`](crate::model::TypeSummary)
pub mod type_summary {
    /// A builder for [`TypeSummary`](crate::model::TypeSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<crate::model::RegistryType>,
        pub(crate) type_name: std::option::Option<std::string::String>,
        pub(crate) default_version_id: std::option::Option<std::string::String>,
        pub(crate) type_arn: std::option::Option<std::string::String>,
        pub(crate) last_updated: std::option::Option<smithy_types::Instant>,
        pub(crate) description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The kind of type.</p>
        pub fn r#type(mut self, inp: crate::model::RegistryType) -> Self {
            self.r#type = Some(inp);
            self
        }
        pub fn set_type(mut self, inp: std::option::Option<crate::model::RegistryType>) -> Self {
            self.r#type = inp;
            self
        }
        /// <p>The name of the type.</p>
        pub fn type_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.type_name = Some(inp.into());
            self
        }
        pub fn set_type_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.type_name = inp;
            self
        }
        /// <p>The ID of the default version of the type. The default version is used when the type version is not specified.</p>
        /// <p>To set the default version of a type, use <code>
        /// <a>SetTypeDefaultVersion</a>
        /// </code>. </p>
        pub fn default_version_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.default_version_id = Some(inp.into());
            self
        }
        pub fn set_default_version_id(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.default_version_id = inp;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the type.</p>
        pub fn type_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.type_arn = Some(inp.into());
            self
        }
        pub fn set_type_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.type_arn = inp;
            self
        }
        /// <p>When the current default version of the type was registered.</p>
        pub fn last_updated(mut self, inp: smithy_types::Instant) -> Self {
            self.last_updated = Some(inp);
            self
        }
        pub fn set_last_updated(mut self, inp: std::option::Option<smithy_types::Instant>) -> Self {
            self.last_updated = inp;
            self
        }
        /// <p>The description of the type.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.description = Some(inp.into());
            self
        }
        pub fn set_description(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.description = inp;
            self
        }
        /// Consumes the builder and constructs a [`TypeSummary`](crate::model::TypeSummary)
        pub fn build(self) -> crate::model::TypeSummary {
            crate::model::TypeSummary {
                r#type: self.r#type,
                type_name: self.type_name,
                default_version_id: self.default_version_id,
                type_arn: self.type_arn,
                last_updated: self.last_updated,
                description: self.description,
            }
        }
    }
}
impl TypeSummary {
    /// Creates a new builder-style object to manufacture [`TypeSummary`](crate::model::TypeSummary)
    pub fn builder() -> crate::model::type_summary::Builder {
        crate::model::type_summary::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ProvisioningType {
    FullyMutable,
    Immutable,
    NonProvisionable,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ProvisioningType {
    fn from(s: &str) -> Self {
        match s {
            "FULLY_MUTABLE" => ProvisioningType::FullyMutable,
            "IMMUTABLE" => ProvisioningType::Immutable,
            "NON_PROVISIONABLE" => ProvisioningType::NonProvisionable,
            other => ProvisioningType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ProvisioningType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(ProvisioningType::from(s))
    }
}
impl ProvisioningType {
    pub fn as_str(&self) -> &str {
        match self {
            ProvisioningType::FullyMutable => "FULLY_MUTABLE",
            ProvisioningType::Immutable => "IMMUTABLE",
            ProvisioningType::NonProvisionable => "NON_PROVISIONABLE",
            ProvisioningType::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for ProvisioningType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for ProvisioningType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Visibility {
    Private,
    Public,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for Visibility {
    fn from(s: &str) -> Self {
        match s {
            "PRIVATE" => Visibility::Private,
            "PUBLIC" => Visibility::Public,
            other => Visibility::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for Visibility {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(Visibility::from(s))
    }
}
impl Visibility {
    pub fn as_str(&self) -> &str {
        match self {
            Visibility::Private => "PRIVATE",
            Visibility::Public => "PUBLIC",
            Visibility::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for Visibility {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for Visibility {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RegistrationStatus {
    Complete,
    Failed,
    InProgress,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for RegistrationStatus {
    fn from(s: &str) -> Self {
        match s {
            "COMPLETE" => RegistrationStatus::Complete,
            "FAILED" => RegistrationStatus::Failed,
            "IN_PROGRESS" => RegistrationStatus::InProgress,
            other => RegistrationStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for RegistrationStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(RegistrationStatus::from(s))
    }
}
impl RegistrationStatus {
    pub fn as_str(&self) -> &str {
        match self {
            RegistrationStatus::Complete => "COMPLETE",
            RegistrationStatus::Failed => "FAILED",
            RegistrationStatus::InProgress => "IN_PROGRESS",
            RegistrationStatus::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for RegistrationStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for RegistrationStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>The structures that contain summary information about the specified stack
/// set.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StackSetSummary {
    /// <p>The name of the stack set.</p>
    pub stack_set_name: std::option::Option<std::string::String>,
    /// <p>The ID of the stack set.</p>
    pub stack_set_id: std::option::Option<std::string::String>,
    /// <p>A description of the stack set that you specify when the stack set is created or
    /// updated.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The status of the stack set.</p>
    pub status: std::option::Option<crate::model::StackSetStatus>,
    /// <p>[Service-managed permissions] Describes whether StackSets automatically deploys to AWS Organizations accounts that are added to a target organizational unit (OU).</p>
    pub auto_deployment: std::option::Option<crate::model::AutoDeployment>,
    /// <p>Describes how the IAM roles required for stack set operations are created.</p>
    /// <ul>
    /// <li>
    /// <p>With <code>self-managed</code> permissions, you must create the administrator and execution roles required to deploy to target accounts. For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacksets-prereqs-self-managed.html">Grant Self-Managed Stack Set Permissions</a>.</p>
    /// </li>
    /// <li>
    /// <p>With <code>service-managed</code> permissions, StackSets automatically creates the IAM roles required to deploy to accounts managed by AWS Organizations. For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacksets-prereqs-service-managed.html">Grant Service-Managed Stack Set Permissions</a>.</p>
    /// </li>
    /// </ul>
    pub permission_model: std::option::Option<crate::model::PermissionModels>,
    /// <p>Status of the stack set's actual configuration compared to its expected template and
    /// parameter configuration. A stack set is considered to have drifted if one or more of its
    /// stack instances have drifted from their expected template and parameter
    /// configuration.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>DRIFTED</code>: One or more of the stack instances belonging to the stack
    /// set stack differs from the expected template and parameter configuration. A stack
    /// instance is considered to have drifted if one or more of the resources in the
    /// associated stack have drifted.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>NOT_CHECKED</code>: AWS CloudFormation has not checked the stack set for drift.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>IN_SYNC</code>: All of the stack instances belonging to the stack set stack
    /// match from the expected template and parameter configuration.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>UNKNOWN</code>: This value is reserved for future use.</p>
    /// </li>
    /// </ul>
    pub drift_status: std::option::Option<crate::model::StackDriftStatus>,
    /// <p>Most recent time when CloudFormation performed a drift detection operation on the stack
    /// set. This value will be <code>NULL</code> for any stack set on which drift detection has
    /// not yet been performed.</p>
    pub last_drift_check_timestamp: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for StackSetSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StackSetSummary");
        formatter.field("stack_set_name", &self.stack_set_name);
        formatter.field("stack_set_id", &self.stack_set_id);
        formatter.field("description", &self.description);
        formatter.field("status", &self.status);
        formatter.field("auto_deployment", &self.auto_deployment);
        formatter.field("permission_model", &self.permission_model);
        formatter.field("drift_status", &self.drift_status);
        formatter.field(
            "last_drift_check_timestamp",
            &self.last_drift_check_timestamp,
        );
        formatter.finish()
    }
}
/// See [`StackSetSummary`](crate::model::StackSetSummary)
pub mod stack_set_summary {
    /// A builder for [`StackSetSummary`](crate::model::StackSetSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) stack_set_name: std::option::Option<std::string::String>,
        pub(crate) stack_set_id: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::StackSetStatus>,
        pub(crate) auto_deployment: std::option::Option<crate::model::AutoDeployment>,
        pub(crate) permission_model: std::option::Option<crate::model::PermissionModels>,
        pub(crate) drift_status: std::option::Option<crate::model::StackDriftStatus>,
        pub(crate) last_drift_check_timestamp: std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The name of the stack set.</p>
        pub fn stack_set_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.stack_set_name = Some(inp.into());
            self
        }
        pub fn set_stack_set_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.stack_set_name = inp;
            self
        }
        /// <p>The ID of the stack set.</p>
        pub fn stack_set_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.stack_set_id = Some(inp.into());
            self
        }
        pub fn set_stack_set_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.stack_set_id = inp;
            self
        }
        /// <p>A description of the stack set that you specify when the stack set is created or
        /// updated.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.description = Some(inp.into());
            self
        }
        pub fn set_description(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.description = inp;
            self
        }
        /// <p>The status of the stack set.</p>
        pub fn status(mut self, inp: crate::model::StackSetStatus) -> Self {
            self.status = Some(inp);
            self
        }
        pub fn set_status(
            mut self,
            inp: std::option::Option<crate::model::StackSetStatus>,
        ) -> Self {
            self.status = inp;
            self
        }
        /// <p>[Service-managed permissions] Describes whether StackSets automatically deploys to AWS Organizations accounts that are added to a target organizational unit (OU).</p>
        pub fn auto_deployment(mut self, inp: crate::model::AutoDeployment) -> Self {
            self.auto_deployment = Some(inp);
            self
        }
        pub fn set_auto_deployment(
            mut self,
            inp: std::option::Option<crate::model::AutoDeployment>,
        ) -> Self {
            self.auto_deployment = inp;
            self
        }
        /// <p>Describes how the IAM roles required for stack set operations are created.</p>
        /// <ul>
        /// <li>
        /// <p>With <code>self-managed</code> permissions, you must create the administrator and execution roles required to deploy to target accounts. For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacksets-prereqs-self-managed.html">Grant Self-Managed Stack Set Permissions</a>.</p>
        /// </li>
        /// <li>
        /// <p>With <code>service-managed</code> permissions, StackSets automatically creates the IAM roles required to deploy to accounts managed by AWS Organizations. For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacksets-prereqs-service-managed.html">Grant Service-Managed Stack Set Permissions</a>.</p>
        /// </li>
        /// </ul>
        pub fn permission_model(mut self, inp: crate::model::PermissionModels) -> Self {
            self.permission_model = Some(inp);
            self
        }
        pub fn set_permission_model(
            mut self,
            inp: std::option::Option<crate::model::PermissionModels>,
        ) -> Self {
            self.permission_model = inp;
            self
        }
        /// <p>Status of the stack set's actual configuration compared to its expected template and
        /// parameter configuration. A stack set is considered to have drifted if one or more of its
        /// stack instances have drifted from their expected template and parameter
        /// configuration.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>DRIFTED</code>: One or more of the stack instances belonging to the stack
        /// set stack differs from the expected template and parameter configuration. A stack
        /// instance is considered to have drifted if one or more of the resources in the
        /// associated stack have drifted.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>NOT_CHECKED</code>: AWS CloudFormation has not checked the stack set for drift.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>IN_SYNC</code>: All of the stack instances belonging to the stack set stack
        /// match from the expected template and parameter configuration.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>UNKNOWN</code>: This value is reserved for future use.</p>
        /// </li>
        /// </ul>
        pub fn drift_status(mut self, inp: crate::model::StackDriftStatus) -> Self {
            self.drift_status = Some(inp);
            self
        }
        pub fn set_drift_status(
            mut self,
            inp: std::option::Option<crate::model::StackDriftStatus>,
        ) -> Self {
            self.drift_status = inp;
            self
        }
        /// <p>Most recent time when CloudFormation performed a drift detection operation on the stack
        /// set. This value will be <code>NULL</code> for any stack set on which drift detection has
        /// not yet been performed.</p>
        pub fn last_drift_check_timestamp(mut self, inp: smithy_types::Instant) -> Self {
            self.last_drift_check_timestamp = Some(inp);
            self
        }
        pub fn set_last_drift_check_timestamp(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_drift_check_timestamp = inp;
            self
        }
        /// Consumes the builder and constructs a [`StackSetSummary`](crate::model::StackSetSummary)
        pub fn build(self) -> crate::model::StackSetSummary {
            crate::model::StackSetSummary {
                stack_set_name: self.stack_set_name,
                stack_set_id: self.stack_set_id,
                description: self.description,
                status: self.status,
                auto_deployment: self.auto_deployment,
                permission_model: self.permission_model,
                drift_status: self.drift_status,
                last_drift_check_timestamp: self.last_drift_check_timestamp,
            }
        }
    }
}
impl StackSetSummary {
    /// Creates a new builder-style object to manufacture [`StackSetSummary`](crate::model::StackSetSummary)
    pub fn builder() -> crate::model::stack_set_summary::Builder {
        crate::model::stack_set_summary::Builder::default()
    }
}

/// **NOTE:** `StackDriftStatus::Unknown` has been renamed to `::UnknownValue`.
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StackDriftStatus {
    Drifted,
    InSync,
    NotChecked,
    /// **NOTE:** `::Unknown` has been renamed to `::UnknownValue`.
    UnknownValue,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for StackDriftStatus {
    fn from(s: &str) -> Self {
        match s {
            "DRIFTED" => StackDriftStatus::Drifted,
            "IN_SYNC" => StackDriftStatus::InSync,
            "NOT_CHECKED" => StackDriftStatus::NotChecked,
            "UNKNOWN" => StackDriftStatus::UnknownValue,
            other => StackDriftStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for StackDriftStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(StackDriftStatus::from(s))
    }
}
impl StackDriftStatus {
    pub fn as_str(&self) -> &str {
        match self {
            StackDriftStatus::Drifted => "DRIFTED",
            StackDriftStatus::InSync => "IN_SYNC",
            StackDriftStatus::NotChecked => "NOT_CHECKED",
            StackDriftStatus::UnknownValue => "UNKNOWN",
            StackDriftStatus::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for StackDriftStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for StackDriftStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StackSetStatus {
    Active,
    Deleted,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for StackSetStatus {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => StackSetStatus::Active,
            "DELETED" => StackSetStatus::Deleted,
            other => StackSetStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for StackSetStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(StackSetStatus::from(s))
    }
}
impl StackSetStatus {
    pub fn as_str(&self) -> &str {
        match self {
            StackSetStatus::Active => "ACTIVE",
            StackSetStatus::Deleted => "DELETED",
            StackSetStatus::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for StackSetStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for StackSetStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>The structures that contain summary information about the specified
/// operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StackSetOperationSummary {
    /// <p>The unique ID of the stack set operation.</p>
    pub operation_id: std::option::Option<std::string::String>,
    /// <p>The type of operation: <code>CREATE</code>, <code>UPDATE</code>, or
    /// <code>DELETE</code>. Create and delete operations affect only the specified stack
    /// instances that are associated with the specified stack set. Update operations affect both
    /// the stack set itself as well as <i>all</i> associated stack set
    /// instances.</p>
    pub action: std::option::Option<crate::model::StackSetOperationAction>,
    /// <p>The overall status of the operation.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>FAILED</code>: The operation exceeded the specified failure tolerance.
    /// The failure tolerance value that you've set for an operation is applied for each
    /// Region during stack create and update operations. If the number of failed stacks
    /// within a Region exceeds the failure tolerance, the status of the operation in the
    /// Region is set to <code>FAILED</code>. This in turn sets the status of the operation
    /// as a whole to <code>FAILED</code>, and AWS CloudFormation cancels the operation in
    /// any remaining Regions.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>QUEUED</code>: [Service-managed permissions] For automatic deployments that
    /// require a sequence of operations, the operation is queued to be performed. For more information, see the <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacksets-concepts.html#stackset-status-codes">stack set operation status codes</a> in the AWS CloudFormation User Guide.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>RUNNING</code>: The operation is currently being performed.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>STOPPED</code>: The user has cancelled the operation.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>STOPPING</code>: The operation is in the process of stopping, at user
    /// request. </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>SUCCEEDED</code>: The operation completed creating or updating all the
    /// specified stacks without exceeding the failure tolerance for the operation.</p>
    /// </li>
    /// </ul>
    pub status: std::option::Option<crate::model::StackSetOperationStatus>,
    /// <p>The time at which the operation was initiated. Note that the creation times for the
    /// stack set operation might differ from the creation time of the individual stacks
    /// themselves. This is because AWS CloudFormation needs to perform preparatory work for the
    /// operation, such as dispatching the work to the requested Regions, before actually creating
    /// the first stacks.</p>
    pub creation_timestamp: std::option::Option<smithy_types::Instant>,
    /// <p>The time at which the stack set operation ended, across all accounts and Regions
    /// specified. Note that this doesn't necessarily mean that the stack set operation was
    /// successful, or even attempted, in each account or Region.</p>
    pub end_timestamp: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for StackSetOperationSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StackSetOperationSummary");
        formatter.field("operation_id", &self.operation_id);
        formatter.field("action", &self.action);
        formatter.field("status", &self.status);
        formatter.field("creation_timestamp", &self.creation_timestamp);
        formatter.field("end_timestamp", &self.end_timestamp);
        formatter.finish()
    }
}
/// See [`StackSetOperationSummary`](crate::model::StackSetOperationSummary)
pub mod stack_set_operation_summary {
    /// A builder for [`StackSetOperationSummary`](crate::model::StackSetOperationSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) operation_id: std::option::Option<std::string::String>,
        pub(crate) action: std::option::Option<crate::model::StackSetOperationAction>,
        pub(crate) status: std::option::Option<crate::model::StackSetOperationStatus>,
        pub(crate) creation_timestamp: std::option::Option<smithy_types::Instant>,
        pub(crate) end_timestamp: std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The unique ID of the stack set operation.</p>
        pub fn operation_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.operation_id = Some(inp.into());
            self
        }
        pub fn set_operation_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.operation_id = inp;
            self
        }
        /// <p>The type of operation: <code>CREATE</code>, <code>UPDATE</code>, or
        /// <code>DELETE</code>. Create and delete operations affect only the specified stack
        /// instances that are associated with the specified stack set. Update operations affect both
        /// the stack set itself as well as <i>all</i> associated stack set
        /// instances.</p>
        pub fn action(mut self, inp: crate::model::StackSetOperationAction) -> Self {
            self.action = Some(inp);
            self
        }
        pub fn set_action(
            mut self,
            inp: std::option::Option<crate::model::StackSetOperationAction>,
        ) -> Self {
            self.action = inp;
            self
        }
        /// <p>The overall status of the operation.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>FAILED</code>: The operation exceeded the specified failure tolerance.
        /// The failure tolerance value that you've set for an operation is applied for each
        /// Region during stack create and update operations. If the number of failed stacks
        /// within a Region exceeds the failure tolerance, the status of the operation in the
        /// Region is set to <code>FAILED</code>. This in turn sets the status of the operation
        /// as a whole to <code>FAILED</code>, and AWS CloudFormation cancels the operation in
        /// any remaining Regions.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>QUEUED</code>: [Service-managed permissions] For automatic deployments that
        /// require a sequence of operations, the operation is queued to be performed. For more information, see the <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacksets-concepts.html#stackset-status-codes">stack set operation status codes</a> in the AWS CloudFormation User Guide.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>RUNNING</code>: The operation is currently being performed.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>STOPPED</code>: The user has cancelled the operation.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>STOPPING</code>: The operation is in the process of stopping, at user
        /// request. </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>SUCCEEDED</code>: The operation completed creating or updating all the
        /// specified stacks without exceeding the failure tolerance for the operation.</p>
        /// </li>
        /// </ul>
        pub fn status(mut self, inp: crate::model::StackSetOperationStatus) -> Self {
            self.status = Some(inp);
            self
        }
        pub fn set_status(
            mut self,
            inp: std::option::Option<crate::model::StackSetOperationStatus>,
        ) -> Self {
            self.status = inp;
            self
        }
        /// <p>The time at which the operation was initiated. Note that the creation times for the
        /// stack set operation might differ from the creation time of the individual stacks
        /// themselves. This is because AWS CloudFormation needs to perform preparatory work for the
        /// operation, such as dispatching the work to the requested Regions, before actually creating
        /// the first stacks.</p>
        pub fn creation_timestamp(mut self, inp: smithy_types::Instant) -> Self {
            self.creation_timestamp = Some(inp);
            self
        }
        pub fn set_creation_timestamp(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_timestamp = inp;
            self
        }
        /// <p>The time at which the stack set operation ended, across all accounts and Regions
        /// specified. Note that this doesn't necessarily mean that the stack set operation was
        /// successful, or even attempted, in each account or Region.</p>
        pub fn end_timestamp(mut self, inp: smithy_types::Instant) -> Self {
            self.end_timestamp = Some(inp);
            self
        }
        pub fn set_end_timestamp(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.end_timestamp = inp;
            self
        }
        /// Consumes the builder and constructs a [`StackSetOperationSummary`](crate::model::StackSetOperationSummary)
        pub fn build(self) -> crate::model::StackSetOperationSummary {
            crate::model::StackSetOperationSummary {
                operation_id: self.operation_id,
                action: self.action,
                status: self.status,
                creation_timestamp: self.creation_timestamp,
                end_timestamp: self.end_timestamp,
            }
        }
    }
}
impl StackSetOperationSummary {
    /// Creates a new builder-style object to manufacture [`StackSetOperationSummary`](crate::model::StackSetOperationSummary)
    pub fn builder() -> crate::model::stack_set_operation_summary::Builder {
        crate::model::stack_set_operation_summary::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StackSetOperationStatus {
    Failed,
    Queued,
    Running,
    Stopped,
    Stopping,
    Succeeded,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for StackSetOperationStatus {
    fn from(s: &str) -> Self {
        match s {
            "FAILED" => StackSetOperationStatus::Failed,
            "QUEUED" => StackSetOperationStatus::Queued,
            "RUNNING" => StackSetOperationStatus::Running,
            "STOPPED" => StackSetOperationStatus::Stopped,
            "STOPPING" => StackSetOperationStatus::Stopping,
            "SUCCEEDED" => StackSetOperationStatus::Succeeded,
            other => StackSetOperationStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for StackSetOperationStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(StackSetOperationStatus::from(s))
    }
}
impl StackSetOperationStatus {
    pub fn as_str(&self) -> &str {
        match self {
            StackSetOperationStatus::Failed => "FAILED",
            StackSetOperationStatus::Queued => "QUEUED",
            StackSetOperationStatus::Running => "RUNNING",
            StackSetOperationStatus::Stopped => "STOPPED",
            StackSetOperationStatus::Stopping => "STOPPING",
            StackSetOperationStatus::Succeeded => "SUCCEEDED",
            StackSetOperationStatus::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for StackSetOperationStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for StackSetOperationStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StackSetOperationAction {
    Create,
    Delete,
    DetectDrift,
    Update,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for StackSetOperationAction {
    fn from(s: &str) -> Self {
        match s {
            "CREATE" => StackSetOperationAction::Create,
            "DELETE" => StackSetOperationAction::Delete,
            "DETECT_DRIFT" => StackSetOperationAction::DetectDrift,
            "UPDATE" => StackSetOperationAction::Update,
            other => StackSetOperationAction::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for StackSetOperationAction {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(StackSetOperationAction::from(s))
    }
}
impl StackSetOperationAction {
    pub fn as_str(&self) -> &str {
        match self {
            StackSetOperationAction::Create => "CREATE",
            StackSetOperationAction::Delete => "DELETE",
            StackSetOperationAction::DetectDrift => "DETECT_DRIFT",
            StackSetOperationAction::Update => "UPDATE",
            StackSetOperationAction::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for StackSetOperationAction {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for StackSetOperationAction {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>The structure that contains information about a specified operation's results for a
/// given account in a given Region.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StackSetOperationResultSummary {
    /// <p>[Self-managed permissions] The name of the AWS account for this operation result.</p>
    pub account: std::option::Option<std::string::String>,
    /// <p>The name of the AWS Region for this operation result.</p>
    pub region: std::option::Option<std::string::String>,
    /// <p>The result status of the stack set operation for the given account in the given
    /// Region.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>CANCELLED</code>: The operation in the specified account and Region has
    /// been cancelled. This is either because a user has stopped the stack set operation, or
    /// because the failure tolerance of the stack set operation has been exceeded.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>FAILED</code>: The operation in the specified account and Region failed. </p>
    /// <p>If the stack set operation fails in enough accounts within a Region, the
    /// failure tolerance for the stack set operation as a whole might be exceeded.
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>RUNNING</code>: The operation in the specified account and Region is
    /// currently in progress.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>PENDING</code>: The operation in the specified account and Region has yet
    /// to start. </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>SUCCEEDED</code>: The operation in the specified account and Region
    /// completed successfully.</p>
    /// </li>
    /// </ul>
    pub status: std::option::Option<crate::model::StackSetOperationResultStatus>,
    /// <p>The reason for the assigned result status.</p>
    pub status_reason: std::option::Option<std::string::String>,
    /// <p>The results of the account gate function AWS CloudFormation invokes, if present,
    /// before proceeding with stack set operations in an account</p>
    pub account_gate_result: std::option::Option<crate::model::AccountGateResult>,
    /// <p>[Service-managed permissions] The organization root ID or organizational unit (OU) IDs that you specified for <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/APIReference/API_DeploymentTargets.html">DeploymentTargets</a>.</p>
    pub organizational_unit_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for StackSetOperationResultSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StackSetOperationResultSummary");
        formatter.field("account", &self.account);
        formatter.field("region", &self.region);
        formatter.field("status", &self.status);
        formatter.field("status_reason", &self.status_reason);
        formatter.field("account_gate_result", &self.account_gate_result);
        formatter.field("organizational_unit_id", &self.organizational_unit_id);
        formatter.finish()
    }
}
/// See [`StackSetOperationResultSummary`](crate::model::StackSetOperationResultSummary)
pub mod stack_set_operation_result_summary {
    /// A builder for [`StackSetOperationResultSummary`](crate::model::StackSetOperationResultSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account: std::option::Option<std::string::String>,
        pub(crate) region: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::StackSetOperationResultStatus>,
        pub(crate) status_reason: std::option::Option<std::string::String>,
        pub(crate) account_gate_result: std::option::Option<crate::model::AccountGateResult>,
        pub(crate) organizational_unit_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>[Self-managed permissions] The name of the AWS account for this operation result.</p>
        pub fn account(mut self, inp: impl Into<std::string::String>) -> Self {
            self.account = Some(inp.into());
            self
        }
        pub fn set_account(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.account = inp;
            self
        }
        /// <p>The name of the AWS Region for this operation result.</p>
        pub fn region(mut self, inp: impl Into<std::string::String>) -> Self {
            self.region = Some(inp.into());
            self
        }
        pub fn set_region(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.region = inp;
            self
        }
        /// <p>The result status of the stack set operation for the given account in the given
        /// Region.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>CANCELLED</code>: The operation in the specified account and Region has
        /// been cancelled. This is either because a user has stopped the stack set operation, or
        /// because the failure tolerance of the stack set operation has been exceeded.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>FAILED</code>: The operation in the specified account and Region failed. </p>
        /// <p>If the stack set operation fails in enough accounts within a Region, the
        /// failure tolerance for the stack set operation as a whole might be exceeded.
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>RUNNING</code>: The operation in the specified account and Region is
        /// currently in progress.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>PENDING</code>: The operation in the specified account and Region has yet
        /// to start. </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>SUCCEEDED</code>: The operation in the specified account and Region
        /// completed successfully.</p>
        /// </li>
        /// </ul>
        pub fn status(mut self, inp: crate::model::StackSetOperationResultStatus) -> Self {
            self.status = Some(inp);
            self
        }
        pub fn set_status(
            mut self,
            inp: std::option::Option<crate::model::StackSetOperationResultStatus>,
        ) -> Self {
            self.status = inp;
            self
        }
        /// <p>The reason for the assigned result status.</p>
        pub fn status_reason(mut self, inp: impl Into<std::string::String>) -> Self {
            self.status_reason = Some(inp.into());
            self
        }
        pub fn set_status_reason(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.status_reason = inp;
            self
        }
        /// <p>The results of the account gate function AWS CloudFormation invokes, if present,
        /// before proceeding with stack set operations in an account</p>
        pub fn account_gate_result(mut self, inp: crate::model::AccountGateResult) -> Self {
            self.account_gate_result = Some(inp);
            self
        }
        pub fn set_account_gate_result(
            mut self,
            inp: std::option::Option<crate::model::AccountGateResult>,
        ) -> Self {
            self.account_gate_result = inp;
            self
        }
        /// <p>[Service-managed permissions] The organization root ID or organizational unit (OU) IDs that you specified for <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/APIReference/API_DeploymentTargets.html">DeploymentTargets</a>.</p>
        pub fn organizational_unit_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.organizational_unit_id = Some(inp.into());
            self
        }
        pub fn set_organizational_unit_id(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.organizational_unit_id = inp;
            self
        }
        /// Consumes the builder and constructs a [`StackSetOperationResultSummary`](crate::model::StackSetOperationResultSummary)
        pub fn build(self) -> crate::model::StackSetOperationResultSummary {
            crate::model::StackSetOperationResultSummary {
                account: self.account,
                region: self.region,
                status: self.status,
                status_reason: self.status_reason,
                account_gate_result: self.account_gate_result,
                organizational_unit_id: self.organizational_unit_id,
            }
        }
    }
}
impl StackSetOperationResultSummary {
    /// Creates a new builder-style object to manufacture [`StackSetOperationResultSummary`](crate::model::StackSetOperationResultSummary)
    pub fn builder() -> crate::model::stack_set_operation_result_summary::Builder {
        crate::model::stack_set_operation_result_summary::Builder::default()
    }
}

/// <p>Structure that contains the results of the account gate function which AWS
/// CloudFormation invokes, if present, before proceeding with a stack set operation in an
/// account and Region.</p>
/// <p>For each account and Region, AWS CloudFormation lets you specify a Lamdba function
/// that encapsulates any requirements that must be met before CloudFormation can proceed with
/// a stack set operation in that account and Region. CloudFormation invokes the function each
/// time a stack set operation is requested for that account and Region; if the function
/// returns <code>FAILED</code>, CloudFormation cancels the operation in that account and
/// Region, and sets the stack set operation result status for that account and Region to
/// <code>FAILED</code>. </p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacksets-account-gating.html">Configuring a
/// target account gate</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AccountGateResult {
    /// <p>The status of the account gate function.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>SUCCEEDED</code>: The account gate function has determined that the
    /// account and Region passes any requirements for a stack set operation to occur. AWS
    /// CloudFormation proceeds with the stack operation in that account and Region.
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>FAILED</code>: The account gate function has determined that the account
    /// and Region does not meet the requirements for a stack set operation to occur. AWS
    /// CloudFormation cancels the stack set operation in that account and Region, and sets
    /// the stack set operation result status for that account and Region to
    /// <code>FAILED</code>. </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>SKIPPED</code>: AWS CloudFormation has skipped calling the account gate
    /// function for this account and Region, for one of the following reasons:</p>
    /// <ul>
    /// <li>
    /// <p>An account gate function has not been specified for the account and
    /// Region. AWS CloudFormation proceeds with the stack set operation in this
    /// account and Region.</p>
    /// </li>
    /// <li>
    /// <p>The <code>AWSCloudFormationStackSetExecutionRole</code> of the stack set
    /// adminstration account lacks permissions to invoke the function. AWS
    /// CloudFormation proceeds with the stack set operation in this account and
    /// Region.</p>
    /// </li>
    /// <li>
    /// <p>Either no action is necessary, or no action is possible, on the stack.
    /// AWS CloudFormation skips the stack set operation in this account and
    /// Region.</p>
    /// </li>
    /// </ul>
    /// </li>
    /// </ul>
    pub status: std::option::Option<crate::model::AccountGateStatus>,
    /// <p>The reason for the account gate status assigned to this account and Region for the
    /// stack set operation.</p>
    pub status_reason: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AccountGateResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AccountGateResult");
        formatter.field("status", &self.status);
        formatter.field("status_reason", &self.status_reason);
        formatter.finish()
    }
}
/// See [`AccountGateResult`](crate::model::AccountGateResult)
pub mod account_gate_result {
    /// A builder for [`AccountGateResult`](crate::model::AccountGateResult)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) status: std::option::Option<crate::model::AccountGateStatus>,
        pub(crate) status_reason: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The status of the account gate function.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>SUCCEEDED</code>: The account gate function has determined that the
        /// account and Region passes any requirements for a stack set operation to occur. AWS
        /// CloudFormation proceeds with the stack operation in that account and Region.
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>FAILED</code>: The account gate function has determined that the account
        /// and Region does not meet the requirements for a stack set operation to occur. AWS
        /// CloudFormation cancels the stack set operation in that account and Region, and sets
        /// the stack set operation result status for that account and Region to
        /// <code>FAILED</code>. </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>SKIPPED</code>: AWS CloudFormation has skipped calling the account gate
        /// function for this account and Region, for one of the following reasons:</p>
        /// <ul>
        /// <li>
        /// <p>An account gate function has not been specified for the account and
        /// Region. AWS CloudFormation proceeds with the stack set operation in this
        /// account and Region.</p>
        /// </li>
        /// <li>
        /// <p>The <code>AWSCloudFormationStackSetExecutionRole</code> of the stack set
        /// adminstration account lacks permissions to invoke the function. AWS
        /// CloudFormation proceeds with the stack set operation in this account and
        /// Region.</p>
        /// </li>
        /// <li>
        /// <p>Either no action is necessary, or no action is possible, on the stack.
        /// AWS CloudFormation skips the stack set operation in this account and
        /// Region.</p>
        /// </li>
        /// </ul>
        /// </li>
        /// </ul>
        pub fn status(mut self, inp: crate::model::AccountGateStatus) -> Self {
            self.status = Some(inp);
            self
        }
        pub fn set_status(
            mut self,
            inp: std::option::Option<crate::model::AccountGateStatus>,
        ) -> Self {
            self.status = inp;
            self
        }
        /// <p>The reason for the account gate status assigned to this account and Region for the
        /// stack set operation.</p>
        pub fn status_reason(mut self, inp: impl Into<std::string::String>) -> Self {
            self.status_reason = Some(inp.into());
            self
        }
        pub fn set_status_reason(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.status_reason = inp;
            self
        }
        /// Consumes the builder and constructs a [`AccountGateResult`](crate::model::AccountGateResult)
        pub fn build(self) -> crate::model::AccountGateResult {
            crate::model::AccountGateResult {
                status: self.status,
                status_reason: self.status_reason,
            }
        }
    }
}
impl AccountGateResult {
    /// Creates a new builder-style object to manufacture [`AccountGateResult`](crate::model::AccountGateResult)
    pub fn builder() -> crate::model::account_gate_result::Builder {
        crate::model::account_gate_result::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AccountGateStatus {
    Failed,
    Skipped,
    Succeeded,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AccountGateStatus {
    fn from(s: &str) -> Self {
        match s {
            "FAILED" => AccountGateStatus::Failed,
            "SKIPPED" => AccountGateStatus::Skipped,
            "SUCCEEDED" => AccountGateStatus::Succeeded,
            other => AccountGateStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AccountGateStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(AccountGateStatus::from(s))
    }
}
impl AccountGateStatus {
    pub fn as_str(&self) -> &str {
        match self {
            AccountGateStatus::Failed => "FAILED",
            AccountGateStatus::Skipped => "SKIPPED",
            AccountGateStatus::Succeeded => "SUCCEEDED",
            AccountGateStatus::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for AccountGateStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for AccountGateStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StackSetOperationResultStatus {
    Cancelled,
    Failed,
    Pending,
    Running,
    Succeeded,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for StackSetOperationResultStatus {
    fn from(s: &str) -> Self {
        match s {
            "CANCELLED" => StackSetOperationResultStatus::Cancelled,
            "FAILED" => StackSetOperationResultStatus::Failed,
            "PENDING" => StackSetOperationResultStatus::Pending,
            "RUNNING" => StackSetOperationResultStatus::Running,
            "SUCCEEDED" => StackSetOperationResultStatus::Succeeded,
            other => StackSetOperationResultStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for StackSetOperationResultStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(StackSetOperationResultStatus::from(s))
    }
}
impl StackSetOperationResultStatus {
    pub fn as_str(&self) -> &str {
        match self {
            StackSetOperationResultStatus::Cancelled => "CANCELLED",
            StackSetOperationResultStatus::Failed => "FAILED",
            StackSetOperationResultStatus::Pending => "PENDING",
            StackSetOperationResultStatus::Running => "RUNNING",
            StackSetOperationResultStatus::Succeeded => "SUCCEEDED",
            StackSetOperationResultStatus::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for StackSetOperationResultStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for StackSetOperationResultStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>The StackSummary Data Type</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StackSummary {
    /// <p>Unique stack identifier.</p>
    pub stack_id: std::option::Option<std::string::String>,
    /// <p>The name associated with the stack.</p>
    pub stack_name: std::option::Option<std::string::String>,
    /// <p>The template description of the template used to create the stack.</p>
    pub template_description: std::option::Option<std::string::String>,
    /// <p>The time the stack was created.</p>
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>The time the stack was last updated. This field will only be returned if the stack
    /// has been updated at least once.</p>
    pub last_updated_time: std::option::Option<smithy_types::Instant>,
    /// <p>The time the stack was deleted.</p>
    pub deletion_time: std::option::Option<smithy_types::Instant>,
    /// <p>The current status of the stack.</p>
    pub stack_status: std::option::Option<crate::model::StackStatus>,
    /// <p>Success/Failure message associated with the stack status.</p>
    pub stack_status_reason: std::option::Option<std::string::String>,
    /// <p>For nested stacks--stacks created as resources for another stack--the stack ID of the
    /// direct parent of this stack. For the first level of nested stacks, the root stack is also
    /// the parent stack.</p>
    /// <p>For more information, see <a href="http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-nested-stacks.html">Working with Nested Stacks</a> in the
    /// <i>AWS CloudFormation User Guide</i>.</p>
    pub parent_id: std::option::Option<std::string::String>,
    /// <p>For nested stacks--stacks created as resources for another stack--the stack ID of the
    /// top-level stack to which the nested stack ultimately belongs.</p>
    /// <p>For more information, see <a href="http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-nested-stacks.html">Working with Nested Stacks</a> in the
    /// <i>AWS CloudFormation User Guide</i>.</p>
    pub root_id: std::option::Option<std::string::String>,
    /// <p>Summarizes information on whether a stack's actual configuration differs, or has
    /// <i>drifted</i>, from it's expected configuration, as defined in the stack
    /// template and any values specified as template parameters. For more information, see <a href="http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-stack-drift.html">Detecting Unregulated Configuration
    /// Changes to Stacks and Resources</a>.</p>
    pub drift_information: std::option::Option<crate::model::StackDriftInformationSummary>,
}
impl std::fmt::Debug for StackSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StackSummary");
        formatter.field("stack_id", &self.stack_id);
        formatter.field("stack_name", &self.stack_name);
        formatter.field("template_description", &self.template_description);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("last_updated_time", &self.last_updated_time);
        formatter.field("deletion_time", &self.deletion_time);
        formatter.field("stack_status", &self.stack_status);
        formatter.field("stack_status_reason", &self.stack_status_reason);
        formatter.field("parent_id", &self.parent_id);
        formatter.field("root_id", &self.root_id);
        formatter.field("drift_information", &self.drift_information);
        formatter.finish()
    }
}
/// See [`StackSummary`](crate::model::StackSummary)
pub mod stack_summary {
    /// A builder for [`StackSummary`](crate::model::StackSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) stack_id: std::option::Option<std::string::String>,
        pub(crate) stack_name: std::option::Option<std::string::String>,
        pub(crate) template_description: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<smithy_types::Instant>,
        pub(crate) last_updated_time: std::option::Option<smithy_types::Instant>,
        pub(crate) deletion_time: std::option::Option<smithy_types::Instant>,
        pub(crate) stack_status: std::option::Option<crate::model::StackStatus>,
        pub(crate) stack_status_reason: std::option::Option<std::string::String>,
        pub(crate) parent_id: std::option::Option<std::string::String>,
        pub(crate) root_id: std::option::Option<std::string::String>,
        pub(crate) drift_information:
            std::option::Option<crate::model::StackDriftInformationSummary>,
    }
    impl Builder {
        /// <p>Unique stack identifier.</p>
        pub fn stack_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.stack_id = Some(inp.into());
            self
        }
        pub fn set_stack_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.stack_id = inp;
            self
        }
        /// <p>The name associated with the stack.</p>
        pub fn stack_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.stack_name = Some(inp.into());
            self
        }
        pub fn set_stack_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.stack_name = inp;
            self
        }
        /// <p>The template description of the template used to create the stack.</p>
        pub fn template_description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.template_description = Some(inp.into());
            self
        }
        pub fn set_template_description(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.template_description = inp;
            self
        }
        /// <p>The time the stack was created.</p>
        pub fn creation_time(mut self, inp: smithy_types::Instant) -> Self {
            self.creation_time = Some(inp);
            self
        }
        pub fn set_creation_time(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = inp;
            self
        }
        /// <p>The time the stack was last updated. This field will only be returned if the stack
        /// has been updated at least once.</p>
        pub fn last_updated_time(mut self, inp: smithy_types::Instant) -> Self {
            self.last_updated_time = Some(inp);
            self
        }
        pub fn set_last_updated_time(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_updated_time = inp;
            self
        }
        /// <p>The time the stack was deleted.</p>
        pub fn deletion_time(mut self, inp: smithy_types::Instant) -> Self {
            self.deletion_time = Some(inp);
            self
        }
        pub fn set_deletion_time(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.deletion_time = inp;
            self
        }
        /// <p>The current status of the stack.</p>
        pub fn stack_status(mut self, inp: crate::model::StackStatus) -> Self {
            self.stack_status = Some(inp);
            self
        }
        pub fn set_stack_status(
            mut self,
            inp: std::option::Option<crate::model::StackStatus>,
        ) -> Self {
            self.stack_status = inp;
            self
        }
        /// <p>Success/Failure message associated with the stack status.</p>
        pub fn stack_status_reason(mut self, inp: impl Into<std::string::String>) -> Self {
            self.stack_status_reason = Some(inp.into());
            self
        }
        pub fn set_stack_status_reason(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.stack_status_reason = inp;
            self
        }
        /// <p>For nested stacks--stacks created as resources for another stack--the stack ID of the
        /// direct parent of this stack. For the first level of nested stacks, the root stack is also
        /// the parent stack.</p>
        /// <p>For more information, see <a href="http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-nested-stacks.html">Working with Nested Stacks</a> in the
        /// <i>AWS CloudFormation User Guide</i>.</p>
        pub fn parent_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.parent_id = Some(inp.into());
            self
        }
        pub fn set_parent_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.parent_id = inp;
            self
        }
        /// <p>For nested stacks--stacks created as resources for another stack--the stack ID of the
        /// top-level stack to which the nested stack ultimately belongs.</p>
        /// <p>For more information, see <a href="http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-nested-stacks.html">Working with Nested Stacks</a> in the
        /// <i>AWS CloudFormation User Guide</i>.</p>
        pub fn root_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.root_id = Some(inp.into());
            self
        }
        pub fn set_root_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.root_id = inp;
            self
        }
        /// <p>Summarizes information on whether a stack's actual configuration differs, or has
        /// <i>drifted</i>, from it's expected configuration, as defined in the stack
        /// template and any values specified as template parameters. For more information, see <a href="http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-stack-drift.html">Detecting Unregulated Configuration
        /// Changes to Stacks and Resources</a>.</p>
        pub fn drift_information(
            mut self,
            inp: crate::model::StackDriftInformationSummary,
        ) -> Self {
            self.drift_information = Some(inp);
            self
        }
        pub fn set_drift_information(
            mut self,
            inp: std::option::Option<crate::model::StackDriftInformationSummary>,
        ) -> Self {
            self.drift_information = inp;
            self
        }
        /// Consumes the builder and constructs a [`StackSummary`](crate::model::StackSummary)
        pub fn build(self) -> crate::model::StackSummary {
            crate::model::StackSummary {
                stack_id: self.stack_id,
                stack_name: self.stack_name,
                template_description: self.template_description,
                creation_time: self.creation_time,
                last_updated_time: self.last_updated_time,
                deletion_time: self.deletion_time,
                stack_status: self.stack_status,
                stack_status_reason: self.stack_status_reason,
                parent_id: self.parent_id,
                root_id: self.root_id,
                drift_information: self.drift_information,
            }
        }
    }
}
impl StackSummary {
    /// Creates a new builder-style object to manufacture [`StackSummary`](crate::model::StackSummary)
    pub fn builder() -> crate::model::stack_summary::Builder {
        crate::model::stack_summary::Builder::default()
    }
}

/// <p>Contains information about whether the stack's actual configuration differs, or has
/// <i>drifted</i>, from its expected configuration, as defined in the stack
/// template and any values specified as template parameters. A stack is considered to have
/// drifted if one or more of its resources have drifted.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StackDriftInformationSummary {
    /// <p>Status of the stack's actual configuration compared to its expected template
    /// configuration. </p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>DRIFTED</code>: The stack differs from its expected template
    /// configuration. A stack is considered to have drifted if one or more of its resources
    /// have drifted.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>NOT_CHECKED</code>: AWS CloudFormation has not checked if the stack differs from its
    /// expected template configuration.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>IN_SYNC</code>: The stack's actual configuration matches its expected
    /// template configuration.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>UNKNOWN</code>: This value is reserved for future use.</p>
    /// </li>
    /// </ul>
    pub stack_drift_status: std::option::Option<crate::model::StackDriftStatus>,
    /// <p>Most recent time when a drift detection operation was initiated on the stack, or any
    /// of its individual resources that support drift detection.</p>
    pub last_check_timestamp: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for StackDriftInformationSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StackDriftInformationSummary");
        formatter.field("stack_drift_status", &self.stack_drift_status);
        formatter.field("last_check_timestamp", &self.last_check_timestamp);
        formatter.finish()
    }
}
/// See [`StackDriftInformationSummary`](crate::model::StackDriftInformationSummary)
pub mod stack_drift_information_summary {
    /// A builder for [`StackDriftInformationSummary`](crate::model::StackDriftInformationSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) stack_drift_status: std::option::Option<crate::model::StackDriftStatus>,
        pub(crate) last_check_timestamp: std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p>Status of the stack's actual configuration compared to its expected template
        /// configuration. </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>DRIFTED</code>: The stack differs from its expected template
        /// configuration. A stack is considered to have drifted if one or more of its resources
        /// have drifted.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>NOT_CHECKED</code>: AWS CloudFormation has not checked if the stack differs from its
        /// expected template configuration.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>IN_SYNC</code>: The stack's actual configuration matches its expected
        /// template configuration.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>UNKNOWN</code>: This value is reserved for future use.</p>
        /// </li>
        /// </ul>
        pub fn stack_drift_status(mut self, inp: crate::model::StackDriftStatus) -> Self {
            self.stack_drift_status = Some(inp);
            self
        }
        pub fn set_stack_drift_status(
            mut self,
            inp: std::option::Option<crate::model::StackDriftStatus>,
        ) -> Self {
            self.stack_drift_status = inp;
            self
        }
        /// <p>Most recent time when a drift detection operation was initiated on the stack, or any
        /// of its individual resources that support drift detection.</p>
        pub fn last_check_timestamp(mut self, inp: smithy_types::Instant) -> Self {
            self.last_check_timestamp = Some(inp);
            self
        }
        pub fn set_last_check_timestamp(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_check_timestamp = inp;
            self
        }
        /// Consumes the builder and constructs a [`StackDriftInformationSummary`](crate::model::StackDriftInformationSummary)
        pub fn build(self) -> crate::model::StackDriftInformationSummary {
            crate::model::StackDriftInformationSummary {
                stack_drift_status: self.stack_drift_status,
                last_check_timestamp: self.last_check_timestamp,
            }
        }
    }
}
impl StackDriftInformationSummary {
    /// Creates a new builder-style object to manufacture [`StackDriftInformationSummary`](crate::model::StackDriftInformationSummary)
    pub fn builder() -> crate::model::stack_drift_information_summary::Builder {
        crate::model::stack_drift_information_summary::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StackStatus {
    CreateComplete,
    CreateFailed,
    CreateInProgress,
    DeleteComplete,
    DeleteFailed,
    DeleteInProgress,
    ImportComplete,
    ImportInProgress,
    ImportRollbackComplete,
    ImportRollbackFailed,
    ImportRollbackInProgress,
    ReviewInProgress,
    RollbackComplete,
    RollbackFailed,
    RollbackInProgress,
    UpdateComplete,
    UpdateCompleteCleanupInProgress,
    UpdateInProgress,
    UpdateRollbackComplete,
    UpdateRollbackCompleteCleanupInProgress,
    UpdateRollbackFailed,
    UpdateRollbackInProgress,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for StackStatus {
    fn from(s: &str) -> Self {
        match s {
            "CREATE_COMPLETE" => StackStatus::CreateComplete,
            "CREATE_FAILED" => StackStatus::CreateFailed,
            "CREATE_IN_PROGRESS" => StackStatus::CreateInProgress,
            "DELETE_COMPLETE" => StackStatus::DeleteComplete,
            "DELETE_FAILED" => StackStatus::DeleteFailed,
            "DELETE_IN_PROGRESS" => StackStatus::DeleteInProgress,
            "IMPORT_COMPLETE" => StackStatus::ImportComplete,
            "IMPORT_IN_PROGRESS" => StackStatus::ImportInProgress,
            "IMPORT_ROLLBACK_COMPLETE" => StackStatus::ImportRollbackComplete,
            "IMPORT_ROLLBACK_FAILED" => StackStatus::ImportRollbackFailed,
            "IMPORT_ROLLBACK_IN_PROGRESS" => StackStatus::ImportRollbackInProgress,
            "REVIEW_IN_PROGRESS" => StackStatus::ReviewInProgress,
            "ROLLBACK_COMPLETE" => StackStatus::RollbackComplete,
            "ROLLBACK_FAILED" => StackStatus::RollbackFailed,
            "ROLLBACK_IN_PROGRESS" => StackStatus::RollbackInProgress,
            "UPDATE_COMPLETE" => StackStatus::UpdateComplete,
            "UPDATE_COMPLETE_CLEANUP_IN_PROGRESS" => StackStatus::UpdateCompleteCleanupInProgress,
            "UPDATE_IN_PROGRESS" => StackStatus::UpdateInProgress,
            "UPDATE_ROLLBACK_COMPLETE" => StackStatus::UpdateRollbackComplete,
            "UPDATE_ROLLBACK_COMPLETE_CLEANUP_IN_PROGRESS" => {
                StackStatus::UpdateRollbackCompleteCleanupInProgress
            }
            "UPDATE_ROLLBACK_FAILED" => StackStatus::UpdateRollbackFailed,
            "UPDATE_ROLLBACK_IN_PROGRESS" => StackStatus::UpdateRollbackInProgress,
            other => StackStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for StackStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(StackStatus::from(s))
    }
}
impl StackStatus {
    pub fn as_str(&self) -> &str {
        match self {
            StackStatus::CreateComplete => "CREATE_COMPLETE",
            StackStatus::CreateFailed => "CREATE_FAILED",
            StackStatus::CreateInProgress => "CREATE_IN_PROGRESS",
            StackStatus::DeleteComplete => "DELETE_COMPLETE",
            StackStatus::DeleteFailed => "DELETE_FAILED",
            StackStatus::DeleteInProgress => "DELETE_IN_PROGRESS",
            StackStatus::ImportComplete => "IMPORT_COMPLETE",
            StackStatus::ImportInProgress => "IMPORT_IN_PROGRESS",
            StackStatus::ImportRollbackComplete => "IMPORT_ROLLBACK_COMPLETE",
            StackStatus::ImportRollbackFailed => "IMPORT_ROLLBACK_FAILED",
            StackStatus::ImportRollbackInProgress => "IMPORT_ROLLBACK_IN_PROGRESS",
            StackStatus::ReviewInProgress => "REVIEW_IN_PROGRESS",
            StackStatus::RollbackComplete => "ROLLBACK_COMPLETE",
            StackStatus::RollbackFailed => "ROLLBACK_FAILED",
            StackStatus::RollbackInProgress => "ROLLBACK_IN_PROGRESS",
            StackStatus::UpdateComplete => "UPDATE_COMPLETE",
            StackStatus::UpdateCompleteCleanupInProgress => "UPDATE_COMPLETE_CLEANUP_IN_PROGRESS",
            StackStatus::UpdateInProgress => "UPDATE_IN_PROGRESS",
            StackStatus::UpdateRollbackComplete => "UPDATE_ROLLBACK_COMPLETE",
            StackStatus::UpdateRollbackCompleteCleanupInProgress => {
                "UPDATE_ROLLBACK_COMPLETE_CLEANUP_IN_PROGRESS"
            }
            StackStatus::UpdateRollbackFailed => "UPDATE_ROLLBACK_FAILED",
            StackStatus::UpdateRollbackInProgress => "UPDATE_ROLLBACK_IN_PROGRESS",
            StackStatus::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for StackStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for StackStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>Contains high-level information about the specified stack resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StackResourceSummary {
    /// <p>The logical name of the resource specified in the template.</p>
    pub logical_resource_id: std::option::Option<std::string::String>,
    /// <p>The name or unique identifier that corresponds to a physical instance ID of the
    /// resource.</p>
    pub physical_resource_id: std::option::Option<std::string::String>,
    /// <p>Type of resource. (For more information, go to <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html"> AWS
    /// Resource Types Reference</a> in the AWS CloudFormation User Guide.)</p>
    pub resource_type: std::option::Option<std::string::String>,
    /// <p>Time the status was updated.</p>
    pub last_updated_timestamp: std::option::Option<smithy_types::Instant>,
    /// <p>Current status of the resource.</p>
    pub resource_status: std::option::Option<crate::model::ResourceStatus>,
    /// <p>Success/failure message associated with the resource.</p>
    pub resource_status_reason: std::option::Option<std::string::String>,
    /// <p>Information about whether the resource's actual configuration differs, or has
    /// <i>drifted</i>, from its expected configuration, as defined in the stack
    /// template and any values specified as template parameters. For more information, see <a href="http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-stack-drift.html">Detecting Unregulated Configuration
    /// Changes to Stacks and Resources</a>.</p>
    pub drift_information: std::option::Option<crate::model::StackResourceDriftInformationSummary>,
    /// <p>Contains information about the module from which the resource was created, if the resource was created from a module included in the stack template.</p>
    pub module_info: std::option::Option<crate::model::ModuleInfo>,
}
impl std::fmt::Debug for StackResourceSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StackResourceSummary");
        formatter.field("logical_resource_id", &self.logical_resource_id);
        formatter.field("physical_resource_id", &self.physical_resource_id);
        formatter.field("resource_type", &self.resource_type);
        formatter.field("last_updated_timestamp", &self.last_updated_timestamp);
        formatter.field("resource_status", &self.resource_status);
        formatter.field("resource_status_reason", &self.resource_status_reason);
        formatter.field("drift_information", &self.drift_information);
        formatter.field("module_info", &self.module_info);
        formatter.finish()
    }
}
/// See [`StackResourceSummary`](crate::model::StackResourceSummary)
pub mod stack_resource_summary {
    /// A builder for [`StackResourceSummary`](crate::model::StackResourceSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) logical_resource_id: std::option::Option<std::string::String>,
        pub(crate) physical_resource_id: std::option::Option<std::string::String>,
        pub(crate) resource_type: std::option::Option<std::string::String>,
        pub(crate) last_updated_timestamp: std::option::Option<smithy_types::Instant>,
        pub(crate) resource_status: std::option::Option<crate::model::ResourceStatus>,
        pub(crate) resource_status_reason: std::option::Option<std::string::String>,
        pub(crate) drift_information:
            std::option::Option<crate::model::StackResourceDriftInformationSummary>,
        pub(crate) module_info: std::option::Option<crate::model::ModuleInfo>,
    }
    impl Builder {
        /// <p>The logical name of the resource specified in the template.</p>
        pub fn logical_resource_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.logical_resource_id = Some(inp.into());
            self
        }
        pub fn set_logical_resource_id(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.logical_resource_id = inp;
            self
        }
        /// <p>The name or unique identifier that corresponds to a physical instance ID of the
        /// resource.</p>
        pub fn physical_resource_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.physical_resource_id = Some(inp.into());
            self
        }
        pub fn set_physical_resource_id(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.physical_resource_id = inp;
            self
        }
        /// <p>Type of resource. (For more information, go to <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html"> AWS
        /// Resource Types Reference</a> in the AWS CloudFormation User Guide.)</p>
        pub fn resource_type(mut self, inp: impl Into<std::string::String>) -> Self {
            self.resource_type = Some(inp.into());
            self
        }
        pub fn set_resource_type(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.resource_type = inp;
            self
        }
        /// <p>Time the status was updated.</p>
        pub fn last_updated_timestamp(mut self, inp: smithy_types::Instant) -> Self {
            self.last_updated_timestamp = Some(inp);
            self
        }
        pub fn set_last_updated_timestamp(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_updated_timestamp = inp;
            self
        }
        /// <p>Current status of the resource.</p>
        pub fn resource_status(mut self, inp: crate::model::ResourceStatus) -> Self {
            self.resource_status = Some(inp);
            self
        }
        pub fn set_resource_status(
            mut self,
            inp: std::option::Option<crate::model::ResourceStatus>,
        ) -> Self {
            self.resource_status = inp;
            self
        }
        /// <p>Success/failure message associated with the resource.</p>
        pub fn resource_status_reason(mut self, inp: impl Into<std::string::String>) -> Self {
            self.resource_status_reason = Some(inp.into());
            self
        }
        pub fn set_resource_status_reason(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_status_reason = inp;
            self
        }
        /// <p>Information about whether the resource's actual configuration differs, or has
        /// <i>drifted</i>, from its expected configuration, as defined in the stack
        /// template and any values specified as template parameters. For more information, see <a href="http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-stack-drift.html">Detecting Unregulated Configuration
        /// Changes to Stacks and Resources</a>.</p>
        pub fn drift_information(
            mut self,
            inp: crate::model::StackResourceDriftInformationSummary,
        ) -> Self {
            self.drift_information = Some(inp);
            self
        }
        pub fn set_drift_information(
            mut self,
            inp: std::option::Option<crate::model::StackResourceDriftInformationSummary>,
        ) -> Self {
            self.drift_information = inp;
            self
        }
        /// <p>Contains information about the module from which the resource was created, if the resource was created from a module included in the stack template.</p>
        pub fn module_info(mut self, inp: crate::model::ModuleInfo) -> Self {
            self.module_info = Some(inp);
            self
        }
        pub fn set_module_info(
            mut self,
            inp: std::option::Option<crate::model::ModuleInfo>,
        ) -> Self {
            self.module_info = inp;
            self
        }
        /// Consumes the builder and constructs a [`StackResourceSummary`](crate::model::StackResourceSummary)
        pub fn build(self) -> crate::model::StackResourceSummary {
            crate::model::StackResourceSummary {
                logical_resource_id: self.logical_resource_id,
                physical_resource_id: self.physical_resource_id,
                resource_type: self.resource_type,
                last_updated_timestamp: self.last_updated_timestamp,
                resource_status: self.resource_status,
                resource_status_reason: self.resource_status_reason,
                drift_information: self.drift_information,
                module_info: self.module_info,
            }
        }
    }
}
impl StackResourceSummary {
    /// Creates a new builder-style object to manufacture [`StackResourceSummary`](crate::model::StackResourceSummary)
    pub fn builder() -> crate::model::stack_resource_summary::Builder {
        crate::model::stack_resource_summary::Builder::default()
    }
}

/// <p>Contains information about the module from which the resource was created, if the resource was created from a module included in the stack template.</p>
/// <p>For more information on modules, see <a href="AWSCloudFormation/latest/UserGuide/modules.html">Using modules to encapsulate and reuse resource configurations</a> in the <i>CloudFormation User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ModuleInfo {
    /// <p>A concantenated list of the the module type or types containing the resource. Module types are listed starting with the inner-most nested module, and separated by  <code>/</code>.</p>
    /// <p>In the following example, the resource was created from a module of type <code>AWS::First::Example::MODULE</code>, that is nested inside a parent module of type <code>AWS::Second::Example::MODULE</code>.</p>
    /// <p>
    /// <code>AWS::First::Example::MODULE/AWS::Second::Example::MODULE</code>
    /// </p>
    pub type_hierarchy: std::option::Option<std::string::String>,
    /// <p>A concantenated list of the logical IDs of the module or modules containing the resource. Modules are listed starting with the inner-most nested module, and separated by  <code>/</code>.</p>
    /// <p>In the following example, the resource was created from a module, <code>moduleA</code>, that is nested inside a parent module, <code>moduleB</code>.</p>
    /// <p>
    /// <code>moduleA/moduleB</code>
    /// </p>
    /// <p>For more information, see <a href="AWSCloudFormation/latest/UserGuide/modules.html#module-ref-resources">Referencing resources in a module</a> in the <i>CloudFormation User Guide</i>.</p>
    pub logical_id_hierarchy: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ModuleInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ModuleInfo");
        formatter.field("type_hierarchy", &self.type_hierarchy);
        formatter.field("logical_id_hierarchy", &self.logical_id_hierarchy);
        formatter.finish()
    }
}
/// See [`ModuleInfo`](crate::model::ModuleInfo)
pub mod module_info {
    /// A builder for [`ModuleInfo`](crate::model::ModuleInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) type_hierarchy: std::option::Option<std::string::String>,
        pub(crate) logical_id_hierarchy: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A concantenated list of the the module type or types containing the resource. Module types are listed starting with the inner-most nested module, and separated by  <code>/</code>.</p>
        /// <p>In the following example, the resource was created from a module of type <code>AWS::First::Example::MODULE</code>, that is nested inside a parent module of type <code>AWS::Second::Example::MODULE</code>.</p>
        /// <p>
        /// <code>AWS::First::Example::MODULE/AWS::Second::Example::MODULE</code>
        /// </p>
        pub fn type_hierarchy(mut self, inp: impl Into<std::string::String>) -> Self {
            self.type_hierarchy = Some(inp.into());
            self
        }
        pub fn set_type_hierarchy(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.type_hierarchy = inp;
            self
        }
        /// <p>A concantenated list of the logical IDs of the module or modules containing the resource. Modules are listed starting with the inner-most nested module, and separated by  <code>/</code>.</p>
        /// <p>In the following example, the resource was created from a module, <code>moduleA</code>, that is nested inside a parent module, <code>moduleB</code>.</p>
        /// <p>
        /// <code>moduleA/moduleB</code>
        /// </p>
        /// <p>For more information, see <a href="AWSCloudFormation/latest/UserGuide/modules.html#module-ref-resources">Referencing resources in a module</a> in the <i>CloudFormation User Guide</i>.</p>
        pub fn logical_id_hierarchy(mut self, inp: impl Into<std::string::String>) -> Self {
            self.logical_id_hierarchy = Some(inp.into());
            self
        }
        pub fn set_logical_id_hierarchy(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.logical_id_hierarchy = inp;
            self
        }
        /// Consumes the builder and constructs a [`ModuleInfo`](crate::model::ModuleInfo)
        pub fn build(self) -> crate::model::ModuleInfo {
            crate::model::ModuleInfo {
                type_hierarchy: self.type_hierarchy,
                logical_id_hierarchy: self.logical_id_hierarchy,
            }
        }
    }
}
impl ModuleInfo {
    /// Creates a new builder-style object to manufacture [`ModuleInfo`](crate::model::ModuleInfo)
    pub fn builder() -> crate::model::module_info::Builder {
        crate::model::module_info::Builder::default()
    }
}

/// <p>Summarizes information about whether the resource's actual configuration differs, or
/// has <i>drifted</i>, from its expected configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StackResourceDriftInformationSummary {
    /// <p>Status of the resource's actual configuration compared to its expected
    /// configuration</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>DELETED</code>: The resource differs from its expected configuration in
    /// that it has been deleted.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>MODIFIED</code>: The resource differs from its expected
    /// configuration.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>NOT_CHECKED</code>: AWS CloudFormation has not checked if the resource differs from
    /// its expected configuration.</p>
    /// <p>Any resources that do not currently support drift detection have a status of
    /// <code>NOT_CHECKED</code>. For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-stack-drift-resource-list.html">Resources that Support Drift Detection</a>. If you performed an <a>ContinueUpdateRollback</a> operation on a stack, any resources included in
    /// <code>ResourcesToSkip</code> will also have a status of <code>NOT_CHECKED</code>.
    /// For more information on skipping resources during rollback operations, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-continueupdaterollback.html">Continue Rolling Back an Update</a> in the AWS CloudFormation User Guide.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>IN_SYNC</code>: The resources's actual configuration matches its expected
    /// configuration.</p>
    /// </li>
    /// </ul>
    pub stack_resource_drift_status: std::option::Option<crate::model::StackResourceDriftStatus>,
    /// <p>When AWS CloudFormation last checked if the resource had drifted from its expected
    /// configuration.</p>
    pub last_check_timestamp: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for StackResourceDriftInformationSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StackResourceDriftInformationSummary");
        formatter.field(
            "stack_resource_drift_status",
            &self.stack_resource_drift_status,
        );
        formatter.field("last_check_timestamp", &self.last_check_timestamp);
        formatter.finish()
    }
}
/// See [`StackResourceDriftInformationSummary`](crate::model::StackResourceDriftInformationSummary)
pub mod stack_resource_drift_information_summary {
    /// A builder for [`StackResourceDriftInformationSummary`](crate::model::StackResourceDriftInformationSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) stack_resource_drift_status:
            std::option::Option<crate::model::StackResourceDriftStatus>,
        pub(crate) last_check_timestamp: std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p>Status of the resource's actual configuration compared to its expected
        /// configuration</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>DELETED</code>: The resource differs from its expected configuration in
        /// that it has been deleted.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>MODIFIED</code>: The resource differs from its expected
        /// configuration.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>NOT_CHECKED</code>: AWS CloudFormation has not checked if the resource differs from
        /// its expected configuration.</p>
        /// <p>Any resources that do not currently support drift detection have a status of
        /// <code>NOT_CHECKED</code>. For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-stack-drift-resource-list.html">Resources that Support Drift Detection</a>. If you performed an <a>ContinueUpdateRollback</a> operation on a stack, any resources included in
        /// <code>ResourcesToSkip</code> will also have a status of <code>NOT_CHECKED</code>.
        /// For more information on skipping resources during rollback operations, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-continueupdaterollback.html">Continue Rolling Back an Update</a> in the AWS CloudFormation User Guide.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>IN_SYNC</code>: The resources's actual configuration matches its expected
        /// configuration.</p>
        /// </li>
        /// </ul>
        pub fn stack_resource_drift_status(
            mut self,
            inp: crate::model::StackResourceDriftStatus,
        ) -> Self {
            self.stack_resource_drift_status = Some(inp);
            self
        }
        pub fn set_stack_resource_drift_status(
            mut self,
            inp: std::option::Option<crate::model::StackResourceDriftStatus>,
        ) -> Self {
            self.stack_resource_drift_status = inp;
            self
        }
        /// <p>When AWS CloudFormation last checked if the resource had drifted from its expected
        /// configuration.</p>
        pub fn last_check_timestamp(mut self, inp: smithy_types::Instant) -> Self {
            self.last_check_timestamp = Some(inp);
            self
        }
        pub fn set_last_check_timestamp(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_check_timestamp = inp;
            self
        }
        /// Consumes the builder and constructs a [`StackResourceDriftInformationSummary`](crate::model::StackResourceDriftInformationSummary)
        pub fn build(self) -> crate::model::StackResourceDriftInformationSummary {
            crate::model::StackResourceDriftInformationSummary {
                stack_resource_drift_status: self.stack_resource_drift_status,
                last_check_timestamp: self.last_check_timestamp,
            }
        }
    }
}
impl StackResourceDriftInformationSummary {
    /// Creates a new builder-style object to manufacture [`StackResourceDriftInformationSummary`](crate::model::StackResourceDriftInformationSummary)
    pub fn builder() -> crate::model::stack_resource_drift_information_summary::Builder {
        crate::model::stack_resource_drift_information_summary::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StackResourceDriftStatus {
    Deleted,
    InSync,
    Modified,
    NotChecked,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for StackResourceDriftStatus {
    fn from(s: &str) -> Self {
        match s {
            "DELETED" => StackResourceDriftStatus::Deleted,
            "IN_SYNC" => StackResourceDriftStatus::InSync,
            "MODIFIED" => StackResourceDriftStatus::Modified,
            "NOT_CHECKED" => StackResourceDriftStatus::NotChecked,
            other => StackResourceDriftStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for StackResourceDriftStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(StackResourceDriftStatus::from(s))
    }
}
impl StackResourceDriftStatus {
    pub fn as_str(&self) -> &str {
        match self {
            StackResourceDriftStatus::Deleted => "DELETED",
            StackResourceDriftStatus::InSync => "IN_SYNC",
            StackResourceDriftStatus::Modified => "MODIFIED",
            StackResourceDriftStatus::NotChecked => "NOT_CHECKED",
            StackResourceDriftStatus::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for StackResourceDriftStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for StackResourceDriftStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ResourceStatus {
    CreateComplete,
    CreateFailed,
    CreateInProgress,
    DeleteComplete,
    DeleteFailed,
    DeleteInProgress,
    DeleteSkipped,
    ImportComplete,
    ImportFailed,
    ImportInProgress,
    ImportRollbackComplete,
    ImportRollbackFailed,
    ImportRollbackInProgress,
    UpdateComplete,
    UpdateFailed,
    UpdateInProgress,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ResourceStatus {
    fn from(s: &str) -> Self {
        match s {
            "CREATE_COMPLETE" => ResourceStatus::CreateComplete,
            "CREATE_FAILED" => ResourceStatus::CreateFailed,
            "CREATE_IN_PROGRESS" => ResourceStatus::CreateInProgress,
            "DELETE_COMPLETE" => ResourceStatus::DeleteComplete,
            "DELETE_FAILED" => ResourceStatus::DeleteFailed,
            "DELETE_IN_PROGRESS" => ResourceStatus::DeleteInProgress,
            "DELETE_SKIPPED" => ResourceStatus::DeleteSkipped,
            "IMPORT_COMPLETE" => ResourceStatus::ImportComplete,
            "IMPORT_FAILED" => ResourceStatus::ImportFailed,
            "IMPORT_IN_PROGRESS" => ResourceStatus::ImportInProgress,
            "IMPORT_ROLLBACK_COMPLETE" => ResourceStatus::ImportRollbackComplete,
            "IMPORT_ROLLBACK_FAILED" => ResourceStatus::ImportRollbackFailed,
            "IMPORT_ROLLBACK_IN_PROGRESS" => ResourceStatus::ImportRollbackInProgress,
            "UPDATE_COMPLETE" => ResourceStatus::UpdateComplete,
            "UPDATE_FAILED" => ResourceStatus::UpdateFailed,
            "UPDATE_IN_PROGRESS" => ResourceStatus::UpdateInProgress,
            other => ResourceStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ResourceStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(ResourceStatus::from(s))
    }
}
impl ResourceStatus {
    pub fn as_str(&self) -> &str {
        match self {
            ResourceStatus::CreateComplete => "CREATE_COMPLETE",
            ResourceStatus::CreateFailed => "CREATE_FAILED",
            ResourceStatus::CreateInProgress => "CREATE_IN_PROGRESS",
            ResourceStatus::DeleteComplete => "DELETE_COMPLETE",
            ResourceStatus::DeleteFailed => "DELETE_FAILED",
            ResourceStatus::DeleteInProgress => "DELETE_IN_PROGRESS",
            ResourceStatus::DeleteSkipped => "DELETE_SKIPPED",
            ResourceStatus::ImportComplete => "IMPORT_COMPLETE",
            ResourceStatus::ImportFailed => "IMPORT_FAILED",
            ResourceStatus::ImportInProgress => "IMPORT_IN_PROGRESS",
            ResourceStatus::ImportRollbackComplete => "IMPORT_ROLLBACK_COMPLETE",
            ResourceStatus::ImportRollbackFailed => "IMPORT_ROLLBACK_FAILED",
            ResourceStatus::ImportRollbackInProgress => "IMPORT_ROLLBACK_IN_PROGRESS",
            ResourceStatus::UpdateComplete => "UPDATE_COMPLETE",
            ResourceStatus::UpdateFailed => "UPDATE_FAILED",
            ResourceStatus::UpdateInProgress => "UPDATE_IN_PROGRESS",
            ResourceStatus::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for ResourceStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for ResourceStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>The structure that contains summary information about a stack instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StackInstanceSummary {
    /// <p>The name or unique ID of the stack set that the stack instance is associated
    /// with.</p>
    pub stack_set_id: std::option::Option<std::string::String>,
    /// <p>The name of the AWS Region that the stack instance is associated with.</p>
    pub region: std::option::Option<std::string::String>,
    /// <p>[Self-managed permissions] The name of the AWS account that the stack instance is associated with.</p>
    pub account: std::option::Option<std::string::String>,
    /// <p>The ID of the stack instance.</p>
    pub stack_id: std::option::Option<std::string::String>,
    /// <p>The status of the stack instance, in terms of its synchronization with its associated
    /// stack set.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>INOPERABLE</code>: A <code>DeleteStackInstances</code> operation has
    /// failed and left the stack in an unstable state. Stacks in this state are excluded
    /// from further <code>UpdateStackSet</code> operations. You might need to perform a
    /// <code>DeleteStackInstances</code> operation, with <code>RetainStacks</code> set to
    /// <code>true</code>, to delete the stack instance, and then delete the stack
    /// manually.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>OUTDATED</code>: The stack isn't currently up to date with the stack set
    /// because:</p>
    /// <ul>
    /// <li>
    /// <p>The associated stack failed during a <code>CreateStackSet</code> or
    /// <code>UpdateStackSet</code> operation. </p>
    /// </li>
    /// <li>
    /// <p>The stack was part of a <code>CreateStackSet</code> or
    /// <code>UpdateStackSet</code> operation that failed or was stopped before the
    /// stack was created or updated. </p>
    /// </li>
    /// </ul>
    /// </li>
    /// <li>
    /// <p>
    /// <code>CURRENT</code>: The stack is currently up to date with the stack
    /// set.</p>
    /// </li>
    /// </ul>
    pub status: std::option::Option<crate::model::StackInstanceStatus>,
    /// <p>The explanation for the specific status code assigned to this stack
    /// instance.</p>
    pub status_reason: std::option::Option<std::string::String>,
    /// <p>The detailed status of the stack instance.</p>
    pub stack_instance_status: std::option::Option<crate::model::StackInstanceComprehensiveStatus>,
    /// <p>[Service-managed permissions] The organization root ID or organizational unit (OU) IDs that you specified for <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/APIReference/API_DeploymentTargets.html">DeploymentTargets</a>.</p>
    pub organizational_unit_id: std::option::Option<std::string::String>,
    /// <p>Status of the stack instance's actual configuration compared to the expected template
    /// and parameter configuration of the stack set to which it belongs. </p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>DRIFTED</code>: The stack differs from the expected template and parameter
    /// configuration of the stack set to which it belongs. A stack instance is considered to
    /// have drifted if one or more of the resources in the associated stack have
    /// drifted.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>NOT_CHECKED</code>: AWS CloudFormation has not checked if the stack instance differs from
    /// its expected stack set configuration.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>IN_SYNC</code>: The stack instance's actual configuration matches its
    /// expected stack set configuration.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>UNKNOWN</code>: This value is reserved for future use.</p>
    /// </li>
    /// </ul>
    pub drift_status: std::option::Option<crate::model::StackDriftStatus>,
    /// <p>Most recent time when CloudFormation performed a drift detection operation on the stack
    /// instance. This value will be <code>NULL</code> for any stack instance on which drift
    /// detection has not yet been performed.</p>
    pub last_drift_check_timestamp: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for StackInstanceSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StackInstanceSummary");
        formatter.field("stack_set_id", &self.stack_set_id);
        formatter.field("region", &self.region);
        formatter.field("account", &self.account);
        formatter.field("stack_id", &self.stack_id);
        formatter.field("status", &self.status);
        formatter.field("status_reason", &self.status_reason);
        formatter.field("stack_instance_status", &self.stack_instance_status);
        formatter.field("organizational_unit_id", &self.organizational_unit_id);
        formatter.field("drift_status", &self.drift_status);
        formatter.field(
            "last_drift_check_timestamp",
            &self.last_drift_check_timestamp,
        );
        formatter.finish()
    }
}
/// See [`StackInstanceSummary`](crate::model::StackInstanceSummary)
pub mod stack_instance_summary {
    /// A builder for [`StackInstanceSummary`](crate::model::StackInstanceSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) stack_set_id: std::option::Option<std::string::String>,
        pub(crate) region: std::option::Option<std::string::String>,
        pub(crate) account: std::option::Option<std::string::String>,
        pub(crate) stack_id: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::StackInstanceStatus>,
        pub(crate) status_reason: std::option::Option<std::string::String>,
        pub(crate) stack_instance_status:
            std::option::Option<crate::model::StackInstanceComprehensiveStatus>,
        pub(crate) organizational_unit_id: std::option::Option<std::string::String>,
        pub(crate) drift_status: std::option::Option<crate::model::StackDriftStatus>,
        pub(crate) last_drift_check_timestamp: std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The name or unique ID of the stack set that the stack instance is associated
        /// with.</p>
        pub fn stack_set_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.stack_set_id = Some(inp.into());
            self
        }
        pub fn set_stack_set_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.stack_set_id = inp;
            self
        }
        /// <p>The name of the AWS Region that the stack instance is associated with.</p>
        pub fn region(mut self, inp: impl Into<std::string::String>) -> Self {
            self.region = Some(inp.into());
            self
        }
        pub fn set_region(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.region = inp;
            self
        }
        /// <p>[Self-managed permissions] The name of the AWS account that the stack instance is associated with.</p>
        pub fn account(mut self, inp: impl Into<std::string::String>) -> Self {
            self.account = Some(inp.into());
            self
        }
        pub fn set_account(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.account = inp;
            self
        }
        /// <p>The ID of the stack instance.</p>
        pub fn stack_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.stack_id = Some(inp.into());
            self
        }
        pub fn set_stack_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.stack_id = inp;
            self
        }
        /// <p>The status of the stack instance, in terms of its synchronization with its associated
        /// stack set.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>INOPERABLE</code>: A <code>DeleteStackInstances</code> operation has
        /// failed and left the stack in an unstable state. Stacks in this state are excluded
        /// from further <code>UpdateStackSet</code> operations. You might need to perform a
        /// <code>DeleteStackInstances</code> operation, with <code>RetainStacks</code> set to
        /// <code>true</code>, to delete the stack instance, and then delete the stack
        /// manually.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>OUTDATED</code>: The stack isn't currently up to date with the stack set
        /// because:</p>
        /// <ul>
        /// <li>
        /// <p>The associated stack failed during a <code>CreateStackSet</code> or
        /// <code>UpdateStackSet</code> operation. </p>
        /// </li>
        /// <li>
        /// <p>The stack was part of a <code>CreateStackSet</code> or
        /// <code>UpdateStackSet</code> operation that failed or was stopped before the
        /// stack was created or updated. </p>
        /// </li>
        /// </ul>
        /// </li>
        /// <li>
        /// <p>
        /// <code>CURRENT</code>: The stack is currently up to date with the stack
        /// set.</p>
        /// </li>
        /// </ul>
        pub fn status(mut self, inp: crate::model::StackInstanceStatus) -> Self {
            self.status = Some(inp);
            self
        }
        pub fn set_status(
            mut self,
            inp: std::option::Option<crate::model::StackInstanceStatus>,
        ) -> Self {
            self.status = inp;
            self
        }
        /// <p>The explanation for the specific status code assigned to this stack
        /// instance.</p>
        pub fn status_reason(mut self, inp: impl Into<std::string::String>) -> Self {
            self.status_reason = Some(inp.into());
            self
        }
        pub fn set_status_reason(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.status_reason = inp;
            self
        }
        /// <p>The detailed status of the stack instance.</p>
        pub fn stack_instance_status(
            mut self,
            inp: crate::model::StackInstanceComprehensiveStatus,
        ) -> Self {
            self.stack_instance_status = Some(inp);
            self
        }
        pub fn set_stack_instance_status(
            mut self,
            inp: std::option::Option<crate::model::StackInstanceComprehensiveStatus>,
        ) -> Self {
            self.stack_instance_status = inp;
            self
        }
        /// <p>[Service-managed permissions] The organization root ID or organizational unit (OU) IDs that you specified for <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/APIReference/API_DeploymentTargets.html">DeploymentTargets</a>.</p>
        pub fn organizational_unit_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.organizational_unit_id = Some(inp.into());
            self
        }
        pub fn set_organizational_unit_id(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.organizational_unit_id = inp;
            self
        }
        /// <p>Status of the stack instance's actual configuration compared to the expected template
        /// and parameter configuration of the stack set to which it belongs. </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>DRIFTED</code>: The stack differs from the expected template and parameter
        /// configuration of the stack set to which it belongs. A stack instance is considered to
        /// have drifted if one or more of the resources in the associated stack have
        /// drifted.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>NOT_CHECKED</code>: AWS CloudFormation has not checked if the stack instance differs from
        /// its expected stack set configuration.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>IN_SYNC</code>: The stack instance's actual configuration matches its
        /// expected stack set configuration.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>UNKNOWN</code>: This value is reserved for future use.</p>
        /// </li>
        /// </ul>
        pub fn drift_status(mut self, inp: crate::model::StackDriftStatus) -> Self {
            self.drift_status = Some(inp);
            self
        }
        pub fn set_drift_status(
            mut self,
            inp: std::option::Option<crate::model::StackDriftStatus>,
        ) -> Self {
            self.drift_status = inp;
            self
        }
        /// <p>Most recent time when CloudFormation performed a drift detection operation on the stack
        /// instance. This value will be <code>NULL</code> for any stack instance on which drift
        /// detection has not yet been performed.</p>
        pub fn last_drift_check_timestamp(mut self, inp: smithy_types::Instant) -> Self {
            self.last_drift_check_timestamp = Some(inp);
            self
        }
        pub fn set_last_drift_check_timestamp(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_drift_check_timestamp = inp;
            self
        }
        /// Consumes the builder and constructs a [`StackInstanceSummary`](crate::model::StackInstanceSummary)
        pub fn build(self) -> crate::model::StackInstanceSummary {
            crate::model::StackInstanceSummary {
                stack_set_id: self.stack_set_id,
                region: self.region,
                account: self.account,
                stack_id: self.stack_id,
                status: self.status,
                status_reason: self.status_reason,
                stack_instance_status: self.stack_instance_status,
                organizational_unit_id: self.organizational_unit_id,
                drift_status: self.drift_status,
                last_drift_check_timestamp: self.last_drift_check_timestamp,
            }
        }
    }
}
impl StackInstanceSummary {
    /// Creates a new builder-style object to manufacture [`StackInstanceSummary`](crate::model::StackInstanceSummary)
    pub fn builder() -> crate::model::stack_instance_summary::Builder {
        crate::model::stack_instance_summary::Builder::default()
    }
}

/// <p>The detailed status of the stack instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StackInstanceComprehensiveStatus {
    /// <ul>
    /// <li>
    /// <p>
    /// <code>CANCELLED</code>: The operation in the specified account and Region has been cancelled. This is either because a user has stopped the stack set operation, or because the failure tolerance of the stack set operation has been exceeded.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>FAILED</code>: The operation in the specified account and Region failed. If
    /// the stack set operation fails in enough accounts within a Region, the failure
    /// tolerance for the stack set operation as a whole might be exceeded.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>INOPERABLE</code>: A <code>DeleteStackInstances</code> operation has failed and left the stack in an unstable state. Stacks in this state are excluded from further <code>UpdateStackSet</code> operations. You might need to perform a <code>DeleteStackInstances</code> operation, with <code>RetainStacks</code> set to <code>true</code>, to delete the stack instance, and then delete the stack manually.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>PENDING</code>: The operation in the specified account and Region has yet to start.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>RUNNING</code>: The operation in the specified account and Region is currently in progress.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>SUCCEEDED</code>: The operation in the specified account and Region completed successfully.</p>
    /// </li>
    /// </ul>
    pub detailed_status: std::option::Option<crate::model::StackInstanceDetailedStatus>,
}
impl std::fmt::Debug for StackInstanceComprehensiveStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StackInstanceComprehensiveStatus");
        formatter.field("detailed_status", &self.detailed_status);
        formatter.finish()
    }
}
/// See [`StackInstanceComprehensiveStatus`](crate::model::StackInstanceComprehensiveStatus)
pub mod stack_instance_comprehensive_status {
    /// A builder for [`StackInstanceComprehensiveStatus`](crate::model::StackInstanceComprehensiveStatus)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) detailed_status: std::option::Option<crate::model::StackInstanceDetailedStatus>,
    }
    impl Builder {
        /// <ul>
        /// <li>
        /// <p>
        /// <code>CANCELLED</code>: The operation in the specified account and Region has been cancelled. This is either because a user has stopped the stack set operation, or because the failure tolerance of the stack set operation has been exceeded.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>FAILED</code>: The operation in the specified account and Region failed. If
        /// the stack set operation fails in enough accounts within a Region, the failure
        /// tolerance for the stack set operation as a whole might be exceeded.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>INOPERABLE</code>: A <code>DeleteStackInstances</code> operation has failed and left the stack in an unstable state. Stacks in this state are excluded from further <code>UpdateStackSet</code> operations. You might need to perform a <code>DeleteStackInstances</code> operation, with <code>RetainStacks</code> set to <code>true</code>, to delete the stack instance, and then delete the stack manually.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>PENDING</code>: The operation in the specified account and Region has yet to start.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>RUNNING</code>: The operation in the specified account and Region is currently in progress.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>SUCCEEDED</code>: The operation in the specified account and Region completed successfully.</p>
        /// </li>
        /// </ul>
        pub fn detailed_status(mut self, inp: crate::model::StackInstanceDetailedStatus) -> Self {
            self.detailed_status = Some(inp);
            self
        }
        pub fn set_detailed_status(
            mut self,
            inp: std::option::Option<crate::model::StackInstanceDetailedStatus>,
        ) -> Self {
            self.detailed_status = inp;
            self
        }
        /// Consumes the builder and constructs a [`StackInstanceComprehensiveStatus`](crate::model::StackInstanceComprehensiveStatus)
        pub fn build(self) -> crate::model::StackInstanceComprehensiveStatus {
            crate::model::StackInstanceComprehensiveStatus {
                detailed_status: self.detailed_status,
            }
        }
    }
}
impl StackInstanceComprehensiveStatus {
    /// Creates a new builder-style object to manufacture [`StackInstanceComprehensiveStatus`](crate::model::StackInstanceComprehensiveStatus)
    pub fn builder() -> crate::model::stack_instance_comprehensive_status::Builder {
        crate::model::stack_instance_comprehensive_status::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StackInstanceDetailedStatus {
    Cancelled,
    Failed,
    Inoperable,
    Pending,
    Running,
    Succeeded,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for StackInstanceDetailedStatus {
    fn from(s: &str) -> Self {
        match s {
            "CANCELLED" => StackInstanceDetailedStatus::Cancelled,
            "FAILED" => StackInstanceDetailedStatus::Failed,
            "INOPERABLE" => StackInstanceDetailedStatus::Inoperable,
            "PENDING" => StackInstanceDetailedStatus::Pending,
            "RUNNING" => StackInstanceDetailedStatus::Running,
            "SUCCEEDED" => StackInstanceDetailedStatus::Succeeded,
            other => StackInstanceDetailedStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for StackInstanceDetailedStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(StackInstanceDetailedStatus::from(s))
    }
}
impl StackInstanceDetailedStatus {
    pub fn as_str(&self) -> &str {
        match self {
            StackInstanceDetailedStatus::Cancelled => "CANCELLED",
            StackInstanceDetailedStatus::Failed => "FAILED",
            StackInstanceDetailedStatus::Inoperable => "INOPERABLE",
            StackInstanceDetailedStatus::Pending => "PENDING",
            StackInstanceDetailedStatus::Running => "RUNNING",
            StackInstanceDetailedStatus::Succeeded => "SUCCEEDED",
            StackInstanceDetailedStatus::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for StackInstanceDetailedStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for StackInstanceDetailedStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StackInstanceStatus {
    Current,
    Inoperable,
    Outdated,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for StackInstanceStatus {
    fn from(s: &str) -> Self {
        match s {
            "CURRENT" => StackInstanceStatus::Current,
            "INOPERABLE" => StackInstanceStatus::Inoperable,
            "OUTDATED" => StackInstanceStatus::Outdated,
            other => StackInstanceStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for StackInstanceStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(StackInstanceStatus::from(s))
    }
}
impl StackInstanceStatus {
    pub fn as_str(&self) -> &str {
        match self {
            StackInstanceStatus::Current => "CURRENT",
            StackInstanceStatus::Inoperable => "INOPERABLE",
            StackInstanceStatus::Outdated => "OUTDATED",
            StackInstanceStatus::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for StackInstanceStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for StackInstanceStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>The status that stack instances are filtered by.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StackInstanceFilter {
    /// <p>The type of filter to apply.</p>
    pub name: std::option::Option<crate::model::StackInstanceFilterName>,
    /// <p>The status to filter by.</p>
    pub values: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for StackInstanceFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StackInstanceFilter");
        formatter.field("name", &self.name);
        formatter.field("values", &self.values);
        formatter.finish()
    }
}
/// See [`StackInstanceFilter`](crate::model::StackInstanceFilter)
pub mod stack_instance_filter {
    /// A builder for [`StackInstanceFilter`](crate::model::StackInstanceFilter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<crate::model::StackInstanceFilterName>,
        pub(crate) values: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The type of filter to apply.</p>
        pub fn name(mut self, inp: crate::model::StackInstanceFilterName) -> Self {
            self.name = Some(inp);
            self
        }
        pub fn set_name(
            mut self,
            inp: std::option::Option<crate::model::StackInstanceFilterName>,
        ) -> Self {
            self.name = inp;
            self
        }
        /// <p>The status to filter by.</p>
        pub fn values(mut self, inp: impl Into<std::string::String>) -> Self {
            self.values = Some(inp.into());
            self
        }
        pub fn set_values(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.values = inp;
            self
        }
        /// Consumes the builder and constructs a [`StackInstanceFilter`](crate::model::StackInstanceFilter)
        pub fn build(self) -> crate::model::StackInstanceFilter {
            crate::model::StackInstanceFilter {
                name: self.name,
                values: self.values,
            }
        }
    }
}
impl StackInstanceFilter {
    /// Creates a new builder-style object to manufacture [`StackInstanceFilter`](crate::model::StackInstanceFilter)
    pub fn builder() -> crate::model::stack_instance_filter::Builder {
        crate::model::stack_instance_filter::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StackInstanceFilterName {
    DetailedStatus,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for StackInstanceFilterName {
    fn from(s: &str) -> Self {
        match s {
            "DETAILED_STATUS" => StackInstanceFilterName::DetailedStatus,
            other => StackInstanceFilterName::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for StackInstanceFilterName {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(StackInstanceFilterName::from(s))
    }
}
impl StackInstanceFilterName {
    pub fn as_str(&self) -> &str {
        match self {
            StackInstanceFilterName::DetailedStatus => "DETAILED_STATUS",
            StackInstanceFilterName::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for StackInstanceFilterName {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for StackInstanceFilterName {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>The <code>Export</code> structure describes the exported output values for a
/// stack.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Export {
    /// <p>The stack that contains the exported output name and value.</p>
    pub exporting_stack_id: std::option::Option<std::string::String>,
    /// <p>The name of exported output value. Use this name and the <code>Fn::ImportValue</code>
    /// function to import the associated value into other stacks. The name is defined in the
    /// <code>Export</code> field in the associated stack's <code>Outputs</code>
    /// section.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The value of the exported output, such as a resource physical ID. This value is
    /// defined in the <code>Export</code> field in the associated stack's <code>Outputs</code>
    /// section.</p>
    pub value: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Export {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Export");
        formatter.field("exporting_stack_id", &self.exporting_stack_id);
        formatter.field("name", &self.name);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`Export`](crate::model::Export)
pub mod export {
    /// A builder for [`Export`](crate::model::Export)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) exporting_stack_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The stack that contains the exported output name and value.</p>
        pub fn exporting_stack_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.exporting_stack_id = Some(inp.into());
            self
        }
        pub fn set_exporting_stack_id(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.exporting_stack_id = inp;
            self
        }
        /// <p>The name of exported output value. Use this name and the <code>Fn::ImportValue</code>
        /// function to import the associated value into other stacks. The name is defined in the
        /// <code>Export</code> field in the associated stack's <code>Outputs</code>
        /// section.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.name = Some(inp.into());
            self
        }
        pub fn set_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.name = inp;
            self
        }
        /// <p>The value of the exported output, such as a resource physical ID. This value is
        /// defined in the <code>Export</code> field in the associated stack's <code>Outputs</code>
        /// section.</p>
        pub fn value(mut self, inp: impl Into<std::string::String>) -> Self {
            self.value = Some(inp.into());
            self
        }
        pub fn set_value(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.value = inp;
            self
        }
        /// Consumes the builder and constructs a [`Export`](crate::model::Export)
        pub fn build(self) -> crate::model::Export {
            crate::model::Export {
                exporting_stack_id: self.exporting_stack_id,
                name: self.name,
                value: self.value,
            }
        }
    }
}
impl Export {
    /// Creates a new builder-style object to manufacture [`Export`](crate::model::Export)
    pub fn builder() -> crate::model::export::Builder {
        crate::model::export::Builder::default()
    }
}

/// <p>The <code>ChangeSetSummary</code> structure describes a change set, its status, and
/// the stack with which it's associated.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ChangeSetSummary {
    /// <p>The ID of the stack with which the change set is associated.</p>
    pub stack_id: std::option::Option<std::string::String>,
    /// <p>The name of the stack with which the change set is associated.</p>
    pub stack_name: std::option::Option<std::string::String>,
    /// <p>The ID of the change set.</p>
    pub change_set_id: std::option::Option<std::string::String>,
    /// <p>The name of the change set.</p>
    pub change_set_name: std::option::Option<std::string::String>,
    /// <p>If the change set execution status is <code>AVAILABLE</code>, you can execute the
    /// change set. If you can’t execute the change set, the status indicates why. For example, a
    /// change set might be in an <code>UNAVAILABLE</code> state because AWS CloudFormation is
    /// still creating it or in an <code>OBSOLETE</code> state because the stack was already
    /// updated.</p>
    pub execution_status: std::option::Option<crate::model::ExecutionStatus>,
    /// <p>The state of the change set, such as <code>CREATE_IN_PROGRESS</code>,
    /// <code>CREATE_COMPLETE</code>, or <code>FAILED</code>.</p>
    pub status: std::option::Option<crate::model::ChangeSetStatus>,
    /// <p>A description of the change set's status. For example, if your change set is in the
    /// <code>FAILED</code> state, AWS CloudFormation shows the error message.</p>
    pub status_reason: std::option::Option<std::string::String>,
    /// <p>The start time when the change set was created, in UTC.</p>
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>Descriptive information about the change set.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>Specifies the current setting of <code>IncludeNestedStacks</code> for the change
    /// set.</p>
    pub include_nested_stacks: std::option::Option<bool>,
    /// <p>The parent change set ID.</p>
    pub parent_change_set_id: std::option::Option<std::string::String>,
    /// <p>The root change set ID.</p>
    pub root_change_set_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ChangeSetSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ChangeSetSummary");
        formatter.field("stack_id", &self.stack_id);
        formatter.field("stack_name", &self.stack_name);
        formatter.field("change_set_id", &self.change_set_id);
        formatter.field("change_set_name", &self.change_set_name);
        formatter.field("execution_status", &self.execution_status);
        formatter.field("status", &self.status);
        formatter.field("status_reason", &self.status_reason);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("description", &self.description);
        formatter.field("include_nested_stacks", &self.include_nested_stacks);
        formatter.field("parent_change_set_id", &self.parent_change_set_id);
        formatter.field("root_change_set_id", &self.root_change_set_id);
        formatter.finish()
    }
}
/// See [`ChangeSetSummary`](crate::model::ChangeSetSummary)
pub mod change_set_summary {
    /// A builder for [`ChangeSetSummary`](crate::model::ChangeSetSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) stack_id: std::option::Option<std::string::String>,
        pub(crate) stack_name: std::option::Option<std::string::String>,
        pub(crate) change_set_id: std::option::Option<std::string::String>,
        pub(crate) change_set_name: std::option::Option<std::string::String>,
        pub(crate) execution_status: std::option::Option<crate::model::ExecutionStatus>,
        pub(crate) status: std::option::Option<crate::model::ChangeSetStatus>,
        pub(crate) status_reason: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<smithy_types::Instant>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) include_nested_stacks: std::option::Option<bool>,
        pub(crate) parent_change_set_id: std::option::Option<std::string::String>,
        pub(crate) root_change_set_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the stack with which the change set is associated.</p>
        pub fn stack_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.stack_id = Some(inp.into());
            self
        }
        pub fn set_stack_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.stack_id = inp;
            self
        }
        /// <p>The name of the stack with which the change set is associated.</p>
        pub fn stack_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.stack_name = Some(inp.into());
            self
        }
        pub fn set_stack_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.stack_name = inp;
            self
        }
        /// <p>The ID of the change set.</p>
        pub fn change_set_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.change_set_id = Some(inp.into());
            self
        }
        pub fn set_change_set_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.change_set_id = inp;
            self
        }
        /// <p>The name of the change set.</p>
        pub fn change_set_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.change_set_name = Some(inp.into());
            self
        }
        pub fn set_change_set_name(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.change_set_name = inp;
            self
        }
        /// <p>If the change set execution status is <code>AVAILABLE</code>, you can execute the
        /// change set. If you can’t execute the change set, the status indicates why. For example, a
        /// change set might be in an <code>UNAVAILABLE</code> state because AWS CloudFormation is
        /// still creating it or in an <code>OBSOLETE</code> state because the stack was already
        /// updated.</p>
        pub fn execution_status(mut self, inp: crate::model::ExecutionStatus) -> Self {
            self.execution_status = Some(inp);
            self
        }
        pub fn set_execution_status(
            mut self,
            inp: std::option::Option<crate::model::ExecutionStatus>,
        ) -> Self {
            self.execution_status = inp;
            self
        }
        /// <p>The state of the change set, such as <code>CREATE_IN_PROGRESS</code>,
        /// <code>CREATE_COMPLETE</code>, or <code>FAILED</code>.</p>
        pub fn status(mut self, inp: crate::model::ChangeSetStatus) -> Self {
            self.status = Some(inp);
            self
        }
        pub fn set_status(
            mut self,
            inp: std::option::Option<crate::model::ChangeSetStatus>,
        ) -> Self {
            self.status = inp;
            self
        }
        /// <p>A description of the change set's status. For example, if your change set is in the
        /// <code>FAILED</code> state, AWS CloudFormation shows the error message.</p>
        pub fn status_reason(mut self, inp: impl Into<std::string::String>) -> Self {
            self.status_reason = Some(inp.into());
            self
        }
        pub fn set_status_reason(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.status_reason = inp;
            self
        }
        /// <p>The start time when the change set was created, in UTC.</p>
        pub fn creation_time(mut self, inp: smithy_types::Instant) -> Self {
            self.creation_time = Some(inp);
            self
        }
        pub fn set_creation_time(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = inp;
            self
        }
        /// <p>Descriptive information about the change set.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.description = Some(inp.into());
            self
        }
        pub fn set_description(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.description = inp;
            self
        }
        /// <p>Specifies the current setting of <code>IncludeNestedStacks</code> for the change
        /// set.</p>
        pub fn include_nested_stacks(mut self, inp: bool) -> Self {
            self.include_nested_stacks = Some(inp);
            self
        }
        pub fn set_include_nested_stacks(mut self, inp: std::option::Option<bool>) -> Self {
            self.include_nested_stacks = inp;
            self
        }
        /// <p>The parent change set ID.</p>
        pub fn parent_change_set_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.parent_change_set_id = Some(inp.into());
            self
        }
        pub fn set_parent_change_set_id(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.parent_change_set_id = inp;
            self
        }
        /// <p>The root change set ID.</p>
        pub fn root_change_set_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.root_change_set_id = Some(inp.into());
            self
        }
        pub fn set_root_change_set_id(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.root_change_set_id = inp;
            self
        }
        /// Consumes the builder and constructs a [`ChangeSetSummary`](crate::model::ChangeSetSummary)
        pub fn build(self) -> crate::model::ChangeSetSummary {
            crate::model::ChangeSetSummary {
                stack_id: self.stack_id,
                stack_name: self.stack_name,
                change_set_id: self.change_set_id,
                change_set_name: self.change_set_name,
                execution_status: self.execution_status,
                status: self.status,
                status_reason: self.status_reason,
                creation_time: self.creation_time,
                description: self.description,
                include_nested_stacks: self.include_nested_stacks,
                parent_change_set_id: self.parent_change_set_id,
                root_change_set_id: self.root_change_set_id,
            }
        }
    }
}
impl ChangeSetSummary {
    /// Creates a new builder-style object to manufacture [`ChangeSetSummary`](crate::model::ChangeSetSummary)
    pub fn builder() -> crate::model::change_set_summary::Builder {
        crate::model::change_set_summary::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ChangeSetStatus {
    CreateComplete,
    CreateInProgress,
    CreatePending,
    DeleteComplete,
    DeleteFailed,
    DeleteInProgress,
    DeletePending,
    Failed,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ChangeSetStatus {
    fn from(s: &str) -> Self {
        match s {
            "CREATE_COMPLETE" => ChangeSetStatus::CreateComplete,
            "CREATE_IN_PROGRESS" => ChangeSetStatus::CreateInProgress,
            "CREATE_PENDING" => ChangeSetStatus::CreatePending,
            "DELETE_COMPLETE" => ChangeSetStatus::DeleteComplete,
            "DELETE_FAILED" => ChangeSetStatus::DeleteFailed,
            "DELETE_IN_PROGRESS" => ChangeSetStatus::DeleteInProgress,
            "DELETE_PENDING" => ChangeSetStatus::DeletePending,
            "FAILED" => ChangeSetStatus::Failed,
            other => ChangeSetStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ChangeSetStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(ChangeSetStatus::from(s))
    }
}
impl ChangeSetStatus {
    pub fn as_str(&self) -> &str {
        match self {
            ChangeSetStatus::CreateComplete => "CREATE_COMPLETE",
            ChangeSetStatus::CreateInProgress => "CREATE_IN_PROGRESS",
            ChangeSetStatus::CreatePending => "CREATE_PENDING",
            ChangeSetStatus::DeleteComplete => "DELETE_COMPLETE",
            ChangeSetStatus::DeleteFailed => "DELETE_FAILED",
            ChangeSetStatus::DeleteInProgress => "DELETE_IN_PROGRESS",
            ChangeSetStatus::DeletePending => "DELETE_PENDING",
            ChangeSetStatus::Failed => "FAILED",
            ChangeSetStatus::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for ChangeSetStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for ChangeSetStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ExecutionStatus {
    Available,
    ExecuteComplete,
    ExecuteFailed,
    ExecuteInProgress,
    Obsolete,
    Unavailable,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ExecutionStatus {
    fn from(s: &str) -> Self {
        match s {
            "AVAILABLE" => ExecutionStatus::Available,
            "EXECUTE_COMPLETE" => ExecutionStatus::ExecuteComplete,
            "EXECUTE_FAILED" => ExecutionStatus::ExecuteFailed,
            "EXECUTE_IN_PROGRESS" => ExecutionStatus::ExecuteInProgress,
            "OBSOLETE" => ExecutionStatus::Obsolete,
            "UNAVAILABLE" => ExecutionStatus::Unavailable,
            other => ExecutionStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ExecutionStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(ExecutionStatus::from(s))
    }
}
impl ExecutionStatus {
    pub fn as_str(&self) -> &str {
        match self {
            ExecutionStatus::Available => "AVAILABLE",
            ExecutionStatus::ExecuteComplete => "EXECUTE_COMPLETE",
            ExecutionStatus::ExecuteFailed => "EXECUTE_FAILED",
            ExecutionStatus::ExecuteInProgress => "EXECUTE_IN_PROGRESS",
            ExecutionStatus::Obsolete => "OBSOLETE",
            ExecutionStatus::Unavailable => "UNAVAILABLE",
            ExecutionStatus::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for ExecutionStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for ExecutionStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>Describes the target resources of a specific type in your import template (for example,
/// all <code>AWS::S3::Bucket</code> resources) and the properties you can provide during the
/// import to identify resources of that type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceIdentifierSummary {
    /// <p>The template resource type of the target resources, such as
    /// <code>AWS::S3::Bucket</code>.</p>
    pub resource_type: std::option::Option<std::string::String>,
    /// <p>The logical IDs of the target resources of the specified <code>ResourceType</code>, as
    /// defined in the import template.</p>
    pub logical_resource_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The resource properties you can provide during the import to identify your target
    /// resources. For example, <code>BucketName</code> is a possible identifier property for
    /// <code>AWS::S3::Bucket</code> resources.</p>
    pub resource_identifiers: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for ResourceIdentifierSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceIdentifierSummary");
        formatter.field("resource_type", &self.resource_type);
        formatter.field("logical_resource_ids", &self.logical_resource_ids);
        formatter.field("resource_identifiers", &self.resource_identifiers);
        formatter.finish()
    }
}
/// See [`ResourceIdentifierSummary`](crate::model::ResourceIdentifierSummary)
pub mod resource_identifier_summary {
    /// A builder for [`ResourceIdentifierSummary`](crate::model::ResourceIdentifierSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_type: std::option::Option<std::string::String>,
        pub(crate) logical_resource_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) resource_identifiers: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The template resource type of the target resources, such as
        /// <code>AWS::S3::Bucket</code>.</p>
        pub fn resource_type(mut self, inp: impl Into<std::string::String>) -> Self {
            self.resource_type = Some(inp.into());
            self
        }
        pub fn set_resource_type(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.resource_type = inp;
            self
        }
        pub fn logical_resource_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            let mut v = self.logical_resource_ids.unwrap_or_default();
            v.push(inp.into());
            self.logical_resource_ids = Some(v);
            self
        }
        pub fn set_logical_resource_ids(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.logical_resource_ids = inp;
            self
        }
        pub fn resource_identifiers(mut self, inp: impl Into<std::string::String>) -> Self {
            let mut v = self.resource_identifiers.unwrap_or_default();
            v.push(inp.into());
            self.resource_identifiers = Some(v);
            self
        }
        pub fn set_resource_identifiers(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.resource_identifiers = inp;
            self
        }
        /// Consumes the builder and constructs a [`ResourceIdentifierSummary`](crate::model::ResourceIdentifierSummary)
        pub fn build(self) -> crate::model::ResourceIdentifierSummary {
            crate::model::ResourceIdentifierSummary {
                resource_type: self.resource_type,
                logical_resource_ids: self.logical_resource_ids,
                resource_identifiers: self.resource_identifiers,
            }
        }
    }
}
impl ResourceIdentifierSummary {
    /// Creates a new builder-style object to manufacture [`ResourceIdentifierSummary`](crate::model::ResourceIdentifierSummary)
    pub fn builder() -> crate::model::resource_identifier_summary::Builder {
        crate::model::resource_identifier_summary::Builder::default()
    }
}

/// <p>The ParameterDeclaration data type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ParameterDeclaration {
    /// <p>The name that is associated with the parameter.</p>
    pub parameter_key: std::option::Option<std::string::String>,
    /// <p>The default value of the parameter.</p>
    pub default_value: std::option::Option<std::string::String>,
    /// <p>The type of parameter.</p>
    pub parameter_type: std::option::Option<std::string::String>,
    /// <p>Flag that indicates whether the parameter value is shown as plain text in logs and in
    /// the AWS Management Console.</p>
    pub no_echo: std::option::Option<bool>,
    /// <p>The description that is associate with the parameter.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The criteria that AWS CloudFormation uses to validate parameter values.</p>
    pub parameter_constraints: std::option::Option<crate::model::ParameterConstraints>,
}
impl std::fmt::Debug for ParameterDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ParameterDeclaration");
        formatter.field("parameter_key", &self.parameter_key);
        formatter.field("default_value", &self.default_value);
        formatter.field("parameter_type", &self.parameter_type);
        formatter.field("no_echo", &self.no_echo);
        formatter.field("description", &self.description);
        formatter.field("parameter_constraints", &self.parameter_constraints);
        formatter.finish()
    }
}
/// See [`ParameterDeclaration`](crate::model::ParameterDeclaration)
pub mod parameter_declaration {
    /// A builder for [`ParameterDeclaration`](crate::model::ParameterDeclaration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) parameter_key: std::option::Option<std::string::String>,
        pub(crate) default_value: std::option::Option<std::string::String>,
        pub(crate) parameter_type: std::option::Option<std::string::String>,
        pub(crate) no_echo: std::option::Option<bool>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) parameter_constraints: std::option::Option<crate::model::ParameterConstraints>,
    }
    impl Builder {
        /// <p>The name that is associated with the parameter.</p>
        pub fn parameter_key(mut self, inp: impl Into<std::string::String>) -> Self {
            self.parameter_key = Some(inp.into());
            self
        }
        pub fn set_parameter_key(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.parameter_key = inp;
            self
        }
        /// <p>The default value of the parameter.</p>
        pub fn default_value(mut self, inp: impl Into<std::string::String>) -> Self {
            self.default_value = Some(inp.into());
            self
        }
        pub fn set_default_value(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.default_value = inp;
            self
        }
        /// <p>The type of parameter.</p>
        pub fn parameter_type(mut self, inp: impl Into<std::string::String>) -> Self {
            self.parameter_type = Some(inp.into());
            self
        }
        pub fn set_parameter_type(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.parameter_type = inp;
            self
        }
        /// <p>Flag that indicates whether the parameter value is shown as plain text in logs and in
        /// the AWS Management Console.</p>
        pub fn no_echo(mut self, inp: bool) -> Self {
            self.no_echo = Some(inp);
            self
        }
        pub fn set_no_echo(mut self, inp: std::option::Option<bool>) -> Self {
            self.no_echo = inp;
            self
        }
        /// <p>The description that is associate with the parameter.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.description = Some(inp.into());
            self
        }
        pub fn set_description(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.description = inp;
            self
        }
        /// <p>The criteria that AWS CloudFormation uses to validate parameter values.</p>
        pub fn parameter_constraints(mut self, inp: crate::model::ParameterConstraints) -> Self {
            self.parameter_constraints = Some(inp);
            self
        }
        pub fn set_parameter_constraints(
            mut self,
            inp: std::option::Option<crate::model::ParameterConstraints>,
        ) -> Self {
            self.parameter_constraints = inp;
            self
        }
        /// Consumes the builder and constructs a [`ParameterDeclaration`](crate::model::ParameterDeclaration)
        pub fn build(self) -> crate::model::ParameterDeclaration {
            crate::model::ParameterDeclaration {
                parameter_key: self.parameter_key,
                default_value: self.default_value,
                parameter_type: self.parameter_type,
                no_echo: self.no_echo,
                description: self.description,
                parameter_constraints: self.parameter_constraints,
            }
        }
    }
}
impl ParameterDeclaration {
    /// Creates a new builder-style object to manufacture [`ParameterDeclaration`](crate::model::ParameterDeclaration)
    pub fn builder() -> crate::model::parameter_declaration::Builder {
        crate::model::parameter_declaration::Builder::default()
    }
}

/// <p>A set of criteria that AWS CloudFormation uses to validate parameter values. Although
/// other constraints might be defined in the stack template, AWS CloudFormation returns only
/// the <code>AllowedValues</code> property.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ParameterConstraints {
    /// <p>A list of values that are permitted for a parameter.</p>
    pub allowed_values: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for ParameterConstraints {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ParameterConstraints");
        formatter.field("allowed_values", &self.allowed_values);
        formatter.finish()
    }
}
/// See [`ParameterConstraints`](crate::model::ParameterConstraints)
pub mod parameter_constraints {
    /// A builder for [`ParameterConstraints`](crate::model::ParameterConstraints)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) allowed_values: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        pub fn allowed_values(mut self, inp: impl Into<std::string::String>) -> Self {
            let mut v = self.allowed_values.unwrap_or_default();
            v.push(inp.into());
            self.allowed_values = Some(v);
            self
        }
        pub fn set_allowed_values(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.allowed_values = inp;
            self
        }
        /// Consumes the builder and constructs a [`ParameterConstraints`](crate::model::ParameterConstraints)
        pub fn build(self) -> crate::model::ParameterConstraints {
            crate::model::ParameterConstraints {
                allowed_values: self.allowed_values,
            }
        }
    }
}
impl ParameterConstraints {
    /// Creates a new builder-style object to manufacture [`ParameterConstraints`](crate::model::ParameterConstraints)
    pub fn builder() -> crate::model::parameter_constraints::Builder {
        crate::model::parameter_constraints::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TemplateStage {
    Original,
    Processed,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for TemplateStage {
    fn from(s: &str) -> Self {
        match s {
            "Original" => TemplateStage::Original,
            "Processed" => TemplateStage::Processed,
            other => TemplateStage::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for TemplateStage {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(TemplateStage::from(s))
    }
}
impl TemplateStage {
    pub fn as_str(&self) -> &str {
        match self {
            TemplateStage::Original => "Original",
            TemplateStage::Processed => "Processed",
            TemplateStage::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for TemplateStage {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for TemplateStage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>Contains the drift information for a resource that has been checked for drift. This
/// includes actual and expected property values for resources in which AWS CloudFormation has detected
/// drift. Only resource properties explicitly defined in the stack template are checked for
/// drift. For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-stack-drift.html">Detecting
/// Unregulated Configuration Changes to Stacks and Resources</a>.</p>
/// <p>Resources that do not currently support drift detection cannot be checked. For a list
/// of resources that support drift detection, see <a href="http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-stack-drift-resource-list.html">Resources that Support
/// Drift Detection</a>.</p>
/// <p>Use <a>DetectStackResourceDrift</a> to detect drift on individual
/// resources, or <a>DetectStackDrift</a> to detect drift on all resources in a
/// given stack that support drift detection.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StackResourceDrift {
    /// <p>The ID of the stack.</p>
    pub stack_id: std::option::Option<std::string::String>,
    /// <p>The logical name of the resource specified in the template.</p>
    pub logical_resource_id: std::option::Option<std::string::String>,
    /// <p>The name or unique identifier that corresponds to a physical instance ID of a
    /// resource supported by AWS CloudFormation. </p>
    pub physical_resource_id: std::option::Option<std::string::String>,
    /// <p>Context information that enables AWS CloudFormation to uniquely identify a resource. AWS CloudFormation uses
    /// context key-value pairs in cases where a resource's logical and physical IDs are not enough
    /// to uniquely identify that resource. Each context key-value pair specifies a unique resource
    /// that contains the targeted resource.</p>
    pub physical_resource_id_context:
        std::option::Option<std::vec::Vec<crate::model::PhysicalResourceIdContextKeyValuePair>>,
    /// <p>The type of the resource.</p>
    pub resource_type: std::option::Option<std::string::String>,
    /// <p>A JSON structure containing the expected property values of the stack resource, as
    /// defined in the stack template and any values specified as template parameters. </p>
    /// <p>For resources whose <code>StackResourceDriftStatus</code> is <code>DELETED</code>,
    /// this structure will not be present. </p>
    pub expected_properties: std::option::Option<std::string::String>,
    /// <p>A JSON structure containing the actual property values of the stack
    /// resource.</p>
    /// <p>For resources whose <code>StackResourceDriftStatus</code> is <code>DELETED</code>,
    /// this structure will not be present. </p>
    pub actual_properties: std::option::Option<std::string::String>,
    /// <p>A collection of the resource properties whose actual values differ from their
    /// expected values. These will be present only for resources whose
    /// <code>StackResourceDriftStatus</code> is <code>MODIFIED</code>.
    /// </p>
    pub property_differences: std::option::Option<std::vec::Vec<crate::model::PropertyDifference>>,
    /// <p>Status of the resource's actual configuration compared to its expected
    /// configuration</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>DELETED</code>: The resource differs from its expected template
    /// configuration because the resource has been deleted.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>MODIFIED</code>: One or more resource properties differ from their
    /// expected values (as defined in the stack template and any values specified as
    /// template parameters).</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>IN_SYNC</code>: The resources's actual configuration matches its expected
    /// template configuration.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>NOT_CHECKED</code>: AWS CloudFormation does not currently return this value.</p>
    /// </li>
    /// </ul>
    pub stack_resource_drift_status: std::option::Option<crate::model::StackResourceDriftStatus>,
    /// <p>Time at which AWS CloudFormation performed drift detection on the stack resource.</p>
    pub timestamp: std::option::Option<smithy_types::Instant>,
    /// <p>Contains information about the module from which the resource was created, if the resource was created from a module included in the stack template.</p>
    pub module_info: std::option::Option<crate::model::ModuleInfo>,
}
impl std::fmt::Debug for StackResourceDrift {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StackResourceDrift");
        formatter.field("stack_id", &self.stack_id);
        formatter.field("logical_resource_id", &self.logical_resource_id);
        formatter.field("physical_resource_id", &self.physical_resource_id);
        formatter.field(
            "physical_resource_id_context",
            &self.physical_resource_id_context,
        );
        formatter.field("resource_type", &self.resource_type);
        formatter.field("expected_properties", &self.expected_properties);
        formatter.field("actual_properties", &self.actual_properties);
        formatter.field("property_differences", &self.property_differences);
        formatter.field(
            "stack_resource_drift_status",
            &self.stack_resource_drift_status,
        );
        formatter.field("timestamp", &self.timestamp);
        formatter.field("module_info", &self.module_info);
        formatter.finish()
    }
}
/// See [`StackResourceDrift`](crate::model::StackResourceDrift)
pub mod stack_resource_drift {
    /// A builder for [`StackResourceDrift`](crate::model::StackResourceDrift)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) stack_id: std::option::Option<std::string::String>,
        pub(crate) logical_resource_id: std::option::Option<std::string::String>,
        pub(crate) physical_resource_id: std::option::Option<std::string::String>,
        pub(crate) physical_resource_id_context:
            std::option::Option<std::vec::Vec<crate::model::PhysicalResourceIdContextKeyValuePair>>,
        pub(crate) resource_type: std::option::Option<std::string::String>,
        pub(crate) expected_properties: std::option::Option<std::string::String>,
        pub(crate) actual_properties: std::option::Option<std::string::String>,
        pub(crate) property_differences:
            std::option::Option<std::vec::Vec<crate::model::PropertyDifference>>,
        pub(crate) stack_resource_drift_status:
            std::option::Option<crate::model::StackResourceDriftStatus>,
        pub(crate) timestamp: std::option::Option<smithy_types::Instant>,
        pub(crate) module_info: std::option::Option<crate::model::ModuleInfo>,
    }
    impl Builder {
        /// <p>The ID of the stack.</p>
        pub fn stack_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.stack_id = Some(inp.into());
            self
        }
        pub fn set_stack_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.stack_id = inp;
            self
        }
        /// <p>The logical name of the resource specified in the template.</p>
        pub fn logical_resource_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.logical_resource_id = Some(inp.into());
            self
        }
        pub fn set_logical_resource_id(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.logical_resource_id = inp;
            self
        }
        /// <p>The name or unique identifier that corresponds to a physical instance ID of a
        /// resource supported by AWS CloudFormation. </p>
        pub fn physical_resource_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.physical_resource_id = Some(inp.into());
            self
        }
        pub fn set_physical_resource_id(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.physical_resource_id = inp;
            self
        }
        pub fn physical_resource_id_context(
            mut self,
            inp: impl Into<crate::model::PhysicalResourceIdContextKeyValuePair>,
        ) -> Self {
            let mut v = self.physical_resource_id_context.unwrap_or_default();
            v.push(inp.into());
            self.physical_resource_id_context = Some(v);
            self
        }
        pub fn set_physical_resource_id_context(
            mut self,
            inp: std::option::Option<
                std::vec::Vec<crate::model::PhysicalResourceIdContextKeyValuePair>,
            >,
        ) -> Self {
            self.physical_resource_id_context = inp;
            self
        }
        /// <p>The type of the resource.</p>
        pub fn resource_type(mut self, inp: impl Into<std::string::String>) -> Self {
            self.resource_type = Some(inp.into());
            self
        }
        pub fn set_resource_type(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.resource_type = inp;
            self
        }
        /// <p>A JSON structure containing the expected property values of the stack resource, as
        /// defined in the stack template and any values specified as template parameters. </p>
        /// <p>For resources whose <code>StackResourceDriftStatus</code> is <code>DELETED</code>,
        /// this structure will not be present. </p>
        pub fn expected_properties(mut self, inp: impl Into<std::string::String>) -> Self {
            self.expected_properties = Some(inp.into());
            self
        }
        pub fn set_expected_properties(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_properties = inp;
            self
        }
        /// <p>A JSON structure containing the actual property values of the stack
        /// resource.</p>
        /// <p>For resources whose <code>StackResourceDriftStatus</code> is <code>DELETED</code>,
        /// this structure will not be present. </p>
        pub fn actual_properties(mut self, inp: impl Into<std::string::String>) -> Self {
            self.actual_properties = Some(inp.into());
            self
        }
        pub fn set_actual_properties(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.actual_properties = inp;
            self
        }
        pub fn property_differences(
            mut self,
            inp: impl Into<crate::model::PropertyDifference>,
        ) -> Self {
            let mut v = self.property_differences.unwrap_or_default();
            v.push(inp.into());
            self.property_differences = Some(v);
            self
        }
        pub fn set_property_differences(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::PropertyDifference>>,
        ) -> Self {
            self.property_differences = inp;
            self
        }
        /// <p>Status of the resource's actual configuration compared to its expected
        /// configuration</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>DELETED</code>: The resource differs from its expected template
        /// configuration because the resource has been deleted.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>MODIFIED</code>: One or more resource properties differ from their
        /// expected values (as defined in the stack template and any values specified as
        /// template parameters).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>IN_SYNC</code>: The resources's actual configuration matches its expected
        /// template configuration.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>NOT_CHECKED</code>: AWS CloudFormation does not currently return this value.</p>
        /// </li>
        /// </ul>
        pub fn stack_resource_drift_status(
            mut self,
            inp: crate::model::StackResourceDriftStatus,
        ) -> Self {
            self.stack_resource_drift_status = Some(inp);
            self
        }
        pub fn set_stack_resource_drift_status(
            mut self,
            inp: std::option::Option<crate::model::StackResourceDriftStatus>,
        ) -> Self {
            self.stack_resource_drift_status = inp;
            self
        }
        /// <p>Time at which AWS CloudFormation performed drift detection on the stack resource.</p>
        pub fn timestamp(mut self, inp: smithy_types::Instant) -> Self {
            self.timestamp = Some(inp);
            self
        }
        pub fn set_timestamp(mut self, inp: std::option::Option<smithy_types::Instant>) -> Self {
            self.timestamp = inp;
            self
        }
        /// <p>Contains information about the module from which the resource was created, if the resource was created from a module included in the stack template.</p>
        pub fn module_info(mut self, inp: crate::model::ModuleInfo) -> Self {
            self.module_info = Some(inp);
            self
        }
        pub fn set_module_info(
            mut self,
            inp: std::option::Option<crate::model::ModuleInfo>,
        ) -> Self {
            self.module_info = inp;
            self
        }
        /// Consumes the builder and constructs a [`StackResourceDrift`](crate::model::StackResourceDrift)
        pub fn build(self) -> crate::model::StackResourceDrift {
            crate::model::StackResourceDrift {
                stack_id: self.stack_id,
                logical_resource_id: self.logical_resource_id,
                physical_resource_id: self.physical_resource_id,
                physical_resource_id_context: self.physical_resource_id_context,
                resource_type: self.resource_type,
                expected_properties: self.expected_properties,
                actual_properties: self.actual_properties,
                property_differences: self.property_differences,
                stack_resource_drift_status: self.stack_resource_drift_status,
                timestamp: self.timestamp,
                module_info: self.module_info,
            }
        }
    }
}
impl StackResourceDrift {
    /// Creates a new builder-style object to manufacture [`StackResourceDrift`](crate::model::StackResourceDrift)
    pub fn builder() -> crate::model::stack_resource_drift::Builder {
        crate::model::stack_resource_drift::Builder::default()
    }
}

/// <p>Information about a resource property whose actual value differs from its expected
/// value, as defined in the stack template and any values specified as template parameters.
/// These will be present only for resources whose <code>StackResourceDriftStatus</code> is
/// <code>MODIFIED</code>. For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-stack-drift.html">Detecting
/// Unregulated Configuration Changes to Stacks and Resources</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PropertyDifference {
    /// <p>The fully-qualified path to the resource property.</p>
    pub property_path: std::option::Option<std::string::String>,
    /// <p>The expected property value of the resource property, as defined in the stack
    /// template and any values specified as template parameters.</p>
    pub expected_value: std::option::Option<std::string::String>,
    /// <p>The actual property value of the resource property.</p>
    pub actual_value: std::option::Option<std::string::String>,
    /// <p>The type of property difference.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>ADD</code>: A value has been added to a resource property that is an
    /// array or list data type.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>REMOVE</code>: The property has been removed from the current resource
    /// configuration.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>NOT_EQUAL</code>: The current property value differs from its expected
    /// value (as defined in the stack template and any values specified as template
    /// parameters).</p>
    /// </li>
    /// </ul>
    pub difference_type: std::option::Option<crate::model::DifferenceType>,
}
impl std::fmt::Debug for PropertyDifference {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PropertyDifference");
        formatter.field("property_path", &self.property_path);
        formatter.field("expected_value", &self.expected_value);
        formatter.field("actual_value", &self.actual_value);
        formatter.field("difference_type", &self.difference_type);
        formatter.finish()
    }
}
/// See [`PropertyDifference`](crate::model::PropertyDifference)
pub mod property_difference {
    /// A builder for [`PropertyDifference`](crate::model::PropertyDifference)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) property_path: std::option::Option<std::string::String>,
        pub(crate) expected_value: std::option::Option<std::string::String>,
        pub(crate) actual_value: std::option::Option<std::string::String>,
        pub(crate) difference_type: std::option::Option<crate::model::DifferenceType>,
    }
    impl Builder {
        /// <p>The fully-qualified path to the resource property.</p>
        pub fn property_path(mut self, inp: impl Into<std::string::String>) -> Self {
            self.property_path = Some(inp.into());
            self
        }
        pub fn set_property_path(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.property_path = inp;
            self
        }
        /// <p>The expected property value of the resource property, as defined in the stack
        /// template and any values specified as template parameters.</p>
        pub fn expected_value(mut self, inp: impl Into<std::string::String>) -> Self {
            self.expected_value = Some(inp.into());
            self
        }
        pub fn set_expected_value(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.expected_value = inp;
            self
        }
        /// <p>The actual property value of the resource property.</p>
        pub fn actual_value(mut self, inp: impl Into<std::string::String>) -> Self {
            self.actual_value = Some(inp.into());
            self
        }
        pub fn set_actual_value(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.actual_value = inp;
            self
        }
        /// <p>The type of property difference.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>ADD</code>: A value has been added to a resource property that is an
        /// array or list data type.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>REMOVE</code>: The property has been removed from the current resource
        /// configuration.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>NOT_EQUAL</code>: The current property value differs from its expected
        /// value (as defined in the stack template and any values specified as template
        /// parameters).</p>
        /// </li>
        /// </ul>
        pub fn difference_type(mut self, inp: crate::model::DifferenceType) -> Self {
            self.difference_type = Some(inp);
            self
        }
        pub fn set_difference_type(
            mut self,
            inp: std::option::Option<crate::model::DifferenceType>,
        ) -> Self {
            self.difference_type = inp;
            self
        }
        /// Consumes the builder and constructs a [`PropertyDifference`](crate::model::PropertyDifference)
        pub fn build(self) -> crate::model::PropertyDifference {
            crate::model::PropertyDifference {
                property_path: self.property_path,
                expected_value: self.expected_value,
                actual_value: self.actual_value,
                difference_type: self.difference_type,
            }
        }
    }
}
impl PropertyDifference {
    /// Creates a new builder-style object to manufacture [`PropertyDifference`](crate::model::PropertyDifference)
    pub fn builder() -> crate::model::property_difference::Builder {
        crate::model::property_difference::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DifferenceType {
    Add,
    NotEqual,
    Remove,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for DifferenceType {
    fn from(s: &str) -> Self {
        match s {
            "ADD" => DifferenceType::Add,
            "NOT_EQUAL" => DifferenceType::NotEqual,
            "REMOVE" => DifferenceType::Remove,
            other => DifferenceType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for DifferenceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(DifferenceType::from(s))
    }
}
impl DifferenceType {
    pub fn as_str(&self) -> &str {
        match self {
            DifferenceType::Add => "ADD",
            DifferenceType::NotEqual => "NOT_EQUAL",
            DifferenceType::Remove => "REMOVE",
            DifferenceType::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for DifferenceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for DifferenceType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>Context information that enables AWS CloudFormation to uniquely identify a resource. AWS CloudFormation uses
/// context key-value pairs in cases where a resource's logical and physical IDs are not enough
/// to uniquely identify that resource. Each context key-value pair specifies a resource that
/// contains the targeted resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PhysicalResourceIdContextKeyValuePair {
    /// <p>The resource context key.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>The resource context value.</p>
    pub value: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PhysicalResourceIdContextKeyValuePair {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PhysicalResourceIdContextKeyValuePair");
        formatter.field("key", &self.key);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`PhysicalResourceIdContextKeyValuePair`](crate::model::PhysicalResourceIdContextKeyValuePair)
pub mod physical_resource_id_context_key_value_pair {
    /// A builder for [`PhysicalResourceIdContextKeyValuePair`](crate::model::PhysicalResourceIdContextKeyValuePair)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The resource context key.</p>
        pub fn key(mut self, inp: impl Into<std::string::String>) -> Self {
            self.key = Some(inp.into());
            self
        }
        pub fn set_key(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.key = inp;
            self
        }
        /// <p>The resource context value.</p>
        pub fn value(mut self, inp: impl Into<std::string::String>) -> Self {
            self.value = Some(inp.into());
            self
        }
        pub fn set_value(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.value = inp;
            self
        }
        /// Consumes the builder and constructs a [`PhysicalResourceIdContextKeyValuePair`](crate::model::PhysicalResourceIdContextKeyValuePair)
        pub fn build(self) -> crate::model::PhysicalResourceIdContextKeyValuePair {
            crate::model::PhysicalResourceIdContextKeyValuePair {
                key: self.key,
                value: self.value,
            }
        }
    }
}
impl PhysicalResourceIdContextKeyValuePair {
    /// Creates a new builder-style object to manufacture [`PhysicalResourceIdContextKeyValuePair`](crate::model::PhysicalResourceIdContextKeyValuePair)
    pub fn builder() -> crate::model::physical_resource_id_context_key_value_pair::Builder {
        crate::model::physical_resource_id_context_key_value_pair::Builder::default()
    }
}

/// <p>The structure that contains information about a stack set operation. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StackSetOperation {
    /// <p>The unique ID of a stack set operation.</p>
    pub operation_id: std::option::Option<std::string::String>,
    /// <p>The ID of the stack set.</p>
    pub stack_set_id: std::option::Option<std::string::String>,
    /// <p>The type of stack set operation: <code>CREATE</code>, <code>UPDATE</code>, or
    /// <code>DELETE</code>. Create and delete operations affect only the specified stack set
    /// instances that are associated with the specified stack set. Update operations affect both
    /// the stack set itself, as well as <i>all</i> associated stack set
    /// instances.</p>
    pub action: std::option::Option<crate::model::StackSetOperationAction>,
    /// <p>The status of the operation. </p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>FAILED</code>: The operation exceeded the specified failure tolerance.
    /// The failure tolerance value that you've set for an operation is applied for each
    /// Region during stack create and update operations. If the number of failed stacks
    /// within a Region exceeds the failure tolerance, the status of the operation in the
    /// Region is set to <code>FAILED</code>. This in turn sets the status of the operation
    /// as a whole to <code>FAILED</code>, and AWS CloudFormation cancels the operation in
    /// any remaining Regions.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>QUEUED</code>: [Service-managed permissions] For automatic deployments that
    /// require a sequence of operations, the operation is queued to be performed. For more information, see the <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacksets-concepts.html#stackset-status-codes">stack set operation status codes</a> in the AWS CloudFormation User Guide.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>RUNNING</code>: The operation is currently being performed.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>STOPPED</code>: The user has cancelled the operation.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>STOPPING</code>: The operation is in the process of stopping, at user
    /// request. </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>SUCCEEDED</code>: The operation completed creating or updating all the
    /// specified stacks without exceeding the failure tolerance for the operation.</p>
    /// </li>
    /// </ul>
    pub status: std::option::Option<crate::model::StackSetOperationStatus>,
    /// <p>The preferences for how AWS CloudFormation performs this stack set
    /// operation.</p>
    pub operation_preferences: std::option::Option<crate::model::StackSetOperationPreferences>,
    /// <p>For stack set operations of action type <code>DELETE</code>, specifies whether to
    /// remove the stack instances from the specified stack set, but doesn't delete the stacks. You
    /// can't reassociate a retained stack, or add an existing, saved stack to a new stack
    /// set.</p>
    pub retain_stacks: std::option::Option<bool>,
    /// <p>The Amazon Resource Number (ARN) of the IAM role used to perform this stack set
    /// operation. </p>
    /// <p>Use customized administrator roles to control which users or groups can manage specific
    /// stack sets within the same administrator account. For more information, see <a href="http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacksets-prereqs.html">Define Permissions for Multiple
    /// Administrators</a> in the <i>AWS CloudFormation User Guide</i>.</p>
    pub administration_role_arn: std::option::Option<std::string::String>,
    /// <p>The name of the IAM execution role used to create or update the stack set.</p>
    /// <p>Use customized execution roles to control which stack resources users and groups can
    /// include in their stack sets.
    /// </p>
    pub execution_role_name: std::option::Option<std::string::String>,
    /// <p>The time at which the operation was initiated. Note that the creation times for the
    /// stack set operation might differ from the creation time of the individual stacks
    /// themselves. This is because AWS CloudFormation needs to perform preparatory work for the
    /// operation, such as dispatching the work to the requested Regions, before actually creating
    /// the first stacks.</p>
    pub creation_timestamp: std::option::Option<smithy_types::Instant>,
    /// <p>The time at which the stack set operation ended, across all accounts and Regions
    /// specified. Note that this doesn't necessarily mean that the stack set operation was
    /// successful, or even attempted, in each account or Region.</p>
    pub end_timestamp: std::option::Option<smithy_types::Instant>,
    /// <p>[Service-managed permissions] The AWS Organizations accounts affected by the stack operation.</p>
    pub deployment_targets: std::option::Option<crate::model::DeploymentTargets>,
    /// <p>Detailed information about the drift status of the stack set. This includes information
    /// about drift operations currently being performed on the stack set.</p>
    /// <p>this information will only be present for stack set operations whose <code>Action</code>
    /// type is <code>DETECT_DRIFT</code>.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacksets-drift.html">Detecting Unmanaged
    /// Changes in Stack Sets</a> in the AWS CloudFormation User Guide.</p>
    pub stack_set_drift_detection_details:
        std::option::Option<crate::model::StackSetDriftDetectionDetails>,
}
impl std::fmt::Debug for StackSetOperation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StackSetOperation");
        formatter.field("operation_id", &self.operation_id);
        formatter.field("stack_set_id", &self.stack_set_id);
        formatter.field("action", &self.action);
        formatter.field("status", &self.status);
        formatter.field("operation_preferences", &self.operation_preferences);
        formatter.field("retain_stacks", &self.retain_stacks);
        formatter.field("administration_role_arn", &self.administration_role_arn);
        formatter.field("execution_role_name", &self.execution_role_name);
        formatter.field("creation_timestamp", &self.creation_timestamp);
        formatter.field("end_timestamp", &self.end_timestamp);
        formatter.field("deployment_targets", &self.deployment_targets);
        formatter.field(
            "stack_set_drift_detection_details",
            &self.stack_set_drift_detection_details,
        );
        formatter.finish()
    }
}
/// See [`StackSetOperation`](crate::model::StackSetOperation)
pub mod stack_set_operation {
    /// A builder for [`StackSetOperation`](crate::model::StackSetOperation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) operation_id: std::option::Option<std::string::String>,
        pub(crate) stack_set_id: std::option::Option<std::string::String>,
        pub(crate) action: std::option::Option<crate::model::StackSetOperationAction>,
        pub(crate) status: std::option::Option<crate::model::StackSetOperationStatus>,
        pub(crate) operation_preferences:
            std::option::Option<crate::model::StackSetOperationPreferences>,
        pub(crate) retain_stacks: std::option::Option<bool>,
        pub(crate) administration_role_arn: std::option::Option<std::string::String>,
        pub(crate) execution_role_name: std::option::Option<std::string::String>,
        pub(crate) creation_timestamp: std::option::Option<smithy_types::Instant>,
        pub(crate) end_timestamp: std::option::Option<smithy_types::Instant>,
        pub(crate) deployment_targets: std::option::Option<crate::model::DeploymentTargets>,
        pub(crate) stack_set_drift_detection_details:
            std::option::Option<crate::model::StackSetDriftDetectionDetails>,
    }
    impl Builder {
        /// <p>The unique ID of a stack set operation.</p>
        pub fn operation_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.operation_id = Some(inp.into());
            self
        }
        pub fn set_operation_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.operation_id = inp;
            self
        }
        /// <p>The ID of the stack set.</p>
        pub fn stack_set_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.stack_set_id = Some(inp.into());
            self
        }
        pub fn set_stack_set_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.stack_set_id = inp;
            self
        }
        /// <p>The type of stack set operation: <code>CREATE</code>, <code>UPDATE</code>, or
        /// <code>DELETE</code>. Create and delete operations affect only the specified stack set
        /// instances that are associated with the specified stack set. Update operations affect both
        /// the stack set itself, as well as <i>all</i> associated stack set
        /// instances.</p>
        pub fn action(mut self, inp: crate::model::StackSetOperationAction) -> Self {
            self.action = Some(inp);
            self
        }
        pub fn set_action(
            mut self,
            inp: std::option::Option<crate::model::StackSetOperationAction>,
        ) -> Self {
            self.action = inp;
            self
        }
        /// <p>The status of the operation. </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>FAILED</code>: The operation exceeded the specified failure tolerance.
        /// The failure tolerance value that you've set for an operation is applied for each
        /// Region during stack create and update operations. If the number of failed stacks
        /// within a Region exceeds the failure tolerance, the status of the operation in the
        /// Region is set to <code>FAILED</code>. This in turn sets the status of the operation
        /// as a whole to <code>FAILED</code>, and AWS CloudFormation cancels the operation in
        /// any remaining Regions.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>QUEUED</code>: [Service-managed permissions] For automatic deployments that
        /// require a sequence of operations, the operation is queued to be performed. For more information, see the <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacksets-concepts.html#stackset-status-codes">stack set operation status codes</a> in the AWS CloudFormation User Guide.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>RUNNING</code>: The operation is currently being performed.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>STOPPED</code>: The user has cancelled the operation.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>STOPPING</code>: The operation is in the process of stopping, at user
        /// request. </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>SUCCEEDED</code>: The operation completed creating or updating all the
        /// specified stacks without exceeding the failure tolerance for the operation.</p>
        /// </li>
        /// </ul>
        pub fn status(mut self, inp: crate::model::StackSetOperationStatus) -> Self {
            self.status = Some(inp);
            self
        }
        pub fn set_status(
            mut self,
            inp: std::option::Option<crate::model::StackSetOperationStatus>,
        ) -> Self {
            self.status = inp;
            self
        }
        /// <p>The preferences for how AWS CloudFormation performs this stack set
        /// operation.</p>
        pub fn operation_preferences(
            mut self,
            inp: crate::model::StackSetOperationPreferences,
        ) -> Self {
            self.operation_preferences = Some(inp);
            self
        }
        pub fn set_operation_preferences(
            mut self,
            inp: std::option::Option<crate::model::StackSetOperationPreferences>,
        ) -> Self {
            self.operation_preferences = inp;
            self
        }
        /// <p>For stack set operations of action type <code>DELETE</code>, specifies whether to
        /// remove the stack instances from the specified stack set, but doesn't delete the stacks. You
        /// can't reassociate a retained stack, or add an existing, saved stack to a new stack
        /// set.</p>
        pub fn retain_stacks(mut self, inp: bool) -> Self {
            self.retain_stacks = Some(inp);
            self
        }
        pub fn set_retain_stacks(mut self, inp: std::option::Option<bool>) -> Self {
            self.retain_stacks = inp;
            self
        }
        /// <p>The Amazon Resource Number (ARN) of the IAM role used to perform this stack set
        /// operation. </p>
        /// <p>Use customized administrator roles to control which users or groups can manage specific
        /// stack sets within the same administrator account. For more information, see <a href="http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacksets-prereqs.html">Define Permissions for Multiple
        /// Administrators</a> in the <i>AWS CloudFormation User Guide</i>.</p>
        pub fn administration_role_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.administration_role_arn = Some(inp.into());
            self
        }
        pub fn set_administration_role_arn(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.administration_role_arn = inp;
            self
        }
        /// <p>The name of the IAM execution role used to create or update the stack set.</p>
        /// <p>Use customized execution roles to control which stack resources users and groups can
        /// include in their stack sets.
        /// </p>
        pub fn execution_role_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.execution_role_name = Some(inp.into());
            self
        }
        pub fn set_execution_role_name(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.execution_role_name = inp;
            self
        }
        /// <p>The time at which the operation was initiated. Note that the creation times for the
        /// stack set operation might differ from the creation time of the individual stacks
        /// themselves. This is because AWS CloudFormation needs to perform preparatory work for the
        /// operation, such as dispatching the work to the requested Regions, before actually creating
        /// the first stacks.</p>
        pub fn creation_timestamp(mut self, inp: smithy_types::Instant) -> Self {
            self.creation_timestamp = Some(inp);
            self
        }
        pub fn set_creation_timestamp(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_timestamp = inp;
            self
        }
        /// <p>The time at which the stack set operation ended, across all accounts and Regions
        /// specified. Note that this doesn't necessarily mean that the stack set operation was
        /// successful, or even attempted, in each account or Region.</p>
        pub fn end_timestamp(mut self, inp: smithy_types::Instant) -> Self {
            self.end_timestamp = Some(inp);
            self
        }
        pub fn set_end_timestamp(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.end_timestamp = inp;
            self
        }
        /// <p>[Service-managed permissions] The AWS Organizations accounts affected by the stack operation.</p>
        pub fn deployment_targets(mut self, inp: crate::model::DeploymentTargets) -> Self {
            self.deployment_targets = Some(inp);
            self
        }
        pub fn set_deployment_targets(
            mut self,
            inp: std::option::Option<crate::model::DeploymentTargets>,
        ) -> Self {
            self.deployment_targets = inp;
            self
        }
        /// <p>Detailed information about the drift status of the stack set. This includes information
        /// about drift operations currently being performed on the stack set.</p>
        /// <p>this information will only be present for stack set operations whose <code>Action</code>
        /// type is <code>DETECT_DRIFT</code>.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacksets-drift.html">Detecting Unmanaged
        /// Changes in Stack Sets</a> in the AWS CloudFormation User Guide.</p>
        pub fn stack_set_drift_detection_details(
            mut self,
            inp: crate::model::StackSetDriftDetectionDetails,
        ) -> Self {
            self.stack_set_drift_detection_details = Some(inp);
            self
        }
        pub fn set_stack_set_drift_detection_details(
            mut self,
            inp: std::option::Option<crate::model::StackSetDriftDetectionDetails>,
        ) -> Self {
            self.stack_set_drift_detection_details = inp;
            self
        }
        /// Consumes the builder and constructs a [`StackSetOperation`](crate::model::StackSetOperation)
        pub fn build(self) -> crate::model::StackSetOperation {
            crate::model::StackSetOperation {
                operation_id: self.operation_id,
                stack_set_id: self.stack_set_id,
                action: self.action,
                status: self.status,
                operation_preferences: self.operation_preferences,
                retain_stacks: self.retain_stacks,
                administration_role_arn: self.administration_role_arn,
                execution_role_name: self.execution_role_name,
                creation_timestamp: self.creation_timestamp,
                end_timestamp: self.end_timestamp,
                deployment_targets: self.deployment_targets,
                stack_set_drift_detection_details: self.stack_set_drift_detection_details,
            }
        }
    }
}
impl StackSetOperation {
    /// Creates a new builder-style object to manufacture [`StackSetOperation`](crate::model::StackSetOperation)
    pub fn builder() -> crate::model::stack_set_operation::Builder {
        crate::model::stack_set_operation::Builder::default()
    }
}

/// <p>Detailed information about the drift status of the stack set.</p>
/// <p>For stack sets, contains information about the last <i>completed</i> drift
/// operation performed on the stack set. Information about drift operations in-progress is not
/// included. </p>
/// <p>For stack set operations, includes information about drift operations currently being
/// performed on the stack set.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacksets-drift.html">Detecting Unmanaged
/// Changes in Stack Sets</a> in the <i>AWS CloudFormation User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StackSetDriftDetectionDetails {
    /// <p>Status of the stack set's actual configuration compared to its expected template and
    /// parameter configuration. A stack set is considered to have drifted if one or more of its
    /// stack instances have drifted from their expected template and parameter
    /// configuration.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>DRIFTED</code>: One or more of the stack instances belonging to the stack
    /// set stack differs from the expected template and parameter configuration. A stack
    /// instance is considered to have drifted if one or more of the resources in the
    /// associated stack have drifted.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>NOT_CHECKED</code>: AWS CloudFormation has not checked the stack set for drift.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>IN_SYNC</code>: All of the stack instances belonging to the stack set stack
    /// match from the expected template and parameter configuration.</p>
    /// </li>
    /// </ul>
    pub drift_status: std::option::Option<crate::model::StackSetDriftStatus>,
    /// <p>The status of the stack set drift detection operation.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>COMPLETED</code>: The drift detection operation completed without failing on
    /// any stack instances.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>FAILED</code>: The drift detection operation exceeded the specified failure
    /// tolerance. </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>PARTIAL_SUCCESS</code>: The drift detection operation completed without
    /// exceeding the failure tolerance for the operation.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>IN_PROGRESS</code>: The drift detection operation is currently being
    /// performed.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>STOPPED</code>: The user has cancelled the drift detection operation.</p>
    /// </li>
    /// </ul>
    pub drift_detection_status: std::option::Option<crate::model::StackSetDriftDetectionStatus>,
    /// <p>Most recent time when CloudFormation performed a drift detection operation on the stack
    /// set. This value will be <code>NULL</code> for any stack set on which drift detection has
    /// not yet been performed.</p>
    pub last_drift_check_timestamp: std::option::Option<smithy_types::Instant>,
    /// <p>The total number of stack instances belonging to this stack set. </p>
    /// <p>The total number of stack instances is equal to the total of:</p>
    /// <ul>
    /// <li>
    /// <p>Stack instances that match the stack set configuration. </p>
    /// </li>
    /// <li>
    /// <p>Stack instances that have drifted from the stack set configuration. </p>
    /// </li>
    /// <li>
    /// <p>Stack instances where the drift detection operation has failed.</p>
    /// </li>
    /// <li>
    /// <p>Stack instances currently being checked for drift.</p>
    /// </li>
    /// </ul>
    pub total_stack_instances_count: i32,
    /// <p>The number of stack instances that have drifted from the expected template and parameter
    /// configuration of the stack set. A stack instance is considered to have drifted if one or
    /// more of the resources in the associated stack do not match their expected
    /// configuration.</p>
    pub drifted_stack_instances_count: i32,
    /// <p>The number of stack instances which match the expected template and parameter
    /// configuration of the stack set.</p>
    pub in_sync_stack_instances_count: i32,
    /// <p>The number of stack instances that are currently being checked for drift.</p>
    pub in_progress_stack_instances_count: i32,
    /// <p>The number of stack instances for which the drift detection operation failed.</p>
    pub failed_stack_instances_count: i32,
}
impl std::fmt::Debug for StackSetDriftDetectionDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StackSetDriftDetectionDetails");
        formatter.field("drift_status", &self.drift_status);
        formatter.field("drift_detection_status", &self.drift_detection_status);
        formatter.field(
            "last_drift_check_timestamp",
            &self.last_drift_check_timestamp,
        );
        formatter.field(
            "total_stack_instances_count",
            &self.total_stack_instances_count,
        );
        formatter.field(
            "drifted_stack_instances_count",
            &self.drifted_stack_instances_count,
        );
        formatter.field(
            "in_sync_stack_instances_count",
            &self.in_sync_stack_instances_count,
        );
        formatter.field(
            "in_progress_stack_instances_count",
            &self.in_progress_stack_instances_count,
        );
        formatter.field(
            "failed_stack_instances_count",
            &self.failed_stack_instances_count,
        );
        formatter.finish()
    }
}
/// See [`StackSetDriftDetectionDetails`](crate::model::StackSetDriftDetectionDetails)
pub mod stack_set_drift_detection_details {
    /// A builder for [`StackSetDriftDetectionDetails`](crate::model::StackSetDriftDetectionDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) drift_status: std::option::Option<crate::model::StackSetDriftStatus>,
        pub(crate) drift_detection_status:
            std::option::Option<crate::model::StackSetDriftDetectionStatus>,
        pub(crate) last_drift_check_timestamp: std::option::Option<smithy_types::Instant>,
        pub(crate) total_stack_instances_count: std::option::Option<i32>,
        pub(crate) drifted_stack_instances_count: std::option::Option<i32>,
        pub(crate) in_sync_stack_instances_count: std::option::Option<i32>,
        pub(crate) in_progress_stack_instances_count: std::option::Option<i32>,
        pub(crate) failed_stack_instances_count: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>Status of the stack set's actual configuration compared to its expected template and
        /// parameter configuration. A stack set is considered to have drifted if one or more of its
        /// stack instances have drifted from their expected template and parameter
        /// configuration.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>DRIFTED</code>: One or more of the stack instances belonging to the stack
        /// set stack differs from the expected template and parameter configuration. A stack
        /// instance is considered to have drifted if one or more of the resources in the
        /// associated stack have drifted.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>NOT_CHECKED</code>: AWS CloudFormation has not checked the stack set for drift.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>IN_SYNC</code>: All of the stack instances belonging to the stack set stack
        /// match from the expected template and parameter configuration.</p>
        /// </li>
        /// </ul>
        pub fn drift_status(mut self, inp: crate::model::StackSetDriftStatus) -> Self {
            self.drift_status = Some(inp);
            self
        }
        pub fn set_drift_status(
            mut self,
            inp: std::option::Option<crate::model::StackSetDriftStatus>,
        ) -> Self {
            self.drift_status = inp;
            self
        }
        /// <p>The status of the stack set drift detection operation.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>COMPLETED</code>: The drift detection operation completed without failing on
        /// any stack instances.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>FAILED</code>: The drift detection operation exceeded the specified failure
        /// tolerance. </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>PARTIAL_SUCCESS</code>: The drift detection operation completed without
        /// exceeding the failure tolerance for the operation.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>IN_PROGRESS</code>: The drift detection operation is currently being
        /// performed.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>STOPPED</code>: The user has cancelled the drift detection operation.</p>
        /// </li>
        /// </ul>
        pub fn drift_detection_status(
            mut self,
            inp: crate::model::StackSetDriftDetectionStatus,
        ) -> Self {
            self.drift_detection_status = Some(inp);
            self
        }
        pub fn set_drift_detection_status(
            mut self,
            inp: std::option::Option<crate::model::StackSetDriftDetectionStatus>,
        ) -> Self {
            self.drift_detection_status = inp;
            self
        }
        /// <p>Most recent time when CloudFormation performed a drift detection operation on the stack
        /// set. This value will be <code>NULL</code> for any stack set on which drift detection has
        /// not yet been performed.</p>
        pub fn last_drift_check_timestamp(mut self, inp: smithy_types::Instant) -> Self {
            self.last_drift_check_timestamp = Some(inp);
            self
        }
        pub fn set_last_drift_check_timestamp(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_drift_check_timestamp = inp;
            self
        }
        /// <p>The total number of stack instances belonging to this stack set. </p>
        /// <p>The total number of stack instances is equal to the total of:</p>
        /// <ul>
        /// <li>
        /// <p>Stack instances that match the stack set configuration. </p>
        /// </li>
        /// <li>
        /// <p>Stack instances that have drifted from the stack set configuration. </p>
        /// </li>
        /// <li>
        /// <p>Stack instances where the drift detection operation has failed.</p>
        /// </li>
        /// <li>
        /// <p>Stack instances currently being checked for drift.</p>
        /// </li>
        /// </ul>
        pub fn total_stack_instances_count(mut self, inp: i32) -> Self {
            self.total_stack_instances_count = Some(inp);
            self
        }
        pub fn set_total_stack_instances_count(mut self, inp: i32) -> Self {
            self.total_stack_instances_count = Some(inp);
            self
        }
        /// <p>The number of stack instances that have drifted from the expected template and parameter
        /// configuration of the stack set. A stack instance is considered to have drifted if one or
        /// more of the resources in the associated stack do not match their expected
        /// configuration.</p>
        pub fn drifted_stack_instances_count(mut self, inp: i32) -> Self {
            self.drifted_stack_instances_count = Some(inp);
            self
        }
        pub fn set_drifted_stack_instances_count(mut self, inp: i32) -> Self {
            self.drifted_stack_instances_count = Some(inp);
            self
        }
        /// <p>The number of stack instances which match the expected template and parameter
        /// configuration of the stack set.</p>
        pub fn in_sync_stack_instances_count(mut self, inp: i32) -> Self {
            self.in_sync_stack_instances_count = Some(inp);
            self
        }
        pub fn set_in_sync_stack_instances_count(mut self, inp: i32) -> Self {
            self.in_sync_stack_instances_count = Some(inp);
            self
        }
        /// <p>The number of stack instances that are currently being checked for drift.</p>
        pub fn in_progress_stack_instances_count(mut self, inp: i32) -> Self {
            self.in_progress_stack_instances_count = Some(inp);
            self
        }
        pub fn set_in_progress_stack_instances_count(mut self, inp: i32) -> Self {
            self.in_progress_stack_instances_count = Some(inp);
            self
        }
        /// <p>The number of stack instances for which the drift detection operation failed.</p>
        pub fn failed_stack_instances_count(mut self, inp: i32) -> Self {
            self.failed_stack_instances_count = Some(inp);
            self
        }
        pub fn set_failed_stack_instances_count(mut self, inp: i32) -> Self {
            self.failed_stack_instances_count = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`StackSetDriftDetectionDetails`](crate::model::StackSetDriftDetectionDetails)
        pub fn build(self) -> crate::model::StackSetDriftDetectionDetails {
            crate::model::StackSetDriftDetectionDetails {
                drift_status: self.drift_status,
                drift_detection_status: self.drift_detection_status,
                last_drift_check_timestamp: self.last_drift_check_timestamp,
                total_stack_instances_count: self.total_stack_instances_count.unwrap_or_default(),
                drifted_stack_instances_count: self
                    .drifted_stack_instances_count
                    .unwrap_or_default(),
                in_sync_stack_instances_count: self
                    .in_sync_stack_instances_count
                    .unwrap_or_default(),
                in_progress_stack_instances_count: self
                    .in_progress_stack_instances_count
                    .unwrap_or_default(),
                failed_stack_instances_count: self.failed_stack_instances_count.unwrap_or_default(),
            }
        }
    }
}
impl StackSetDriftDetectionDetails {
    /// Creates a new builder-style object to manufacture [`StackSetDriftDetectionDetails`](crate::model::StackSetDriftDetectionDetails)
    pub fn builder() -> crate::model::stack_set_drift_detection_details::Builder {
        crate::model::stack_set_drift_detection_details::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StackSetDriftDetectionStatus {
    Completed,
    Failed,
    InProgress,
    PartialSuccess,
    Stopped,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for StackSetDriftDetectionStatus {
    fn from(s: &str) -> Self {
        match s {
            "COMPLETED" => StackSetDriftDetectionStatus::Completed,
            "FAILED" => StackSetDriftDetectionStatus::Failed,
            "IN_PROGRESS" => StackSetDriftDetectionStatus::InProgress,
            "PARTIAL_SUCCESS" => StackSetDriftDetectionStatus::PartialSuccess,
            "STOPPED" => StackSetDriftDetectionStatus::Stopped,
            other => StackSetDriftDetectionStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for StackSetDriftDetectionStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(StackSetDriftDetectionStatus::from(s))
    }
}
impl StackSetDriftDetectionStatus {
    pub fn as_str(&self) -> &str {
        match self {
            StackSetDriftDetectionStatus::Completed => "COMPLETED",
            StackSetDriftDetectionStatus::Failed => "FAILED",
            StackSetDriftDetectionStatus::InProgress => "IN_PROGRESS",
            StackSetDriftDetectionStatus::PartialSuccess => "PARTIAL_SUCCESS",
            StackSetDriftDetectionStatus::Stopped => "STOPPED",
            StackSetDriftDetectionStatus::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for StackSetDriftDetectionStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for StackSetDriftDetectionStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StackSetDriftStatus {
    Drifted,
    InSync,
    NotChecked,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for StackSetDriftStatus {
    fn from(s: &str) -> Self {
        match s {
            "DRIFTED" => StackSetDriftStatus::Drifted,
            "IN_SYNC" => StackSetDriftStatus::InSync,
            "NOT_CHECKED" => StackSetDriftStatus::NotChecked,
            other => StackSetDriftStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for StackSetDriftStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(StackSetDriftStatus::from(s))
    }
}
impl StackSetDriftStatus {
    pub fn as_str(&self) -> &str {
        match self {
            StackSetDriftStatus::Drifted => "DRIFTED",
            StackSetDriftStatus::InSync => "IN_SYNC",
            StackSetDriftStatus::NotChecked => "NOT_CHECKED",
            StackSetDriftStatus::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for StackSetDriftStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for StackSetDriftStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>A structure that contains information about a stack set. A stack set enables you to
/// provision stacks into AWS accounts and across Regions by using a single CloudFormation
/// template. In the stack set, you specify the template to use, as well as any parameters and
/// capabilities that the template requires. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StackSet {
    /// <p>The name that's associated with the stack set.</p>
    pub stack_set_name: std::option::Option<std::string::String>,
    /// <p>The ID of the stack set.</p>
    pub stack_set_id: std::option::Option<std::string::String>,
    /// <p>A description of the stack set that you specify when the stack set is created or
    /// updated.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The status of the stack set.</p>
    pub status: std::option::Option<crate::model::StackSetStatus>,
    /// <p>The structure that contains the body of the template that was used to create or
    /// update the stack set.</p>
    pub template_body: std::option::Option<std::string::String>,
    /// <p>A list of input parameters for a stack set.</p>
    pub parameters: std::option::Option<std::vec::Vec<crate::model::Parameter>>,
    /// <p>The capabilities that are allowed in the stack set. Some stack set templates might
    /// include resources that can affect permissions in your AWS account—for example, by creating
    /// new AWS Identity and Access Management (IAM) users. For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-iam-template.html#capabilities">Acknowledging IAM Resources in AWS CloudFormation Templates.</a>
    /// </p>
    pub capabilities: std::option::Option<std::vec::Vec<crate::model::Capability>>,
    /// <p>A list of tags that specify information about the stack set. A maximum number of 50
    /// tags can be specified.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>The Amazon Resource Number (ARN) of the stack set.</p>
    pub stack_set_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Number (ARN) of the IAM role used to create or update the stack
    /// set.</p>
    /// <p>Use customized administrator roles to control which users or groups can manage specific
    /// stack sets within the same administrator account. For more information, see <a href="http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacksets-prereqs.html">Prerequisites: Granting Permissions for Stack
    /// Set Operations</a> in the <i>AWS CloudFormation User Guide</i>.</p>
    pub administration_role_arn: std::option::Option<std::string::String>,
    /// <p>The name of the IAM execution role used to create or update the stack set. </p>
    /// <p>Use customized execution roles to control which stack resources users and groups can
    /// include in their stack sets.
    /// </p>
    pub execution_role_name: std::option::Option<std::string::String>,
    /// <p>Detailed information about the drift status of the stack set.</p>
    /// <p>For stack sets, contains information about the last <i>completed</i> drift
    /// operation performed on the stack set. Information about drift operations currently in
    /// progress is not included.</p>
    pub stack_set_drift_detection_details:
        std::option::Option<crate::model::StackSetDriftDetectionDetails>,
    /// <p>[Service-managed permissions] Describes whether StackSets automatically deploys to AWS Organizations accounts that are added to a target organization or organizational unit (OU).</p>
    pub auto_deployment: std::option::Option<crate::model::AutoDeployment>,
    /// <p>Describes how the IAM roles required for stack set operations are created.</p>
    /// <ul>
    /// <li>
    /// <p>With <code>self-managed</code> permissions, you must create the administrator and execution roles required to deploy to target accounts. For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacksets-prereqs-self-managed.html">Grant Self-Managed Stack Set Permissions</a>.</p>
    /// </li>
    /// <li>
    /// <p>With <code>service-managed</code> permissions, StackSets automatically creates the IAM roles required to deploy to accounts managed by AWS Organizations. For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacksets-prereqs-service-managed.html">Grant Service-Managed Stack Set Permissions</a>.</p>
    /// </li>
    /// </ul>
    pub permission_model: std::option::Option<crate::model::PermissionModels>,
    /// <p>[Service-managed permissions] The organization root ID or organizational unit (OU) IDs that you specified for <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/APIReference/API_DeploymentTargets.html">DeploymentTargets</a>.</p>
    pub organizational_unit_ids: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for StackSet {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StackSet");
        formatter.field("stack_set_name", &self.stack_set_name);
        formatter.field("stack_set_id", &self.stack_set_id);
        formatter.field("description", &self.description);
        formatter.field("status", &self.status);
        formatter.field("template_body", &self.template_body);
        formatter.field("parameters", &self.parameters);
        formatter.field("capabilities", &self.capabilities);
        formatter.field("tags", &self.tags);
        formatter.field("stack_set_arn", &self.stack_set_arn);
        formatter.field("administration_role_arn", &self.administration_role_arn);
        formatter.field("execution_role_name", &self.execution_role_name);
        formatter.field(
            "stack_set_drift_detection_details",
            &self.stack_set_drift_detection_details,
        );
        formatter.field("auto_deployment", &self.auto_deployment);
        formatter.field("permission_model", &self.permission_model);
        formatter.field("organizational_unit_ids", &self.organizational_unit_ids);
        formatter.finish()
    }
}
/// See [`StackSet`](crate::model::StackSet)
pub mod stack_set {
    /// A builder for [`StackSet`](crate::model::StackSet)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) stack_set_name: std::option::Option<std::string::String>,
        pub(crate) stack_set_id: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::StackSetStatus>,
        pub(crate) template_body: std::option::Option<std::string::String>,
        pub(crate) parameters: std::option::Option<std::vec::Vec<crate::model::Parameter>>,
        pub(crate) capabilities: std::option::Option<std::vec::Vec<crate::model::Capability>>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) stack_set_arn: std::option::Option<std::string::String>,
        pub(crate) administration_role_arn: std::option::Option<std::string::String>,
        pub(crate) execution_role_name: std::option::Option<std::string::String>,
        pub(crate) stack_set_drift_detection_details:
            std::option::Option<crate::model::StackSetDriftDetectionDetails>,
        pub(crate) auto_deployment: std::option::Option<crate::model::AutoDeployment>,
        pub(crate) permission_model: std::option::Option<crate::model::PermissionModels>,
        pub(crate) organizational_unit_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The name that's associated with the stack set.</p>
        pub fn stack_set_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.stack_set_name = Some(inp.into());
            self
        }
        pub fn set_stack_set_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.stack_set_name = inp;
            self
        }
        /// <p>The ID of the stack set.</p>
        pub fn stack_set_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.stack_set_id = Some(inp.into());
            self
        }
        pub fn set_stack_set_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.stack_set_id = inp;
            self
        }
        /// <p>A description of the stack set that you specify when the stack set is created or
        /// updated.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.description = Some(inp.into());
            self
        }
        pub fn set_description(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.description = inp;
            self
        }
        /// <p>The status of the stack set.</p>
        pub fn status(mut self, inp: crate::model::StackSetStatus) -> Self {
            self.status = Some(inp);
            self
        }
        pub fn set_status(
            mut self,
            inp: std::option::Option<crate::model::StackSetStatus>,
        ) -> Self {
            self.status = inp;
            self
        }
        /// <p>The structure that contains the body of the template that was used to create or
        /// update the stack set.</p>
        pub fn template_body(mut self, inp: impl Into<std::string::String>) -> Self {
            self.template_body = Some(inp.into());
            self
        }
        pub fn set_template_body(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.template_body = inp;
            self
        }
        pub fn parameters(mut self, inp: impl Into<crate::model::Parameter>) -> Self {
            let mut v = self.parameters.unwrap_or_default();
            v.push(inp.into());
            self.parameters = Some(v);
            self
        }
        pub fn set_parameters(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Parameter>>,
        ) -> Self {
            self.parameters = inp;
            self
        }
        pub fn capabilities(mut self, inp: impl Into<crate::model::Capability>) -> Self {
            let mut v = self.capabilities.unwrap_or_default();
            v.push(inp.into());
            self.capabilities = Some(v);
            self
        }
        pub fn set_capabilities(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Capability>>,
        ) -> Self {
            self.capabilities = inp;
            self
        }
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(inp.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = inp;
            self
        }
        /// <p>The Amazon Resource Number (ARN) of the stack set.</p>
        pub fn stack_set_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.stack_set_arn = Some(inp.into());
            self
        }
        pub fn set_stack_set_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.stack_set_arn = inp;
            self
        }
        /// <p>The Amazon Resource Number (ARN) of the IAM role used to create or update the stack
        /// set.</p>
        /// <p>Use customized administrator roles to control which users or groups can manage specific
        /// stack sets within the same administrator account. For more information, see <a href="http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacksets-prereqs.html">Prerequisites: Granting Permissions for Stack
        /// Set Operations</a> in the <i>AWS CloudFormation User Guide</i>.</p>
        pub fn administration_role_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.administration_role_arn = Some(inp.into());
            self
        }
        pub fn set_administration_role_arn(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.administration_role_arn = inp;
            self
        }
        /// <p>The name of the IAM execution role used to create or update the stack set. </p>
        /// <p>Use customized execution roles to control which stack resources users and groups can
        /// include in their stack sets.
        /// </p>
        pub fn execution_role_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.execution_role_name = Some(inp.into());
            self
        }
        pub fn set_execution_role_name(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.execution_role_name = inp;
            self
        }
        /// <p>Detailed information about the drift status of the stack set.</p>
        /// <p>For stack sets, contains information about the last <i>completed</i> drift
        /// operation performed on the stack set. Information about drift operations currently in
        /// progress is not included.</p>
        pub fn stack_set_drift_detection_details(
            mut self,
            inp: crate::model::StackSetDriftDetectionDetails,
        ) -> Self {
            self.stack_set_drift_detection_details = Some(inp);
            self
        }
        pub fn set_stack_set_drift_detection_details(
            mut self,
            inp: std::option::Option<crate::model::StackSetDriftDetectionDetails>,
        ) -> Self {
            self.stack_set_drift_detection_details = inp;
            self
        }
        /// <p>[Service-managed permissions] Describes whether StackSets automatically deploys to AWS Organizations accounts that are added to a target organization or organizational unit (OU).</p>
        pub fn auto_deployment(mut self, inp: crate::model::AutoDeployment) -> Self {
            self.auto_deployment = Some(inp);
            self
        }
        pub fn set_auto_deployment(
            mut self,
            inp: std::option::Option<crate::model::AutoDeployment>,
        ) -> Self {
            self.auto_deployment = inp;
            self
        }
        /// <p>Describes how the IAM roles required for stack set operations are created.</p>
        /// <ul>
        /// <li>
        /// <p>With <code>self-managed</code> permissions, you must create the administrator and execution roles required to deploy to target accounts. For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacksets-prereqs-self-managed.html">Grant Self-Managed Stack Set Permissions</a>.</p>
        /// </li>
        /// <li>
        /// <p>With <code>service-managed</code> permissions, StackSets automatically creates the IAM roles required to deploy to accounts managed by AWS Organizations. For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacksets-prereqs-service-managed.html">Grant Service-Managed Stack Set Permissions</a>.</p>
        /// </li>
        /// </ul>
        pub fn permission_model(mut self, inp: crate::model::PermissionModels) -> Self {
            self.permission_model = Some(inp);
            self
        }
        pub fn set_permission_model(
            mut self,
            inp: std::option::Option<crate::model::PermissionModels>,
        ) -> Self {
            self.permission_model = inp;
            self
        }
        pub fn organizational_unit_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            let mut v = self.organizational_unit_ids.unwrap_or_default();
            v.push(inp.into());
            self.organizational_unit_ids = Some(v);
            self
        }
        pub fn set_organizational_unit_ids(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.organizational_unit_ids = inp;
            self
        }
        /// Consumes the builder and constructs a [`StackSet`](crate::model::StackSet)
        pub fn build(self) -> crate::model::StackSet {
            crate::model::StackSet {
                stack_set_name: self.stack_set_name,
                stack_set_id: self.stack_set_id,
                description: self.description,
                status: self.status,
                template_body: self.template_body,
                parameters: self.parameters,
                capabilities: self.capabilities,
                tags: self.tags,
                stack_set_arn: self.stack_set_arn,
                administration_role_arn: self.administration_role_arn,
                execution_role_name: self.execution_role_name,
                stack_set_drift_detection_details: self.stack_set_drift_detection_details,
                auto_deployment: self.auto_deployment,
                permission_model: self.permission_model,
                organizational_unit_ids: self.organizational_unit_ids,
            }
        }
    }
}
impl StackSet {
    /// Creates a new builder-style object to manufacture [`StackSet`](crate::model::StackSet)
    pub fn builder() -> crate::model::stack_set::Builder {
        crate::model::stack_set::Builder::default()
    }
}

/// <p>The Stack data type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Stack {
    /// <p>Unique identifier of the stack.</p>
    pub stack_id: std::option::Option<std::string::String>,
    /// <p>The name associated with the stack.</p>
    pub stack_name: std::option::Option<std::string::String>,
    /// <p>The unique ID of the change set.</p>
    pub change_set_id: std::option::Option<std::string::String>,
    /// <p>A user-defined description associated with the stack.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>A list of <code>Parameter</code> structures.</p>
    pub parameters: std::option::Option<std::vec::Vec<crate::model::Parameter>>,
    /// <p>The time at which the stack was created.</p>
    pub creation_time: std::option::Option<smithy_types::Instant>,
    /// <p>The time the stack was deleted.</p>
    pub deletion_time: std::option::Option<smithy_types::Instant>,
    /// <p>The time the stack was last updated. This field will only be returned if the stack
    /// has been updated at least once.</p>
    pub last_updated_time: std::option::Option<smithy_types::Instant>,
    /// <p>The rollback triggers for AWS CloudFormation to monitor during stack creation and
    /// updating operations, and for the specified monitoring period afterwards.</p>
    pub rollback_configuration: std::option::Option<crate::model::RollbackConfiguration>,
    /// <p>Current status of the stack.</p>
    pub stack_status: std::option::Option<crate::model::StackStatus>,
    /// <p>Success/failure message associated with the stack status.</p>
    pub stack_status_reason: std::option::Option<std::string::String>,
    /// <p>Boolean to enable or disable rollback on stack creation failures:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>true</code>: disable rollback</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>false</code>: enable rollback</p>
    /// </li>
    /// </ul>
    pub disable_rollback: std::option::Option<bool>,
    /// <p>SNS topic ARNs to which stack related events are published.</p>
    pub notification_ar_ns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The amount of time within which stack creation should complete.</p>
    pub timeout_in_minutes: std::option::Option<i32>,
    /// <p>The capabilities allowed in the stack.</p>
    pub capabilities: std::option::Option<std::vec::Vec<crate::model::Capability>>,
    /// <p>A list of output structures.</p>
    pub outputs: std::option::Option<std::vec::Vec<crate::model::Output>>,
    /// <p>The Amazon Resource Name (ARN) of an AWS Identity and Access Management (IAM) role
    /// that is associated with the stack. During a stack operation, AWS CloudFormation uses this
    /// role's credentials to make calls on your behalf.</p>
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>A list of <code>Tag</code>s that specify information about the stack.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>Whether termination protection is enabled for the stack.</p>
    /// <p> For <a href="http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-nested-stacks.html">nested stacks</a>,
    /// termination protection is set on the root stack and cannot be changed directly on the
    /// nested stack. For more information, see <a href="http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-protect-stacks.html">Protecting a Stack From Being
    /// Deleted</a> in the <i>AWS CloudFormation User Guide</i>.</p>
    pub enable_termination_protection: std::option::Option<bool>,
    /// <p>For nested stacks--stacks created as resources for another stack--the stack ID of the
    /// direct parent of this stack. For the first level of nested stacks, the root stack is also
    /// the parent stack.</p>
    /// <p>For more information, see <a href="http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-nested-stacks.html">Working with Nested Stacks</a> in the
    /// <i>AWS CloudFormation User Guide</i>.</p>
    pub parent_id: std::option::Option<std::string::String>,
    /// <p>For nested stacks--stacks created as resources for another stack--the stack ID of the
    /// top-level stack to which the nested stack ultimately belongs.</p>
    /// <p>For more information, see <a href="http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-nested-stacks.html">Working with Nested Stacks</a> in the
    /// <i>AWS CloudFormation User Guide</i>.</p>
    pub root_id: std::option::Option<std::string::String>,
    /// <p>Information on whether a stack's actual configuration differs, or has
    /// <i>drifted</i>, from it's expected configuration, as defined in the stack
    /// template and any values specified as template parameters. For more information, see <a href="http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-stack-drift.html">Detecting Unregulated Configuration
    /// Changes to Stacks and Resources</a>.</p>
    pub drift_information: std::option::Option<crate::model::StackDriftInformation>,
}
impl std::fmt::Debug for Stack {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Stack");
        formatter.field("stack_id", &self.stack_id);
        formatter.field("stack_name", &self.stack_name);
        formatter.field("change_set_id", &self.change_set_id);
        formatter.field("description", &self.description);
        formatter.field("parameters", &self.parameters);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("deletion_time", &self.deletion_time);
        formatter.field("last_updated_time", &self.last_updated_time);
        formatter.field("rollback_configuration", &self.rollback_configuration);
        formatter.field("stack_status", &self.stack_status);
        formatter.field("stack_status_reason", &self.stack_status_reason);
        formatter.field("disable_rollback", &self.disable_rollback);
        formatter.field("notification_ar_ns", &self.notification_ar_ns);
        formatter.field("timeout_in_minutes", &self.timeout_in_minutes);
        formatter.field("capabilities", &self.capabilities);
        formatter.field("outputs", &self.outputs);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("tags", &self.tags);
        formatter.field(
            "enable_termination_protection",
            &self.enable_termination_protection,
        );
        formatter.field("parent_id", &self.parent_id);
        formatter.field("root_id", &self.root_id);
        formatter.field("drift_information", &self.drift_information);
        formatter.finish()
    }
}
/// See [`Stack`](crate::model::Stack)
pub mod stack {
    /// A builder for [`Stack`](crate::model::Stack)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) stack_id: std::option::Option<std::string::String>,
        pub(crate) stack_name: std::option::Option<std::string::String>,
        pub(crate) change_set_id: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) parameters: std::option::Option<std::vec::Vec<crate::model::Parameter>>,
        pub(crate) creation_time: std::option::Option<smithy_types::Instant>,
        pub(crate) deletion_time: std::option::Option<smithy_types::Instant>,
        pub(crate) last_updated_time: std::option::Option<smithy_types::Instant>,
        pub(crate) rollback_configuration: std::option::Option<crate::model::RollbackConfiguration>,
        pub(crate) stack_status: std::option::Option<crate::model::StackStatus>,
        pub(crate) stack_status_reason: std::option::Option<std::string::String>,
        pub(crate) disable_rollback: std::option::Option<bool>,
        pub(crate) notification_ar_ns: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) timeout_in_minutes: std::option::Option<i32>,
        pub(crate) capabilities: std::option::Option<std::vec::Vec<crate::model::Capability>>,
        pub(crate) outputs: std::option::Option<std::vec::Vec<crate::model::Output>>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) enable_termination_protection: std::option::Option<bool>,
        pub(crate) parent_id: std::option::Option<std::string::String>,
        pub(crate) root_id: std::option::Option<std::string::String>,
        pub(crate) drift_information: std::option::Option<crate::model::StackDriftInformation>,
    }
    impl Builder {
        /// <p>Unique identifier of the stack.</p>
        pub fn stack_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.stack_id = Some(inp.into());
            self
        }
        pub fn set_stack_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.stack_id = inp;
            self
        }
        /// <p>The name associated with the stack.</p>
        pub fn stack_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.stack_name = Some(inp.into());
            self
        }
        pub fn set_stack_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.stack_name = inp;
            self
        }
        /// <p>The unique ID of the change set.</p>
        pub fn change_set_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.change_set_id = Some(inp.into());
            self
        }
        pub fn set_change_set_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.change_set_id = inp;
            self
        }
        /// <p>A user-defined description associated with the stack.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.description = Some(inp.into());
            self
        }
        pub fn set_description(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.description = inp;
            self
        }
        pub fn parameters(mut self, inp: impl Into<crate::model::Parameter>) -> Self {
            let mut v = self.parameters.unwrap_or_default();
            v.push(inp.into());
            self.parameters = Some(v);
            self
        }
        pub fn set_parameters(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Parameter>>,
        ) -> Self {
            self.parameters = inp;
            self
        }
        /// <p>The time at which the stack was created.</p>
        pub fn creation_time(mut self, inp: smithy_types::Instant) -> Self {
            self.creation_time = Some(inp);
            self
        }
        pub fn set_creation_time(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.creation_time = inp;
            self
        }
        /// <p>The time the stack was deleted.</p>
        pub fn deletion_time(mut self, inp: smithy_types::Instant) -> Self {
            self.deletion_time = Some(inp);
            self
        }
        pub fn set_deletion_time(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.deletion_time = inp;
            self
        }
        /// <p>The time the stack was last updated. This field will only be returned if the stack
        /// has been updated at least once.</p>
        pub fn last_updated_time(mut self, inp: smithy_types::Instant) -> Self {
            self.last_updated_time = Some(inp);
            self
        }
        pub fn set_last_updated_time(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_updated_time = inp;
            self
        }
        /// <p>The rollback triggers for AWS CloudFormation to monitor during stack creation and
        /// updating operations, and for the specified monitoring period afterwards.</p>
        pub fn rollback_configuration(mut self, inp: crate::model::RollbackConfiguration) -> Self {
            self.rollback_configuration = Some(inp);
            self
        }
        pub fn set_rollback_configuration(
            mut self,
            inp: std::option::Option<crate::model::RollbackConfiguration>,
        ) -> Self {
            self.rollback_configuration = inp;
            self
        }
        /// <p>Current status of the stack.</p>
        pub fn stack_status(mut self, inp: crate::model::StackStatus) -> Self {
            self.stack_status = Some(inp);
            self
        }
        pub fn set_stack_status(
            mut self,
            inp: std::option::Option<crate::model::StackStatus>,
        ) -> Self {
            self.stack_status = inp;
            self
        }
        /// <p>Success/failure message associated with the stack status.</p>
        pub fn stack_status_reason(mut self, inp: impl Into<std::string::String>) -> Self {
            self.stack_status_reason = Some(inp.into());
            self
        }
        pub fn set_stack_status_reason(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.stack_status_reason = inp;
            self
        }
        /// <p>Boolean to enable or disable rollback on stack creation failures:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>true</code>: disable rollback</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>false</code>: enable rollback</p>
        /// </li>
        /// </ul>
        pub fn disable_rollback(mut self, inp: bool) -> Self {
            self.disable_rollback = Some(inp);
            self
        }
        pub fn set_disable_rollback(mut self, inp: std::option::Option<bool>) -> Self {
            self.disable_rollback = inp;
            self
        }
        pub fn notification_ar_ns(mut self, inp: impl Into<std::string::String>) -> Self {
            let mut v = self.notification_ar_ns.unwrap_or_default();
            v.push(inp.into());
            self.notification_ar_ns = Some(v);
            self
        }
        pub fn set_notification_ar_ns(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.notification_ar_ns = inp;
            self
        }
        /// <p>The amount of time within which stack creation should complete.</p>
        pub fn timeout_in_minutes(mut self, inp: i32) -> Self {
            self.timeout_in_minutes = Some(inp);
            self
        }
        pub fn set_timeout_in_minutes(mut self, inp: std::option::Option<i32>) -> Self {
            self.timeout_in_minutes = inp;
            self
        }
        pub fn capabilities(mut self, inp: impl Into<crate::model::Capability>) -> Self {
            let mut v = self.capabilities.unwrap_or_default();
            v.push(inp.into());
            self.capabilities = Some(v);
            self
        }
        pub fn set_capabilities(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Capability>>,
        ) -> Self {
            self.capabilities = inp;
            self
        }
        pub fn outputs(mut self, inp: impl Into<crate::model::Output>) -> Self {
            let mut v = self.outputs.unwrap_or_default();
            v.push(inp.into());
            self.outputs = Some(v);
            self
        }
        pub fn set_outputs(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Output>>,
        ) -> Self {
            self.outputs = inp;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of an AWS Identity and Access Management (IAM) role
        /// that is associated with the stack. During a stack operation, AWS CloudFormation uses this
        /// role's credentials to make calls on your behalf.</p>
        pub fn role_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(inp.into());
            self
        }
        pub fn set_role_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.role_arn = inp;
            self
        }
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(inp.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = inp;
            self
        }
        /// <p>Whether termination protection is enabled for the stack.</p>
        /// <p> For <a href="http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-nested-stacks.html">nested stacks</a>,
        /// termination protection is set on the root stack and cannot be changed directly on the
        /// nested stack. For more information, see <a href="http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-protect-stacks.html">Protecting a Stack From Being
        /// Deleted</a> in the <i>AWS CloudFormation User Guide</i>.</p>
        pub fn enable_termination_protection(mut self, inp: bool) -> Self {
            self.enable_termination_protection = Some(inp);
            self
        }
        pub fn set_enable_termination_protection(mut self, inp: std::option::Option<bool>) -> Self {
            self.enable_termination_protection = inp;
            self
        }
        /// <p>For nested stacks--stacks created as resources for another stack--the stack ID of the
        /// direct parent of this stack. For the first level of nested stacks, the root stack is also
        /// the parent stack.</p>
        /// <p>For more information, see <a href="http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-nested-stacks.html">Working with Nested Stacks</a> in the
        /// <i>AWS CloudFormation User Guide</i>.</p>
        pub fn parent_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.parent_id = Some(inp.into());
            self
        }
        pub fn set_parent_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.parent_id = inp;
            self
        }
        /// <p>For nested stacks--stacks created as resources for another stack--the stack ID of the
        /// top-level stack to which the nested stack ultimately belongs.</p>
        /// <p>For more information, see <a href="http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-nested-stacks.html">Working with Nested Stacks</a> in the
        /// <i>AWS CloudFormation User Guide</i>.</p>
        pub fn root_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.root_id = Some(inp.into());
            self
        }
        pub fn set_root_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.root_id = inp;
            self
        }
        /// <p>Information on whether a stack's actual configuration differs, or has
        /// <i>drifted</i>, from it's expected configuration, as defined in the stack
        /// template and any values specified as template parameters. For more information, see <a href="http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-stack-drift.html">Detecting Unregulated Configuration
        /// Changes to Stacks and Resources</a>.</p>
        pub fn drift_information(mut self, inp: crate::model::StackDriftInformation) -> Self {
            self.drift_information = Some(inp);
            self
        }
        pub fn set_drift_information(
            mut self,
            inp: std::option::Option<crate::model::StackDriftInformation>,
        ) -> Self {
            self.drift_information = inp;
            self
        }
        /// Consumes the builder and constructs a [`Stack`](crate::model::Stack)
        pub fn build(self) -> crate::model::Stack {
            crate::model::Stack {
                stack_id: self.stack_id,
                stack_name: self.stack_name,
                change_set_id: self.change_set_id,
                description: self.description,
                parameters: self.parameters,
                creation_time: self.creation_time,
                deletion_time: self.deletion_time,
                last_updated_time: self.last_updated_time,
                rollback_configuration: self.rollback_configuration,
                stack_status: self.stack_status,
                stack_status_reason: self.stack_status_reason,
                disable_rollback: self.disable_rollback,
                notification_ar_ns: self.notification_ar_ns,
                timeout_in_minutes: self.timeout_in_minutes,
                capabilities: self.capabilities,
                outputs: self.outputs,
                role_arn: self.role_arn,
                tags: self.tags,
                enable_termination_protection: self.enable_termination_protection,
                parent_id: self.parent_id,
                root_id: self.root_id,
                drift_information: self.drift_information,
            }
        }
    }
}
impl Stack {
    /// Creates a new builder-style object to manufacture [`Stack`](crate::model::Stack)
    pub fn builder() -> crate::model::stack::Builder {
        crate::model::stack::Builder::default()
    }
}

/// <p>Contains information about whether the stack's actual configuration differs, or has
/// <i>drifted</i>, from its expected configuration, as defined in the stack
/// template and any values specified as template parameters. A stack is considered to have
/// drifted if one or more of its resources have drifted.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StackDriftInformation {
    /// <p>Status of the stack's actual configuration compared to its expected template
    /// configuration. </p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>DRIFTED</code>: The stack differs from its expected template
    /// configuration. A stack is considered to have drifted if one or more of its resources
    /// have drifted.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>NOT_CHECKED</code>: AWS CloudFormation has not checked if the stack differs from its
    /// expected template configuration.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>IN_SYNC</code>: The stack's actual configuration matches its expected
    /// template configuration.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>UNKNOWN</code>: This value is reserved for future use.</p>
    /// </li>
    /// </ul>
    pub stack_drift_status: std::option::Option<crate::model::StackDriftStatus>,
    /// <p>Most recent time when a drift detection operation was initiated on the stack, or any
    /// of its individual resources that support drift detection.</p>
    pub last_check_timestamp: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for StackDriftInformation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StackDriftInformation");
        formatter.field("stack_drift_status", &self.stack_drift_status);
        formatter.field("last_check_timestamp", &self.last_check_timestamp);
        formatter.finish()
    }
}
/// See [`StackDriftInformation`](crate::model::StackDriftInformation)
pub mod stack_drift_information {
    /// A builder for [`StackDriftInformation`](crate::model::StackDriftInformation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) stack_drift_status: std::option::Option<crate::model::StackDriftStatus>,
        pub(crate) last_check_timestamp: std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p>Status of the stack's actual configuration compared to its expected template
        /// configuration. </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>DRIFTED</code>: The stack differs from its expected template
        /// configuration. A stack is considered to have drifted if one or more of its resources
        /// have drifted.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>NOT_CHECKED</code>: AWS CloudFormation has not checked if the stack differs from its
        /// expected template configuration.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>IN_SYNC</code>: The stack's actual configuration matches its expected
        /// template configuration.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>UNKNOWN</code>: This value is reserved for future use.</p>
        /// </li>
        /// </ul>
        pub fn stack_drift_status(mut self, inp: crate::model::StackDriftStatus) -> Self {
            self.stack_drift_status = Some(inp);
            self
        }
        pub fn set_stack_drift_status(
            mut self,
            inp: std::option::Option<crate::model::StackDriftStatus>,
        ) -> Self {
            self.stack_drift_status = inp;
            self
        }
        /// <p>Most recent time when a drift detection operation was initiated on the stack, or any
        /// of its individual resources that support drift detection.</p>
        pub fn last_check_timestamp(mut self, inp: smithy_types::Instant) -> Self {
            self.last_check_timestamp = Some(inp);
            self
        }
        pub fn set_last_check_timestamp(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_check_timestamp = inp;
            self
        }
        /// Consumes the builder and constructs a [`StackDriftInformation`](crate::model::StackDriftInformation)
        pub fn build(self) -> crate::model::StackDriftInformation {
            crate::model::StackDriftInformation {
                stack_drift_status: self.stack_drift_status,
                last_check_timestamp: self.last_check_timestamp,
            }
        }
    }
}
impl StackDriftInformation {
    /// Creates a new builder-style object to manufacture [`StackDriftInformation`](crate::model::StackDriftInformation)
    pub fn builder() -> crate::model::stack_drift_information::Builder {
        crate::model::stack_drift_information::Builder::default()
    }
}

/// <p>The Output data type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Output {
    /// <p>The key associated with the output.</p>
    pub output_key: std::option::Option<std::string::String>,
    /// <p>The value associated with the output.</p>
    pub output_value: std::option::Option<std::string::String>,
    /// <p>User defined description associated with the output.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The name of the export associated with the output.</p>
    pub export_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Output {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Output");
        formatter.field("output_key", &self.output_key);
        formatter.field("output_value", &self.output_value);
        formatter.field("description", &self.description);
        formatter.field("export_name", &self.export_name);
        formatter.finish()
    }
}
/// See [`Output`](crate::model::Output)
pub mod output {
    /// A builder for [`Output`](crate::model::Output)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) output_key: std::option::Option<std::string::String>,
        pub(crate) output_value: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) export_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The key associated with the output.</p>
        pub fn output_key(mut self, inp: impl Into<std::string::String>) -> Self {
            self.output_key = Some(inp.into());
            self
        }
        pub fn set_output_key(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.output_key = inp;
            self
        }
        /// <p>The value associated with the output.</p>
        pub fn output_value(mut self, inp: impl Into<std::string::String>) -> Self {
            self.output_value = Some(inp.into());
            self
        }
        pub fn set_output_value(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.output_value = inp;
            self
        }
        /// <p>User defined description associated with the output.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.description = Some(inp.into());
            self
        }
        pub fn set_description(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.description = inp;
            self
        }
        /// <p>The name of the export associated with the output.</p>
        pub fn export_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.export_name = Some(inp.into());
            self
        }
        pub fn set_export_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.export_name = inp;
            self
        }
        /// Consumes the builder and constructs a [`Output`](crate::model::Output)
        pub fn build(self) -> crate::model::Output {
            crate::model::Output {
                output_key: self.output_key,
                output_value: self.output_value,
                description: self.description,
                export_name: self.export_name,
            }
        }
    }
}
impl Output {
    /// Creates a new builder-style object to manufacture [`Output`](crate::model::Output)
    pub fn builder() -> crate::model::output::Builder {
        crate::model::output::Builder::default()
    }
}

/// <p>The StackResource data type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StackResource {
    /// <p>The name associated with the stack.</p>
    pub stack_name: std::option::Option<std::string::String>,
    /// <p>Unique identifier of the stack.</p>
    pub stack_id: std::option::Option<std::string::String>,
    /// <p>The logical name of the resource specified in the template.</p>
    pub logical_resource_id: std::option::Option<std::string::String>,
    /// <p>The name or unique identifier that corresponds to a physical instance ID of a
    /// resource supported by AWS CloudFormation.</p>
    pub physical_resource_id: std::option::Option<std::string::String>,
    /// <p>Type of resource. (For more information, go to <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html"> AWS
    /// Resource Types Reference</a> in the AWS CloudFormation User Guide.)</p>
    pub resource_type: std::option::Option<std::string::String>,
    /// <p>Time the status was updated.</p>
    pub timestamp: std::option::Option<smithy_types::Instant>,
    /// <p>Current status of the resource.</p>
    pub resource_status: std::option::Option<crate::model::ResourceStatus>,
    /// <p>Success/failure message associated with the resource.</p>
    pub resource_status_reason: std::option::Option<std::string::String>,
    /// <p>User defined description associated with the resource.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>Information about whether the resource's actual configuration differs, or has
    /// <i>drifted</i>, from its expected configuration, as defined in the stack
    /// template and any values specified as template parameters. For more information, see <a href="http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-stack-drift.html">Detecting Unregulated Configuration
    /// Changes to Stacks and Resources</a>.</p>
    pub drift_information: std::option::Option<crate::model::StackResourceDriftInformation>,
    /// <p>Contains information about the module from which the resource was created, if the resource was created from a module included in the stack template.</p>
    pub module_info: std::option::Option<crate::model::ModuleInfo>,
}
impl std::fmt::Debug for StackResource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StackResource");
        formatter.field("stack_name", &self.stack_name);
        formatter.field("stack_id", &self.stack_id);
        formatter.field("logical_resource_id", &self.logical_resource_id);
        formatter.field("physical_resource_id", &self.physical_resource_id);
        formatter.field("resource_type", &self.resource_type);
        formatter.field("timestamp", &self.timestamp);
        formatter.field("resource_status", &self.resource_status);
        formatter.field("resource_status_reason", &self.resource_status_reason);
        formatter.field("description", &self.description);
        formatter.field("drift_information", &self.drift_information);
        formatter.field("module_info", &self.module_info);
        formatter.finish()
    }
}
/// See [`StackResource`](crate::model::StackResource)
pub mod stack_resource {
    /// A builder for [`StackResource`](crate::model::StackResource)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) stack_name: std::option::Option<std::string::String>,
        pub(crate) stack_id: std::option::Option<std::string::String>,
        pub(crate) logical_resource_id: std::option::Option<std::string::String>,
        pub(crate) physical_resource_id: std::option::Option<std::string::String>,
        pub(crate) resource_type: std::option::Option<std::string::String>,
        pub(crate) timestamp: std::option::Option<smithy_types::Instant>,
        pub(crate) resource_status: std::option::Option<crate::model::ResourceStatus>,
        pub(crate) resource_status_reason: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) drift_information:
            std::option::Option<crate::model::StackResourceDriftInformation>,
        pub(crate) module_info: std::option::Option<crate::model::ModuleInfo>,
    }
    impl Builder {
        /// <p>The name associated with the stack.</p>
        pub fn stack_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.stack_name = Some(inp.into());
            self
        }
        pub fn set_stack_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.stack_name = inp;
            self
        }
        /// <p>Unique identifier of the stack.</p>
        pub fn stack_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.stack_id = Some(inp.into());
            self
        }
        pub fn set_stack_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.stack_id = inp;
            self
        }
        /// <p>The logical name of the resource specified in the template.</p>
        pub fn logical_resource_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.logical_resource_id = Some(inp.into());
            self
        }
        pub fn set_logical_resource_id(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.logical_resource_id = inp;
            self
        }
        /// <p>The name or unique identifier that corresponds to a physical instance ID of a
        /// resource supported by AWS CloudFormation.</p>
        pub fn physical_resource_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.physical_resource_id = Some(inp.into());
            self
        }
        pub fn set_physical_resource_id(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.physical_resource_id = inp;
            self
        }
        /// <p>Type of resource. (For more information, go to <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html"> AWS
        /// Resource Types Reference</a> in the AWS CloudFormation User Guide.)</p>
        pub fn resource_type(mut self, inp: impl Into<std::string::String>) -> Self {
            self.resource_type = Some(inp.into());
            self
        }
        pub fn set_resource_type(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.resource_type = inp;
            self
        }
        /// <p>Time the status was updated.</p>
        pub fn timestamp(mut self, inp: smithy_types::Instant) -> Self {
            self.timestamp = Some(inp);
            self
        }
        pub fn set_timestamp(mut self, inp: std::option::Option<smithy_types::Instant>) -> Self {
            self.timestamp = inp;
            self
        }
        /// <p>Current status of the resource.</p>
        pub fn resource_status(mut self, inp: crate::model::ResourceStatus) -> Self {
            self.resource_status = Some(inp);
            self
        }
        pub fn set_resource_status(
            mut self,
            inp: std::option::Option<crate::model::ResourceStatus>,
        ) -> Self {
            self.resource_status = inp;
            self
        }
        /// <p>Success/failure message associated with the resource.</p>
        pub fn resource_status_reason(mut self, inp: impl Into<std::string::String>) -> Self {
            self.resource_status_reason = Some(inp.into());
            self
        }
        pub fn set_resource_status_reason(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_status_reason = inp;
            self
        }
        /// <p>User defined description associated with the resource.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.description = Some(inp.into());
            self
        }
        pub fn set_description(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.description = inp;
            self
        }
        /// <p>Information about whether the resource's actual configuration differs, or has
        /// <i>drifted</i>, from its expected configuration, as defined in the stack
        /// template and any values specified as template parameters. For more information, see <a href="http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-stack-drift.html">Detecting Unregulated Configuration
        /// Changes to Stacks and Resources</a>.</p>
        pub fn drift_information(
            mut self,
            inp: crate::model::StackResourceDriftInformation,
        ) -> Self {
            self.drift_information = Some(inp);
            self
        }
        pub fn set_drift_information(
            mut self,
            inp: std::option::Option<crate::model::StackResourceDriftInformation>,
        ) -> Self {
            self.drift_information = inp;
            self
        }
        /// <p>Contains information about the module from which the resource was created, if the resource was created from a module included in the stack template.</p>
        pub fn module_info(mut self, inp: crate::model::ModuleInfo) -> Self {
            self.module_info = Some(inp);
            self
        }
        pub fn set_module_info(
            mut self,
            inp: std::option::Option<crate::model::ModuleInfo>,
        ) -> Self {
            self.module_info = inp;
            self
        }
        /// Consumes the builder and constructs a [`StackResource`](crate::model::StackResource)
        pub fn build(self) -> crate::model::StackResource {
            crate::model::StackResource {
                stack_name: self.stack_name,
                stack_id: self.stack_id,
                logical_resource_id: self.logical_resource_id,
                physical_resource_id: self.physical_resource_id,
                resource_type: self.resource_type,
                timestamp: self.timestamp,
                resource_status: self.resource_status,
                resource_status_reason: self.resource_status_reason,
                description: self.description,
                drift_information: self.drift_information,
                module_info: self.module_info,
            }
        }
    }
}
impl StackResource {
    /// Creates a new builder-style object to manufacture [`StackResource`](crate::model::StackResource)
    pub fn builder() -> crate::model::stack_resource::Builder {
        crate::model::stack_resource::Builder::default()
    }
}

/// <p>Contains information about whether the resource's actual configuration differs, or
/// has <i>drifted</i>, from its expected configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StackResourceDriftInformation {
    /// <p>Status of the resource's actual configuration compared to its expected
    /// configuration</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>DELETED</code>: The resource differs from its expected configuration in
    /// that it has been deleted.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>MODIFIED</code>: The resource differs from its expected
    /// configuration.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>NOT_CHECKED</code>: AWS CloudFormation has not checked if the resource differs from
    /// its expected configuration.</p>
    /// <p>Any resources that do not currently support drift detection have a status of
    /// <code>NOT_CHECKED</code>. For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-stack-drift-resource-list.html">Resources that Support Drift Detection</a>. </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>IN_SYNC</code>: The resources's actual configuration matches its expected
    /// configuration.</p>
    /// </li>
    /// </ul>
    pub stack_resource_drift_status: std::option::Option<crate::model::StackResourceDriftStatus>,
    /// <p>When AWS CloudFormation last checked if the resource had drifted from its expected
    /// configuration.</p>
    pub last_check_timestamp: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for StackResourceDriftInformation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StackResourceDriftInformation");
        formatter.field(
            "stack_resource_drift_status",
            &self.stack_resource_drift_status,
        );
        formatter.field("last_check_timestamp", &self.last_check_timestamp);
        formatter.finish()
    }
}
/// See [`StackResourceDriftInformation`](crate::model::StackResourceDriftInformation)
pub mod stack_resource_drift_information {
    /// A builder for [`StackResourceDriftInformation`](crate::model::StackResourceDriftInformation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) stack_resource_drift_status:
            std::option::Option<crate::model::StackResourceDriftStatus>,
        pub(crate) last_check_timestamp: std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p>Status of the resource's actual configuration compared to its expected
        /// configuration</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>DELETED</code>: The resource differs from its expected configuration in
        /// that it has been deleted.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>MODIFIED</code>: The resource differs from its expected
        /// configuration.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>NOT_CHECKED</code>: AWS CloudFormation has not checked if the resource differs from
        /// its expected configuration.</p>
        /// <p>Any resources that do not currently support drift detection have a status of
        /// <code>NOT_CHECKED</code>. For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-stack-drift-resource-list.html">Resources that Support Drift Detection</a>. </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>IN_SYNC</code>: The resources's actual configuration matches its expected
        /// configuration.</p>
        /// </li>
        /// </ul>
        pub fn stack_resource_drift_status(
            mut self,
            inp: crate::model::StackResourceDriftStatus,
        ) -> Self {
            self.stack_resource_drift_status = Some(inp);
            self
        }
        pub fn set_stack_resource_drift_status(
            mut self,
            inp: std::option::Option<crate::model::StackResourceDriftStatus>,
        ) -> Self {
            self.stack_resource_drift_status = inp;
            self
        }
        /// <p>When AWS CloudFormation last checked if the resource had drifted from its expected
        /// configuration.</p>
        pub fn last_check_timestamp(mut self, inp: smithy_types::Instant) -> Self {
            self.last_check_timestamp = Some(inp);
            self
        }
        pub fn set_last_check_timestamp(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_check_timestamp = inp;
            self
        }
        /// Consumes the builder and constructs a [`StackResourceDriftInformation`](crate::model::StackResourceDriftInformation)
        pub fn build(self) -> crate::model::StackResourceDriftInformation {
            crate::model::StackResourceDriftInformation {
                stack_resource_drift_status: self.stack_resource_drift_status,
                last_check_timestamp: self.last_check_timestamp,
            }
        }
    }
}
impl StackResourceDriftInformation {
    /// Creates a new builder-style object to manufacture [`StackResourceDriftInformation`](crate::model::StackResourceDriftInformation)
    pub fn builder() -> crate::model::stack_resource_drift_information::Builder {
        crate::model::stack_resource_drift_information::Builder::default()
    }
}

/// <p>Contains detailed information about the specified stack resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StackResourceDetail {
    /// <p>The name associated with the stack.</p>
    pub stack_name: std::option::Option<std::string::String>,
    /// <p>Unique identifier of the stack.</p>
    pub stack_id: std::option::Option<std::string::String>,
    /// <p>The logical name of the resource specified in the template.</p>
    pub logical_resource_id: std::option::Option<std::string::String>,
    /// <p>The name or unique identifier that corresponds to a physical instance ID of a
    /// resource supported by AWS CloudFormation.</p>
    pub physical_resource_id: std::option::Option<std::string::String>,
    /// <p>Type of resource. ((For more information, go to <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html"> AWS
    /// Resource Types Reference</a> in the AWS CloudFormation User Guide.)</p>
    pub resource_type: std::option::Option<std::string::String>,
    /// <p>Time the status was updated.</p>
    pub last_updated_timestamp: std::option::Option<smithy_types::Instant>,
    /// <p>Current status of the resource.</p>
    pub resource_status: std::option::Option<crate::model::ResourceStatus>,
    /// <p>Success/failure message associated with the resource.</p>
    pub resource_status_reason: std::option::Option<std::string::String>,
    /// <p>User defined description associated with the resource.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The content of the <code>Metadata</code> attribute declared for the resource. For
    /// more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-metadata.html">Metadata
    /// Attribute</a> in the AWS CloudFormation User Guide.</p>
    pub metadata: std::option::Option<std::string::String>,
    /// <p>Information about whether the resource's actual configuration differs, or has
    /// <i>drifted</i>, from its expected configuration, as defined in the stack
    /// template and any values specified as template parameters. For more information, see <a href="http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-stack-drift.html">Detecting Unregulated Configuration
    /// Changes to Stacks and Resources</a>.</p>
    pub drift_information: std::option::Option<crate::model::StackResourceDriftInformation>,
    /// <p>Contains information about the module from which the resource was created, if the resource was created from a module included in the stack template.</p>
    pub module_info: std::option::Option<crate::model::ModuleInfo>,
}
impl std::fmt::Debug for StackResourceDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StackResourceDetail");
        formatter.field("stack_name", &self.stack_name);
        formatter.field("stack_id", &self.stack_id);
        formatter.field("logical_resource_id", &self.logical_resource_id);
        formatter.field("physical_resource_id", &self.physical_resource_id);
        formatter.field("resource_type", &self.resource_type);
        formatter.field("last_updated_timestamp", &self.last_updated_timestamp);
        formatter.field("resource_status", &self.resource_status);
        formatter.field("resource_status_reason", &self.resource_status_reason);
        formatter.field("description", &self.description);
        formatter.field("metadata", &self.metadata);
        formatter.field("drift_information", &self.drift_information);
        formatter.field("module_info", &self.module_info);
        formatter.finish()
    }
}
/// See [`StackResourceDetail`](crate::model::StackResourceDetail)
pub mod stack_resource_detail {
    /// A builder for [`StackResourceDetail`](crate::model::StackResourceDetail)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) stack_name: std::option::Option<std::string::String>,
        pub(crate) stack_id: std::option::Option<std::string::String>,
        pub(crate) logical_resource_id: std::option::Option<std::string::String>,
        pub(crate) physical_resource_id: std::option::Option<std::string::String>,
        pub(crate) resource_type: std::option::Option<std::string::String>,
        pub(crate) last_updated_timestamp: std::option::Option<smithy_types::Instant>,
        pub(crate) resource_status: std::option::Option<crate::model::ResourceStatus>,
        pub(crate) resource_status_reason: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) metadata: std::option::Option<std::string::String>,
        pub(crate) drift_information:
            std::option::Option<crate::model::StackResourceDriftInformation>,
        pub(crate) module_info: std::option::Option<crate::model::ModuleInfo>,
    }
    impl Builder {
        /// <p>The name associated with the stack.</p>
        pub fn stack_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.stack_name = Some(inp.into());
            self
        }
        pub fn set_stack_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.stack_name = inp;
            self
        }
        /// <p>Unique identifier of the stack.</p>
        pub fn stack_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.stack_id = Some(inp.into());
            self
        }
        pub fn set_stack_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.stack_id = inp;
            self
        }
        /// <p>The logical name of the resource specified in the template.</p>
        pub fn logical_resource_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.logical_resource_id = Some(inp.into());
            self
        }
        pub fn set_logical_resource_id(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.logical_resource_id = inp;
            self
        }
        /// <p>The name or unique identifier that corresponds to a physical instance ID of a
        /// resource supported by AWS CloudFormation.</p>
        pub fn physical_resource_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.physical_resource_id = Some(inp.into());
            self
        }
        pub fn set_physical_resource_id(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.physical_resource_id = inp;
            self
        }
        /// <p>Type of resource. ((For more information, go to <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html"> AWS
        /// Resource Types Reference</a> in the AWS CloudFormation User Guide.)</p>
        pub fn resource_type(mut self, inp: impl Into<std::string::String>) -> Self {
            self.resource_type = Some(inp.into());
            self
        }
        pub fn set_resource_type(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.resource_type = inp;
            self
        }
        /// <p>Time the status was updated.</p>
        pub fn last_updated_timestamp(mut self, inp: smithy_types::Instant) -> Self {
            self.last_updated_timestamp = Some(inp);
            self
        }
        pub fn set_last_updated_timestamp(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_updated_timestamp = inp;
            self
        }
        /// <p>Current status of the resource.</p>
        pub fn resource_status(mut self, inp: crate::model::ResourceStatus) -> Self {
            self.resource_status = Some(inp);
            self
        }
        pub fn set_resource_status(
            mut self,
            inp: std::option::Option<crate::model::ResourceStatus>,
        ) -> Self {
            self.resource_status = inp;
            self
        }
        /// <p>Success/failure message associated with the resource.</p>
        pub fn resource_status_reason(mut self, inp: impl Into<std::string::String>) -> Self {
            self.resource_status_reason = Some(inp.into());
            self
        }
        pub fn set_resource_status_reason(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_status_reason = inp;
            self
        }
        /// <p>User defined description associated with the resource.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.description = Some(inp.into());
            self
        }
        pub fn set_description(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.description = inp;
            self
        }
        /// <p>The content of the <code>Metadata</code> attribute declared for the resource. For
        /// more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-metadata.html">Metadata
        /// Attribute</a> in the AWS CloudFormation User Guide.</p>
        pub fn metadata(mut self, inp: impl Into<std::string::String>) -> Self {
            self.metadata = Some(inp.into());
            self
        }
        pub fn set_metadata(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.metadata = inp;
            self
        }
        /// <p>Information about whether the resource's actual configuration differs, or has
        /// <i>drifted</i>, from its expected configuration, as defined in the stack
        /// template and any values specified as template parameters. For more information, see <a href="http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-stack-drift.html">Detecting Unregulated Configuration
        /// Changes to Stacks and Resources</a>.</p>
        pub fn drift_information(
            mut self,
            inp: crate::model::StackResourceDriftInformation,
        ) -> Self {
            self.drift_information = Some(inp);
            self
        }
        pub fn set_drift_information(
            mut self,
            inp: std::option::Option<crate::model::StackResourceDriftInformation>,
        ) -> Self {
            self.drift_information = inp;
            self
        }
        /// <p>Contains information about the module from which the resource was created, if the resource was created from a module included in the stack template.</p>
        pub fn module_info(mut self, inp: crate::model::ModuleInfo) -> Self {
            self.module_info = Some(inp);
            self
        }
        pub fn set_module_info(
            mut self,
            inp: std::option::Option<crate::model::ModuleInfo>,
        ) -> Self {
            self.module_info = inp;
            self
        }
        /// Consumes the builder and constructs a [`StackResourceDetail`](crate::model::StackResourceDetail)
        pub fn build(self) -> crate::model::StackResourceDetail {
            crate::model::StackResourceDetail {
                stack_name: self.stack_name,
                stack_id: self.stack_id,
                logical_resource_id: self.logical_resource_id,
                physical_resource_id: self.physical_resource_id,
                resource_type: self.resource_type,
                last_updated_timestamp: self.last_updated_timestamp,
                resource_status: self.resource_status,
                resource_status_reason: self.resource_status_reason,
                description: self.description,
                metadata: self.metadata,
                drift_information: self.drift_information,
                module_info: self.module_info,
            }
        }
    }
}
impl StackResourceDetail {
    /// Creates a new builder-style object to manufacture [`StackResourceDetail`](crate::model::StackResourceDetail)
    pub fn builder() -> crate::model::stack_resource_detail::Builder {
        crate::model::stack_resource_detail::Builder::default()
    }
}

/// <p>An AWS CloudFormation stack, in a specific account and Region, that's part of a stack
/// set operation. A stack instance is a reference to an attempted or actual stack in a given
/// account within a given Region. A stack instance can exist without a stack—for example, if
/// the stack couldn't be created for some reason. A stack instance is associated with only one
/// stack set. Each stack instance contains the ID of its associated stack set, as well as the
/// ID of the actual stack and the stack status.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StackInstance {
    /// <p>The name or unique ID of the stack set that the stack instance is associated
    /// with.</p>
    pub stack_set_id: std::option::Option<std::string::String>,
    /// <p>The name of the AWS Region that the stack instance is associated with.</p>
    pub region: std::option::Option<std::string::String>,
    /// <p>[Self-managed permissions] The name of the AWS account that the stack instance is associated with.</p>
    pub account: std::option::Option<std::string::String>,
    /// <p>The ID of the stack instance.</p>
    pub stack_id: std::option::Option<std::string::String>,
    /// <p>A list of parameters from the stack set template whose values have been overridden in
    /// this stack instance.</p>
    pub parameter_overrides: std::option::Option<std::vec::Vec<crate::model::Parameter>>,
    /// <p>The status of the stack instance, in terms of its synchronization with its associated
    /// stack set.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>INOPERABLE</code>: A <code>DeleteStackInstances</code> operation has
    /// failed and left the stack in an unstable state. Stacks in this state are excluded
    /// from further <code>UpdateStackSet</code> operations. You might need to perform a
    /// <code>DeleteStackInstances</code> operation, with <code>RetainStacks</code> set to
    /// <code>true</code>, to delete the stack instance, and then delete the stack
    /// manually.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>OUTDATED</code>: The stack isn't currently up to date with the stack set
    /// because:</p>
    /// <ul>
    /// <li>
    /// <p>The associated stack failed during a <code>CreateStackSet</code> or
    /// <code>UpdateStackSet</code> operation. </p>
    /// </li>
    /// <li>
    /// <p>The stack was part of a <code>CreateStackSet</code> or
    /// <code>UpdateStackSet</code> operation that failed or was stopped before the
    /// stack was created or updated. </p>
    /// </li>
    /// </ul>
    /// </li>
    /// <li>
    /// <p>
    /// <code>CURRENT</code>: The stack is currently up to date with the stack
    /// set.</p>
    /// </li>
    /// </ul>
    pub status: std::option::Option<crate::model::StackInstanceStatus>,
    /// <p>The detailed status of the stack instance.</p>
    pub stack_instance_status: std::option::Option<crate::model::StackInstanceComprehensiveStatus>,
    /// <p>The explanation for the specific status code that is assigned to this stack
    /// instance.</p>
    pub status_reason: std::option::Option<std::string::String>,
    /// <p>[Service-managed permissions] The organization root ID or organizational unit (OU) IDs that you specified for <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/APIReference/API_DeploymentTargets.html">DeploymentTargets</a>.</p>
    pub organizational_unit_id: std::option::Option<std::string::String>,
    /// <p>Status of the stack instance's actual configuration compared to the expected template
    /// and parameter configuration of the stack set to which it belongs. </p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>DRIFTED</code>: The stack differs from the expected template and parameter
    /// configuration of the stack set to which it belongs. A stack instance is considered to
    /// have drifted if one or more of the resources in the associated stack have
    /// drifted.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>NOT_CHECKED</code>: AWS CloudFormation has not checked if the stack instance differs from
    /// its expected stack set configuration.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>IN_SYNC</code>: The stack instance's actual configuration matches its
    /// expected stack set configuration.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>UNKNOWN</code>: This value is reserved for future use.</p>
    /// </li>
    /// </ul>
    pub drift_status: std::option::Option<crate::model::StackDriftStatus>,
    /// <p>Most recent time when CloudFormation performed a drift detection operation on the stack
    /// instance. This value will be <code>NULL</code> for any stack instance on which drift
    /// detection has not yet been performed.</p>
    pub last_drift_check_timestamp: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for StackInstance {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StackInstance");
        formatter.field("stack_set_id", &self.stack_set_id);
        formatter.field("region", &self.region);
        formatter.field("account", &self.account);
        formatter.field("stack_id", &self.stack_id);
        formatter.field("parameter_overrides", &self.parameter_overrides);
        formatter.field("status", &self.status);
        formatter.field("stack_instance_status", &self.stack_instance_status);
        formatter.field("status_reason", &self.status_reason);
        formatter.field("organizational_unit_id", &self.organizational_unit_id);
        formatter.field("drift_status", &self.drift_status);
        formatter.field(
            "last_drift_check_timestamp",
            &self.last_drift_check_timestamp,
        );
        formatter.finish()
    }
}
/// See [`StackInstance`](crate::model::StackInstance)
pub mod stack_instance {
    /// A builder for [`StackInstance`](crate::model::StackInstance)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) stack_set_id: std::option::Option<std::string::String>,
        pub(crate) region: std::option::Option<std::string::String>,
        pub(crate) account: std::option::Option<std::string::String>,
        pub(crate) stack_id: std::option::Option<std::string::String>,
        pub(crate) parameter_overrides: std::option::Option<std::vec::Vec<crate::model::Parameter>>,
        pub(crate) status: std::option::Option<crate::model::StackInstanceStatus>,
        pub(crate) stack_instance_status:
            std::option::Option<crate::model::StackInstanceComprehensiveStatus>,
        pub(crate) status_reason: std::option::Option<std::string::String>,
        pub(crate) organizational_unit_id: std::option::Option<std::string::String>,
        pub(crate) drift_status: std::option::Option<crate::model::StackDriftStatus>,
        pub(crate) last_drift_check_timestamp: std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The name or unique ID of the stack set that the stack instance is associated
        /// with.</p>
        pub fn stack_set_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.stack_set_id = Some(inp.into());
            self
        }
        pub fn set_stack_set_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.stack_set_id = inp;
            self
        }
        /// <p>The name of the AWS Region that the stack instance is associated with.</p>
        pub fn region(mut self, inp: impl Into<std::string::String>) -> Self {
            self.region = Some(inp.into());
            self
        }
        pub fn set_region(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.region = inp;
            self
        }
        /// <p>[Self-managed permissions] The name of the AWS account that the stack instance is associated with.</p>
        pub fn account(mut self, inp: impl Into<std::string::String>) -> Self {
            self.account = Some(inp.into());
            self
        }
        pub fn set_account(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.account = inp;
            self
        }
        /// <p>The ID of the stack instance.</p>
        pub fn stack_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.stack_id = Some(inp.into());
            self
        }
        pub fn set_stack_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.stack_id = inp;
            self
        }
        pub fn parameter_overrides(mut self, inp: impl Into<crate::model::Parameter>) -> Self {
            let mut v = self.parameter_overrides.unwrap_or_default();
            v.push(inp.into());
            self.parameter_overrides = Some(v);
            self
        }
        pub fn set_parameter_overrides(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Parameter>>,
        ) -> Self {
            self.parameter_overrides = inp;
            self
        }
        /// <p>The status of the stack instance, in terms of its synchronization with its associated
        /// stack set.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>INOPERABLE</code>: A <code>DeleteStackInstances</code> operation has
        /// failed and left the stack in an unstable state. Stacks in this state are excluded
        /// from further <code>UpdateStackSet</code> operations. You might need to perform a
        /// <code>DeleteStackInstances</code> operation, with <code>RetainStacks</code> set to
        /// <code>true</code>, to delete the stack instance, and then delete the stack
        /// manually.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>OUTDATED</code>: The stack isn't currently up to date with the stack set
        /// because:</p>
        /// <ul>
        /// <li>
        /// <p>The associated stack failed during a <code>CreateStackSet</code> or
        /// <code>UpdateStackSet</code> operation. </p>
        /// </li>
        /// <li>
        /// <p>The stack was part of a <code>CreateStackSet</code> or
        /// <code>UpdateStackSet</code> operation that failed or was stopped before the
        /// stack was created or updated. </p>
        /// </li>
        /// </ul>
        /// </li>
        /// <li>
        /// <p>
        /// <code>CURRENT</code>: The stack is currently up to date with the stack
        /// set.</p>
        /// </li>
        /// </ul>
        pub fn status(mut self, inp: crate::model::StackInstanceStatus) -> Self {
            self.status = Some(inp);
            self
        }
        pub fn set_status(
            mut self,
            inp: std::option::Option<crate::model::StackInstanceStatus>,
        ) -> Self {
            self.status = inp;
            self
        }
        /// <p>The detailed status of the stack instance.</p>
        pub fn stack_instance_status(
            mut self,
            inp: crate::model::StackInstanceComprehensiveStatus,
        ) -> Self {
            self.stack_instance_status = Some(inp);
            self
        }
        pub fn set_stack_instance_status(
            mut self,
            inp: std::option::Option<crate::model::StackInstanceComprehensiveStatus>,
        ) -> Self {
            self.stack_instance_status = inp;
            self
        }
        /// <p>The explanation for the specific status code that is assigned to this stack
        /// instance.</p>
        pub fn status_reason(mut self, inp: impl Into<std::string::String>) -> Self {
            self.status_reason = Some(inp.into());
            self
        }
        pub fn set_status_reason(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.status_reason = inp;
            self
        }
        /// <p>[Service-managed permissions] The organization root ID or organizational unit (OU) IDs that you specified for <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/APIReference/API_DeploymentTargets.html">DeploymentTargets</a>.</p>
        pub fn organizational_unit_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.organizational_unit_id = Some(inp.into());
            self
        }
        pub fn set_organizational_unit_id(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.organizational_unit_id = inp;
            self
        }
        /// <p>Status of the stack instance's actual configuration compared to the expected template
        /// and parameter configuration of the stack set to which it belongs. </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>DRIFTED</code>: The stack differs from the expected template and parameter
        /// configuration of the stack set to which it belongs. A stack instance is considered to
        /// have drifted if one or more of the resources in the associated stack have
        /// drifted.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>NOT_CHECKED</code>: AWS CloudFormation has not checked if the stack instance differs from
        /// its expected stack set configuration.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>IN_SYNC</code>: The stack instance's actual configuration matches its
        /// expected stack set configuration.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>UNKNOWN</code>: This value is reserved for future use.</p>
        /// </li>
        /// </ul>
        pub fn drift_status(mut self, inp: crate::model::StackDriftStatus) -> Self {
            self.drift_status = Some(inp);
            self
        }
        pub fn set_drift_status(
            mut self,
            inp: std::option::Option<crate::model::StackDriftStatus>,
        ) -> Self {
            self.drift_status = inp;
            self
        }
        /// <p>Most recent time when CloudFormation performed a drift detection operation on the stack
        /// instance. This value will be <code>NULL</code> for any stack instance on which drift
        /// detection has not yet been performed.</p>
        pub fn last_drift_check_timestamp(mut self, inp: smithy_types::Instant) -> Self {
            self.last_drift_check_timestamp = Some(inp);
            self
        }
        pub fn set_last_drift_check_timestamp(
            mut self,
            inp: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.last_drift_check_timestamp = inp;
            self
        }
        /// Consumes the builder and constructs a [`StackInstance`](crate::model::StackInstance)
        pub fn build(self) -> crate::model::StackInstance {
            crate::model::StackInstance {
                stack_set_id: self.stack_set_id,
                region: self.region,
                account: self.account,
                stack_id: self.stack_id,
                parameter_overrides: self.parameter_overrides,
                status: self.status,
                stack_instance_status: self.stack_instance_status,
                status_reason: self.status_reason,
                organizational_unit_id: self.organizational_unit_id,
                drift_status: self.drift_status,
                last_drift_check_timestamp: self.last_drift_check_timestamp,
            }
        }
    }
}
impl StackInstance {
    /// Creates a new builder-style object to manufacture [`StackInstance`](crate::model::StackInstance)
    pub fn builder() -> crate::model::stack_instance::Builder {
        crate::model::stack_instance::Builder::default()
    }
}

/// <p>The StackEvent data type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StackEvent {
    /// <p>The unique ID name of the instance of the stack.</p>
    pub stack_id: std::option::Option<std::string::String>,
    /// <p>The unique ID of this event.</p>
    pub event_id: std::option::Option<std::string::String>,
    /// <p>The name associated with a stack.</p>
    pub stack_name: std::option::Option<std::string::String>,
    /// <p>The logical name of the resource specified in the template.</p>
    pub logical_resource_id: std::option::Option<std::string::String>,
    /// <p>The name or unique identifier associated with the physical instance of the
    /// resource.</p>
    pub physical_resource_id: std::option::Option<std::string::String>,
    /// <p>Type of resource. (For more information, go to <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html"> AWS
    /// Resource Types Reference</a> in the AWS CloudFormation User Guide.)</p>
    pub resource_type: std::option::Option<std::string::String>,
    /// <p>Time the status was updated.</p>
    pub timestamp: std::option::Option<smithy_types::Instant>,
    /// <p>Current status of the resource.</p>
    pub resource_status: std::option::Option<crate::model::ResourceStatus>,
    /// <p>Success/failure message associated with the resource.</p>
    pub resource_status_reason: std::option::Option<std::string::String>,
    /// <p>BLOB of the properties used to create the resource.</p>
    pub resource_properties: std::option::Option<std::string::String>,
    /// <p>The token passed to the operation that generated this event.</p>
    /// <p>All events triggered by a given stack operation are assigned the same client request
    /// token, which you can use to track operations. For example, if you execute a
    /// <code>CreateStack</code> operation with the token <code>token1</code>, then all the
    /// <code>StackEvents</code> generated by that operation will have
    /// <code>ClientRequestToken</code> set as <code>token1</code>.</p>
    /// <p>In the console, stack operations display the client request token on the Events tab.
    /// Stack operations that are initiated from the console use the token format
    /// <i>Console-StackOperation-ID</i>, which helps you easily identify the
    /// stack operation . For example, if you create a stack using the console, each stack event
    /// would be assigned the same token in the following format:
    /// <code>Console-CreateStack-7f59c3cf-00d2-40c7-b2ff-e75db0987002</code>. </p>
    pub client_request_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for StackEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StackEvent");
        formatter.field("stack_id", &self.stack_id);
        formatter.field("event_id", &self.event_id);
        formatter.field("stack_name", &self.stack_name);
        formatter.field("logical_resource_id", &self.logical_resource_id);
        formatter.field("physical_resource_id", &self.physical_resource_id);
        formatter.field("resource_type", &self.resource_type);
        formatter.field("timestamp", &self.timestamp);
        formatter.field("resource_status", &self.resource_status);
        formatter.field("resource_status_reason", &self.resource_status_reason);
        formatter.field("resource_properties", &self.resource_properties);
        formatter.field("client_request_token", &self.client_request_token);
        formatter.finish()
    }
}
/// See [`StackEvent`](crate::model::StackEvent)
pub mod stack_event {
    /// A builder for [`StackEvent`](crate::model::StackEvent)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) stack_id: std::option::Option<std::string::String>,
        pub(crate) event_id: std::option::Option<std::string::String>,
        pub(crate) stack_name: std::option::Option<std::string::String>,
        pub(crate) logical_resource_id: std::option::Option<std::string::String>,
        pub(crate) physical_resource_id: std::option::Option<std::string::String>,
        pub(crate) resource_type: std::option::Option<std::string::String>,
        pub(crate) timestamp: std::option::Option<smithy_types::Instant>,
        pub(crate) resource_status: std::option::Option<crate::model::ResourceStatus>,
        pub(crate) resource_status_reason: std::option::Option<std::string::String>,
        pub(crate) resource_properties: std::option::Option<std::string::String>,
        pub(crate) client_request_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique ID name of the instance of the stack.</p>
        pub fn stack_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.stack_id = Some(inp.into());
            self
        }
        pub fn set_stack_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.stack_id = inp;
            self
        }
        /// <p>The unique ID of this event.</p>
        pub fn event_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.event_id = Some(inp.into());
            self
        }
        pub fn set_event_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.event_id = inp;
            self
        }
        /// <p>The name associated with a stack.</p>
        pub fn stack_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.stack_name = Some(inp.into());
            self
        }
        pub fn set_stack_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.stack_name = inp;
            self
        }
        /// <p>The logical name of the resource specified in the template.</p>
        pub fn logical_resource_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.logical_resource_id = Some(inp.into());
            self
        }
        pub fn set_logical_resource_id(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.logical_resource_id = inp;
            self
        }
        /// <p>The name or unique identifier associated with the physical instance of the
        /// resource.</p>
        pub fn physical_resource_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.physical_resource_id = Some(inp.into());
            self
        }
        pub fn set_physical_resource_id(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.physical_resource_id = inp;
            self
        }
        /// <p>Type of resource. (For more information, go to <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html"> AWS
        /// Resource Types Reference</a> in the AWS CloudFormation User Guide.)</p>
        pub fn resource_type(mut self, inp: impl Into<std::string::String>) -> Self {
            self.resource_type = Some(inp.into());
            self
        }
        pub fn set_resource_type(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.resource_type = inp;
            self
        }
        /// <p>Time the status was updated.</p>
        pub fn timestamp(mut self, inp: smithy_types::Instant) -> Self {
            self.timestamp = Some(inp);
            self
        }
        pub fn set_timestamp(mut self, inp: std::option::Option<smithy_types::Instant>) -> Self {
            self.timestamp = inp;
            self
        }
        /// <p>Current status of the resource.</p>
        pub fn resource_status(mut self, inp: crate::model::ResourceStatus) -> Self {
            self.resource_status = Some(inp);
            self
        }
        pub fn set_resource_status(
            mut self,
            inp: std::option::Option<crate::model::ResourceStatus>,
        ) -> Self {
            self.resource_status = inp;
            self
        }
        /// <p>Success/failure message associated with the resource.</p>
        pub fn resource_status_reason(mut self, inp: impl Into<std::string::String>) -> Self {
            self.resource_status_reason = Some(inp.into());
            self
        }
        pub fn set_resource_status_reason(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_status_reason = inp;
            self
        }
        /// <p>BLOB of the properties used to create the resource.</p>
        pub fn resource_properties(mut self, inp: impl Into<std::string::String>) -> Self {
            self.resource_properties = Some(inp.into());
            self
        }
        pub fn set_resource_properties(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_properties = inp;
            self
        }
        /// <p>The token passed to the operation that generated this event.</p>
        /// <p>All events triggered by a given stack operation are assigned the same client request
        /// token, which you can use to track operations. For example, if you execute a
        /// <code>CreateStack</code> operation with the token <code>token1</code>, then all the
        /// <code>StackEvents</code> generated by that operation will have
        /// <code>ClientRequestToken</code> set as <code>token1</code>.</p>
        /// <p>In the console, stack operations display the client request token on the Events tab.
        /// Stack operations that are initiated from the console use the token format
        /// <i>Console-StackOperation-ID</i>, which helps you easily identify the
        /// stack operation . For example, if you create a stack using the console, each stack event
        /// would be assigned the same token in the following format:
        /// <code>Console-CreateStack-7f59c3cf-00d2-40c7-b2ff-e75db0987002</code>. </p>
        pub fn client_request_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.client_request_token = Some(inp.into());
            self
        }
        pub fn set_client_request_token(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.client_request_token = inp;
            self
        }
        /// Consumes the builder and constructs a [`StackEvent`](crate::model::StackEvent)
        pub fn build(self) -> crate::model::StackEvent {
            crate::model::StackEvent {
                stack_id: self.stack_id,
                event_id: self.event_id,
                stack_name: self.stack_name,
                logical_resource_id: self.logical_resource_id,
                physical_resource_id: self.physical_resource_id,
                resource_type: self.resource_type,
                timestamp: self.timestamp,
                resource_status: self.resource_status,
                resource_status_reason: self.resource_status_reason,
                resource_properties: self.resource_properties,
                client_request_token: self.client_request_token,
            }
        }
    }
}
impl StackEvent {
    /// Creates a new builder-style object to manufacture [`StackEvent`](crate::model::StackEvent)
    pub fn builder() -> crate::model::stack_event::Builder {
        crate::model::stack_event::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StackDriftDetectionStatus {
    DetectionComplete,
    DetectionFailed,
    DetectionInProgress,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for StackDriftDetectionStatus {
    fn from(s: &str) -> Self {
        match s {
            "DETECTION_COMPLETE" => StackDriftDetectionStatus::DetectionComplete,
            "DETECTION_FAILED" => StackDriftDetectionStatus::DetectionFailed,
            "DETECTION_IN_PROGRESS" => StackDriftDetectionStatus::DetectionInProgress,
            other => StackDriftDetectionStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for StackDriftDetectionStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(StackDriftDetectionStatus::from(s))
    }
}
impl StackDriftDetectionStatus {
    pub fn as_str(&self) -> &str {
        match self {
            StackDriftDetectionStatus::DetectionComplete => "DETECTION_COMPLETE",
            StackDriftDetectionStatus::DetectionFailed => "DETECTION_FAILED",
            StackDriftDetectionStatus::DetectionInProgress => "DETECTION_IN_PROGRESS",
            StackDriftDetectionStatus::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for StackDriftDetectionStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for StackDriftDetectionStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>The <code>Change</code> structure describes the changes AWS CloudFormation will
/// perform if you execute the change set.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Change {
    /// <p>The type of entity that AWS CloudFormation changes. Currently, the only entity type
    /// is <code>Resource</code>.</p>
    pub r#type: std::option::Option<crate::model::ChangeType>,
    /// <p>A <code>ResourceChange</code> structure that describes the resource and action that
    /// AWS CloudFormation will perform.</p>
    pub resource_change: std::option::Option<crate::model::ResourceChange>,
}
impl std::fmt::Debug for Change {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Change");
        formatter.field("r#type", &self.r#type);
        formatter.field("resource_change", &self.resource_change);
        formatter.finish()
    }
}
/// See [`Change`](crate::model::Change)
pub mod change {
    /// A builder for [`Change`](crate::model::Change)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<crate::model::ChangeType>,
        pub(crate) resource_change: std::option::Option<crate::model::ResourceChange>,
    }
    impl Builder {
        /// <p>The type of entity that AWS CloudFormation changes. Currently, the only entity type
        /// is <code>Resource</code>.</p>
        pub fn r#type(mut self, inp: crate::model::ChangeType) -> Self {
            self.r#type = Some(inp);
            self
        }
        pub fn set_type(mut self, inp: std::option::Option<crate::model::ChangeType>) -> Self {
            self.r#type = inp;
            self
        }
        /// <p>A <code>ResourceChange</code> structure that describes the resource and action that
        /// AWS CloudFormation will perform.</p>
        pub fn resource_change(mut self, inp: crate::model::ResourceChange) -> Self {
            self.resource_change = Some(inp);
            self
        }
        pub fn set_resource_change(
            mut self,
            inp: std::option::Option<crate::model::ResourceChange>,
        ) -> Self {
            self.resource_change = inp;
            self
        }
        /// Consumes the builder and constructs a [`Change`](crate::model::Change)
        pub fn build(self) -> crate::model::Change {
            crate::model::Change {
                r#type: self.r#type,
                resource_change: self.resource_change,
            }
        }
    }
}
impl Change {
    /// Creates a new builder-style object to manufacture [`Change`](crate::model::Change)
    pub fn builder() -> crate::model::change::Builder {
        crate::model::change::Builder::default()
    }
}

/// <p>The <code>ResourceChange</code> structure describes the resource and the action that
/// AWS CloudFormation will perform on it if you execute this change set.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceChange {
    /// <p>The action that AWS CloudFormation takes on the resource, such as <code>Add</code>
    /// (adds a new resource), <code>Modify</code> (changes a resource), <code>Remove</code>
    /// (deletes a resource), <code>Import</code> (imports a resource), or <code>Dynamic</code>
    /// (exact action for the resource cannot be determined).</p>
    pub action: std::option::Option<crate::model::ChangeAction>,
    /// <p>The resource's logical ID, which is defined in the stack's template.</p>
    pub logical_resource_id: std::option::Option<std::string::String>,
    /// <p>The resource's physical ID (resource name). Resources that you are adding don't have
    /// physical IDs because they haven't been created.</p>
    pub physical_resource_id: std::option::Option<std::string::String>,
    /// <p>The type of AWS CloudFormation resource, such as
    /// <code>AWS::S3::Bucket</code>.</p>
    pub resource_type: std::option::Option<std::string::String>,
    /// <p>For the <code>Modify</code> action, indicates whether AWS CloudFormation will replace
    /// the resource by creating a new one and deleting the old one. This value depends on the
    /// value of the <code>RequiresRecreation</code> property in the
    /// <code>ResourceTargetDefinition</code> structure. For example, if the
    /// <code>RequiresRecreation</code> field is <code>Always</code> and the
    /// <code>Evaluation</code> field is <code>Static</code>, <code>Replacement</code> is
    /// <code>True</code>. If the <code>RequiresRecreation</code> field is <code>Always</code>
    /// and the <code>Evaluation</code> field is <code>Dynamic</code>, <code>Replacement</code> is
    /// <code>Conditionally</code>.</p>
    /// <p>If you have multiple changes with different <code>RequiresRecreation</code> values,
    /// the <code>Replacement</code> value depends on the change with the most impact. A
    /// <code>RequiresRecreation</code> value of <code>Always</code> has the most impact,
    /// followed by <code>Conditionally</code>, and then <code>Never</code>.</p>
    pub replacement: std::option::Option<crate::model::Replacement>,
    /// <p>For the <code>Modify</code> action, indicates which resource attribute is triggering
    /// this update, such as a change in the resource attribute's <code>Metadata</code>,
    /// <code>Properties</code>, or <code>Tags</code>.</p>
    pub scope: std::option::Option<std::vec::Vec<crate::model::ResourceAttribute>>,
    /// <p>For the <code>Modify</code> action, a list of <code>ResourceChangeDetail</code>
    /// structures that describes the changes that AWS CloudFormation will make to the resource.
    /// </p>
    pub details: std::option::Option<std::vec::Vec<crate::model::ResourceChangeDetail>>,
    /// <p>The change set ID of the nested change set.</p>
    pub change_set_id: std::option::Option<std::string::String>,
    /// <p>Contains information about the module from which the resource was created, if the resource was created from a module included in the stack template.</p>
    pub module_info: std::option::Option<crate::model::ModuleInfo>,
}
impl std::fmt::Debug for ResourceChange {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceChange");
        formatter.field("action", &self.action);
        formatter.field("logical_resource_id", &self.logical_resource_id);
        formatter.field("physical_resource_id", &self.physical_resource_id);
        formatter.field("resource_type", &self.resource_type);
        formatter.field("replacement", &self.replacement);
        formatter.field("scope", &self.scope);
        formatter.field("details", &self.details);
        formatter.field("change_set_id", &self.change_set_id);
        formatter.field("module_info", &self.module_info);
        formatter.finish()
    }
}
/// See [`ResourceChange`](crate::model::ResourceChange)
pub mod resource_change {
    /// A builder for [`ResourceChange`](crate::model::ResourceChange)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) action: std::option::Option<crate::model::ChangeAction>,
        pub(crate) logical_resource_id: std::option::Option<std::string::String>,
        pub(crate) physical_resource_id: std::option::Option<std::string::String>,
        pub(crate) resource_type: std::option::Option<std::string::String>,
        pub(crate) replacement: std::option::Option<crate::model::Replacement>,
        pub(crate) scope: std::option::Option<std::vec::Vec<crate::model::ResourceAttribute>>,
        pub(crate) details: std::option::Option<std::vec::Vec<crate::model::ResourceChangeDetail>>,
        pub(crate) change_set_id: std::option::Option<std::string::String>,
        pub(crate) module_info: std::option::Option<crate::model::ModuleInfo>,
    }
    impl Builder {
        /// <p>The action that AWS CloudFormation takes on the resource, such as <code>Add</code>
        /// (adds a new resource), <code>Modify</code> (changes a resource), <code>Remove</code>
        /// (deletes a resource), <code>Import</code> (imports a resource), or <code>Dynamic</code>
        /// (exact action for the resource cannot be determined).</p>
        pub fn action(mut self, inp: crate::model::ChangeAction) -> Self {
            self.action = Some(inp);
            self
        }
        pub fn set_action(mut self, inp: std::option::Option<crate::model::ChangeAction>) -> Self {
            self.action = inp;
            self
        }
        /// <p>The resource's logical ID, which is defined in the stack's template.</p>
        pub fn logical_resource_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.logical_resource_id = Some(inp.into());
            self
        }
        pub fn set_logical_resource_id(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.logical_resource_id = inp;
            self
        }
        /// <p>The resource's physical ID (resource name). Resources that you are adding don't have
        /// physical IDs because they haven't been created.</p>
        pub fn physical_resource_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.physical_resource_id = Some(inp.into());
            self
        }
        pub fn set_physical_resource_id(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.physical_resource_id = inp;
            self
        }
        /// <p>The type of AWS CloudFormation resource, such as
        /// <code>AWS::S3::Bucket</code>.</p>
        pub fn resource_type(mut self, inp: impl Into<std::string::String>) -> Self {
            self.resource_type = Some(inp.into());
            self
        }
        pub fn set_resource_type(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.resource_type = inp;
            self
        }
        /// <p>For the <code>Modify</code> action, indicates whether AWS CloudFormation will replace
        /// the resource by creating a new one and deleting the old one. This value depends on the
        /// value of the <code>RequiresRecreation</code> property in the
        /// <code>ResourceTargetDefinition</code> structure. For example, if the
        /// <code>RequiresRecreation</code> field is <code>Always</code> and the
        /// <code>Evaluation</code> field is <code>Static</code>, <code>Replacement</code> is
        /// <code>True</code>. If the <code>RequiresRecreation</code> field is <code>Always</code>
        /// and the <code>Evaluation</code> field is <code>Dynamic</code>, <code>Replacement</code> is
        /// <code>Conditionally</code>.</p>
        /// <p>If you have multiple changes with different <code>RequiresRecreation</code> values,
        /// the <code>Replacement</code> value depends on the change with the most impact. A
        /// <code>RequiresRecreation</code> value of <code>Always</code> has the most impact,
        /// followed by <code>Conditionally</code>, and then <code>Never</code>.</p>
        pub fn replacement(mut self, inp: crate::model::Replacement) -> Self {
            self.replacement = Some(inp);
            self
        }
        pub fn set_replacement(
            mut self,
            inp: std::option::Option<crate::model::Replacement>,
        ) -> Self {
            self.replacement = inp;
            self
        }
        pub fn scope(mut self, inp: impl Into<crate::model::ResourceAttribute>) -> Self {
            let mut v = self.scope.unwrap_or_default();
            v.push(inp.into());
            self.scope = Some(v);
            self
        }
        pub fn set_scope(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::ResourceAttribute>>,
        ) -> Self {
            self.scope = inp;
            self
        }
        pub fn details(mut self, inp: impl Into<crate::model::ResourceChangeDetail>) -> Self {
            let mut v = self.details.unwrap_or_default();
            v.push(inp.into());
            self.details = Some(v);
            self
        }
        pub fn set_details(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::ResourceChangeDetail>>,
        ) -> Self {
            self.details = inp;
            self
        }
        /// <p>The change set ID of the nested change set.</p>
        pub fn change_set_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.change_set_id = Some(inp.into());
            self
        }
        pub fn set_change_set_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.change_set_id = inp;
            self
        }
        /// <p>Contains information about the module from which the resource was created, if the resource was created from a module included in the stack template.</p>
        pub fn module_info(mut self, inp: crate::model::ModuleInfo) -> Self {
            self.module_info = Some(inp);
            self
        }
        pub fn set_module_info(
            mut self,
            inp: std::option::Option<crate::model::ModuleInfo>,
        ) -> Self {
            self.module_info = inp;
            self
        }
        /// Consumes the builder and constructs a [`ResourceChange`](crate::model::ResourceChange)
        pub fn build(self) -> crate::model::ResourceChange {
            crate::model::ResourceChange {
                action: self.action,
                logical_resource_id: self.logical_resource_id,
                physical_resource_id: self.physical_resource_id,
                resource_type: self.resource_type,
                replacement: self.replacement,
                scope: self.scope,
                details: self.details,
                change_set_id: self.change_set_id,
                module_info: self.module_info,
            }
        }
    }
}
impl ResourceChange {
    /// Creates a new builder-style object to manufacture [`ResourceChange`](crate::model::ResourceChange)
    pub fn builder() -> crate::model::resource_change::Builder {
        crate::model::resource_change::Builder::default()
    }
}

/// <p>For a resource with <code>Modify</code> as the action, the
/// <code>ResourceChange</code> structure describes the changes AWS CloudFormation will make
/// to that resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceChangeDetail {
    /// <p>A <code>ResourceTargetDefinition</code> structure that describes the field that AWS
    /// CloudFormation will change and whether the resource will be recreated.</p>
    pub target: std::option::Option<crate::model::ResourceTargetDefinition>,
    /// <p>Indicates whether AWS CloudFormation can determine the target value, and whether the
    /// target value will change before you execute a change set.</p>
    /// <p>For <code>Static</code> evaluations, AWS CloudFormation can determine that the target
    /// value will change, and its value. For example, if you directly modify the
    /// <code>InstanceType</code> property of an EC2 instance, AWS CloudFormation knows that
    /// this property value will change, and its value, so this is a <code>Static</code>
    /// evaluation.</p>
    /// <p>For <code>Dynamic</code> evaluations, cannot determine the target value because it
    /// depends on the result of an intrinsic function, such as a <code>Ref</code> or
    /// <code>Fn::GetAtt</code> intrinsic function, when the stack is updated. For example, if
    /// your template includes a reference to a resource that is conditionally recreated, the value
    /// of the reference (the physical ID of the resource) might change, depending on if the
    /// resource is recreated. If the resource is recreated, it will have a new physical ID, so all
    /// references to that resource will also be updated.</p>
    pub evaluation: std::option::Option<crate::model::EvaluationType>,
    /// <p>The group to which the <code>CausingEntity</code> value belongs. There are five
    /// entity groups:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>ResourceReference</code> entities are <code>Ref</code> intrinsic functions that
    /// refer to resources in the template, such as <code>{ "Ref" : "MyEC2InstanceResource"
    /// }</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>ParameterReference</code> entities are <code>Ref</code> intrinsic functions
    /// that get template parameter values, such as <code>{ "Ref" : "MyPasswordParameter"
    /// }</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>ResourceAttribute</code> entities are <code>Fn::GetAtt</code> intrinsic
    /// functions that get resource attribute values, such as <code>{ "Fn::GetAtt" : [
    /// "MyEC2InstanceResource", "PublicDnsName" ] }</code>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>DirectModification</code> entities are changes that are made directly to the
    /// template.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Automatic</code> entities are <code>AWS::CloudFormation::Stack</code> resource
    /// types, which are also known as nested stacks. If you made no changes to the
    /// <code>AWS::CloudFormation::Stack</code> resource, AWS CloudFormation sets the
    /// <code>ChangeSource</code> to <code>Automatic</code> because the nested stack's
    /// template might have changed. Changes to a nested stack's template aren't visible to
    /// AWS CloudFormation until you run an update on the parent stack.</p>
    /// </li>
    /// </ul>
    pub change_source: std::option::Option<crate::model::ChangeSource>,
    /// <p>The identity of the entity that triggered this change. This entity is a member of the
    /// group that is specified by the <code>ChangeSource</code> field. For example, if you
    /// modified the value of the <code>KeyPairName</code> parameter, the
    /// <code>CausingEntity</code> is the name of the parameter
    /// (<code>KeyPairName</code>).</p>
    /// <p>If the <code>ChangeSource</code> value is <code>DirectModification</code>, no value
    /// is given for <code>CausingEntity</code>.</p>
    pub causing_entity: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceChangeDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceChangeDetail");
        formatter.field("target", &self.target);
        formatter.field("evaluation", &self.evaluation);
        formatter.field("change_source", &self.change_source);
        formatter.field("causing_entity", &self.causing_entity);
        formatter.finish()
    }
}
/// See [`ResourceChangeDetail`](crate::model::ResourceChangeDetail)
pub mod resource_change_detail {
    /// A builder for [`ResourceChangeDetail`](crate::model::ResourceChangeDetail)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) target: std::option::Option<crate::model::ResourceTargetDefinition>,
        pub(crate) evaluation: std::option::Option<crate::model::EvaluationType>,
        pub(crate) change_source: std::option::Option<crate::model::ChangeSource>,
        pub(crate) causing_entity: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A <code>ResourceTargetDefinition</code> structure that describes the field that AWS
        /// CloudFormation will change and whether the resource will be recreated.</p>
        pub fn target(mut self, inp: crate::model::ResourceTargetDefinition) -> Self {
            self.target = Some(inp);
            self
        }
        pub fn set_target(
            mut self,
            inp: std::option::Option<crate::model::ResourceTargetDefinition>,
        ) -> Self {
            self.target = inp;
            self
        }
        /// <p>Indicates whether AWS CloudFormation can determine the target value, and whether the
        /// target value will change before you execute a change set.</p>
        /// <p>For <code>Static</code> evaluations, AWS CloudFormation can determine that the target
        /// value will change, and its value. For example, if you directly modify the
        /// <code>InstanceType</code> property of an EC2 instance, AWS CloudFormation knows that
        /// this property value will change, and its value, so this is a <code>Static</code>
        /// evaluation.</p>
        /// <p>For <code>Dynamic</code> evaluations, cannot determine the target value because it
        /// depends on the result of an intrinsic function, such as a <code>Ref</code> or
        /// <code>Fn::GetAtt</code> intrinsic function, when the stack is updated. For example, if
        /// your template includes a reference to a resource that is conditionally recreated, the value
        /// of the reference (the physical ID of the resource) might change, depending on if the
        /// resource is recreated. If the resource is recreated, it will have a new physical ID, so all
        /// references to that resource will also be updated.</p>
        pub fn evaluation(mut self, inp: crate::model::EvaluationType) -> Self {
            self.evaluation = Some(inp);
            self
        }
        pub fn set_evaluation(
            mut self,
            inp: std::option::Option<crate::model::EvaluationType>,
        ) -> Self {
            self.evaluation = inp;
            self
        }
        /// <p>The group to which the <code>CausingEntity</code> value belongs. There are five
        /// entity groups:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>ResourceReference</code> entities are <code>Ref</code> intrinsic functions that
        /// refer to resources in the template, such as <code>{ "Ref" : "MyEC2InstanceResource"
        /// }</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ParameterReference</code> entities are <code>Ref</code> intrinsic functions
        /// that get template parameter values, such as <code>{ "Ref" : "MyPasswordParameter"
        /// }</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ResourceAttribute</code> entities are <code>Fn::GetAtt</code> intrinsic
        /// functions that get resource attribute values, such as <code>{ "Fn::GetAtt" : [
        /// "MyEC2InstanceResource", "PublicDnsName" ] }</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>DirectModification</code> entities are changes that are made directly to the
        /// template.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Automatic</code> entities are <code>AWS::CloudFormation::Stack</code> resource
        /// types, which are also known as nested stacks. If you made no changes to the
        /// <code>AWS::CloudFormation::Stack</code> resource, AWS CloudFormation sets the
        /// <code>ChangeSource</code> to <code>Automatic</code> because the nested stack's
        /// template might have changed. Changes to a nested stack's template aren't visible to
        /// AWS CloudFormation until you run an update on the parent stack.</p>
        /// </li>
        /// </ul>
        pub fn change_source(mut self, inp: crate::model::ChangeSource) -> Self {
            self.change_source = Some(inp);
            self
        }
        pub fn set_change_source(
            mut self,
            inp: std::option::Option<crate::model::ChangeSource>,
        ) -> Self {
            self.change_source = inp;
            self
        }
        /// <p>The identity of the entity that triggered this change. This entity is a member of the
        /// group that is specified by the <code>ChangeSource</code> field. For example, if you
        /// modified the value of the <code>KeyPairName</code> parameter, the
        /// <code>CausingEntity</code> is the name of the parameter
        /// (<code>KeyPairName</code>).</p>
        /// <p>If the <code>ChangeSource</code> value is <code>DirectModification</code>, no value
        /// is given for <code>CausingEntity</code>.</p>
        pub fn causing_entity(mut self, inp: impl Into<std::string::String>) -> Self {
            self.causing_entity = Some(inp.into());
            self
        }
        pub fn set_causing_entity(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.causing_entity = inp;
            self
        }
        /// Consumes the builder and constructs a [`ResourceChangeDetail`](crate::model::ResourceChangeDetail)
        pub fn build(self) -> crate::model::ResourceChangeDetail {
            crate::model::ResourceChangeDetail {
                target: self.target,
                evaluation: self.evaluation,
                change_source: self.change_source,
                causing_entity: self.causing_entity,
            }
        }
    }
}
impl ResourceChangeDetail {
    /// Creates a new builder-style object to manufacture [`ResourceChangeDetail`](crate::model::ResourceChangeDetail)
    pub fn builder() -> crate::model::resource_change_detail::Builder {
        crate::model::resource_change_detail::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ChangeSource {
    Automatic,
    DirectModification,
    ParameterReference,
    ResourceAttribute,
    ResourceReference,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ChangeSource {
    fn from(s: &str) -> Self {
        match s {
            "Automatic" => ChangeSource::Automatic,
            "DirectModification" => ChangeSource::DirectModification,
            "ParameterReference" => ChangeSource::ParameterReference,
            "ResourceAttribute" => ChangeSource::ResourceAttribute,
            "ResourceReference" => ChangeSource::ResourceReference,
            other => ChangeSource::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ChangeSource {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(ChangeSource::from(s))
    }
}
impl ChangeSource {
    pub fn as_str(&self) -> &str {
        match self {
            ChangeSource::Automatic => "Automatic",
            ChangeSource::DirectModification => "DirectModification",
            ChangeSource::ParameterReference => "ParameterReference",
            ChangeSource::ResourceAttribute => "ResourceAttribute",
            ChangeSource::ResourceReference => "ResourceReference",
            ChangeSource::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for ChangeSource {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for ChangeSource {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum EvaluationType {
    Dynamic,
    Static,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for EvaluationType {
    fn from(s: &str) -> Self {
        match s {
            "Dynamic" => EvaluationType::Dynamic,
            "Static" => EvaluationType::Static,
            other => EvaluationType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for EvaluationType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(EvaluationType::from(s))
    }
}
impl EvaluationType {
    pub fn as_str(&self) -> &str {
        match self {
            EvaluationType::Dynamic => "Dynamic",
            EvaluationType::Static => "Static",
            EvaluationType::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for EvaluationType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for EvaluationType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>The field that AWS CloudFormation will change, such as the name of a resource's
/// property, and whether the resource will be recreated.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceTargetDefinition {
    /// <p>Indicates which resource attribute is triggering this update, such as a change in the
    /// resource attribute's <code>Metadata</code>, <code>Properties</code>, or
    /// <code>Tags</code>.</p>
    pub attribute: std::option::Option<crate::model::ResourceAttribute>,
    /// <p>If the <code>Attribute</code> value is <code>Properties</code>, the name of the
    /// property. For all other attributes, the value is null.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>If the <code>Attribute</code> value is <code>Properties</code>, indicates whether a
    /// change to this property causes the resource to be recreated. The value can be
    /// <code>Never</code>, <code>Always</code>, or <code>Conditionally</code>. To determine the
    /// conditions for a <code>Conditionally</code> recreation, see the update behavior for that
    /// <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html">property</a> in the AWS CloudFormation User Guide.</p>
    pub requires_recreation: std::option::Option<crate::model::RequiresRecreation>,
}
impl std::fmt::Debug for ResourceTargetDefinition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceTargetDefinition");
        formatter.field("attribute", &self.attribute);
        formatter.field("name", &self.name);
        formatter.field("requires_recreation", &self.requires_recreation);
        formatter.finish()
    }
}
/// See [`ResourceTargetDefinition`](crate::model::ResourceTargetDefinition)
pub mod resource_target_definition {
    /// A builder for [`ResourceTargetDefinition`](crate::model::ResourceTargetDefinition)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attribute: std::option::Option<crate::model::ResourceAttribute>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) requires_recreation: std::option::Option<crate::model::RequiresRecreation>,
    }
    impl Builder {
        /// <p>Indicates which resource attribute is triggering this update, such as a change in the
        /// resource attribute's <code>Metadata</code>, <code>Properties</code>, or
        /// <code>Tags</code>.</p>
        pub fn attribute(mut self, inp: crate::model::ResourceAttribute) -> Self {
            self.attribute = Some(inp);
            self
        }
        pub fn set_attribute(
            mut self,
            inp: std::option::Option<crate::model::ResourceAttribute>,
        ) -> Self {
            self.attribute = inp;
            self
        }
        /// <p>If the <code>Attribute</code> value is <code>Properties</code>, the name of the
        /// property. For all other attributes, the value is null.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.name = Some(inp.into());
            self
        }
        pub fn set_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.name = inp;
            self
        }
        /// <p>If the <code>Attribute</code> value is <code>Properties</code>, indicates whether a
        /// change to this property causes the resource to be recreated. The value can be
        /// <code>Never</code>, <code>Always</code>, or <code>Conditionally</code>. To determine the
        /// conditions for a <code>Conditionally</code> recreation, see the update behavior for that
        /// <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html">property</a> in the AWS CloudFormation User Guide.</p>
        pub fn requires_recreation(mut self, inp: crate::model::RequiresRecreation) -> Self {
            self.requires_recreation = Some(inp);
            self
        }
        pub fn set_requires_recreation(
            mut self,
            inp: std::option::Option<crate::model::RequiresRecreation>,
        ) -> Self {
            self.requires_recreation = inp;
            self
        }
        /// Consumes the builder and constructs a [`ResourceTargetDefinition`](crate::model::ResourceTargetDefinition)
        pub fn build(self) -> crate::model::ResourceTargetDefinition {
            crate::model::ResourceTargetDefinition {
                attribute: self.attribute,
                name: self.name,
                requires_recreation: self.requires_recreation,
            }
        }
    }
}
impl ResourceTargetDefinition {
    /// Creates a new builder-style object to manufacture [`ResourceTargetDefinition`](crate::model::ResourceTargetDefinition)
    pub fn builder() -> crate::model::resource_target_definition::Builder {
        crate::model::resource_target_definition::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RequiresRecreation {
    Always,
    Conditionally,
    Never,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for RequiresRecreation {
    fn from(s: &str) -> Self {
        match s {
            "Always" => RequiresRecreation::Always,
            "Conditionally" => RequiresRecreation::Conditionally,
            "Never" => RequiresRecreation::Never,
            other => RequiresRecreation::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for RequiresRecreation {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(RequiresRecreation::from(s))
    }
}
impl RequiresRecreation {
    pub fn as_str(&self) -> &str {
        match self {
            RequiresRecreation::Always => "Always",
            RequiresRecreation::Conditionally => "Conditionally",
            RequiresRecreation::Never => "Never",
            RequiresRecreation::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for RequiresRecreation {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for RequiresRecreation {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ResourceAttribute {
    CreationPolicy,
    DeletionPolicy,
    Metadata,
    Properties,
    Tags,
    UpdatePolicy,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ResourceAttribute {
    fn from(s: &str) -> Self {
        match s {
            "CreationPolicy" => ResourceAttribute::CreationPolicy,
            "DeletionPolicy" => ResourceAttribute::DeletionPolicy,
            "Metadata" => ResourceAttribute::Metadata,
            "Properties" => ResourceAttribute::Properties,
            "Tags" => ResourceAttribute::Tags,
            "UpdatePolicy" => ResourceAttribute::UpdatePolicy,
            other => ResourceAttribute::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ResourceAttribute {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(ResourceAttribute::from(s))
    }
}
impl ResourceAttribute {
    pub fn as_str(&self) -> &str {
        match self {
            ResourceAttribute::CreationPolicy => "CreationPolicy",
            ResourceAttribute::DeletionPolicy => "DeletionPolicy",
            ResourceAttribute::Metadata => "Metadata",
            ResourceAttribute::Properties => "Properties",
            ResourceAttribute::Tags => "Tags",
            ResourceAttribute::UpdatePolicy => "UpdatePolicy",
            ResourceAttribute::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for ResourceAttribute {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for ResourceAttribute {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Replacement {
    Conditional,
    False,
    True,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for Replacement {
    fn from(s: &str) -> Self {
        match s {
            "Conditional" => Replacement::Conditional,
            "False" => Replacement::False,
            "True" => Replacement::True,
            other => Replacement::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for Replacement {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(Replacement::from(s))
    }
}
impl Replacement {
    pub fn as_str(&self) -> &str {
        match self {
            Replacement::Conditional => "Conditional",
            Replacement::False => "False",
            Replacement::True => "True",
            Replacement::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for Replacement {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for Replacement {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ChangeAction {
    Add,
    Dynamic,
    Import,
    Modify,
    Remove,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ChangeAction {
    fn from(s: &str) -> Self {
        match s {
            "Add" => ChangeAction::Add,
            "Dynamic" => ChangeAction::Dynamic,
            "Import" => ChangeAction::Import,
            "Modify" => ChangeAction::Modify,
            "Remove" => ChangeAction::Remove,
            other => ChangeAction::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ChangeAction {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(ChangeAction::from(s))
    }
}
impl ChangeAction {
    pub fn as_str(&self) -> &str {
        match self {
            ChangeAction::Add => "Add",
            ChangeAction::Dynamic => "Dynamic",
            ChangeAction::Import => "Import",
            ChangeAction::Modify => "Modify",
            ChangeAction::Remove => "Remove",
            ChangeAction::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for ChangeAction {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for ChangeAction {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ChangeType {
    Resource,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ChangeType {
    fn from(s: &str) -> Self {
        match s {
            "Resource" => ChangeType::Resource,
            other => ChangeType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ChangeType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(ChangeType::from(s))
    }
}
impl ChangeType {
    pub fn as_str(&self) -> &str {
        match self {
            ChangeType::Resource => "Resource",
            ChangeType::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for ChangeType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for ChangeType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>The AccountLimit data type. </p>
/// <p>CloudFormation has the following limits per account:</p>
/// <ul>
/// <li>
/// <p>Number of concurrent resources</p>
/// </li>
/// <li>
/// <p>Number of stacks</p>
/// </li>
/// <li>
/// <p>Number of stack outputs</p>
/// </li>
/// </ul>
/// <p>For more information about these account limits, and other CloudFormation limits, see
/// <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/cloudformation-limits.html">AWS CloudFormation
/// Limits</a> in the <i>AWS CloudFormation User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AccountLimit {
    /// <p>The name of the account limit.</p>
    /// <p>Values: <code>ConcurrentResourcesLimit</code> | <code>StackLimit</code> |
    /// <code>StackOutputsLimit</code>
    /// </p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The value that is associated with the account limit name.</p>
    pub value: std::option::Option<i32>,
}
impl std::fmt::Debug for AccountLimit {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AccountLimit");
        formatter.field("name", &self.name);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`AccountLimit`](crate::model::AccountLimit)
pub mod account_limit {
    /// A builder for [`AccountLimit`](crate::model::AccountLimit)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The name of the account limit.</p>
        /// <p>Values: <code>ConcurrentResourcesLimit</code> | <code>StackLimit</code> |
        /// <code>StackOutputsLimit</code>
        /// </p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.name = Some(inp.into());
            self
        }
        pub fn set_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.name = inp;
            self
        }
        /// <p>The value that is associated with the account limit name.</p>
        pub fn value(mut self, inp: i32) -> Self {
            self.value = Some(inp);
            self
        }
        pub fn set_value(mut self, inp: std::option::Option<i32>) -> Self {
            self.value = inp;
            self
        }
        /// Consumes the builder and constructs a [`AccountLimit`](crate::model::AccountLimit)
        pub fn build(self) -> crate::model::AccountLimit {
            crate::model::AccountLimit {
                name: self.name,
                value: self.value,
            }
        }
    }
}
impl AccountLimit {
    /// Creates a new builder-style object to manufacture [`AccountLimit`](crate::model::AccountLimit)
    pub fn builder() -> crate::model::account_limit::Builder {
        crate::model::account_limit::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum OnFailure {
    Delete,
    DoNothing,
    Rollback,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for OnFailure {
    fn from(s: &str) -> Self {
        match s {
            "DELETE" => OnFailure::Delete,
            "DO_NOTHING" => OnFailure::DoNothing,
            "ROLLBACK" => OnFailure::Rollback,
            other => OnFailure::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for OnFailure {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(OnFailure::from(s))
    }
}
impl OnFailure {
    pub fn as_str(&self) -> &str {
        match self {
            OnFailure::Delete => "DELETE",
            OnFailure::DoNothing => "DO_NOTHING",
            OnFailure::Rollback => "ROLLBACK",
            OnFailure::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for OnFailure {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for OnFailure {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}

/// <p>Describes the target resource of an import operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceToImport {
    /// <p>The type of resource to import into your stack, such as <code>AWS::S3::Bucket</code>. For a list of supported resource types, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/resource-import-supported-resources.html">Resources that support import operations</a> in the AWS CloudFormation User Guide.</p>
    pub resource_type: std::option::Option<std::string::String>,
    /// <p>The logical ID of the target resource as specified in the template.</p>
    pub logical_resource_id: std::option::Option<std::string::String>,
    /// <p>A key-value pair that identifies the target resource. The key is an identifier property
    /// (for example, <code>BucketName</code> for <code>AWS::S3::Bucket</code> resources) and the
    /// value is the actual property value (for example, <code>MyS3Bucket</code>).</p>
    pub resource_identifier:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl std::fmt::Debug for ResourceToImport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceToImport");
        formatter.field("resource_type", &self.resource_type);
        formatter.field("logical_resource_id", &self.logical_resource_id);
        formatter.field("resource_identifier", &self.resource_identifier);
        formatter.finish()
    }
}
/// See [`ResourceToImport`](crate::model::ResourceToImport)
pub mod resource_to_import {
    /// A builder for [`ResourceToImport`](crate::model::ResourceToImport)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_type: std::option::Option<std::string::String>,
        pub(crate) logical_resource_id: std::option::Option<std::string::String>,
        pub(crate) resource_identifier: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The type of resource to import into your stack, such as <code>AWS::S3::Bucket</code>. For a list of supported resource types, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/resource-import-supported-resources.html">Resources that support import operations</a> in the AWS CloudFormation User Guide.</p>
        pub fn resource_type(mut self, inp: impl Into<std::string::String>) -> Self {
            self.resource_type = Some(inp.into());
            self
        }
        pub fn set_resource_type(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.resource_type = inp;
            self
        }
        /// <p>The logical ID of the target resource as specified in the template.</p>
        pub fn logical_resource_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.logical_resource_id = Some(inp.into());
            self
        }
        pub fn set_logical_resource_id(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.logical_resource_id = inp;
            self
        }
        pub fn resource_identifier(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.resource_identifier.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.resource_identifier = Some(hash_map);
            self
        }
        pub fn set_resource_identifier(
            mut self,
            inp: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.resource_identifier = inp;
            self
        }
        /// Consumes the builder and constructs a [`ResourceToImport`](crate::model::ResourceToImport)
        pub fn build(self) -> crate::model::ResourceToImport {
            crate::model::ResourceToImport {
                resource_type: self.resource_type,
                logical_resource_id: self.logical_resource_id,
                resource_identifier: self.resource_identifier,
            }
        }
    }
}
impl ResourceToImport {
    /// Creates a new builder-style object to manufacture [`ResourceToImport`](crate::model::ResourceToImport)
    pub fn builder() -> crate::model::resource_to_import::Builder {
        crate::model::resource_to_import::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ChangeSetType {
    Create,
    Import,
    Update,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ChangeSetType {
    fn from(s: &str) -> Self {
        match s {
            "CREATE" => ChangeSetType::Create,
            "IMPORT" => ChangeSetType::Import,
            "UPDATE" => ChangeSetType::Update,
            other => ChangeSetType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ChangeSetType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(ChangeSetType::from(s))
    }
}
impl ChangeSetType {
    pub fn as_str(&self) -> &str {
        match self {
            ChangeSetType::Create => "CREATE",
            ChangeSetType::Import => "IMPORT",
            ChangeSetType::Update => "UPDATE",
            ChangeSetType::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for ChangeSetType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl<'de> serde::Deserialize<'de> for ChangeSetType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        Ok(Self::from(data))
    }
}
