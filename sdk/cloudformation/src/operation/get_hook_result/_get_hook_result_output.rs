// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct GetHookResultOutput {
    /// <p>The unique identifier of the Hook result.</p>
    pub hook_result_id: ::std::option::Option<::std::string::String>,
    /// <p>The specific point in the provisioning process where the Hook is invoked.</p>
    pub invocation_point: ::std::option::Option<crate::types::HookInvocationPoint>,
    /// <p>The failure mode of the invocation.</p>
    pub failure_mode: ::std::option::Option<crate::types::HookFailureMode>,
    /// <p>The name of the Hook that was invoked.</p>
    pub type_name: ::std::option::Option<::std::string::String>,
    /// <p>The original public type name of the Hook when an alias is used.</p>
    /// <p>For example, if you activate <code>AWS::Hooks::GuardHook</code> with alias <code>MyCompany::Custom::GuardHook</code>, then <code>TypeName</code> will be <code>MyCompany::Custom::GuardHook</code> and <code>OriginalTypeName</code> will be <code>AWS::Hooks::GuardHook</code>.</p>
    pub original_type_name: ::std::option::Option<::std::string::String>,
    /// <p>The version identifier of the Hook that was invoked.</p>
    pub type_version_id: ::std::option::Option<::std::string::String>,
    /// <p>The version identifier of the Hook configuration data that was used during invocation.</p>
    pub type_configuration_version_id: ::std::option::Option<::std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the Hook.</p>
    pub type_arn: ::std::option::Option<::std::string::String>,
    /// <p>The status of the Hook invocation. The following statuses are possible:</p>
    /// <ul>
    /// <li>
    /// <p><code>HOOK_IN_PROGRESS</code>: The Hook is currently running.</p></li>
    /// <li>
    /// <p><code>HOOK_COMPLETE_SUCCEEDED</code>: The Hook completed successfully.</p></li>
    /// <li>
    /// <p><code>HOOK_COMPLETE_FAILED</code>: The Hook completed but failed validation.</p></li>
    /// <li>
    /// <p><code>HOOK_FAILED</code>: The Hook encountered an error during execution.</p></li>
    /// </ul>
    pub status: ::std::option::Option<crate::types::HookStatus>,
    /// <p>A message that provides additional details about the Hook invocation status.</p>
    pub hook_status_reason: ::std::option::Option<::std::string::String>,
    /// <p>The timestamp when the Hook was invoked.</p>
    pub invoked_at: ::std::option::Option<::aws_smithy_types::DateTime>,
    /// <p>Information about the target of the Hook invocation.</p>
    pub target: ::std::option::Option<crate::types::HookTarget>,
    /// <p>A list of objects with additional information and guidance that can help you resolve a failed Hook invocation.</p>
    pub annotations: ::std::option::Option<::std::vec::Vec<crate::types::Annotation>>,
    _request_id: Option<String>,
}
impl GetHookResultOutput {
    /// <p>The unique identifier of the Hook result.</p>
    pub fn hook_result_id(&self) -> ::std::option::Option<&str> {
        self.hook_result_id.as_deref()
    }
    /// <p>The specific point in the provisioning process where the Hook is invoked.</p>
    pub fn invocation_point(&self) -> ::std::option::Option<&crate::types::HookInvocationPoint> {
        self.invocation_point.as_ref()
    }
    /// <p>The failure mode of the invocation.</p>
    pub fn failure_mode(&self) -> ::std::option::Option<&crate::types::HookFailureMode> {
        self.failure_mode.as_ref()
    }
    /// <p>The name of the Hook that was invoked.</p>
    pub fn type_name(&self) -> ::std::option::Option<&str> {
        self.type_name.as_deref()
    }
    /// <p>The original public type name of the Hook when an alias is used.</p>
    /// <p>For example, if you activate <code>AWS::Hooks::GuardHook</code> with alias <code>MyCompany::Custom::GuardHook</code>, then <code>TypeName</code> will be <code>MyCompany::Custom::GuardHook</code> and <code>OriginalTypeName</code> will be <code>AWS::Hooks::GuardHook</code>.</p>
    pub fn original_type_name(&self) -> ::std::option::Option<&str> {
        self.original_type_name.as_deref()
    }
    /// <p>The version identifier of the Hook that was invoked.</p>
    pub fn type_version_id(&self) -> ::std::option::Option<&str> {
        self.type_version_id.as_deref()
    }
    /// <p>The version identifier of the Hook configuration data that was used during invocation.</p>
    pub fn type_configuration_version_id(&self) -> ::std::option::Option<&str> {
        self.type_configuration_version_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the Hook.</p>
    pub fn type_arn(&self) -> ::std::option::Option<&str> {
        self.type_arn.as_deref()
    }
    /// <p>The status of the Hook invocation. The following statuses are possible:</p>
    /// <ul>
    /// <li>
    /// <p><code>HOOK_IN_PROGRESS</code>: The Hook is currently running.</p></li>
    /// <li>
    /// <p><code>HOOK_COMPLETE_SUCCEEDED</code>: The Hook completed successfully.</p></li>
    /// <li>
    /// <p><code>HOOK_COMPLETE_FAILED</code>: The Hook completed but failed validation.</p></li>
    /// <li>
    /// <p><code>HOOK_FAILED</code>: The Hook encountered an error during execution.</p></li>
    /// </ul>
    pub fn status(&self) -> ::std::option::Option<&crate::types::HookStatus> {
        self.status.as_ref()
    }
    /// <p>A message that provides additional details about the Hook invocation status.</p>
    pub fn hook_status_reason(&self) -> ::std::option::Option<&str> {
        self.hook_status_reason.as_deref()
    }
    /// <p>The timestamp when the Hook was invoked.</p>
    pub fn invoked_at(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.invoked_at.as_ref()
    }
    /// <p>Information about the target of the Hook invocation.</p>
    pub fn target(&self) -> ::std::option::Option<&crate::types::HookTarget> {
        self.target.as_ref()
    }
    /// <p>A list of objects with additional information and guidance that can help you resolve a failed Hook invocation.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.annotations.is_none()`.
    pub fn annotations(&self) -> &[crate::types::Annotation] {
        self.annotations.as_deref().unwrap_or_default()
    }
}
impl ::aws_types::request_id::RequestId for GetHookResultOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
impl GetHookResultOutput {
    /// Creates a new builder-style object to manufacture [`GetHookResultOutput`](crate::operation::get_hook_result::GetHookResultOutput).
    pub fn builder() -> crate::operation::get_hook_result::builders::GetHookResultOutputBuilder {
        crate::operation::get_hook_result::builders::GetHookResultOutputBuilder::default()
    }
}

/// A builder for [`GetHookResultOutput`](crate::operation::get_hook_result::GetHookResultOutput).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct GetHookResultOutputBuilder {
    pub(crate) hook_result_id: ::std::option::Option<::std::string::String>,
    pub(crate) invocation_point: ::std::option::Option<crate::types::HookInvocationPoint>,
    pub(crate) failure_mode: ::std::option::Option<crate::types::HookFailureMode>,
    pub(crate) type_name: ::std::option::Option<::std::string::String>,
    pub(crate) original_type_name: ::std::option::Option<::std::string::String>,
    pub(crate) type_version_id: ::std::option::Option<::std::string::String>,
    pub(crate) type_configuration_version_id: ::std::option::Option<::std::string::String>,
    pub(crate) type_arn: ::std::option::Option<::std::string::String>,
    pub(crate) status: ::std::option::Option<crate::types::HookStatus>,
    pub(crate) hook_status_reason: ::std::option::Option<::std::string::String>,
    pub(crate) invoked_at: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) target: ::std::option::Option<crate::types::HookTarget>,
    pub(crate) annotations: ::std::option::Option<::std::vec::Vec<crate::types::Annotation>>,
    _request_id: Option<String>,
}
impl GetHookResultOutputBuilder {
    /// <p>The unique identifier of the Hook result.</p>
    pub fn hook_result_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.hook_result_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The unique identifier of the Hook result.</p>
    pub fn set_hook_result_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.hook_result_id = input;
        self
    }
    /// <p>The unique identifier of the Hook result.</p>
    pub fn get_hook_result_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.hook_result_id
    }
    /// <p>The specific point in the provisioning process where the Hook is invoked.</p>
    pub fn invocation_point(mut self, input: crate::types::HookInvocationPoint) -> Self {
        self.invocation_point = ::std::option::Option::Some(input);
        self
    }
    /// <p>The specific point in the provisioning process where the Hook is invoked.</p>
    pub fn set_invocation_point(mut self, input: ::std::option::Option<crate::types::HookInvocationPoint>) -> Self {
        self.invocation_point = input;
        self
    }
    /// <p>The specific point in the provisioning process where the Hook is invoked.</p>
    pub fn get_invocation_point(&self) -> &::std::option::Option<crate::types::HookInvocationPoint> {
        &self.invocation_point
    }
    /// <p>The failure mode of the invocation.</p>
    pub fn failure_mode(mut self, input: crate::types::HookFailureMode) -> Self {
        self.failure_mode = ::std::option::Option::Some(input);
        self
    }
    /// <p>The failure mode of the invocation.</p>
    pub fn set_failure_mode(mut self, input: ::std::option::Option<crate::types::HookFailureMode>) -> Self {
        self.failure_mode = input;
        self
    }
    /// <p>The failure mode of the invocation.</p>
    pub fn get_failure_mode(&self) -> &::std::option::Option<crate::types::HookFailureMode> {
        &self.failure_mode
    }
    /// <p>The name of the Hook that was invoked.</p>
    pub fn type_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.type_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of the Hook that was invoked.</p>
    pub fn set_type_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.type_name = input;
        self
    }
    /// <p>The name of the Hook that was invoked.</p>
    pub fn get_type_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.type_name
    }
    /// <p>The original public type name of the Hook when an alias is used.</p>
    /// <p>For example, if you activate <code>AWS::Hooks::GuardHook</code> with alias <code>MyCompany::Custom::GuardHook</code>, then <code>TypeName</code> will be <code>MyCompany::Custom::GuardHook</code> and <code>OriginalTypeName</code> will be <code>AWS::Hooks::GuardHook</code>.</p>
    pub fn original_type_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.original_type_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The original public type name of the Hook when an alias is used.</p>
    /// <p>For example, if you activate <code>AWS::Hooks::GuardHook</code> with alias <code>MyCompany::Custom::GuardHook</code>, then <code>TypeName</code> will be <code>MyCompany::Custom::GuardHook</code> and <code>OriginalTypeName</code> will be <code>AWS::Hooks::GuardHook</code>.</p>
    pub fn set_original_type_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.original_type_name = input;
        self
    }
    /// <p>The original public type name of the Hook when an alias is used.</p>
    /// <p>For example, if you activate <code>AWS::Hooks::GuardHook</code> with alias <code>MyCompany::Custom::GuardHook</code>, then <code>TypeName</code> will be <code>MyCompany::Custom::GuardHook</code> and <code>OriginalTypeName</code> will be <code>AWS::Hooks::GuardHook</code>.</p>
    pub fn get_original_type_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.original_type_name
    }
    /// <p>The version identifier of the Hook that was invoked.</p>
    pub fn type_version_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.type_version_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The version identifier of the Hook that was invoked.</p>
    pub fn set_type_version_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.type_version_id = input;
        self
    }
    /// <p>The version identifier of the Hook that was invoked.</p>
    pub fn get_type_version_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.type_version_id
    }
    /// <p>The version identifier of the Hook configuration data that was used during invocation.</p>
    pub fn type_configuration_version_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.type_configuration_version_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The version identifier of the Hook configuration data that was used during invocation.</p>
    pub fn set_type_configuration_version_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.type_configuration_version_id = input;
        self
    }
    /// <p>The version identifier of the Hook configuration data that was used during invocation.</p>
    pub fn get_type_configuration_version_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.type_configuration_version_id
    }
    /// <p>The Amazon Resource Name (ARN) of the Hook.</p>
    pub fn type_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.type_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the Hook.</p>
    pub fn set_type_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.type_arn = input;
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the Hook.</p>
    pub fn get_type_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.type_arn
    }
    /// <p>The status of the Hook invocation. The following statuses are possible:</p>
    /// <ul>
    /// <li>
    /// <p><code>HOOK_IN_PROGRESS</code>: The Hook is currently running.</p></li>
    /// <li>
    /// <p><code>HOOK_COMPLETE_SUCCEEDED</code>: The Hook completed successfully.</p></li>
    /// <li>
    /// <p><code>HOOK_COMPLETE_FAILED</code>: The Hook completed but failed validation.</p></li>
    /// <li>
    /// <p><code>HOOK_FAILED</code>: The Hook encountered an error during execution.</p></li>
    /// </ul>
    pub fn status(mut self, input: crate::types::HookStatus) -> Self {
        self.status = ::std::option::Option::Some(input);
        self
    }
    /// <p>The status of the Hook invocation. The following statuses are possible:</p>
    /// <ul>
    /// <li>
    /// <p><code>HOOK_IN_PROGRESS</code>: The Hook is currently running.</p></li>
    /// <li>
    /// <p><code>HOOK_COMPLETE_SUCCEEDED</code>: The Hook completed successfully.</p></li>
    /// <li>
    /// <p><code>HOOK_COMPLETE_FAILED</code>: The Hook completed but failed validation.</p></li>
    /// <li>
    /// <p><code>HOOK_FAILED</code>: The Hook encountered an error during execution.</p></li>
    /// </ul>
    pub fn set_status(mut self, input: ::std::option::Option<crate::types::HookStatus>) -> Self {
        self.status = input;
        self
    }
    /// <p>The status of the Hook invocation. The following statuses are possible:</p>
    /// <ul>
    /// <li>
    /// <p><code>HOOK_IN_PROGRESS</code>: The Hook is currently running.</p></li>
    /// <li>
    /// <p><code>HOOK_COMPLETE_SUCCEEDED</code>: The Hook completed successfully.</p></li>
    /// <li>
    /// <p><code>HOOK_COMPLETE_FAILED</code>: The Hook completed but failed validation.</p></li>
    /// <li>
    /// <p><code>HOOK_FAILED</code>: The Hook encountered an error during execution.</p></li>
    /// </ul>
    pub fn get_status(&self) -> &::std::option::Option<crate::types::HookStatus> {
        &self.status
    }
    /// <p>A message that provides additional details about the Hook invocation status.</p>
    pub fn hook_status_reason(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.hook_status_reason = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>A message that provides additional details about the Hook invocation status.</p>
    pub fn set_hook_status_reason(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.hook_status_reason = input;
        self
    }
    /// <p>A message that provides additional details about the Hook invocation status.</p>
    pub fn get_hook_status_reason(&self) -> &::std::option::Option<::std::string::String> {
        &self.hook_status_reason
    }
    /// <p>The timestamp when the Hook was invoked.</p>
    pub fn invoked_at(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.invoked_at = ::std::option::Option::Some(input);
        self
    }
    /// <p>The timestamp when the Hook was invoked.</p>
    pub fn set_invoked_at(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.invoked_at = input;
        self
    }
    /// <p>The timestamp when the Hook was invoked.</p>
    pub fn get_invoked_at(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.invoked_at
    }
    /// <p>Information about the target of the Hook invocation.</p>
    pub fn target(mut self, input: crate::types::HookTarget) -> Self {
        self.target = ::std::option::Option::Some(input);
        self
    }
    /// <p>Information about the target of the Hook invocation.</p>
    pub fn set_target(mut self, input: ::std::option::Option<crate::types::HookTarget>) -> Self {
        self.target = input;
        self
    }
    /// <p>Information about the target of the Hook invocation.</p>
    pub fn get_target(&self) -> &::std::option::Option<crate::types::HookTarget> {
        &self.target
    }
    /// Appends an item to `annotations`.
    ///
    /// To override the contents of this collection use [`set_annotations`](Self::set_annotations).
    ///
    /// <p>A list of objects with additional information and guidance that can help you resolve a failed Hook invocation.</p>
    pub fn annotations(mut self, input: crate::types::Annotation) -> Self {
        let mut v = self.annotations.unwrap_or_default();
        v.push(input);
        self.annotations = ::std::option::Option::Some(v);
        self
    }
    /// <p>A list of objects with additional information and guidance that can help you resolve a failed Hook invocation.</p>
    pub fn set_annotations(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::Annotation>>) -> Self {
        self.annotations = input;
        self
    }
    /// <p>A list of objects with additional information and guidance that can help you resolve a failed Hook invocation.</p>
    pub fn get_annotations(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::Annotation>> {
        &self.annotations
    }
    pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
        self._request_id = Some(request_id.into());
        self
    }

    pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
        self._request_id = request_id;
        self
    }
    /// Consumes the builder and constructs a [`GetHookResultOutput`](crate::operation::get_hook_result::GetHookResultOutput).
    pub fn build(self) -> crate::operation::get_hook_result::GetHookResultOutput {
        crate::operation::get_hook_result::GetHookResultOutput {
            hook_result_id: self.hook_result_id,
            invocation_point: self.invocation_point,
            failure_mode: self.failure_mode,
            type_name: self.type_name,
            original_type_name: self.original_type_name,
            type_version_id: self.type_version_id,
            type_configuration_version_id: self.type_configuration_version_id,
            type_arn: self.type_arn,
            status: self.status,
            hook_status_reason: self.hook_status_reason,
            invoked_at: self.invoked_at,
            target: self.target,
            annotations: self.annotations,
            _request_id: self._request_id,
        }
    }
}
