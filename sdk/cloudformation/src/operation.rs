// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>Activates a public third-party extension, making it available for use in stack
/// templates. For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/registry-public.html">Using
/// public extensions</a> in the <i>CloudFormation User Guide</i>.</p>
/// <p>Once you have activated a public third-party extension in your account and region, use
/// <a href="AWSCloudFormation/latest/APIReference/API_SetTypeConfiguration.html">SetTypeConfiguration</a> to specify configuration properties for the extension. For
/// more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/registry-register.html#registry-set-configuration">Configuring extensions at the account level</a> in the <i>CloudFormation
/// User Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ActivateType {
    _private: (),
}
impl ActivateType {
    /// Creates a new builder-style object to manufacture [`ActivateTypeInput`](crate::input::ActivateTypeInput)
    pub fn builder() -> crate::input::activate_type_input::Builder {
        crate::input::activate_type_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ActivateType {
    type Output =
        std::result::Result<crate::output::ActivateTypeOutput, crate::error::ActivateTypeError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_activate_type_error(response)
        } else {
            crate::operation_ser::parse_activate_type_response(response)
        }
    }
}

/// <p>Returns configuration data for the specified CloudFormation extensions, from the
/// CloudFormation registry for the account and region.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/registry-register.html#registry-set-configuration">Configuring extensions at the account level</a> in the
/// <i>CloudFormation User Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct BatchDescribeTypeConfigurations {
    _private: (),
}
impl BatchDescribeTypeConfigurations {
    /// Creates a new builder-style object to manufacture [`BatchDescribeTypeConfigurationsInput`](crate::input::BatchDescribeTypeConfigurationsInput)
    pub fn builder() -> crate::input::batch_describe_type_configurations_input::Builder {
        crate::input::batch_describe_type_configurations_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for BatchDescribeTypeConfigurations {
    type Output = std::result::Result<
        crate::output::BatchDescribeTypeConfigurationsOutput,
        crate::error::BatchDescribeTypeConfigurationsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_batch_describe_type_configurations_error(response)
        } else {
            crate::operation_ser::parse_batch_describe_type_configurations_response(response)
        }
    }
}

/// <p>Cancels an update on the specified stack. If the call completes successfully, the
/// stack rolls back the update and reverts to the previous stack configuration.</p>
/// <note>
/// <p>You can cancel only stacks that are in the UPDATE_IN_PROGRESS state.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CancelUpdateStack {
    _private: (),
}
impl CancelUpdateStack {
    /// Creates a new builder-style object to manufacture [`CancelUpdateStackInput`](crate::input::CancelUpdateStackInput)
    pub fn builder() -> crate::input::cancel_update_stack_input::Builder {
        crate::input::cancel_update_stack_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CancelUpdateStack {
    type Output = std::result::Result<
        crate::output::CancelUpdateStackOutput,
        crate::error::CancelUpdateStackError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_cancel_update_stack_error(response)
        } else {
            crate::operation_ser::parse_cancel_update_stack_response(response)
        }
    }
}

/// <p>For a specified stack that is in the <code>UPDATE_ROLLBACK_FAILED</code> state,
/// continues rolling it back to the <code>UPDATE_ROLLBACK_COMPLETE</code> state. Depending on
/// the cause of the failure, you can manually <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/troubleshooting.html#troubleshooting-errors-update-rollback-failed"> fix the error</a> and continue the rollback. By continuing the rollback, you can
/// return your stack to a working state (the <code>UPDATE_ROLLBACK_COMPLETE</code> state), and
/// then try to update the stack again.</p>
/// <p>A stack goes into the <code>UPDATE_ROLLBACK_FAILED</code> state when
/// CloudFormation cannot roll back all changes after a failed stack update. For example, you
/// might have a stack that is rolling back to an old database instance that was deleted
/// outside of CloudFormation. Because CloudFormation doesn't know the database was
/// deleted, it assumes that the database instance still exists and attempts to roll back to
/// it, causing the update rollback to fail.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ContinueUpdateRollback {
    _private: (),
}
impl ContinueUpdateRollback {
    /// Creates a new builder-style object to manufacture [`ContinueUpdateRollbackInput`](crate::input::ContinueUpdateRollbackInput)
    pub fn builder() -> crate::input::continue_update_rollback_input::Builder {
        crate::input::continue_update_rollback_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ContinueUpdateRollback {
    type Output = std::result::Result<
        crate::output::ContinueUpdateRollbackOutput,
        crate::error::ContinueUpdateRollbackError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_continue_update_rollback_error(response)
        } else {
            crate::operation_ser::parse_continue_update_rollback_response(response)
        }
    }
}

/// <p>Creates a list of changes that will be applied to a stack so that you can review the
/// changes before executing them. You can create a change set for a stack that doesn't exist
/// or an existing stack. If you create a change set for a stack that doesn't exist, the change
/// set shows all of the resources that CloudFormation will create. If you create a change
/// set for an existing stack, CloudFormation compares the stack's information with the
/// information that you submit in the change set and lists the differences. Use change sets to
/// understand which resources CloudFormation will create or change, and how it will change
/// resources in an existing stack, before you create or update a stack.</p>
/// <p>To create a change set for a stack that doesn't exist, for the
/// <code>ChangeSetType</code> parameter, specify <code>CREATE</code>. To create a change
/// set for an existing stack, specify <code>UPDATE</code> for the <code>ChangeSetType</code>
/// parameter. To create a change set for an import operation, specify <code>IMPORT</code> for
/// the <code>ChangeSetType</code> parameter. After the <code>CreateChangeSet</code> call
/// successfully completes, CloudFormation starts creating the change set. To check the
/// status of the change set or to review it, use the <a>DescribeChangeSet</a>
/// action.</p>
/// <p>When you are satisfied with the changes the change set will make, execute the change
/// set by using the <a>ExecuteChangeSet</a> action. CloudFormation doesn't make
/// changes until you execute the change set.</p>
/// <p>To create a change set for the entire stack hierachy, set
/// <code>IncludeNestedStacks</code> to <code>True</code>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateChangeSet {
    _private: (),
}
impl CreateChangeSet {
    /// Creates a new builder-style object to manufacture [`CreateChangeSetInput`](crate::input::CreateChangeSetInput)
    pub fn builder() -> crate::input::create_change_set_input::Builder {
        crate::input::create_change_set_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateChangeSet {
    type Output = std::result::Result<
        crate::output::CreateChangeSetOutput,
        crate::error::CreateChangeSetError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_create_change_set_error(response)
        } else {
            crate::operation_ser::parse_create_change_set_response(response)
        }
    }
}

/// <p>Creates a stack as specified in the template. After the call completes successfully,
/// the stack creation starts. You can check the status of the stack via the <a>DescribeStacks</a> API.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateStack {
    _private: (),
}
impl CreateStack {
    /// Creates a new builder-style object to manufacture [`CreateStackInput`](crate::input::CreateStackInput)
    pub fn builder() -> crate::input::create_stack_input::Builder {
        crate::input::create_stack_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateStack {
    type Output =
        std::result::Result<crate::output::CreateStackOutput, crate::error::CreateStackError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_create_stack_error(response)
        } else {
            crate::operation_ser::parse_create_stack_response(response)
        }
    }
}

/// <p>Creates stack instances for the specified accounts, within the specified Regions. A
/// stack instance refers to a stack in a specific account and Region. You must specify at least one value for either <code>Accounts</code> or <code>DeploymentTargets</code>, and you must specify at least one value for <code>Regions</code>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateStackInstances {
    _private: (),
}
impl CreateStackInstances {
    /// Creates a new builder-style object to manufacture [`CreateStackInstancesInput`](crate::input::CreateStackInstancesInput)
    pub fn builder() -> crate::input::create_stack_instances_input::Builder {
        crate::input::create_stack_instances_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateStackInstances {
    type Output = std::result::Result<
        crate::output::CreateStackInstancesOutput,
        crate::error::CreateStackInstancesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_create_stack_instances_error(response)
        } else {
            crate::operation_ser::parse_create_stack_instances_response(response)
        }
    }
}

/// <p>Creates a stack set.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateStackSet {
    _private: (),
}
impl CreateStackSet {
    /// Creates a new builder-style object to manufacture [`CreateStackSetInput`](crate::input::CreateStackSetInput)
    pub fn builder() -> crate::input::create_stack_set_input::Builder {
        crate::input::create_stack_set_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateStackSet {
    type Output =
        std::result::Result<crate::output::CreateStackSetOutput, crate::error::CreateStackSetError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_create_stack_set_error(response)
        } else {
            crate::operation_ser::parse_create_stack_set_response(response)
        }
    }
}

/// <p>Deactivates a public extension that was previously activated in this account and
/// region.</p>
/// <p>Once deactivated, an extension cannot be used in any CloudFormation operation. This
/// includes stack update operations where the stack template includes the extension, even if
/// no updates are being made to the extension. In addition, deactivated extensions are not
/// automatically updated if a new version of the extension is released.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeactivateType {
    _private: (),
}
impl DeactivateType {
    /// Creates a new builder-style object to manufacture [`DeactivateTypeInput`](crate::input::DeactivateTypeInput)
    pub fn builder() -> crate::input::deactivate_type_input::Builder {
        crate::input::deactivate_type_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeactivateType {
    type Output =
        std::result::Result<crate::output::DeactivateTypeOutput, crate::error::DeactivateTypeError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_deactivate_type_error(response)
        } else {
            crate::operation_ser::parse_deactivate_type_response(response)
        }
    }
}

/// <p>Deletes the specified change set. Deleting change sets ensures that no one executes
/// the wrong change set.</p>
/// <p>If the call successfully completes, CloudFormation successfully deleted the
/// change set.</p>
/// <p>If <code>IncludeNestedStacks</code> specifies <code>True</code> during the creation of
/// the nested change set, then <code>DeleteChangeSet</code> will delete all change sets that
/// belong to the stacks hierarchy and will also delete all change sets for nested stacks with
/// the status of <code>REVIEW_IN_PROGRESS</code>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteChangeSet {
    _private: (),
}
impl DeleteChangeSet {
    /// Creates a new builder-style object to manufacture [`DeleteChangeSetInput`](crate::input::DeleteChangeSetInput)
    pub fn builder() -> crate::input::delete_change_set_input::Builder {
        crate::input::delete_change_set_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteChangeSet {
    type Output = std::result::Result<
        crate::output::DeleteChangeSetOutput,
        crate::error::DeleteChangeSetError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_delete_change_set_error(response)
        } else {
            crate::operation_ser::parse_delete_change_set_response(response)
        }
    }
}

/// <p>Deletes a specified stack. Once the call completes successfully, stack deletion
/// starts. Deleted stacks do not show up in the <a>DescribeStacks</a> API if the
/// deletion has been completed successfully.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteStack {
    _private: (),
}
impl DeleteStack {
    /// Creates a new builder-style object to manufacture [`DeleteStackInput`](crate::input::DeleteStackInput)
    pub fn builder() -> crate::input::delete_stack_input::Builder {
        crate::input::delete_stack_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteStack {
    type Output =
        std::result::Result<crate::output::DeleteStackOutput, crate::error::DeleteStackError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_delete_stack_error(response)
        } else {
            crate::operation_ser::parse_delete_stack_response(response)
        }
    }
}

/// <p>Deletes stack instances for the specified accounts, in the specified Regions.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteStackInstances {
    _private: (),
}
impl DeleteStackInstances {
    /// Creates a new builder-style object to manufacture [`DeleteStackInstancesInput`](crate::input::DeleteStackInstancesInput)
    pub fn builder() -> crate::input::delete_stack_instances_input::Builder {
        crate::input::delete_stack_instances_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteStackInstances {
    type Output = std::result::Result<
        crate::output::DeleteStackInstancesOutput,
        crate::error::DeleteStackInstancesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_delete_stack_instances_error(response)
        } else {
            crate::operation_ser::parse_delete_stack_instances_response(response)
        }
    }
}

/// <p>Deletes a stack set. Before you can delete a stack set, all of its member stack
/// instances must be deleted. For more information about how to do this, see <a>DeleteStackInstances</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteStackSet {
    _private: (),
}
impl DeleteStackSet {
    /// Creates a new builder-style object to manufacture [`DeleteStackSetInput`](crate::input::DeleteStackSetInput)
    pub fn builder() -> crate::input::delete_stack_set_input::Builder {
        crate::input::delete_stack_set_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteStackSet {
    type Output =
        std::result::Result<crate::output::DeleteStackSetOutput, crate::error::DeleteStackSetError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_delete_stack_set_error(response)
        } else {
            crate::operation_ser::parse_delete_stack_set_response(response)
        }
    }
}

/// <p>Marks an extension or extension version as <code>DEPRECATED</code> in the CloudFormation registry, removing it from active use. Deprecated extensions or
/// extension versions cannot be used in CloudFormation operations.</p>
/// <p>To deregister an entire extension, you must individually deregister all active versions
/// of that extension. If an extension has only a single active version, deregistering that
/// version results in the extension itself being deregistered and marked as deprecated in the
/// registry. </p>
/// <p>You cannot deregister the default version of an extension if there are other active
/// version of that extension. If you do deregister the default version of an extension, the
/// textensionype itself is deregistered as well and marked as deprecated. </p>
/// <p>To view the deprecation status of an extension or extension version, use <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/APIReference/API_DescribeType.html">DescribeType</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeregisterType {
    _private: (),
}
impl DeregisterType {
    /// Creates a new builder-style object to manufacture [`DeregisterTypeInput`](crate::input::DeregisterTypeInput)
    pub fn builder() -> crate::input::deregister_type_input::Builder {
        crate::input::deregister_type_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeregisterType {
    type Output =
        std::result::Result<crate::output::DeregisterTypeOutput, crate::error::DeregisterTypeError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_deregister_type_error(response)
        } else {
            crate::operation_ser::parse_deregister_type_response(response)
        }
    }
}

/// <p>Retrieves your account's CloudFormation limits, such as the maximum number of
/// stacks that you can create in your account. For more information about account limits, see
/// <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/cloudformation-limits.html">CloudFormation
/// Limits</a> in the <i>CloudFormation User Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeAccountLimits {
    _private: (),
}
impl DescribeAccountLimits {
    /// Creates a new builder-style object to manufacture [`DescribeAccountLimitsInput`](crate::input::DescribeAccountLimitsInput)
    pub fn builder() -> crate::input::describe_account_limits_input::Builder {
        crate::input::describe_account_limits_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeAccountLimits {
    type Output = std::result::Result<
        crate::output::DescribeAccountLimitsOutput,
        crate::error::DescribeAccountLimitsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_account_limits_error(response)
        } else {
            crate::operation_ser::parse_describe_account_limits_response(response)
        }
    }
}

/// <p>Returns the inputs for the change set and a list of changes that CloudFormation
/// will make if you execute the change set. For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-changesets.html">Updating Stacks Using Change Sets</a> in the CloudFormation User
/// Guide.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeChangeSet {
    _private: (),
}
impl DescribeChangeSet {
    /// Creates a new builder-style object to manufacture [`DescribeChangeSetInput`](crate::input::DescribeChangeSetInput)
    pub fn builder() -> crate::input::describe_change_set_input::Builder {
        crate::input::describe_change_set_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeChangeSet {
    type Output = std::result::Result<
        crate::output::DescribeChangeSetOutput,
        crate::error::DescribeChangeSetError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_change_set_error(response)
        } else {
            crate::operation_ser::parse_describe_change_set_response(response)
        }
    }
}

/// <p>Returns information about a CloudFormation extension publisher.</p>
/// <p>If you do not supply a <code>PublisherId</code>, and you have registered as an extension
/// publisher, <code>DescribePublisher</code> returns information about your own publisher
/// account. </p>
/// <p>For more information on registering as a publisher, see:</p>
/// <ul>
/// <li>
/// <p>
/// <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/APIReference/API_RegisterPublisher.html">RegisterPublisher</a>
/// </p>
/// </li>
/// <li>
/// <p>
/// <a href="https://docs.aws.amazon.com/cloudformation-cli/latest/userguide/publish-extension.html">Publishing
/// extensions to make them available for public use</a> in the
/// <i>CloudFormation CLI User Guide</i>
/// </p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribePublisher {
    _private: (),
}
impl DescribePublisher {
    /// Creates a new builder-style object to manufacture [`DescribePublisherInput`](crate::input::DescribePublisherInput)
    pub fn builder() -> crate::input::describe_publisher_input::Builder {
        crate::input::describe_publisher_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribePublisher {
    type Output = std::result::Result<
        crate::output::DescribePublisherOutput,
        crate::error::DescribePublisherError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_publisher_error(response)
        } else {
            crate::operation_ser::parse_describe_publisher_response(response)
        }
    }
}

/// <p>Returns information about a stack drift detection operation. A stack drift detection
/// operation detects whether a stack's actual configuration differs, or has
/// <i>drifted</i>, from it's expected configuration, as defined in the stack
/// template and any values specified as template parameters. A stack is considered to have
/// drifted if one or more of its resources have drifted. For more information on stack and
/// resource drift, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-stack-drift.html">Detecting
/// Unregulated Configuration Changes to Stacks and Resources</a>.</p>
/// <p>Use <a>DetectStackDrift</a> to initiate a stack drift detection operation.
/// <code>DetectStackDrift</code> returns a <code>StackDriftDetectionId</code> you can use
/// to monitor the progress of the operation using
/// <code>DescribeStackDriftDetectionStatus</code>. Once the drift detection operation has
/// completed, use <a>DescribeStackResourceDrifts</a> to return drift information
/// about the stack and its resources.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeStackDriftDetectionStatus {
    _private: (),
}
impl DescribeStackDriftDetectionStatus {
    /// Creates a new builder-style object to manufacture [`DescribeStackDriftDetectionStatusInput`](crate::input::DescribeStackDriftDetectionStatusInput)
    pub fn builder() -> crate::input::describe_stack_drift_detection_status_input::Builder {
        crate::input::describe_stack_drift_detection_status_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeStackDriftDetectionStatus {
    type Output = std::result::Result<
        crate::output::DescribeStackDriftDetectionStatusOutput,
        crate::error::DescribeStackDriftDetectionStatusError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_stack_drift_detection_status_error(response)
        } else {
            crate::operation_ser::parse_describe_stack_drift_detection_status_response(response)
        }
    }
}

/// <p>Returns all stack related events for a specified stack in reverse chronological
/// order. For more information about a stack's event history, go to <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/concept-stack.html">Stacks</a> in the CloudFormation User Guide.</p>
/// <note>
/// <p>You can list events for stacks that have failed to create or have been deleted by
/// specifying the unique stack identifier (stack ID).</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeStackEvents {
    _private: (),
}
impl DescribeStackEvents {
    /// Creates a new builder-style object to manufacture [`DescribeStackEventsInput`](crate::input::DescribeStackEventsInput)
    pub fn builder() -> crate::input::describe_stack_events_input::Builder {
        crate::input::describe_stack_events_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeStackEvents {
    type Output = std::result::Result<
        crate::output::DescribeStackEventsOutput,
        crate::error::DescribeStackEventsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_stack_events_error(response)
        } else {
            crate::operation_ser::parse_describe_stack_events_response(response)
        }
    }
}

/// <p>Returns the stack instance that's associated with the specified stack set, Amazon Web Services account, and Region.</p>
/// <p>For a list of stack instances that are associated with a specific stack set, use
/// <a>ListStackInstances</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeStackInstance {
    _private: (),
}
impl DescribeStackInstance {
    /// Creates a new builder-style object to manufacture [`DescribeStackInstanceInput`](crate::input::DescribeStackInstanceInput)
    pub fn builder() -> crate::input::describe_stack_instance_input::Builder {
        crate::input::describe_stack_instance_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeStackInstance {
    type Output = std::result::Result<
        crate::output::DescribeStackInstanceOutput,
        crate::error::DescribeStackInstanceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_stack_instance_error(response)
        } else {
            crate::operation_ser::parse_describe_stack_instance_response(response)
        }
    }
}

/// <p>Returns a description of the specified resource in the specified stack.</p>
/// <p>For deleted stacks, DescribeStackResource returns resource information for up to 90
/// days after the stack has been deleted.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeStackResource {
    _private: (),
}
impl DescribeStackResource {
    /// Creates a new builder-style object to manufacture [`DescribeStackResourceInput`](crate::input::DescribeStackResourceInput)
    pub fn builder() -> crate::input::describe_stack_resource_input::Builder {
        crate::input::describe_stack_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeStackResource {
    type Output = std::result::Result<
        crate::output::DescribeStackResourceOutput,
        crate::error::DescribeStackResourceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_stack_resource_error(response)
        } else {
            crate::operation_ser::parse_describe_stack_resource_response(response)
        }
    }
}

/// <p>Returns drift information for the resources that have been checked for drift in the
/// specified stack. This includes actual and expected configuration values for resources where
/// CloudFormation detects configuration drift.</p>
/// <p>For a given stack, there will be one <code>StackResourceDrift</code> for each stack
/// resource that has been checked for drift. Resources that haven't yet been checked for drift
/// are not included. Resources that do not currently support drift detection are not checked,
/// and so not included. For a list of resources that support drift detection, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-stack-drift-resource-list.html">Resources that Support Drift Detection</a>.</p>
/// <p>Use <a>DetectStackResourceDrift</a> to detect drift on individual
/// resources, or <a>DetectStackDrift</a> to detect drift on all supported resources
/// for a given stack.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeStackResourceDrifts {
    _private: (),
}
impl DescribeStackResourceDrifts {
    /// Creates a new builder-style object to manufacture [`DescribeStackResourceDriftsInput`](crate::input::DescribeStackResourceDriftsInput)
    pub fn builder() -> crate::input::describe_stack_resource_drifts_input::Builder {
        crate::input::describe_stack_resource_drifts_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeStackResourceDrifts {
    type Output = std::result::Result<
        crate::output::DescribeStackResourceDriftsOutput,
        crate::error::DescribeStackResourceDriftsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_stack_resource_drifts_error(response)
        } else {
            crate::operation_ser::parse_describe_stack_resource_drifts_response(response)
        }
    }
}

/// <p>Returns Amazon Web Services resource descriptions for running and deleted stacks. If
/// <code>StackName</code> is specified, all the associated resources that are part of the
/// stack are returned. If <code>PhysicalResourceId</code> is specified, the associated
/// resources of the stack that the resource belongs to are returned.</p>
/// <note>
/// <p>Only the first 100 resources will be returned. If your stack has more resources
/// than this, you should use <code>ListStackResources</code> instead.</p>
/// </note>
/// <p>For deleted stacks, <code>DescribeStackResources</code> returns resource information
/// for up to 90 days after the stack has been deleted.</p>
/// <p>You must specify either <code>StackName</code> or <code>PhysicalResourceId</code>,
/// but not both. In addition, you can specify <code>LogicalResourceId</code> to filter the
/// returned result. For more information about resources, the <code>LogicalResourceId</code>
/// and <code>PhysicalResourceId</code>, go to the <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/">CloudFormation User
/// Guide</a>.</p>
/// <note>
/// <p>A <code>ValidationError</code> is returned if you specify both
/// <code>StackName</code> and <code>PhysicalResourceId</code> in the same
/// request.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeStackResources {
    _private: (),
}
impl DescribeStackResources {
    /// Creates a new builder-style object to manufacture [`DescribeStackResourcesInput`](crate::input::DescribeStackResourcesInput)
    pub fn builder() -> crate::input::describe_stack_resources_input::Builder {
        crate::input::describe_stack_resources_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeStackResources {
    type Output = std::result::Result<
        crate::output::DescribeStackResourcesOutput,
        crate::error::DescribeStackResourcesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_stack_resources_error(response)
        } else {
            crate::operation_ser::parse_describe_stack_resources_response(response)
        }
    }
}

/// <p>Returns the description for the specified stack; if no stack name was specified, then
/// it returns the description for all the stacks created.</p>
/// <note>
/// <p>If the stack does not exist, an <code>ValidationError</code> is
/// returned.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeStacks {
    _private: (),
}
impl DescribeStacks {
    /// Creates a new builder-style object to manufacture [`DescribeStacksInput`](crate::input::DescribeStacksInput)
    pub fn builder() -> crate::input::describe_stacks_input::Builder {
        crate::input::describe_stacks_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeStacks {
    type Output =
        std::result::Result<crate::output::DescribeStacksOutput, crate::error::DescribeStacksError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_stacks_error(response)
        } else {
            crate::operation_ser::parse_describe_stacks_response(response)
        }
    }
}

/// <p>Returns the description of the specified stack set. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeStackSet {
    _private: (),
}
impl DescribeStackSet {
    /// Creates a new builder-style object to manufacture [`DescribeStackSetInput`](crate::input::DescribeStackSetInput)
    pub fn builder() -> crate::input::describe_stack_set_input::Builder {
        crate::input::describe_stack_set_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeStackSet {
    type Output = std::result::Result<
        crate::output::DescribeStackSetOutput,
        crate::error::DescribeStackSetError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_stack_set_error(response)
        } else {
            crate::operation_ser::parse_describe_stack_set_response(response)
        }
    }
}

/// <p>Returns the description of the specified stack set operation. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeStackSetOperation {
    _private: (),
}
impl DescribeStackSetOperation {
    /// Creates a new builder-style object to manufacture [`DescribeStackSetOperationInput`](crate::input::DescribeStackSetOperationInput)
    pub fn builder() -> crate::input::describe_stack_set_operation_input::Builder {
        crate::input::describe_stack_set_operation_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeStackSetOperation {
    type Output = std::result::Result<
        crate::output::DescribeStackSetOperationOutput,
        crate::error::DescribeStackSetOperationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_stack_set_operation_error(response)
        } else {
            crate::operation_ser::parse_describe_stack_set_operation_response(response)
        }
    }
}

/// <p>Returns detailed information about an extension that has been registered.</p>
/// <p>If you specify a <code>VersionId</code>, <code>DescribeType</code> returns information
/// about that specific extension version. Otherwise, it returns information about the default
/// extension version.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeType {
    _private: (),
}
impl DescribeType {
    /// Creates a new builder-style object to manufacture [`DescribeTypeInput`](crate::input::DescribeTypeInput)
    pub fn builder() -> crate::input::describe_type_input::Builder {
        crate::input::describe_type_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeType {
    type Output =
        std::result::Result<crate::output::DescribeTypeOutput, crate::error::DescribeTypeError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_type_error(response)
        } else {
            crate::operation_ser::parse_describe_type_response(response)
        }
    }
}

/// <p>Returns information about an extension's registration, including its current status and
/// type and version identifiers.</p>
/// <p>When you initiate a registration request using <code>
/// <a>RegisterType</a>
/// </code>, you can then use <code>
/// <a>DescribeTypeRegistration</a>
/// </code> to
/// monitor the progress of that registration request.</p>
/// <p>Once the registration request has completed, use <code>
/// <a>DescribeType</a>
/// </code> to return detailed information about an extension.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeTypeRegistration {
    _private: (),
}
impl DescribeTypeRegistration {
    /// Creates a new builder-style object to manufacture [`DescribeTypeRegistrationInput`](crate::input::DescribeTypeRegistrationInput)
    pub fn builder() -> crate::input::describe_type_registration_input::Builder {
        crate::input::describe_type_registration_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeTypeRegistration {
    type Output = std::result::Result<
        crate::output::DescribeTypeRegistrationOutput,
        crate::error::DescribeTypeRegistrationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_type_registration_error(response)
        } else {
            crate::operation_ser::parse_describe_type_registration_response(response)
        }
    }
}

/// <p>Detects whether a stack's actual configuration differs, or has
/// <i>drifted</i>, from it's expected configuration, as defined in the stack
/// template and any values specified as template parameters. For each resource in the stack
/// that supports drift detection, CloudFormation compares the actual configuration of the resource with
/// its expected template configuration. Only resource properties explicitly defined in the
/// stack template are checked for drift. A stack is considered to have drifted if one or more
/// of its resources differ from their expected template configurations. For more information,
/// see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-stack-drift.html">Detecting
/// Unregulated Configuration Changes to Stacks and Resources</a>.</p>
/// <p>Use <code>DetectStackDrift</code> to detect drift on all supported resources for a
/// given stack, or <a>DetectStackResourceDrift</a> to detect drift on individual
/// resources.</p>
/// <p>For a list of stack resources that currently support drift detection, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-stack-drift-resource-list.html">Resources that Support Drift Detection</a>.</p>
/// <p>
/// <code>DetectStackDrift</code> can take up to several minutes, depending on the number
/// of resources contained within the stack. Use <a>DescribeStackDriftDetectionStatus</a> to monitor the progress of a detect stack
/// drift operation. Once the drift detection operation has completed, use <a>DescribeStackResourceDrifts</a> to return drift information about the stack and
/// its resources.</p>
/// <p>When detecting drift on a stack, CloudFormation does not detect drift on any nested stacks
/// belonging to that stack. Perform <code>DetectStackDrift</code> directly on the nested stack
/// itself.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DetectStackDrift {
    _private: (),
}
impl DetectStackDrift {
    /// Creates a new builder-style object to manufacture [`DetectStackDriftInput`](crate::input::DetectStackDriftInput)
    pub fn builder() -> crate::input::detect_stack_drift_input::Builder {
        crate::input::detect_stack_drift_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DetectStackDrift {
    type Output = std::result::Result<
        crate::output::DetectStackDriftOutput,
        crate::error::DetectStackDriftError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_detect_stack_drift_error(response)
        } else {
            crate::operation_ser::parse_detect_stack_drift_response(response)
        }
    }
}

/// <p>Returns information about whether a resource's actual configuration differs, or has
/// <i>drifted</i>, from it's expected configuration, as defined in the stack
/// template and any values specified as template parameters. This information includes actual
/// and expected property values for resources in which CloudFormation detects drift. Only resource
/// properties explicitly defined in the stack template are checked for drift. For more
/// information about stack and resource drift, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-stack-drift.html">Detecting
/// Unregulated Configuration Changes to Stacks and Resources</a>.</p>
/// <p>Use <code>DetectStackResourceDrift</code> to detect drift on individual resources, or
/// <a>DetectStackDrift</a> to detect drift on all resources in a given stack
/// that support drift detection.</p>
/// <p>Resources that do not currently support drift detection cannot be checked. For a list
/// of resources that support drift detection, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-stack-drift-resource-list.html">Resources that Support Drift Detection</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DetectStackResourceDrift {
    _private: (),
}
impl DetectStackResourceDrift {
    /// Creates a new builder-style object to manufacture [`DetectStackResourceDriftInput`](crate::input::DetectStackResourceDriftInput)
    pub fn builder() -> crate::input::detect_stack_resource_drift_input::Builder {
        crate::input::detect_stack_resource_drift_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DetectStackResourceDrift {
    type Output = std::result::Result<
        crate::output::DetectStackResourceDriftOutput,
        crate::error::DetectStackResourceDriftError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_detect_stack_resource_drift_error(response)
        } else {
            crate::operation_ser::parse_detect_stack_resource_drift_response(response)
        }
    }
}

/// <p>Detect drift on a stack set. When CloudFormation performs drift detection on a
/// stack set, it performs drift detection on the stack associated with each stack instance in
/// the stack set. For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacksets-drift.html">How CloudFormation Performs Drift Detection on a Stack Set</a>.</p>
/// <p>
/// <code>DetectStackSetDrift</code> returns the <code>OperationId</code> of the stack set
/// drift detection operation. Use this operation id with <code>
/// <a>DescribeStackSetOperation</a>
/// </code> to monitor the progress of the drift
/// detection operation. The drift detection operation may take some time, depending on the
/// number of stack instances included in the stack set, as well as the number of resources
/// included in each stack.</p>
/// <p>Once the operation has completed, use the following actions to return drift
/// information:</p>
/// <ul>
/// <li>
/// <p>Use <code>
/// <a>DescribeStackSet</a>
/// </code> to return detailed information
/// about the stack set, including detailed information about the last
/// <i>completed</i> drift operation performed on the stack set.
/// (Information about drift operations that are in progress is not included.)</p>
/// </li>
/// <li>
/// <p>Use <code>
/// <a>ListStackInstances</a>
/// </code> to return a list of stack
/// instances belonging to the stack set, including the drift status and last drift time
/// checked of each instance.</p>
/// </li>
/// <li>
/// <p>Use <code>
/// <a>DescribeStackInstance</a>
/// </code> to return detailed
/// information about a specific stack instance, including its drift status and last
/// drift time checked.</p>
/// </li>
/// </ul>
/// <p>For more information on performing a drift detection operation on a stack set, see
/// <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacksets-drift.html">Detecting Unmanaged
/// Changes in Stack Sets</a>. </p>
/// <p>You can only run a single drift detection operation on a given stack set at one time. </p>
/// <p>To stop a drift detection stack set operation, use <code>
/// <a>StopStackSetOperation</a>
/// </code>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DetectStackSetDrift {
    _private: (),
}
impl DetectStackSetDrift {
    /// Creates a new builder-style object to manufacture [`DetectStackSetDriftInput`](crate::input::DetectStackSetDriftInput)
    pub fn builder() -> crate::input::detect_stack_set_drift_input::Builder {
        crate::input::detect_stack_set_drift_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DetectStackSetDrift {
    type Output = std::result::Result<
        crate::output::DetectStackSetDriftOutput,
        crate::error::DetectStackSetDriftError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_detect_stack_set_drift_error(response)
        } else {
            crate::operation_ser::parse_detect_stack_set_drift_response(response)
        }
    }
}

/// <p>Returns the estimated monthly cost of a template. The return value is an Amazon Web Services Simple
/// Monthly Calculator URL with a query string that describes the resources required to run the
/// template.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct EstimateTemplateCost {
    _private: (),
}
impl EstimateTemplateCost {
    /// Creates a new builder-style object to manufacture [`EstimateTemplateCostInput`](crate::input::EstimateTemplateCostInput)
    pub fn builder() -> crate::input::estimate_template_cost_input::Builder {
        crate::input::estimate_template_cost_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for EstimateTemplateCost {
    type Output = std::result::Result<
        crate::output::EstimateTemplateCostOutput,
        crate::error::EstimateTemplateCostError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_estimate_template_cost_error(response)
        } else {
            crate::operation_ser::parse_estimate_template_cost_response(response)
        }
    }
}

/// <p>Updates a stack using the input information that was provided when the specified
/// change set was created. After the call successfully completes, CloudFormation starts
/// updating the stack. Use the <a>DescribeStacks</a> action to view the status of
/// the update.</p>
/// <p>When you execute a change set, CloudFormation deletes all other change sets
/// associated with the stack because they aren't valid for the updated stack.</p>
/// <p>If a stack policy is associated with the stack, CloudFormation enforces the
/// policy during the update. You can't specify a temporary stack policy that overrides the
/// current policy.</p>
/// <p>To create a change set for the entire stack hierachy, <code>IncludeNestedStacks</code>
/// must have been set to <code>True</code>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ExecuteChangeSet {
    _private: (),
}
impl ExecuteChangeSet {
    /// Creates a new builder-style object to manufacture [`ExecuteChangeSetInput`](crate::input::ExecuteChangeSetInput)
    pub fn builder() -> crate::input::execute_change_set_input::Builder {
        crate::input::execute_change_set_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ExecuteChangeSet {
    type Output = std::result::Result<
        crate::output::ExecuteChangeSetOutput,
        crate::error::ExecuteChangeSetError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_execute_change_set_error(response)
        } else {
            crate::operation_ser::parse_execute_change_set_response(response)
        }
    }
}

/// <p>Returns the stack policy for a specified stack. If a stack doesn't have a policy, a
/// null value is returned.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetStackPolicy {
    _private: (),
}
impl GetStackPolicy {
    /// Creates a new builder-style object to manufacture [`GetStackPolicyInput`](crate::input::GetStackPolicyInput)
    pub fn builder() -> crate::input::get_stack_policy_input::Builder {
        crate::input::get_stack_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetStackPolicy {
    type Output =
        std::result::Result<crate::output::GetStackPolicyOutput, crate::error::GetStackPolicyError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_get_stack_policy_error(response)
        } else {
            crate::operation_ser::parse_get_stack_policy_response(response)
        }
    }
}

/// <p>Returns the template body for a specified stack. You can get the template for running
/// or deleted stacks.</p>
/// <p>For deleted stacks, GetTemplate returns the template for up to 90 days after the
/// stack has been deleted.</p>
/// <note>
/// <p>If the template does not exist, a <code>ValidationError</code> is returned.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetTemplate {
    _private: (),
}
impl GetTemplate {
    /// Creates a new builder-style object to manufacture [`GetTemplateInput`](crate::input::GetTemplateInput)
    pub fn builder() -> crate::input::get_template_input::Builder {
        crate::input::get_template_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetTemplate {
    type Output =
        std::result::Result<crate::output::GetTemplateOutput, crate::error::GetTemplateError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_get_template_error(response)
        } else {
            crate::operation_ser::parse_get_template_response(response)
        }
    }
}

/// <p>Returns information about a new or existing template. The
/// <code>GetTemplateSummary</code> action is useful for viewing parameter information, such
/// as default parameter values and parameter types, before you create or update a stack or
/// stack set.</p>
/// <p>You can use the <code>GetTemplateSummary</code> action when you submit a template, or
/// you can get template information for a stack set, or a running or deleted stack.</p>
/// <p>For deleted stacks, <code>GetTemplateSummary</code> returns the template information
/// for up to 90 days after the stack has been deleted. If the template does not exist, a
/// <code>ValidationError</code> is returned.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetTemplateSummary {
    _private: (),
}
impl GetTemplateSummary {
    /// Creates a new builder-style object to manufacture [`GetTemplateSummaryInput`](crate::input::GetTemplateSummaryInput)
    pub fn builder() -> crate::input::get_template_summary_input::Builder {
        crate::input::get_template_summary_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetTemplateSummary {
    type Output = std::result::Result<
        crate::output::GetTemplateSummaryOutput,
        crate::error::GetTemplateSummaryError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_get_template_summary_error(response)
        } else {
            crate::operation_ser::parse_get_template_summary_response(response)
        }
    }
}

/// <p>Import existing stacks into a new stack sets. Use the stack import operation to import
/// up to 10 stacks into a new stack set in the same account as the source stack or in a
/// different administrator account and Region, by specifying the stack ID of the stack you
/// intend to import.</p>
/// <note>
/// <p>
/// <code>ImportStacksToStackSet</code> is only supported by self-managed permissions.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ImportStacksToStackSet {
    _private: (),
}
impl ImportStacksToStackSet {
    /// Creates a new builder-style object to manufacture [`ImportStacksToStackSetInput`](crate::input::ImportStacksToStackSetInput)
    pub fn builder() -> crate::input::import_stacks_to_stack_set_input::Builder {
        crate::input::import_stacks_to_stack_set_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ImportStacksToStackSet {
    type Output = std::result::Result<
        crate::output::ImportStacksToStackSetOutput,
        crate::error::ImportStacksToStackSetError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_import_stacks_to_stack_set_error(response)
        } else {
            crate::operation_ser::parse_import_stacks_to_stack_set_response(response)
        }
    }
}

/// <p>Returns the ID and status of each active change set for a stack. For example,
/// CloudFormation lists change sets that are in the <code>CREATE_IN_PROGRESS</code> or
/// <code>CREATE_PENDING</code> state.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListChangeSets {
    _private: (),
}
impl ListChangeSets {
    /// Creates a new builder-style object to manufacture [`ListChangeSetsInput`](crate::input::ListChangeSetsInput)
    pub fn builder() -> crate::input::list_change_sets_input::Builder {
        crate::input::list_change_sets_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListChangeSets {
    type Output =
        std::result::Result<crate::output::ListChangeSetsOutput, crate::error::ListChangeSetsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_list_change_sets_error(response)
        } else {
            crate::operation_ser::parse_list_change_sets_response(response)
        }
    }
}

/// <p>Lists all exported output values in the account and Region in which you call this
/// action. Use this action to see the exported output values that you can import into other
/// stacks. To import values, use the <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference-importvalue.html">
/// <code>Fn::ImportValue</code>
/// </a> function.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-stack-exports.html">
/// CloudFormation Export Stack Output Values</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListExports {
    _private: (),
}
impl ListExports {
    /// Creates a new builder-style object to manufacture [`ListExportsInput`](crate::input::ListExportsInput)
    pub fn builder() -> crate::input::list_exports_input::Builder {
        crate::input::list_exports_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListExports {
    type Output =
        std::result::Result<crate::output::ListExportsOutput, crate::error::ListExportsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_list_exports_error(response)
        } else {
            crate::operation_ser::parse_list_exports_response(response)
        }
    }
}

/// <p>Lists all stacks that are importing an exported output value. To modify or remove an
/// exported output value, first use this action to see which stacks are using it. To see the
/// exported output values in your account, see <a>ListExports</a>.</p>
/// <p>For more information about importing an exported output value, see the <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference-importvalue.html">
/// <code>Fn::ImportValue</code>
/// </a> function.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListImports {
    _private: (),
}
impl ListImports {
    /// Creates a new builder-style object to manufacture [`ListImportsInput`](crate::input::ListImportsInput)
    pub fn builder() -> crate::input::list_imports_input::Builder {
        crate::input::list_imports_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListImports {
    type Output =
        std::result::Result<crate::output::ListImportsOutput, crate::error::ListImportsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_list_imports_error(response)
        } else {
            crate::operation_ser::parse_list_imports_response(response)
        }
    }
}

/// <p>Returns summary information about stack instances that are associated with the
/// specified stack set. You can filter for stack instances that are associated with a specific
/// Amazon Web Services account name or Region, or that have a specific status.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListStackInstances {
    _private: (),
}
impl ListStackInstances {
    /// Creates a new builder-style object to manufacture [`ListStackInstancesInput`](crate::input::ListStackInstancesInput)
    pub fn builder() -> crate::input::list_stack_instances_input::Builder {
        crate::input::list_stack_instances_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListStackInstances {
    type Output = std::result::Result<
        crate::output::ListStackInstancesOutput,
        crate::error::ListStackInstancesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_list_stack_instances_error(response)
        } else {
            crate::operation_ser::parse_list_stack_instances_response(response)
        }
    }
}

/// <p>Returns descriptions of all resources of the specified stack.</p>
/// <p>For deleted stacks, ListStackResources returns resource information for up to 90 days
/// after the stack has been deleted.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListStackResources {
    _private: (),
}
impl ListStackResources {
    /// Creates a new builder-style object to manufacture [`ListStackResourcesInput`](crate::input::ListStackResourcesInput)
    pub fn builder() -> crate::input::list_stack_resources_input::Builder {
        crate::input::list_stack_resources_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListStackResources {
    type Output = std::result::Result<
        crate::output::ListStackResourcesOutput,
        crate::error::ListStackResourcesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_list_stack_resources_error(response)
        } else {
            crate::operation_ser::parse_list_stack_resources_response(response)
        }
    }
}

/// <p>Returns the summary information for stacks whose status matches the specified
/// StackStatusFilter. Summary information for stacks that have been deleted is kept for 90
/// days after the stack is deleted. If no StackStatusFilter is specified, summary information
/// for all stacks is returned (including existing stacks and stacks that have been
/// deleted).</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListStacks {
    _private: (),
}
impl ListStacks {
    /// Creates a new builder-style object to manufacture [`ListStacksInput`](crate::input::ListStacksInput)
    pub fn builder() -> crate::input::list_stacks_input::Builder {
        crate::input::list_stacks_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListStacks {
    type Output =
        std::result::Result<crate::output::ListStacksOutput, crate::error::ListStacksError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_list_stacks_error(response)
        } else {
            crate::operation_ser::parse_list_stacks_response(response)
        }
    }
}

/// <p>Returns summary information about the results of a stack set operation. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListStackSetOperationResults {
    _private: (),
}
impl ListStackSetOperationResults {
    /// Creates a new builder-style object to manufacture [`ListStackSetOperationResultsInput`](crate::input::ListStackSetOperationResultsInput)
    pub fn builder() -> crate::input::list_stack_set_operation_results_input::Builder {
        crate::input::list_stack_set_operation_results_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListStackSetOperationResults {
    type Output = std::result::Result<
        crate::output::ListStackSetOperationResultsOutput,
        crate::error::ListStackSetOperationResultsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_list_stack_set_operation_results_error(response)
        } else {
            crate::operation_ser::parse_list_stack_set_operation_results_response(response)
        }
    }
}

/// <p>Returns summary information about operations performed on a stack set. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListStackSetOperations {
    _private: (),
}
impl ListStackSetOperations {
    /// Creates a new builder-style object to manufacture [`ListStackSetOperationsInput`](crate::input::ListStackSetOperationsInput)
    pub fn builder() -> crate::input::list_stack_set_operations_input::Builder {
        crate::input::list_stack_set_operations_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListStackSetOperations {
    type Output = std::result::Result<
        crate::output::ListStackSetOperationsOutput,
        crate::error::ListStackSetOperationsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_list_stack_set_operations_error(response)
        } else {
            crate::operation_ser::parse_list_stack_set_operations_response(response)
        }
    }
}

/// <p>Returns summary information about stack sets that are associated with the
/// user.</p>
/// <ul>
/// <li>
/// <p>[Self-managed permissions] If you set the <code>CallAs</code> parameter to
/// <code>SELF</code> while signed in to your Amazon Web Services account,
/// <code>ListStackSets</code> returns all self-managed stack sets in your Amazon Web Services account.</p>
/// </li>
/// <li>
/// <p>[Service-managed permissions] If you set the <code>CallAs</code> parameter to
/// <code>SELF</code> while signed in to the organization's management account,
/// <code>ListStackSets</code> returns all stack sets in the management
/// account.</p>
/// </li>
/// <li>
/// <p>[Service-managed permissions] If you set the <code>CallAs</code> parameter to
/// <code>DELEGATED_ADMIN</code> while signed in to your member account,
/// <code>ListStackSets</code> returns all stack sets with service-managed permissions
/// in the management account.</p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListStackSets {
    _private: (),
}
impl ListStackSets {
    /// Creates a new builder-style object to manufacture [`ListStackSetsInput`](crate::input::ListStackSetsInput)
    pub fn builder() -> crate::input::list_stack_sets_input::Builder {
        crate::input::list_stack_sets_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListStackSets {
    type Output =
        std::result::Result<crate::output::ListStackSetsOutput, crate::error::ListStackSetsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_list_stack_sets_error(response)
        } else {
            crate::operation_ser::parse_list_stack_sets_response(response)
        }
    }
}

/// <p>Returns a list of registration tokens for the specified extension(s).</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTypeRegistrations {
    _private: (),
}
impl ListTypeRegistrations {
    /// Creates a new builder-style object to manufacture [`ListTypeRegistrationsInput`](crate::input::ListTypeRegistrationsInput)
    pub fn builder() -> crate::input::list_type_registrations_input::Builder {
        crate::input::list_type_registrations_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTypeRegistrations {
    type Output = std::result::Result<
        crate::output::ListTypeRegistrationsOutput,
        crate::error::ListTypeRegistrationsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_list_type_registrations_error(response)
        } else {
            crate::operation_ser::parse_list_type_registrations_response(response)
        }
    }
}

/// <p>Returns summary information about extension that have been registered with CloudFormation.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTypes {
    _private: (),
}
impl ListTypes {
    /// Creates a new builder-style object to manufacture [`ListTypesInput`](crate::input::ListTypesInput)
    pub fn builder() -> crate::input::list_types_input::Builder {
        crate::input::list_types_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTypes {
    type Output = std::result::Result<crate::output::ListTypesOutput, crate::error::ListTypesError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_list_types_error(response)
        } else {
            crate::operation_ser::parse_list_types_response(response)
        }
    }
}

/// <p>Returns summary information about the versions of an extension.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTypeVersions {
    _private: (),
}
impl ListTypeVersions {
    /// Creates a new builder-style object to manufacture [`ListTypeVersionsInput`](crate::input::ListTypeVersionsInput)
    pub fn builder() -> crate::input::list_type_versions_input::Builder {
        crate::input::list_type_versions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTypeVersions {
    type Output = std::result::Result<
        crate::output::ListTypeVersionsOutput,
        crate::error::ListTypeVersionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_list_type_versions_error(response)
        } else {
            crate::operation_ser::parse_list_type_versions_response(response)
        }
    }
}

/// <p>Publishes the specified extension to the CloudFormation registry as a public extension
/// in this region. Public extensions are available for use by all CloudFormation users. For
/// more information on publishing extensions, see <a href="https://docs.aws.amazon.com/cloudformation-cli/latest/userguide/publish-extension.html">Publishing extensions to make them available for public use</a> in the
/// <i>CloudFormation CLI User Guide</i>.</p>
/// <p>To publish an extension, you must be registered as a publisher with CloudFormation. For
/// more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/APIReference/API_RegisterPublisher.html">RegisterPublisher</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PublishType {
    _private: (),
}
impl PublishType {
    /// Creates a new builder-style object to manufacture [`PublishTypeInput`](crate::input::PublishTypeInput)
    pub fn builder() -> crate::input::publish_type_input::Builder {
        crate::input::publish_type_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PublishType {
    type Output =
        std::result::Result<crate::output::PublishTypeOutput, crate::error::PublishTypeError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_publish_type_error(response)
        } else {
            crate::operation_ser::parse_publish_type_response(response)
        }
    }
}

/// <p>Reports progress of a resource handler to CloudFormation.</p>
/// <p>Reserved for use by the <a href="https://docs.aws.amazon.com/cloudformation-cli/latest/userguide/what-is-cloudformation-cli.html">CloudFormation CLI</a>. Do not use this API in your code.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct RecordHandlerProgress {
    _private: (),
}
impl RecordHandlerProgress {
    /// Creates a new builder-style object to manufacture [`RecordHandlerProgressInput`](crate::input::RecordHandlerProgressInput)
    pub fn builder() -> crate::input::record_handler_progress_input::Builder {
        crate::input::record_handler_progress_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for RecordHandlerProgress {
    type Output = std::result::Result<
        crate::output::RecordHandlerProgressOutput,
        crate::error::RecordHandlerProgressError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_record_handler_progress_error(response)
        } else {
            crate::operation_ser::parse_record_handler_progress_response(response)
        }
    }
}

/// <p>Registers your account as a publisher of public extensions in the CloudFormation
/// registry. Public extensions are available for use by all CloudFormation users. This
/// publisher ID applies to your account in all Amazon Web Services Regions.</p>
/// <p>For information on requirements for registering as a public extension publisher, see
/// <a href="https://docs.aws.amazon.com/cloudformation-cli/latest/userguide/publish-extension.html#publish-extension-prereqs">Registering your account to publish CloudFormation
/// extensions</a> in the <i>CloudFormation CLI User Guide</i>.</p>
/// <p></p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct RegisterPublisher {
    _private: (),
}
impl RegisterPublisher {
    /// Creates a new builder-style object to manufacture [`RegisterPublisherInput`](crate::input::RegisterPublisherInput)
    pub fn builder() -> crate::input::register_publisher_input::Builder {
        crate::input::register_publisher_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for RegisterPublisher {
    type Output = std::result::Result<
        crate::output::RegisterPublisherOutput,
        crate::error::RegisterPublisherError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_register_publisher_error(response)
        } else {
            crate::operation_ser::parse_register_publisher_response(response)
        }
    }
}

/// <p>Registers an extension with the CloudFormation service. Registering an
/// extension makes it available for use in CloudFormation templates in your Amazon Web Services account, and includes:</p>
/// <ul>
/// <li>
/// <p>Validating the extension schema</p>
/// </li>
/// <li>
/// <p>Determining which handlers, if any, have been specified for the extension</p>
/// </li>
/// <li>
/// <p>Making the extension available for use in your account</p>
/// </li>
/// </ul>
/// <p>For more information on how to develop extensions and ready them for registeration, see
/// <a href="https://docs.aws.amazon.com/cloudformation-cli/latest/userguide/resource-types.html">Creating Resource
/// Providers</a> in the <i>CloudFormation CLI User
/// Guide</i>.</p>
/// <p>You can have a maximum of 50 resource extension versions registered at a time. This
/// maximum is per account and per region. Use <a href="AWSCloudFormation/latest/APIReference/API_DeregisterType.html">DeregisterType</a> to deregister specific extension versions if necessary.</p>
/// <p>Once you have initiated a registration request using <code>
/// <a>RegisterType</a>
/// </code>, you can use <code>
/// <a>DescribeTypeRegistration</a>
/// </code> to
/// monitor the progress of the registration request.</p>
/// <p>Once you have registered a private extension in your account and region, use <a href="AWSCloudFormation/latest/APIReference/API_SetTypeConfiguration.html">SetTypeConfiguration</a> to specify configuration properties for the extension. For
/// more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/registry-register.html#registry-set-configuration">Configuring extensions at the account level</a> in the <i>CloudFormation
/// User Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct RegisterType {
    _private: (),
}
impl RegisterType {
    /// Creates a new builder-style object to manufacture [`RegisterTypeInput`](crate::input::RegisterTypeInput)
    pub fn builder() -> crate::input::register_type_input::Builder {
        crate::input::register_type_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for RegisterType {
    type Output =
        std::result::Result<crate::output::RegisterTypeOutput, crate::error::RegisterTypeError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_register_type_error(response)
        } else {
            crate::operation_ser::parse_register_type_response(response)
        }
    }
}

/// <p>When specifying <code>RollbackStack</code>, you preserve the state of previously provisioned resources when an operation fails. You can check the status of the stack through the <a>DescribeStacks</a> API.</p>
/// <p>Rolls back the specified stack to the last known stable state from <code>CREATE_FAILED</code> or <code>UPDATE_FAILED</code> stack statuses.</p>
/// <p>This operation will delete a stack if it doesn't contain a last known stable state. A last known stable state includes any status in a <code>*_COMPLETE</code>. This includes the following stack statuses.</p>
/// <ul>
/// <li>
/// <p>
/// <code>CREATE_COMPLETE</code>
/// </p>
/// </li>
/// <li>
/// <p>
/// <code>UPDATE_COMPLETE</code>
/// </p>
/// </li>
/// <li>
/// <p>
/// <code>UPDATE_ROLLBACK_COMPLETE</code>
/// </p>
/// </li>
/// <li>
/// <p>
/// <code>IMPORT_COMPLETE</code>
/// </p>
/// </li>
/// <li>
/// <p>
/// <code>IMPORT_ROLLBACK_COMPLETE</code>
/// </p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct RollbackStack {
    _private: (),
}
impl RollbackStack {
    /// Creates a new builder-style object to manufacture [`RollbackStackInput`](crate::input::RollbackStackInput)
    pub fn builder() -> crate::input::rollback_stack_input::Builder {
        crate::input::rollback_stack_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for RollbackStack {
    type Output =
        std::result::Result<crate::output::RollbackStackOutput, crate::error::RollbackStackError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_rollback_stack_error(response)
        } else {
            crate::operation_ser::parse_rollback_stack_response(response)
        }
    }
}

/// <p>Sets a stack policy for a specified stack.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct SetStackPolicy {
    _private: (),
}
impl SetStackPolicy {
    /// Creates a new builder-style object to manufacture [`SetStackPolicyInput`](crate::input::SetStackPolicyInput)
    pub fn builder() -> crate::input::set_stack_policy_input::Builder {
        crate::input::set_stack_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for SetStackPolicy {
    type Output =
        std::result::Result<crate::output::SetStackPolicyOutput, crate::error::SetStackPolicyError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_set_stack_policy_error(response)
        } else {
            crate::operation_ser::parse_set_stack_policy_response(response)
        }
    }
}

/// <p>Specifies the configuration data for a registered CloudFormation extension, in the given
/// account and region.</p>
/// <p>To view the current configuration data for an extension, refer to the
/// <code>ConfigurationSchema</code> element of <a href="AWSCloudFormation/latest/APIReference/API_DescribeType.html">DescribeType</a>.
/// For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/registry-register.html#registry-set-configuration">Configuring extensions at the account level</a> in the
/// <i>CloudFormation User Guide</i>.</p>
/// <important>
/// <p>It is strongly recommended that you use dynamic references to restrict sensitive
/// configuration definitions, such as third-party credentials. For more details on dynamic
/// references, see <a href="https://docs.aws.amazon.com/">Using dynamic references to specify
/// template values</a> in the <i>CloudFormation User
/// Guide</i>.</p>
/// </important>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct SetTypeConfiguration {
    _private: (),
}
impl SetTypeConfiguration {
    /// Creates a new builder-style object to manufacture [`SetTypeConfigurationInput`](crate::input::SetTypeConfigurationInput)
    pub fn builder() -> crate::input::set_type_configuration_input::Builder {
        crate::input::set_type_configuration_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for SetTypeConfiguration {
    type Output = std::result::Result<
        crate::output::SetTypeConfigurationOutput,
        crate::error::SetTypeConfigurationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_set_type_configuration_error(response)
        } else {
            crate::operation_ser::parse_set_type_configuration_response(response)
        }
    }
}

/// <p>Specify the default version of an extension. The default version of an extension will be
/// used in CloudFormation operations.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct SetTypeDefaultVersion {
    _private: (),
}
impl SetTypeDefaultVersion {
    /// Creates a new builder-style object to manufacture [`SetTypeDefaultVersionInput`](crate::input::SetTypeDefaultVersionInput)
    pub fn builder() -> crate::input::set_type_default_version_input::Builder {
        crate::input::set_type_default_version_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for SetTypeDefaultVersion {
    type Output = std::result::Result<
        crate::output::SetTypeDefaultVersionOutput,
        crate::error::SetTypeDefaultVersionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_set_type_default_version_error(response)
        } else {
            crate::operation_ser::parse_set_type_default_version_response(response)
        }
    }
}

/// <p>Sends a signal to the specified resource with a success or failure status. You can
/// use the SignalResource API in conjunction with a creation policy or update policy.
/// CloudFormation doesn't proceed with a stack creation or update until resources receive the
/// required number of signals or the timeout period is exceeded. The SignalResource API is
/// useful in cases where you want to send signals from anywhere other than an Amazon EC2
/// instance.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct SignalResource {
    _private: (),
}
impl SignalResource {
    /// Creates a new builder-style object to manufacture [`SignalResourceInput`](crate::input::SignalResourceInput)
    pub fn builder() -> crate::input::signal_resource_input::Builder {
        crate::input::signal_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for SignalResource {
    type Output =
        std::result::Result<crate::output::SignalResourceOutput, crate::error::SignalResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_signal_resource_error(response)
        } else {
            crate::operation_ser::parse_signal_resource_response(response)
        }
    }
}

/// <p>Stops an in-progress operation on a stack set and its associated stack instances. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StopStackSetOperation {
    _private: (),
}
impl StopStackSetOperation {
    /// Creates a new builder-style object to manufacture [`StopStackSetOperationInput`](crate::input::StopStackSetOperationInput)
    pub fn builder() -> crate::input::stop_stack_set_operation_input::Builder {
        crate::input::stop_stack_set_operation_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StopStackSetOperation {
    type Output = std::result::Result<
        crate::output::StopStackSetOperationOutput,
        crate::error::StopStackSetOperationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_stop_stack_set_operation_error(response)
        } else {
            crate::operation_ser::parse_stop_stack_set_operation_response(response)
        }
    }
}

/// <p>Tests a registered extension to make sure it meets all necessary requirements for being
/// published in the CloudFormation registry.</p>
/// <ul>
/// <li>
/// <p>For resource types, this includes passing all contracts tests defined for the
/// type.</p>
/// </li>
/// <li>
/// <p>For modules, this includes determining if the module's model meets all necessary
/// requirements.</p>
/// </li>
/// </ul>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/cloudformation-cli/latest/userguide/publish-extension.html#publish-extension-testing">Testing your public extension prior to publishing</a> in the
/// <i>CloudFormation CLI User Guide</i>.</p>
/// <p>If you do not specify a version, CloudFormation uses the default version of the
/// extension in your account and region for testing.</p>
/// <p>To perform testing, CloudFormation assumes the execution role specified when the type
/// was registered. For more information, see <a href="AWSCloudFormation/latest/APIReference/API_RegisterType.html">RegisterType</a>.</p>
/// <p>Once you've initiated testing on an extension using <code>TestType</code>, you can use
/// <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/APIReference/API_DescribeType.html">DescribeType</a> to monitor the current test status and test
/// status description for the extension.</p>
/// <p>An extension must have a test status of <code>PASSED</code> before it can be published.
/// For more information, see <a href="https://docs.aws.amazon.com/cloudformation-cli/latest/userguide/resource-type-publish.html">Publishing extensions to make them available for public use</a>
/// in the <i>CloudFormation CLI User Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct TestType {
    _private: (),
}
impl TestType {
    /// Creates a new builder-style object to manufacture [`TestTypeInput`](crate::input::TestTypeInput)
    pub fn builder() -> crate::input::test_type_input::Builder {
        crate::input::test_type_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for TestType {
    type Output = std::result::Result<crate::output::TestTypeOutput, crate::error::TestTypeError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_test_type_error(response)
        } else {
            crate::operation_ser::parse_test_type_response(response)
        }
    }
}

/// <p>Updates a stack as specified in the template. After the call completes successfully,
/// the stack update starts. You can check the status of the stack via the <a>DescribeStacks</a> action.</p>
/// <p>To get a copy of the template for an existing stack, you can use the <a>GetTemplate</a> action.</p>
/// <p>For more information about creating an update template, updating a stack, and
/// monitoring the progress of the update, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks.html">Updating a
/// Stack</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateStack {
    _private: (),
}
impl UpdateStack {
    /// Creates a new builder-style object to manufacture [`UpdateStackInput`](crate::input::UpdateStackInput)
    pub fn builder() -> crate::input::update_stack_input::Builder {
        crate::input::update_stack_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateStack {
    type Output =
        std::result::Result<crate::output::UpdateStackOutput, crate::error::UpdateStackError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_update_stack_error(response)
        } else {
            crate::operation_ser::parse_update_stack_response(response)
        }
    }
}

/// <p>Updates the parameter values for stack instances for the specified accounts, within
/// the specified Regions. A stack instance refers to a stack in a specific account and Region. </p>
/// <p>You can only update stack instances in Regions and accounts where they already exist;
/// to create additional stack instances, use <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/APIReference/API_CreateStackInstances.html">CreateStackInstances</a>. </p>
/// <p>During stack set updates, any parameters overridden for a stack instance are not
/// updated, but retain their overridden value.</p>
/// <p>You can only update the parameter <i>values</i> that are specified in
/// the stack set; to add or delete a parameter itself, use <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/APIReference/API_UpdateStackSet.html">UpdateStackSet</a> to update the stack set template. If you add a parameter to a
/// template, before you can override the parameter value specified in the stack set you must
/// first use <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/APIReference/API_UpdateStackSet.html">UpdateStackSet</a> to update all stack instances with the updated template and
/// parameter value specified in the stack set. Once a stack instance has been updated with the
/// new parameter, you can then override the parameter value using
/// <code>UpdateStackInstances</code>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateStackInstances {
    _private: (),
}
impl UpdateStackInstances {
    /// Creates a new builder-style object to manufacture [`UpdateStackInstancesInput`](crate::input::UpdateStackInstancesInput)
    pub fn builder() -> crate::input::update_stack_instances_input::Builder {
        crate::input::update_stack_instances_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateStackInstances {
    type Output = std::result::Result<
        crate::output::UpdateStackInstancesOutput,
        crate::error::UpdateStackInstancesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_update_stack_instances_error(response)
        } else {
            crate::operation_ser::parse_update_stack_instances_response(response)
        }
    }
}

/// <p>Updates the stack set, and associated stack instances in the specified accounts and
/// Regions.</p>
/// <p>Even if the stack set operation created by updating the stack set fails (completely
/// or partially, below or above a specified failure tolerance), the stack set is updated with
/// your changes. Subsequent <a>CreateStackInstances</a> calls on the specified
/// stack set use the updated stack set.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateStackSet {
    _private: (),
}
impl UpdateStackSet {
    /// Creates a new builder-style object to manufacture [`UpdateStackSetInput`](crate::input::UpdateStackSetInput)
    pub fn builder() -> crate::input::update_stack_set_input::Builder {
        crate::input::update_stack_set_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateStackSet {
    type Output =
        std::result::Result<crate::output::UpdateStackSetOutput, crate::error::UpdateStackSetError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_update_stack_set_error(response)
        } else {
            crate::operation_ser::parse_update_stack_set_response(response)
        }
    }
}

/// <p>Updates termination protection for the specified stack. If a user attempts to delete
/// a stack with termination protection enabled, the operation fails and the stack remains
/// unchanged. For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-protect-stacks.html">Protecting a
/// Stack From Being Deleted</a> in the <i>CloudFormation User Guide</i>.</p>
/// <p>For <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-nested-stacks.html">nested
/// stacks</a>, termination protection is set on the root stack and cannot be changed
/// directly on the nested stack.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateTerminationProtection {
    _private: (),
}
impl UpdateTerminationProtection {
    /// Creates a new builder-style object to manufacture [`UpdateTerminationProtectionInput`](crate::input::UpdateTerminationProtectionInput)
    pub fn builder() -> crate::input::update_termination_protection_input::Builder {
        crate::input::update_termination_protection_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateTerminationProtection {
    type Output = std::result::Result<
        crate::output::UpdateTerminationProtectionOutput,
        crate::error::UpdateTerminationProtectionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_update_termination_protection_error(response)
        } else {
            crate::operation_ser::parse_update_termination_protection_response(response)
        }
    }
}

/// <p>Validates a specified template. CloudFormation first checks if the template is
/// valid JSON. If it isn't, CloudFormation checks if the template is valid YAML. If both
/// these checks fail, CloudFormation returns a template validation error.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ValidateTemplate {
    _private: (),
}
impl ValidateTemplate {
    /// Creates a new builder-style object to manufacture [`ValidateTemplateInput`](crate::input::ValidateTemplateInput)
    pub fn builder() -> crate::input::validate_template_input::Builder {
        crate::input::validate_template_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ValidateTemplate {
    type Output = std::result::Result<
        crate::output::ValidateTemplateOutput,
        crate::error::ValidateTemplateError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_validate_template_error(response)
        } else {
            crate::operation_ser::parse_validate_template_response(response)
        }
    }
}
