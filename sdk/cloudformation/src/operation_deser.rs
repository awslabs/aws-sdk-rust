// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(clippy::unnecessary_wraps)]
pub fn parse_activate_type_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ActivateTypeOutput, crate::error::ActivateTypeError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ActivateTypeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ActivateTypeError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "CFNRegistryException" => {
            crate::error::ActivateTypeError::CfnRegistryException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::cfn_registry_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cfn_registry_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ActivateTypeError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TypeNotFoundException" => {
            crate::error::ActivateTypeError::TypeNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::type_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_type_not_found_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ActivateTypeError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::ActivateTypeError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_activate_type_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ActivateTypeOutput, crate::error::ActivateTypeError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::activate_type_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_activate_type(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ActivateTypeError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_batch_describe_type_configurations_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::BatchDescribeTypeConfigurationsOutput,
    crate::error::BatchDescribeTypeConfigurationsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::BatchDescribeTypeConfigurationsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::BatchDescribeTypeConfigurationsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "CFNRegistryException" => {
            crate::error::BatchDescribeTypeConfigurationsError::CfnRegistryException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::cfn_registry_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cfn_registry_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::BatchDescribeTypeConfigurationsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TypeConfigurationNotFoundException" => {
            crate::error::BatchDescribeTypeConfigurationsError::TypeConfigurationNotFoundException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::type_configuration_not_found_exception::Builder::default(
                            );
                        let _ = response;
                        output = crate::xml_deser::deser_structure_crate_error_type_configuration_not_found_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::BatchDescribeTypeConfigurationsError::unhandled)?;
                        let output = output.meta(generic);
                        output.build()
                    };
                    if tmp.message.is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            )
        }
        _ => crate::error::BatchDescribeTypeConfigurationsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_batch_describe_type_configurations_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::BatchDescribeTypeConfigurationsOutput,
    crate::error::BatchDescribeTypeConfigurationsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::batch_describe_type_configurations_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_batch_describe_type_configurations(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::BatchDescribeTypeConfigurationsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_cancel_update_stack_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CancelUpdateStackOutput, crate::error::CancelUpdateStackError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CancelUpdateStackError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CancelUpdateStackError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "TokenAlreadyExistsException" => {
            crate::error::CancelUpdateStackError::TokenAlreadyExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::token_already_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_token_already_exists_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CancelUpdateStackError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::CancelUpdateStackError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_cancel_update_stack_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CancelUpdateStackOutput, crate::error::CancelUpdateStackError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::cancel_update_stack_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_continue_update_rollback_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ContinueUpdateRollbackOutput,
    crate::error::ContinueUpdateRollbackError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ContinueUpdateRollbackError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ContinueUpdateRollbackError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "TokenAlreadyExistsException" => {
            crate::error::ContinueUpdateRollbackError::TokenAlreadyExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::token_already_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_token_already_exists_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ContinueUpdateRollbackError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::ContinueUpdateRollbackError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_continue_update_rollback_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ContinueUpdateRollbackOutput,
    crate::error::ContinueUpdateRollbackError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::continue_update_rollback_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_change_set_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateChangeSetOutput, crate::error::CreateChangeSetError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateChangeSetError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateChangeSetError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AlreadyExistsException" => {
            crate::error::CreateChangeSetError::AlreadyExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::already_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_already_exists_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateChangeSetError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InsufficientCapabilitiesException" => {
            crate::error::CreateChangeSetError::InsufficientCapabilitiesException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::insufficient_capabilities_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_insufficient_capabilities_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateChangeSetError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "LimitExceededException" => {
            crate::error::CreateChangeSetError::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateChangeSetError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::CreateChangeSetError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_change_set_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateChangeSetOutput, crate::error::CreateChangeSetError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_change_set_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_change_set(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateChangeSetError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_stack_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateStackOutput, crate::error::CreateStackError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateStackError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateStackError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AlreadyExistsException" => {
            crate::error::CreateStackError::AlreadyExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::already_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_already_exists_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateStackError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InsufficientCapabilitiesException" => {
            crate::error::CreateStackError::InsufficientCapabilitiesException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::insufficient_capabilities_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_insufficient_capabilities_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateStackError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "LimitExceededException" => {
            crate::error::CreateStackError::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateStackError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TokenAlreadyExistsException" => {
            crate::error::CreateStackError::TokenAlreadyExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::token_already_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_token_already_exists_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateStackError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::CreateStackError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_stack_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateStackOutput, crate::error::CreateStackError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_stack_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_stack(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateStackError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_stack_instances_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateStackInstancesOutput,
    crate::error::CreateStackInstancesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateStackInstancesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateStackInstancesError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidOperationException" => {
            crate::error::CreateStackInstancesError::InvalidOperationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_operation_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_operation_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateStackInstancesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "LimitExceededException" => {
            crate::error::CreateStackInstancesError::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateStackInstancesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "OperationIdAlreadyExistsException" => {
            crate::error::CreateStackInstancesError::OperationIdAlreadyExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::operation_id_already_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_operation_id_already_exists_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateStackInstancesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "OperationInProgressException" => {
            crate::error::CreateStackInstancesError::OperationInProgressException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::operation_in_progress_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_operation_in_progress_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateStackInstancesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "StackSetNotFoundException" => {
            crate::error::CreateStackInstancesError::StackSetNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::stack_set_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_stack_set_not_found_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateStackInstancesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "StaleRequestException" => {
            crate::error::CreateStackInstancesError::StaleRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::stale_request_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_stale_request_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateStackInstancesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::CreateStackInstancesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_stack_instances_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateStackInstancesOutput,
    crate::error::CreateStackInstancesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_stack_instances_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_stack_instances(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateStackInstancesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_stack_set_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateStackSetOutput, crate::error::CreateStackSetError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateStackSetError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateStackSetError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "CreatedButModifiedException" => {
            crate::error::CreateStackSetError::CreatedButModifiedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::created_but_modified_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_created_but_modified_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateStackSetError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "LimitExceededException" => {
            crate::error::CreateStackSetError::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateStackSetError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NameAlreadyExistsException" => {
            crate::error::CreateStackSetError::NameAlreadyExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::name_already_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_name_already_exists_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::CreateStackSetError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::CreateStackSetError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_stack_set_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateStackSetOutput, crate::error::CreateStackSetError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_stack_set_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_create_stack_set(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateStackSetError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deactivate_type_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeactivateTypeOutput, crate::error::DeactivateTypeError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeactivateTypeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeactivateTypeError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "CFNRegistryException" => {
            crate::error::DeactivateTypeError::CfnRegistryException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::cfn_registry_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cfn_registry_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeactivateTypeError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TypeNotFoundException" => {
            crate::error::DeactivateTypeError::TypeNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::type_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_type_not_found_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeactivateTypeError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DeactivateTypeError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deactivate_type_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeactivateTypeOutput, crate::error::DeactivateTypeError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::deactivate_type_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_change_set_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteChangeSetOutput, crate::error::DeleteChangeSetError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteChangeSetError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteChangeSetError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidChangeSetStatus" => {
            crate::error::DeleteChangeSetError::InvalidChangeSetStatusException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_change_set_status_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_change_set_status_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteChangeSetError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DeleteChangeSetError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_change_set_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteChangeSetOutput, crate::error::DeleteChangeSetError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_change_set_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_stack_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteStackOutput, crate::error::DeleteStackError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteStackError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteStackError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "TokenAlreadyExistsException" => {
            crate::error::DeleteStackError::TokenAlreadyExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::token_already_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_token_already_exists_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteStackError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DeleteStackError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_stack_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteStackOutput, crate::error::DeleteStackError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_stack_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_stack_instances_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteStackInstancesOutput,
    crate::error::DeleteStackInstancesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteStackInstancesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteStackInstancesError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidOperationException" => {
            crate::error::DeleteStackInstancesError::InvalidOperationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_operation_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_operation_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteStackInstancesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "OperationIdAlreadyExistsException" => {
            crate::error::DeleteStackInstancesError::OperationIdAlreadyExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::operation_id_already_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_operation_id_already_exists_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteStackInstancesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "OperationInProgressException" => {
            crate::error::DeleteStackInstancesError::OperationInProgressException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::operation_in_progress_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_operation_in_progress_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteStackInstancesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "StackSetNotFoundException" => {
            crate::error::DeleteStackInstancesError::StackSetNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::stack_set_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_stack_set_not_found_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteStackInstancesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "StaleRequestException" => {
            crate::error::DeleteStackInstancesError::StaleRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::stale_request_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_stale_request_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteStackInstancesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DeleteStackInstancesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_stack_instances_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteStackInstancesOutput,
    crate::error::DeleteStackInstancesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_stack_instances_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_delete_stack_instances(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteStackInstancesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_stack_set_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteStackSetOutput, crate::error::DeleteStackSetError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteStackSetError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteStackSetError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "OperationInProgressException" => {
            crate::error::DeleteStackSetError::OperationInProgressException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::operation_in_progress_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_operation_in_progress_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteStackSetError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "StackSetNotEmptyException" => {
            crate::error::DeleteStackSetError::StackSetNotEmptyException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::stack_set_not_empty_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_stack_set_not_empty_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeleteStackSetError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DeleteStackSetError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_stack_set_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteStackSetOutput, crate::error::DeleteStackSetError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_stack_set_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deregister_type_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeregisterTypeOutput, crate::error::DeregisterTypeError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeregisterTypeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeregisterTypeError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "CFNRegistryException" => {
            crate::error::DeregisterTypeError::CfnRegistryException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::cfn_registry_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cfn_registry_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeregisterTypeError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TypeNotFoundException" => {
            crate::error::DeregisterTypeError::TypeNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::type_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_type_not_found_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DeregisterTypeError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DeregisterTypeError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deregister_type_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeregisterTypeOutput, crate::error::DeregisterTypeError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::deregister_type_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_account_limits_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeAccountLimitsOutput,
    crate::error::DescribeAccountLimitsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeAccountLimitsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeAccountLimitsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_account_limits_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeAccountLimitsOutput,
    crate::error::DescribeAccountLimitsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_account_limits_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_account_limits(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeAccountLimitsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_change_set_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeChangeSetOutput, crate::error::DescribeChangeSetError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeChangeSetError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeChangeSetError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ChangeSetNotFound" => crate::error::DescribeChangeSetError::ChangeSetNotFoundException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::change_set_not_found_exception::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_change_set_not_found_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeChangeSetError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::DescribeChangeSetError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_change_set_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeChangeSetOutput, crate::error::DescribeChangeSetError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_change_set_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_change_set(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeChangeSetError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_change_set_hooks_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeChangeSetHooksOutput,
    crate::error::DescribeChangeSetHooksError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeChangeSetHooksError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeChangeSetHooksError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ChangeSetNotFound" => {
            crate::error::DescribeChangeSetHooksError::ChangeSetNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::change_set_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_change_set_not_found_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeChangeSetHooksError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DescribeChangeSetHooksError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_change_set_hooks_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeChangeSetHooksOutput,
    crate::error::DescribeChangeSetHooksError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_change_set_hooks_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_change_set_hooks(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeChangeSetHooksError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_publisher_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribePublisherOutput, crate::error::DescribePublisherError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribePublisherError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribePublisherError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "CFNRegistryException" => {
            crate::error::DescribePublisherError::CfnRegistryException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::cfn_registry_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cfn_registry_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribePublisherError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DescribePublisherError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_publisher_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribePublisherOutput, crate::error::DescribePublisherError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_publisher_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_publisher(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribePublisherError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_stack_drift_detection_status_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeStackDriftDetectionStatusOutput,
    crate::error::DescribeStackDriftDetectionStatusError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeStackDriftDetectionStatusError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeStackDriftDetectionStatusError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_stack_drift_detection_status_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeStackDriftDetectionStatusOutput,
    crate::error::DescribeStackDriftDetectionStatusError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_stack_drift_detection_status_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_stack_drift_detection_status(response.body().as_ref(), output).map_err(crate::error::DescribeStackDriftDetectionStatusError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_stack_events_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeStackEventsOutput,
    crate::error::DescribeStackEventsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeStackEventsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeStackEventsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_stack_events_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeStackEventsOutput,
    crate::error::DescribeStackEventsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_stack_events_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_stack_events(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeStackEventsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_stack_instance_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeStackInstanceOutput,
    crate::error::DescribeStackInstanceError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeStackInstanceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeStackInstanceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "StackInstanceNotFoundException" => {
            crate::error::DescribeStackInstanceError::StackInstanceNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::stack_instance_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_stack_instance_not_found_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeStackInstanceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "StackSetNotFoundException" => {
            crate::error::DescribeStackInstanceError::StackSetNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::stack_set_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_stack_set_not_found_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeStackInstanceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DescribeStackInstanceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_stack_instance_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeStackInstanceOutput,
    crate::error::DescribeStackInstanceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_stack_instance_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_stack_instance(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeStackInstanceError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_stack_resource_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeStackResourceOutput,
    crate::error::DescribeStackResourceError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeStackResourceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeStackResourceError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_stack_resource_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeStackResourceOutput,
    crate::error::DescribeStackResourceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_stack_resource_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_stack_resource(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeStackResourceError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_stack_resource_drifts_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeStackResourceDriftsOutput,
    crate::error::DescribeStackResourceDriftsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeStackResourceDriftsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeStackResourceDriftsError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_stack_resource_drifts_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeStackResourceDriftsOutput,
    crate::error::DescribeStackResourceDriftsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_stack_resource_drifts_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_stack_resource_drifts(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeStackResourceDriftsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_stack_resources_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeStackResourcesOutput,
    crate::error::DescribeStackResourcesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeStackResourcesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeStackResourcesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_stack_resources_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeStackResourcesOutput,
    crate::error::DescribeStackResourcesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_stack_resources_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_stack_resources(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeStackResourcesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_stacks_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeStacksOutput, crate::error::DescribeStacksError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeStacksError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DescribeStacksError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_stacks_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeStacksOutput, crate::error::DescribeStacksError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_stacks_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_stacks(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeStacksError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_stack_set_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeStackSetOutput, crate::error::DescribeStackSetError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeStackSetError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeStackSetError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "StackSetNotFoundException" => {
            crate::error::DescribeStackSetError::StackSetNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::stack_set_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_stack_set_not_found_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeStackSetError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DescribeStackSetError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_stack_set_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeStackSetOutput, crate::error::DescribeStackSetError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_stack_set_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_stack_set(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeStackSetError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_stack_set_operation_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeStackSetOperationOutput,
    crate::error::DescribeStackSetOperationError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeStackSetOperationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeStackSetOperationError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "OperationNotFoundException" => {
            crate::error::DescribeStackSetOperationError::OperationNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::operation_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_operation_not_found_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeStackSetOperationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "StackSetNotFoundException" => {
            crate::error::DescribeStackSetOperationError::StackSetNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::stack_set_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_stack_set_not_found_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeStackSetOperationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DescribeStackSetOperationError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_stack_set_operation_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeStackSetOperationOutput,
    crate::error::DescribeStackSetOperationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_stack_set_operation_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_stack_set_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeStackSetOperationError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_type_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeTypeOutput, crate::error::DescribeTypeError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeTypeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeTypeError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "CFNRegistryException" => {
            crate::error::DescribeTypeError::CfnRegistryException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::cfn_registry_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cfn_registry_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeTypeError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TypeNotFoundException" => {
            crate::error::DescribeTypeError::TypeNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::type_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_type_not_found_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeTypeError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DescribeTypeError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_type_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeTypeOutput, crate::error::DescribeTypeError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_type_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_type(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeTypeError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_type_registration_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeTypeRegistrationOutput,
    crate::error::DescribeTypeRegistrationError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeTypeRegistrationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeTypeRegistrationError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "CFNRegistryException" => {
            crate::error::DescribeTypeRegistrationError::CfnRegistryException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::cfn_registry_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cfn_registry_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DescribeTypeRegistrationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DescribeTypeRegistrationError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_type_registration_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeTypeRegistrationOutput,
    crate::error::DescribeTypeRegistrationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_type_registration_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_describe_type_registration(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeTypeRegistrationError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_detect_stack_drift_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DetectStackDriftOutput, crate::error::DetectStackDriftError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DetectStackDriftError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DetectStackDriftError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_detect_stack_drift_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DetectStackDriftOutput, crate::error::DetectStackDriftError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::detect_stack_drift_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_detect_stack_drift(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DetectStackDriftError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_detect_stack_resource_drift_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DetectStackResourceDriftOutput,
    crate::error::DetectStackResourceDriftError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DetectStackResourceDriftError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::DetectStackResourceDriftError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_detect_stack_resource_drift_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DetectStackResourceDriftOutput,
    crate::error::DetectStackResourceDriftError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::detect_stack_resource_drift_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_detect_stack_resource_drift(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DetectStackResourceDriftError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_detect_stack_set_drift_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DetectStackSetDriftOutput,
    crate::error::DetectStackSetDriftError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DetectStackSetDriftError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DetectStackSetDriftError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidOperationException" => {
            crate::error::DetectStackSetDriftError::InvalidOperationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_operation_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_operation_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DetectStackSetDriftError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "OperationInProgressException" => {
            crate::error::DetectStackSetDriftError::OperationInProgressException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::operation_in_progress_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_operation_in_progress_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DetectStackSetDriftError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "StackSetNotFoundException" => {
            crate::error::DetectStackSetDriftError::StackSetNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::stack_set_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_stack_set_not_found_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::DetectStackSetDriftError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DetectStackSetDriftError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_detect_stack_set_drift_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DetectStackSetDriftOutput,
    crate::error::DetectStackSetDriftError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::detect_stack_set_drift_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_detect_stack_set_drift(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DetectStackSetDriftError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_estimate_template_cost_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::EstimateTemplateCostOutput,
    crate::error::EstimateTemplateCostError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::EstimateTemplateCostError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::EstimateTemplateCostError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_estimate_template_cost_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::EstimateTemplateCostOutput,
    crate::error::EstimateTemplateCostError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::estimate_template_cost_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_estimate_template_cost(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::EstimateTemplateCostError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_execute_change_set_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ExecuteChangeSetOutput, crate::error::ExecuteChangeSetError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ExecuteChangeSetError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ExecuteChangeSetError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ChangeSetNotFound" => crate::error::ExecuteChangeSetError::ChangeSetNotFoundException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::change_set_not_found_exception::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_change_set_not_found_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ExecuteChangeSetError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InsufficientCapabilitiesException" => {
            crate::error::ExecuteChangeSetError::InsufficientCapabilitiesException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::insufficient_capabilities_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_insufficient_capabilities_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ExecuteChangeSetError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidChangeSetStatus" => {
            crate::error::ExecuteChangeSetError::InvalidChangeSetStatusException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_change_set_status_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_change_set_status_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ExecuteChangeSetError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TokenAlreadyExistsException" => {
            crate::error::ExecuteChangeSetError::TokenAlreadyExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::token_already_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_token_already_exists_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ExecuteChangeSetError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::ExecuteChangeSetError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_execute_change_set_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ExecuteChangeSetOutput, crate::error::ExecuteChangeSetError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::execute_change_set_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_stack_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetStackPolicyOutput, crate::error::GetStackPolicyError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetStackPolicyError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::GetStackPolicyError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_stack_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetStackPolicyOutput, crate::error::GetStackPolicyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_stack_policy_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_stack_policy(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetStackPolicyError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_template_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetTemplateOutput, crate::error::GetTemplateError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetTemplateError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetTemplateError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ChangeSetNotFound" => crate::error::GetTemplateError::ChangeSetNotFoundException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::change_set_not_found_exception::Builder::default();
                let _ = response;
                output = crate::xml_deser::deser_structure_crate_error_change_set_not_found_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::GetTemplateError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::GetTemplateError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_template_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetTemplateOutput, crate::error::GetTemplateError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_template_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_template(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetTemplateError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_template_summary_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetTemplateSummaryOutput,
    crate::error::GetTemplateSummaryError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetTemplateSummaryError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetTemplateSummaryError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "StackSetNotFoundException" => {
            crate::error::GetTemplateSummaryError::StackSetNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::stack_set_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_stack_set_not_found_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::GetTemplateSummaryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::GetTemplateSummaryError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_template_summary_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetTemplateSummaryOutput,
    crate::error::GetTemplateSummaryError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_template_summary_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_get_template_summary(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetTemplateSummaryError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_import_stacks_to_stack_set_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ImportStacksToStackSetOutput,
    crate::error::ImportStacksToStackSetError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ImportStacksToStackSetError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ImportStacksToStackSetError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidOperationException" => {
            crate::error::ImportStacksToStackSetError::InvalidOperationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_operation_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_operation_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ImportStacksToStackSetError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "LimitExceededException" => {
            crate::error::ImportStacksToStackSetError::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_limit_exceeded_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ImportStacksToStackSetError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "OperationIdAlreadyExistsException" => {
            crate::error::ImportStacksToStackSetError::OperationIdAlreadyExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::operation_id_already_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_operation_id_already_exists_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ImportStacksToStackSetError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "OperationInProgressException" => {
            crate::error::ImportStacksToStackSetError::OperationInProgressException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::operation_in_progress_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_operation_in_progress_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ImportStacksToStackSetError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "StackNotFoundException" => {
            crate::error::ImportStacksToStackSetError::StackNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::stack_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_stack_not_found_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ImportStacksToStackSetError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "StackSetNotFoundException" => {
            crate::error::ImportStacksToStackSetError::StackSetNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::stack_set_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_stack_set_not_found_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ImportStacksToStackSetError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "StaleRequestException" => {
            crate::error::ImportStacksToStackSetError::StaleRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::stale_request_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_stale_request_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ImportStacksToStackSetError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::ImportStacksToStackSetError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_import_stacks_to_stack_set_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ImportStacksToStackSetOutput,
    crate::error::ImportStacksToStackSetError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::import_stacks_to_stack_set_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_import_stacks_to_stack_set(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ImportStacksToStackSetError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_change_sets_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListChangeSetsOutput, crate::error::ListChangeSetsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListChangeSetsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ListChangeSetsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_change_sets_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListChangeSetsOutput, crate::error::ListChangeSetsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_change_sets_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_change_sets(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListChangeSetsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_exports_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListExportsOutput, crate::error::ListExportsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListExportsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ListExportsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_exports_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListExportsOutput, crate::error::ListExportsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_exports_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_exports(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListExportsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_imports_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListImportsOutput, crate::error::ListImportsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListImportsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ListImportsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_imports_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListImportsOutput, crate::error::ListImportsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_imports_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_imports(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListImportsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_stack_instances_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListStackInstancesOutput,
    crate::error::ListStackInstancesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListStackInstancesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListStackInstancesError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "StackSetNotFoundException" => {
            crate::error::ListStackInstancesError::StackSetNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::stack_set_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_stack_set_not_found_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ListStackInstancesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::ListStackInstancesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_stack_instances_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListStackInstancesOutput,
    crate::error::ListStackInstancesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_stack_instances_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_stack_instances(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListStackInstancesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_stack_resources_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListStackResourcesOutput,
    crate::error::ListStackResourcesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListStackResourcesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ListStackResourcesError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_stack_resources_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListStackResourcesOutput,
    crate::error::ListStackResourcesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_stack_resources_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_stack_resources(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListStackResourcesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_stacks_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListStacksOutput, crate::error::ListStacksError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListStacksError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ListStacksError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_stacks_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListStacksOutput, crate::error::ListStacksError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_stacks_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_stacks(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListStacksError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_stack_set_operation_results_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListStackSetOperationResultsOutput,
    crate::error::ListStackSetOperationResultsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListStackSetOperationResultsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListStackSetOperationResultsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "OperationNotFoundException" => {
            crate::error::ListStackSetOperationResultsError::OperationNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::operation_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_operation_not_found_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ListStackSetOperationResultsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "StackSetNotFoundException" => {
            crate::error::ListStackSetOperationResultsError::StackSetNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::stack_set_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_stack_set_not_found_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ListStackSetOperationResultsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::ListStackSetOperationResultsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_stack_set_operation_results_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListStackSetOperationResultsOutput,
    crate::error::ListStackSetOperationResultsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_stack_set_operation_results_output::Builder::default();
        let _ = response;
        output =
            crate::xml_deser::deser_operation_crate_operation_list_stack_set_operation_results(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::ListStackSetOperationResultsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_stack_set_operations_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListStackSetOperationsOutput,
    crate::error::ListStackSetOperationsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListStackSetOperationsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListStackSetOperationsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "StackSetNotFoundException" => {
            crate::error::ListStackSetOperationsError::StackSetNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::stack_set_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_stack_set_not_found_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ListStackSetOperationsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::ListStackSetOperationsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_stack_set_operations_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListStackSetOperationsOutput,
    crate::error::ListStackSetOperationsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_stack_set_operations_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_stack_set_operations(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListStackSetOperationsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_stack_sets_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListStackSetsOutput, crate::error::ListStackSetsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListStackSetsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ListStackSetsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_stack_sets_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListStackSetsOutput, crate::error::ListStackSetsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_stack_sets_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_stack_sets(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListStackSetsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_type_registrations_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListTypeRegistrationsOutput,
    crate::error::ListTypeRegistrationsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListTypeRegistrationsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListTypeRegistrationsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "CFNRegistryException" => {
            crate::error::ListTypeRegistrationsError::CfnRegistryException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::cfn_registry_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cfn_registry_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ListTypeRegistrationsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::ListTypeRegistrationsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_type_registrations_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListTypeRegistrationsOutput,
    crate::error::ListTypeRegistrationsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_type_registrations_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_type_registrations(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListTypeRegistrationsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_types_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListTypesOutput, crate::error::ListTypesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListTypesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListTypesError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "CFNRegistryException" => {
            crate::error::ListTypesError::CfnRegistryException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::cfn_registry_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cfn_registry_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ListTypesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::ListTypesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_types_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListTypesOutput, crate::error::ListTypesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_types_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_types(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListTypesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_type_versions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListTypeVersionsOutput, crate::error::ListTypeVersionsError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListTypeVersionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListTypeVersionsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "CFNRegistryException" => {
            crate::error::ListTypeVersionsError::CfnRegistryException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::cfn_registry_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cfn_registry_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::ListTypeVersionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::ListTypeVersionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_type_versions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListTypeVersionsOutput, crate::error::ListTypeVersionsError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_type_versions_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_list_type_versions(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListTypeVersionsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_publish_type_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::PublishTypeOutput, crate::error::PublishTypeError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::PublishTypeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::PublishTypeError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "CFNRegistryException" => {
            crate::error::PublishTypeError::CfnRegistryException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::cfn_registry_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cfn_registry_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::PublishTypeError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TypeNotFoundException" => {
            crate::error::PublishTypeError::TypeNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::type_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_type_not_found_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::PublishTypeError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::PublishTypeError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_publish_type_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::PublishTypeOutput, crate::error::PublishTypeError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::publish_type_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_publish_type(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::PublishTypeError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_record_handler_progress_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RecordHandlerProgressOutput,
    crate::error::RecordHandlerProgressError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::RecordHandlerProgressError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::RecordHandlerProgressError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidStateTransition" => {
            crate::error::RecordHandlerProgressError::InvalidStateTransitionException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_state_transition_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_state_transition_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::RecordHandlerProgressError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ConditionalCheckFailed" => {
            crate::error::RecordHandlerProgressError::OperationStatusCheckFailedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::operation_status_check_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_operation_status_check_failed_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::RecordHandlerProgressError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::RecordHandlerProgressError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_record_handler_progress_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RecordHandlerProgressOutput,
    crate::error::RecordHandlerProgressError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::record_handler_progress_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_register_publisher_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::RegisterPublisherOutput, crate::error::RegisterPublisherError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::RegisterPublisherError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::RegisterPublisherError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "CFNRegistryException" => {
            crate::error::RegisterPublisherError::CfnRegistryException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::cfn_registry_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cfn_registry_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::RegisterPublisherError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::RegisterPublisherError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_register_publisher_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::RegisterPublisherOutput, crate::error::RegisterPublisherError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::register_publisher_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_register_publisher(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::RegisterPublisherError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_register_type_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::RegisterTypeOutput, crate::error::RegisterTypeError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::RegisterTypeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::RegisterTypeError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "CFNRegistryException" => {
            crate::error::RegisterTypeError::CfnRegistryException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::cfn_registry_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cfn_registry_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::RegisterTypeError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::RegisterTypeError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_register_type_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::RegisterTypeOutput, crate::error::RegisterTypeError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::register_type_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_register_type(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::RegisterTypeError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_rollback_stack_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::RollbackStackOutput, crate::error::RollbackStackError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::RollbackStackError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::RollbackStackError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "TokenAlreadyExistsException" => {
            crate::error::RollbackStackError::TokenAlreadyExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::token_already_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_token_already_exists_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::RollbackStackError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::RollbackStackError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_rollback_stack_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::RollbackStackOutput, crate::error::RollbackStackError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::rollback_stack_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_rollback_stack(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::RollbackStackError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_set_stack_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::SetStackPolicyOutput, crate::error::SetStackPolicyError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::SetStackPolicyError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::SetStackPolicyError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_set_stack_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::SetStackPolicyOutput, crate::error::SetStackPolicyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::set_stack_policy_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_set_type_configuration_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::SetTypeConfigurationOutput,
    crate::error::SetTypeConfigurationError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::SetTypeConfigurationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::SetTypeConfigurationError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "CFNRegistryException" => {
            crate::error::SetTypeConfigurationError::CfnRegistryException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::cfn_registry_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cfn_registry_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::SetTypeConfigurationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TypeNotFoundException" => {
            crate::error::SetTypeConfigurationError::TypeNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::type_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_type_not_found_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::SetTypeConfigurationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::SetTypeConfigurationError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_set_type_configuration_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::SetTypeConfigurationOutput,
    crate::error::SetTypeConfigurationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::set_type_configuration_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_set_type_configuration(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::SetTypeConfigurationError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_set_type_default_version_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::SetTypeDefaultVersionOutput,
    crate::error::SetTypeDefaultVersionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::SetTypeDefaultVersionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::SetTypeDefaultVersionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "CFNRegistryException" => {
            crate::error::SetTypeDefaultVersionError::CfnRegistryException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::cfn_registry_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cfn_registry_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::SetTypeDefaultVersionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TypeNotFoundException" => {
            crate::error::SetTypeDefaultVersionError::TypeNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::type_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_type_not_found_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::SetTypeDefaultVersionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::SetTypeDefaultVersionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_set_type_default_version_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::SetTypeDefaultVersionOutput,
    crate::error::SetTypeDefaultVersionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::set_type_default_version_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_signal_resource_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::SignalResourceOutput, crate::error::SignalResourceError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::SignalResourceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::SignalResourceError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_signal_resource_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::SignalResourceOutput, crate::error::SignalResourceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::signal_resource_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_stack_set_operation_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StopStackSetOperationOutput,
    crate::error::StopStackSetOperationError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::StopStackSetOperationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::StopStackSetOperationError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidOperationException" => {
            crate::error::StopStackSetOperationError::InvalidOperationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_operation_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_operation_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::StopStackSetOperationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "OperationNotFoundException" => {
            crate::error::StopStackSetOperationError::OperationNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::operation_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_operation_not_found_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::StopStackSetOperationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "StackSetNotFoundException" => {
            crate::error::StopStackSetOperationError::StackSetNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::stack_set_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_stack_set_not_found_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::StopStackSetOperationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::StopStackSetOperationError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_stack_set_operation_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StopStackSetOperationOutput,
    crate::error::StopStackSetOperationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::stop_stack_set_operation_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_test_type_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::TestTypeOutput, crate::error::TestTypeError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::TestTypeError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::TestTypeError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "CFNRegistryException" => {
            crate::error::TestTypeError::CfnRegistryException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::cfn_registry_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_cfn_registry_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::TestTypeError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TypeNotFoundException" => {
            crate::error::TestTypeError::TypeNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::type_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_type_not_found_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::TestTypeError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::TestTypeError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_test_type_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::TestTypeOutput, crate::error::TestTypeError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::test_type_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_test_type(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::TestTypeError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_stack_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateStackOutput, crate::error::UpdateStackError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateStackError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateStackError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InsufficientCapabilitiesException" => {
            crate::error::UpdateStackError::InsufficientCapabilitiesException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::insufficient_capabilities_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_insufficient_capabilities_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateStackError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TokenAlreadyExistsException" => {
            crate::error::UpdateStackError::TokenAlreadyExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::token_already_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_token_already_exists_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateStackError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::UpdateStackError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_stack_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateStackOutput, crate::error::UpdateStackError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_stack_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_update_stack(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateStackError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_stack_instances_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateStackInstancesOutput,
    crate::error::UpdateStackInstancesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateStackInstancesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateStackInstancesError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidOperationException" => {
            crate::error::UpdateStackInstancesError::InvalidOperationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_operation_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_operation_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateStackInstancesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "OperationIdAlreadyExistsException" => {
            crate::error::UpdateStackInstancesError::OperationIdAlreadyExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::operation_id_already_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_operation_id_already_exists_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateStackInstancesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "OperationInProgressException" => {
            crate::error::UpdateStackInstancesError::OperationInProgressException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::operation_in_progress_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_operation_in_progress_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateStackInstancesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "StackInstanceNotFoundException" => {
            crate::error::UpdateStackInstancesError::StackInstanceNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::stack_instance_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_stack_instance_not_found_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateStackInstancesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "StackSetNotFoundException" => {
            crate::error::UpdateStackInstancesError::StackSetNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::stack_set_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_stack_set_not_found_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateStackInstancesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "StaleRequestException" => {
            crate::error::UpdateStackInstancesError::StaleRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::stale_request_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_stale_request_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateStackInstancesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::UpdateStackInstancesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_stack_instances_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateStackInstancesOutput,
    crate::error::UpdateStackInstancesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_stack_instances_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_update_stack_instances(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateStackInstancesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_stack_set_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateStackSetOutput, crate::error::UpdateStackSetError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateStackSetError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateStackSetError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidOperationException" => {
            crate::error::UpdateStackSetError::InvalidOperationException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_operation_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_invalid_operation_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateStackSetError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "OperationIdAlreadyExistsException" => {
            crate::error::UpdateStackSetError::OperationIdAlreadyExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::operation_id_already_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_operation_id_already_exists_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateStackSetError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "OperationInProgressException" => {
            crate::error::UpdateStackSetError::OperationInProgressException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::operation_in_progress_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_operation_in_progress_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateStackSetError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "StackInstanceNotFoundException" => {
            crate::error::UpdateStackSetError::StackInstanceNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::stack_instance_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_stack_instance_not_found_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateStackSetError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "StackSetNotFoundException" => {
            crate::error::UpdateStackSetError::StackSetNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::stack_set_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_stack_set_not_found_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateStackSetError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "StaleRequestException" => {
            crate::error::UpdateStackSetError::StaleRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::stale_request_exception::Builder::default();
                    let _ = response;
                    output = crate::xml_deser::deser_structure_crate_error_stale_request_exception_xml_err(response.body().as_ref(), output).map_err(crate::error::UpdateStackSetError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::UpdateStackSetError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_stack_set_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateStackSetOutput, crate::error::UpdateStackSetError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_stack_set_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_update_stack_set(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateStackSetError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_termination_protection_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateTerminationProtectionOutput,
    crate::error::UpdateTerminationProtectionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateTerminationProtectionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::UpdateTerminationProtectionError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_termination_protection_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateTerminationProtectionOutput,
    crate::error::UpdateTerminationProtectionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_termination_protection_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_update_termination_protection(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateTerminationProtectionError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_validate_template_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ValidateTemplateOutput, crate::error::ValidateTemplateError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::xml_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ValidateTemplateError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    Err(crate::error::ValidateTemplateError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_validate_template_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ValidateTemplateOutput, crate::error::ValidateTemplateError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::validate_template_output::Builder::default();
        let _ = response;
        output = crate::xml_deser::deser_operation_crate_operation_validate_template(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ValidateTemplateError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}
