// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct CreatePortalInput {
    /// <p>The name of the web portal. This is not visible to users who log into the web portal.</p>
    pub display_name: ::std::option::Option<::std::string::String>,
    /// <p>The tags to add to the web portal. A tag is a key-value pair.</p>
    pub tags: ::std::option::Option<::std::vec::Vec<crate::types::Tag>>,
    /// <p>The customer managed key of the web portal.</p>
    pub customer_managed_key: ::std::option::Option<::std::string::String>,
    /// <p>The additional encryption context of the portal.</p>
    pub additional_encryption_context: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token returns the result from the original successful request. </p>
    /// <p>If you do not specify a client token, one is automatically generated by the AWS SDK.</p>
    pub client_token: ::std::option::Option<::std::string::String>,
    /// <p>The type of authentication integration points used when signing into the web portal. Defaults to <code>Standard</code>.</p>
    /// <p> <code>Standard</code> web portals are authenticated directly through your identity provider. You need to call <code>CreateIdentityProvider</code> to integrate your identity provider with your web portal. User and group access to your web portal is controlled through your identity provider.</p>
    /// <p> <code>IAM_Identity_Center</code> web portals are authenticated through AWS IAM Identity Center (successor to AWS Single Sign-On). They provide additional features, such as IdP-initiated authentication. Identity sources (including external identity provider integration), plus user and group access to your web portal, can be configured in the IAM Identity Center.</p>
    pub authentication_type: ::std::option::Option<crate::types::AuthenticationType>,
}
impl CreatePortalInput {
    /// <p>The name of the web portal. This is not visible to users who log into the web portal.</p>
    pub fn display_name(&self) -> ::std::option::Option<&str> {
        self.display_name.as_deref()
    }
    /// <p>The tags to add to the web portal. A tag is a key-value pair.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.tags.is_none()`.
    pub fn tags(&self) -> &[crate::types::Tag] {
        self.tags.as_deref().unwrap_or_default()
    }
    /// <p>The customer managed key of the web portal.</p>
    pub fn customer_managed_key(&self) -> ::std::option::Option<&str> {
        self.customer_managed_key.as_deref()
    }
    /// <p>The additional encryption context of the portal.</p>
    pub fn additional_encryption_context(&self) -> ::std::option::Option<&::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        self.additional_encryption_context.as_ref()
    }
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token returns the result from the original successful request. </p>
    /// <p>If you do not specify a client token, one is automatically generated by the AWS SDK.</p>
    pub fn client_token(&self) -> ::std::option::Option<&str> {
        self.client_token.as_deref()
    }
    /// <p>The type of authentication integration points used when signing into the web portal. Defaults to <code>Standard</code>.</p>
    /// <p> <code>Standard</code> web portals are authenticated directly through your identity provider. You need to call <code>CreateIdentityProvider</code> to integrate your identity provider with your web portal. User and group access to your web portal is controlled through your identity provider.</p>
    /// <p> <code>IAM_Identity_Center</code> web portals are authenticated through AWS IAM Identity Center (successor to AWS Single Sign-On). They provide additional features, such as IdP-initiated authentication. Identity sources (including external identity provider integration), plus user and group access to your web portal, can be configured in the IAM Identity Center.</p>
    pub fn authentication_type(&self) -> ::std::option::Option<&crate::types::AuthenticationType> {
        self.authentication_type.as_ref()
    }
}
impl ::std::fmt::Debug for CreatePortalInput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("CreatePortalInput");
        formatter.field("display_name", &"*** Sensitive Data Redacted ***");
        formatter.field("tags", &self.tags);
        formatter.field("customer_managed_key", &self.customer_managed_key);
        formatter.field("additional_encryption_context", &self.additional_encryption_context);
        formatter.field("client_token", &self.client_token);
        formatter.field("authentication_type", &self.authentication_type);
        formatter.finish()
    }
}
impl CreatePortalInput {
    /// Creates a new builder-style object to manufacture [`CreatePortalInput`](crate::operation::create_portal::CreatePortalInput).
    pub fn builder() -> crate::operation::create_portal::builders::CreatePortalInputBuilder {
        crate::operation::create_portal::builders::CreatePortalInputBuilder::default()
    }
}

/// A builder for [`CreatePortalInput`](crate::operation::create_portal::CreatePortalInput).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default)]
pub struct CreatePortalInputBuilder {
    pub(crate) display_name: ::std::option::Option<::std::string::String>,
    pub(crate) tags: ::std::option::Option<::std::vec::Vec<crate::types::Tag>>,
    pub(crate) customer_managed_key: ::std::option::Option<::std::string::String>,
    pub(crate) additional_encryption_context: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
    pub(crate) client_token: ::std::option::Option<::std::string::String>,
    pub(crate) authentication_type: ::std::option::Option<crate::types::AuthenticationType>,
}
impl CreatePortalInputBuilder {
    /// <p>The name of the web portal. This is not visible to users who log into the web portal.</p>
    pub fn display_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.display_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of the web portal. This is not visible to users who log into the web portal.</p>
    pub fn set_display_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.display_name = input;
        self
    }
    /// <p>The name of the web portal. This is not visible to users who log into the web portal.</p>
    pub fn get_display_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.display_name
    }
    /// Appends an item to `tags`.
    ///
    /// To override the contents of this collection use [`set_tags`](Self::set_tags).
    ///
    /// <p>The tags to add to the web portal. A tag is a key-value pair.</p>
    pub fn tags(mut self, input: crate::types::Tag) -> Self {
        let mut v = self.tags.unwrap_or_default();
        v.push(input);
        self.tags = ::std::option::Option::Some(v);
        self
    }
    /// <p>The tags to add to the web portal. A tag is a key-value pair.</p>
    pub fn set_tags(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::Tag>>) -> Self {
        self.tags = input;
        self
    }
    /// <p>The tags to add to the web portal. A tag is a key-value pair.</p>
    pub fn get_tags(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::Tag>> {
        &self.tags
    }
    /// <p>The customer managed key of the web portal.</p>
    pub fn customer_managed_key(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.customer_managed_key = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The customer managed key of the web portal.</p>
    pub fn set_customer_managed_key(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.customer_managed_key = input;
        self
    }
    /// <p>The customer managed key of the web portal.</p>
    pub fn get_customer_managed_key(&self) -> &::std::option::Option<::std::string::String> {
        &self.customer_managed_key
    }
    /// Adds a key-value pair to `additional_encryption_context`.
    ///
    /// To override the contents of this collection use [`set_additional_encryption_context`](Self::set_additional_encryption_context).
    ///
    /// <p>The additional encryption context of the portal.</p>
    pub fn additional_encryption_context(
        mut self,
        k: impl ::std::convert::Into<::std::string::String>,
        v: impl ::std::convert::Into<::std::string::String>,
    ) -> Self {
        let mut hash_map = self.additional_encryption_context.unwrap_or_default();
        hash_map.insert(k.into(), v.into());
        self.additional_encryption_context = ::std::option::Option::Some(hash_map);
        self
    }
    /// <p>The additional encryption context of the portal.</p>
    pub fn set_additional_encryption_context(
        mut self,
        input: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
    ) -> Self {
        self.additional_encryption_context = input;
        self
    }
    /// <p>The additional encryption context of the portal.</p>
    pub fn get_additional_encryption_context(
        &self,
    ) -> &::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        &self.additional_encryption_context
    }
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token returns the result from the original successful request. </p>
    /// <p>If you do not specify a client token, one is automatically generated by the AWS SDK.</p>
    pub fn client_token(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.client_token = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token returns the result from the original successful request. </p>
    /// <p>If you do not specify a client token, one is automatically generated by the AWS SDK.</p>
    pub fn set_client_token(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.client_token = input;
        self
    }
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token returns the result from the original successful request. </p>
    /// <p>If you do not specify a client token, one is automatically generated by the AWS SDK.</p>
    pub fn get_client_token(&self) -> &::std::option::Option<::std::string::String> {
        &self.client_token
    }
    /// <p>The type of authentication integration points used when signing into the web portal. Defaults to <code>Standard</code>.</p>
    /// <p> <code>Standard</code> web portals are authenticated directly through your identity provider. You need to call <code>CreateIdentityProvider</code> to integrate your identity provider with your web portal. User and group access to your web portal is controlled through your identity provider.</p>
    /// <p> <code>IAM_Identity_Center</code> web portals are authenticated through AWS IAM Identity Center (successor to AWS Single Sign-On). They provide additional features, such as IdP-initiated authentication. Identity sources (including external identity provider integration), plus user and group access to your web portal, can be configured in the IAM Identity Center.</p>
    pub fn authentication_type(mut self, input: crate::types::AuthenticationType) -> Self {
        self.authentication_type = ::std::option::Option::Some(input);
        self
    }
    /// <p>The type of authentication integration points used when signing into the web portal. Defaults to <code>Standard</code>.</p>
    /// <p> <code>Standard</code> web portals are authenticated directly through your identity provider. You need to call <code>CreateIdentityProvider</code> to integrate your identity provider with your web portal. User and group access to your web portal is controlled through your identity provider.</p>
    /// <p> <code>IAM_Identity_Center</code> web portals are authenticated through AWS IAM Identity Center (successor to AWS Single Sign-On). They provide additional features, such as IdP-initiated authentication. Identity sources (including external identity provider integration), plus user and group access to your web portal, can be configured in the IAM Identity Center.</p>
    pub fn set_authentication_type(mut self, input: ::std::option::Option<crate::types::AuthenticationType>) -> Self {
        self.authentication_type = input;
        self
    }
    /// <p>The type of authentication integration points used when signing into the web portal. Defaults to <code>Standard</code>.</p>
    /// <p> <code>Standard</code> web portals are authenticated directly through your identity provider. You need to call <code>CreateIdentityProvider</code> to integrate your identity provider with your web portal. User and group access to your web portal is controlled through your identity provider.</p>
    /// <p> <code>IAM_Identity_Center</code> web portals are authenticated through AWS IAM Identity Center (successor to AWS Single Sign-On). They provide additional features, such as IdP-initiated authentication. Identity sources (including external identity provider integration), plus user and group access to your web portal, can be configured in the IAM Identity Center.</p>
    pub fn get_authentication_type(&self) -> &::std::option::Option<crate::types::AuthenticationType> {
        &self.authentication_type
    }
    /// Consumes the builder and constructs a [`CreatePortalInput`](crate::operation::create_portal::CreatePortalInput).
    pub fn build(
        self,
    ) -> ::std::result::Result<crate::operation::create_portal::CreatePortalInput, ::aws_smithy_types::error::operation::BuildError> {
        ::std::result::Result::Ok(crate::operation::create_portal::CreatePortalInput {
            display_name: self.display_name,
            tags: self.tags,
            customer_managed_key: self.customer_managed_key,
            additional_encryption_context: self.additional_encryption_context,
            client_token: self.client_token,
            authentication_type: self.authentication_type,
        })
    }
}
impl ::std::fmt::Debug for CreatePortalInputBuilder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("CreatePortalInputBuilder");
        formatter.field("display_name", &"*** Sensitive Data Redacted ***");
        formatter.field("tags", &self.tags);
        formatter.field("customer_managed_key", &self.customer_managed_key);
        formatter.field("additional_encryption_context", &self.additional_encryption_context);
        formatter.field("client_token", &self.client_token);
        formatter.field("authentication_type", &self.authentication_type);
        formatter.finish()
    }
}
