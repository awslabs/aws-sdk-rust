// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>Allows the destination domain owner to accept an inbound cross-cluster search connection request.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AcceptInboundCrossClusterSearchConnection {
    _private: (),
}
impl AcceptInboundCrossClusterSearchConnection {
    /// Creates a new builder-style object to manufacture [`AcceptInboundCrossClusterSearchConnectionInput`](crate::input::AcceptInboundCrossClusterSearchConnectionInput)
    pub fn builder() -> crate::input::accept_inbound_cross_cluster_search_connection_input::Builder
    {
        crate::input::accept_inbound_cross_cluster_search_connection_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AcceptInboundCrossClusterSearchConnection {
    type Output = std::result::Result<
        crate::output::AcceptInboundCrossClusterSearchConnectionOutput,
        crate::error::AcceptInboundCrossClusterSearchConnectionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_accept_inbound_cross_cluster_search_connection_error(
                response,
            )
        } else {
            crate::operation_deser::parse_accept_inbound_cross_cluster_search_connection_response(
                response,
            )
        }
    }
}

/// <p>Attaches tags to an existing Elasticsearch domain. Tags are a set of case-sensitive key value pairs. An Elasticsearch domain may have up to 10 tags.  See <a href="http://docs.aws.amazon.com/elasticsearch-service/latest/developerguide/es-managedomains.html#es-managedomains-awsresorcetagging" target="_blank">
/// Tagging Amazon Elasticsearch Service Domains for more information.</a></p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AddTags {
    _private: (),
}
impl AddTags {
    /// Creates a new builder-style object to manufacture [`AddTagsInput`](crate::input::AddTagsInput)
    pub fn builder() -> crate::input::add_tags_input::Builder {
        crate::input::add_tags_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AddTags {
    type Output = std::result::Result<crate::output::AddTagsOutput, crate::error::AddTagsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_add_tags_error(response)
        } else {
            crate::operation_deser::parse_add_tags_response(response)
        }
    }
}

/// <p>Associates a package with an Amazon ES domain.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AssociatePackage {
    _private: (),
}
impl AssociatePackage {
    /// Creates a new builder-style object to manufacture [`AssociatePackageInput`](crate::input::AssociatePackageInput)
    pub fn builder() -> crate::input::associate_package_input::Builder {
        crate::input::associate_package_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AssociatePackage {
    type Output = std::result::Result<
        crate::output::AssociatePackageOutput,
        crate::error::AssociatePackageError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_associate_package_error(response)
        } else {
            crate::operation_deser::parse_associate_package_response(response)
        }
    }
}

/// <p>Cancels a scheduled service software update for an Amazon ES domain. You can only perform this operation before the <code>AutomatedUpdateDate</code> and when the <code>UpdateStatus</code> is in the <code>PENDING_UPDATE</code> state.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CancelElasticsearchServiceSoftwareUpdate {
    _private: (),
}
impl CancelElasticsearchServiceSoftwareUpdate {
    /// Creates a new builder-style object to manufacture [`CancelElasticsearchServiceSoftwareUpdateInput`](crate::input::CancelElasticsearchServiceSoftwareUpdateInput)
    pub fn builder() -> crate::input::cancel_elasticsearch_service_software_update_input::Builder {
        crate::input::cancel_elasticsearch_service_software_update_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CancelElasticsearchServiceSoftwareUpdate {
    type Output = std::result::Result<
        crate::output::CancelElasticsearchServiceSoftwareUpdateOutput,
        crate::error::CancelElasticsearchServiceSoftwareUpdateError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_cancel_elasticsearch_service_software_update_error(
                response,
            )
        } else {
            crate::operation_deser::parse_cancel_elasticsearch_service_software_update_response(
                response,
            )
        }
    }
}

/// <p>Creates a new Elasticsearch domain. For more information,
/// see <a href="http://docs.aws.amazon.com/elasticsearch-service/latest/developerguide/es-createupdatedomains.html#es-createdomains" target="_blank">Creating Elasticsearch Domains</a> in the <i>Amazon Elasticsearch Service Developer Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateElasticsearchDomain {
    _private: (),
}
impl CreateElasticsearchDomain {
    /// Creates a new builder-style object to manufacture [`CreateElasticsearchDomainInput`](crate::input::CreateElasticsearchDomainInput)
    pub fn builder() -> crate::input::create_elasticsearch_domain_input::Builder {
        crate::input::create_elasticsearch_domain_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateElasticsearchDomain {
    type Output = std::result::Result<
        crate::output::CreateElasticsearchDomainOutput,
        crate::error::CreateElasticsearchDomainError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_elasticsearch_domain_error(response)
        } else {
            crate::operation_deser::parse_create_elasticsearch_domain_response(response)
        }
    }
}

/// <p>Creates a new cross-cluster search connection from a source domain to a destination domain.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateOutboundCrossClusterSearchConnection {
    _private: (),
}
impl CreateOutboundCrossClusterSearchConnection {
    /// Creates a new builder-style object to manufacture [`CreateOutboundCrossClusterSearchConnectionInput`](crate::input::CreateOutboundCrossClusterSearchConnectionInput)
    pub fn builder() -> crate::input::create_outbound_cross_cluster_search_connection_input::Builder
    {
        crate::input::create_outbound_cross_cluster_search_connection_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateOutboundCrossClusterSearchConnection {
    type Output = std::result::Result<
        crate::output::CreateOutboundCrossClusterSearchConnectionOutput,
        crate::error::CreateOutboundCrossClusterSearchConnectionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_outbound_cross_cluster_search_connection_error(
                response,
            )
        } else {
            crate::operation_deser::parse_create_outbound_cross_cluster_search_connection_response(
                response,
            )
        }
    }
}

/// <p>Create a package for use with Amazon ES domains.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreatePackage {
    _private: (),
}
impl CreatePackage {
    /// Creates a new builder-style object to manufacture [`CreatePackageInput`](crate::input::CreatePackageInput)
    pub fn builder() -> crate::input::create_package_input::Builder {
        crate::input::create_package_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreatePackage {
    type Output =
        std::result::Result<crate::output::CreatePackageOutput, crate::error::CreatePackageError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_package_error(response)
        } else {
            crate::operation_deser::parse_create_package_response(response)
        }
    }
}

/// <p>Permanently deletes the specified Elasticsearch domain and all of its data. Once a domain is deleted, it cannot be recovered.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteElasticsearchDomain {
    _private: (),
}
impl DeleteElasticsearchDomain {
    /// Creates a new builder-style object to manufacture [`DeleteElasticsearchDomainInput`](crate::input::DeleteElasticsearchDomainInput)
    pub fn builder() -> crate::input::delete_elasticsearch_domain_input::Builder {
        crate::input::delete_elasticsearch_domain_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteElasticsearchDomain {
    type Output = std::result::Result<
        crate::output::DeleteElasticsearchDomainOutput,
        crate::error::DeleteElasticsearchDomainError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_elasticsearch_domain_error(response)
        } else {
            crate::operation_deser::parse_delete_elasticsearch_domain_response(response)
        }
    }
}

/// <p>Deletes the service-linked role that Elasticsearch Service uses to manage and maintain VPC domains. Role deletion will fail if any existing VPC domains use the role. You must delete any such Elasticsearch domains before deleting the role. See <a href="http://docs.aws.amazon.com/elasticsearch-service/latest/developerguide/es-vpc.html#es-enabling-slr" target="_blank">Deleting Elasticsearch Service Role</a> in <i>VPC Endpoints for Amazon Elasticsearch Service Domains</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteElasticsearchServiceRole {
    _private: (),
}
impl DeleteElasticsearchServiceRole {
    /// Creates a new builder-style object to manufacture [`DeleteElasticsearchServiceRoleInput`](crate::input::DeleteElasticsearchServiceRoleInput)
    pub fn builder() -> crate::input::delete_elasticsearch_service_role_input::Builder {
        crate::input::delete_elasticsearch_service_role_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteElasticsearchServiceRole {
    type Output = std::result::Result<
        crate::output::DeleteElasticsearchServiceRoleOutput,
        crate::error::DeleteElasticsearchServiceRoleError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_elasticsearch_service_role_error(response)
        } else {
            crate::operation_deser::parse_delete_elasticsearch_service_role_response(response)
        }
    }
}

/// <p>Allows the destination domain owner to delete an existing inbound cross-cluster search connection.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteInboundCrossClusterSearchConnection {
    _private: (),
}
impl DeleteInboundCrossClusterSearchConnection {
    /// Creates a new builder-style object to manufacture [`DeleteInboundCrossClusterSearchConnectionInput`](crate::input::DeleteInboundCrossClusterSearchConnectionInput)
    pub fn builder() -> crate::input::delete_inbound_cross_cluster_search_connection_input::Builder
    {
        crate::input::delete_inbound_cross_cluster_search_connection_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteInboundCrossClusterSearchConnection {
    type Output = std::result::Result<
        crate::output::DeleteInboundCrossClusterSearchConnectionOutput,
        crate::error::DeleteInboundCrossClusterSearchConnectionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_inbound_cross_cluster_search_connection_error(
                response,
            )
        } else {
            crate::operation_deser::parse_delete_inbound_cross_cluster_search_connection_response(
                response,
            )
        }
    }
}

/// <p>Allows the source domain owner to delete an existing outbound cross-cluster search connection.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteOutboundCrossClusterSearchConnection {
    _private: (),
}
impl DeleteOutboundCrossClusterSearchConnection {
    /// Creates a new builder-style object to manufacture [`DeleteOutboundCrossClusterSearchConnectionInput`](crate::input::DeleteOutboundCrossClusterSearchConnectionInput)
    pub fn builder() -> crate::input::delete_outbound_cross_cluster_search_connection_input::Builder
    {
        crate::input::delete_outbound_cross_cluster_search_connection_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteOutboundCrossClusterSearchConnection {
    type Output = std::result::Result<
        crate::output::DeleteOutboundCrossClusterSearchConnectionOutput,
        crate::error::DeleteOutboundCrossClusterSearchConnectionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_outbound_cross_cluster_search_connection_error(
                response,
            )
        } else {
            crate::operation_deser::parse_delete_outbound_cross_cluster_search_connection_response(
                response,
            )
        }
    }
}

/// <p>Delete the package.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeletePackage {
    _private: (),
}
impl DeletePackage {
    /// Creates a new builder-style object to manufacture [`DeletePackageInput`](crate::input::DeletePackageInput)
    pub fn builder() -> crate::input::delete_package_input::Builder {
        crate::input::delete_package_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeletePackage {
    type Output =
        std::result::Result<crate::output::DeletePackageOutput, crate::error::DeletePackageError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_package_error(response)
        } else {
            crate::operation_deser::parse_delete_package_response(response)
        }
    }
}

/// <p>Provides scheduled Auto-Tune action details for the Elasticsearch domain, such as Auto-Tune action type, description, severity, and scheduled date.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeDomainAutoTunes {
    _private: (),
}
impl DescribeDomainAutoTunes {
    /// Creates a new builder-style object to manufacture [`DescribeDomainAutoTunesInput`](crate::input::DescribeDomainAutoTunesInput)
    pub fn builder() -> crate::input::describe_domain_auto_tunes_input::Builder {
        crate::input::describe_domain_auto_tunes_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeDomainAutoTunes {
    type Output = std::result::Result<
        crate::output::DescribeDomainAutoTunesOutput,
        crate::error::DescribeDomainAutoTunesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_domain_auto_tunes_error(response)
        } else {
            crate::operation_deser::parse_describe_domain_auto_tunes_response(response)
        }
    }
}

/// <p>Returns domain configuration information about the specified Elasticsearch domain, including the domain ID, domain endpoint, and domain ARN.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeElasticsearchDomain {
    _private: (),
}
impl DescribeElasticsearchDomain {
    /// Creates a new builder-style object to manufacture [`DescribeElasticsearchDomainInput`](crate::input::DescribeElasticsearchDomainInput)
    pub fn builder() -> crate::input::describe_elasticsearch_domain_input::Builder {
        crate::input::describe_elasticsearch_domain_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeElasticsearchDomain {
    type Output = std::result::Result<
        crate::output::DescribeElasticsearchDomainOutput,
        crate::error::DescribeElasticsearchDomainError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_elasticsearch_domain_error(response)
        } else {
            crate::operation_deser::parse_describe_elasticsearch_domain_response(response)
        }
    }
}

/// <p>Provides cluster configuration information about the specified Elasticsearch domain, such as the state, creation date, update version, and update date for cluster options.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeElasticsearchDomainConfig {
    _private: (),
}
impl DescribeElasticsearchDomainConfig {
    /// Creates a new builder-style object to manufacture [`DescribeElasticsearchDomainConfigInput`](crate::input::DescribeElasticsearchDomainConfigInput)
    pub fn builder() -> crate::input::describe_elasticsearch_domain_config_input::Builder {
        crate::input::describe_elasticsearch_domain_config_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeElasticsearchDomainConfig {
    type Output = std::result::Result<
        crate::output::DescribeElasticsearchDomainConfigOutput,
        crate::error::DescribeElasticsearchDomainConfigError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_elasticsearch_domain_config_error(response)
        } else {
            crate::operation_deser::parse_describe_elasticsearch_domain_config_response(response)
        }
    }
}

/// <p>Returns domain configuration information about the specified Elasticsearch domains, including the domain ID, domain endpoint, and domain ARN.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeElasticsearchDomains {
    _private: (),
}
impl DescribeElasticsearchDomains {
    /// Creates a new builder-style object to manufacture [`DescribeElasticsearchDomainsInput`](crate::input::DescribeElasticsearchDomainsInput)
    pub fn builder() -> crate::input::describe_elasticsearch_domains_input::Builder {
        crate::input::describe_elasticsearch_domains_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeElasticsearchDomains {
    type Output = std::result::Result<
        crate::output::DescribeElasticsearchDomainsOutput,
        crate::error::DescribeElasticsearchDomainsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_elasticsearch_domains_error(response)
        } else {
            crate::operation_deser::parse_describe_elasticsearch_domains_response(response)
        }
    }
}

/// <p>
/// Describe Elasticsearch Limits for a given InstanceType and ElasticsearchVersion.
/// When modifying existing Domain, specify the
/// <code>
/// <a>DomainName</a>
/// </code>
/// to know what Limits are supported for modifying.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeElasticsearchInstanceTypeLimits {
    _private: (),
}
impl DescribeElasticsearchInstanceTypeLimits {
    /// Creates a new builder-style object to manufacture [`DescribeElasticsearchInstanceTypeLimitsInput`](crate::input::DescribeElasticsearchInstanceTypeLimitsInput)
    pub fn builder() -> crate::input::describe_elasticsearch_instance_type_limits_input::Builder {
        crate::input::describe_elasticsearch_instance_type_limits_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeElasticsearchInstanceTypeLimits {
    type Output = std::result::Result<
        crate::output::DescribeElasticsearchInstanceTypeLimitsOutput,
        crate::error::DescribeElasticsearchInstanceTypeLimitsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_elasticsearch_instance_type_limits_error(
                response,
            )
        } else {
            crate::operation_deser::parse_describe_elasticsearch_instance_type_limits_response(
                response,
            )
        }
    }
}

/// <p>Lists all the inbound cross-cluster search connections for a destination domain.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeInboundCrossClusterSearchConnections {
    _private: (),
}
impl DescribeInboundCrossClusterSearchConnections {
    /// Creates a new builder-style object to manufacture [`DescribeInboundCrossClusterSearchConnectionsInput`](crate::input::DescribeInboundCrossClusterSearchConnectionsInput)
    pub fn builder(
    ) -> crate::input::describe_inbound_cross_cluster_search_connections_input::Builder {
        crate::input::describe_inbound_cross_cluster_search_connections_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeInboundCrossClusterSearchConnections {
    type Output = std::result::Result<
        crate::output::DescribeInboundCrossClusterSearchConnectionsOutput,
        crate::error::DescribeInboundCrossClusterSearchConnectionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_inbound_cross_cluster_search_connections_error(
                response,
            )
        } else {
            crate::operation_deser::parse_describe_inbound_cross_cluster_search_connections_response(
                response,
            )
        }
    }
}

/// <p>Lists all the outbound cross-cluster search connections for a source domain.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeOutboundCrossClusterSearchConnections {
    _private: (),
}
impl DescribeOutboundCrossClusterSearchConnections {
    /// Creates a new builder-style object to manufacture [`DescribeOutboundCrossClusterSearchConnectionsInput`](crate::input::DescribeOutboundCrossClusterSearchConnectionsInput)
    pub fn builder(
    ) -> crate::input::describe_outbound_cross_cluster_search_connections_input::Builder {
        crate::input::describe_outbound_cross_cluster_search_connections_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeOutboundCrossClusterSearchConnections {
    type Output = std::result::Result<
        crate::output::DescribeOutboundCrossClusterSearchConnectionsOutput,
        crate::error::DescribeOutboundCrossClusterSearchConnectionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_outbound_cross_cluster_search_connections_error(
                response,
            )
        } else {
            crate::operation_deser::parse_describe_outbound_cross_cluster_search_connections_response(response)
        }
    }
}

/// <p>Describes all packages available to Amazon ES. Includes options for filtering, limiting the number of results, and pagination.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribePackages {
    _private: (),
}
impl DescribePackages {
    /// Creates a new builder-style object to manufacture [`DescribePackagesInput`](crate::input::DescribePackagesInput)
    pub fn builder() -> crate::input::describe_packages_input::Builder {
        crate::input::describe_packages_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribePackages {
    type Output = std::result::Result<
        crate::output::DescribePackagesOutput,
        crate::error::DescribePackagesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_packages_error(response)
        } else {
            crate::operation_deser::parse_describe_packages_response(response)
        }
    }
}

/// <p>Lists available reserved Elasticsearch instance offerings.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeReservedElasticsearchInstanceOfferings {
    _private: (),
}
impl DescribeReservedElasticsearchInstanceOfferings {
    /// Creates a new builder-style object to manufacture [`DescribeReservedElasticsearchInstanceOfferingsInput`](crate::input::DescribeReservedElasticsearchInstanceOfferingsInput)
    pub fn builder(
    ) -> crate::input::describe_reserved_elasticsearch_instance_offerings_input::Builder {
        crate::input::describe_reserved_elasticsearch_instance_offerings_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeReservedElasticsearchInstanceOfferings {
    type Output = std::result::Result<
        crate::output::DescribeReservedElasticsearchInstanceOfferingsOutput,
        crate::error::DescribeReservedElasticsearchInstanceOfferingsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_reserved_elasticsearch_instance_offerings_error(
                response,
            )
        } else {
            crate::operation_deser::parse_describe_reserved_elasticsearch_instance_offerings_response(response)
        }
    }
}

/// <p>Returns information about reserved Elasticsearch instances for this account.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeReservedElasticsearchInstances {
    _private: (),
}
impl DescribeReservedElasticsearchInstances {
    /// Creates a new builder-style object to manufacture [`DescribeReservedElasticsearchInstancesInput`](crate::input::DescribeReservedElasticsearchInstancesInput)
    pub fn builder() -> crate::input::describe_reserved_elasticsearch_instances_input::Builder {
        crate::input::describe_reserved_elasticsearch_instances_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeReservedElasticsearchInstances {
    type Output = std::result::Result<
        crate::output::DescribeReservedElasticsearchInstancesOutput,
        crate::error::DescribeReservedElasticsearchInstancesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_reserved_elasticsearch_instances_error(response)
        } else {
            crate::operation_deser::parse_describe_reserved_elasticsearch_instances_response(
                response,
            )
        }
    }
}

/// <p>Dissociates a package from the Amazon ES domain.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DissociatePackage {
    _private: (),
}
impl DissociatePackage {
    /// Creates a new builder-style object to manufacture [`DissociatePackageInput`](crate::input::DissociatePackageInput)
    pub fn builder() -> crate::input::dissociate_package_input::Builder {
        crate::input::dissociate_package_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DissociatePackage {
    type Output = std::result::Result<
        crate::output::DissociatePackageOutput,
        crate::error::DissociatePackageError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_dissociate_package_error(response)
        } else {
            crate::operation_deser::parse_dissociate_package_response(response)
        }
    }
}

/// <p>
/// Returns a list of upgrade compatible Elastisearch versions.
/// You can optionally pass a
/// <code>
/// <a>DomainName</a>
/// </code>
/// to get all upgrade compatible Elasticsearch versions for that specific domain.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetCompatibleElasticsearchVersions {
    _private: (),
}
impl GetCompatibleElasticsearchVersions {
    /// Creates a new builder-style object to manufacture [`GetCompatibleElasticsearchVersionsInput`](crate::input::GetCompatibleElasticsearchVersionsInput)
    pub fn builder() -> crate::input::get_compatible_elasticsearch_versions_input::Builder {
        crate::input::get_compatible_elasticsearch_versions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetCompatibleElasticsearchVersions {
    type Output = std::result::Result<
        crate::output::GetCompatibleElasticsearchVersionsOutput,
        crate::error::GetCompatibleElasticsearchVersionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_compatible_elasticsearch_versions_error(response)
        } else {
            crate::operation_deser::parse_get_compatible_elasticsearch_versions_response(response)
        }
    }
}

/// <p>Returns a list of versions of the package, along with their creation time and commit message.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetPackageVersionHistory {
    _private: (),
}
impl GetPackageVersionHistory {
    /// Creates a new builder-style object to manufacture [`GetPackageVersionHistoryInput`](crate::input::GetPackageVersionHistoryInput)
    pub fn builder() -> crate::input::get_package_version_history_input::Builder {
        crate::input::get_package_version_history_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetPackageVersionHistory {
    type Output = std::result::Result<
        crate::output::GetPackageVersionHistoryOutput,
        crate::error::GetPackageVersionHistoryError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_package_version_history_error(response)
        } else {
            crate::operation_deser::parse_get_package_version_history_response(response)
        }
    }
}

/// <p>Retrieves the complete history of the last 10 upgrades that were performed on the domain.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetUpgradeHistory {
    _private: (),
}
impl GetUpgradeHistory {
    /// Creates a new builder-style object to manufacture [`GetUpgradeHistoryInput`](crate::input::GetUpgradeHistoryInput)
    pub fn builder() -> crate::input::get_upgrade_history_input::Builder {
        crate::input::get_upgrade_history_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetUpgradeHistory {
    type Output = std::result::Result<
        crate::output::GetUpgradeHistoryOutput,
        crate::error::GetUpgradeHistoryError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_upgrade_history_error(response)
        } else {
            crate::operation_deser::parse_get_upgrade_history_response(response)
        }
    }
}

/// <p>Retrieves the latest status of the last upgrade or upgrade eligibility check that was performed on the domain.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetUpgradeStatus {
    _private: (),
}
impl GetUpgradeStatus {
    /// Creates a new builder-style object to manufacture [`GetUpgradeStatusInput`](crate::input::GetUpgradeStatusInput)
    pub fn builder() -> crate::input::get_upgrade_status_input::Builder {
        crate::input::get_upgrade_status_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetUpgradeStatus {
    type Output = std::result::Result<
        crate::output::GetUpgradeStatusOutput,
        crate::error::GetUpgradeStatusError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_upgrade_status_error(response)
        } else {
            crate::operation_deser::parse_get_upgrade_status_response(response)
        }
    }
}

/// <p>Returns the name of all Elasticsearch domains owned by the current user's account. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListDomainNames {
    _private: (),
}
impl ListDomainNames {
    /// Creates a new builder-style object to manufacture [`ListDomainNamesInput`](crate::input::ListDomainNamesInput)
    pub fn builder() -> crate::input::list_domain_names_input::Builder {
        crate::input::list_domain_names_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListDomainNames {
    type Output = std::result::Result<
        crate::output::ListDomainNamesOutput,
        crate::error::ListDomainNamesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_domain_names_error(response)
        } else {
            crate::operation_deser::parse_list_domain_names_response(response)
        }
    }
}

/// <p>Lists all Amazon ES domains associated with the package.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListDomainsForPackage {
    _private: (),
}
impl ListDomainsForPackage {
    /// Creates a new builder-style object to manufacture [`ListDomainsForPackageInput`](crate::input::ListDomainsForPackageInput)
    pub fn builder() -> crate::input::list_domains_for_package_input::Builder {
        crate::input::list_domains_for_package_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListDomainsForPackage {
    type Output = std::result::Result<
        crate::output::ListDomainsForPackageOutput,
        crate::error::ListDomainsForPackageError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_domains_for_package_error(response)
        } else {
            crate::operation_deser::parse_list_domains_for_package_response(response)
        }
    }
}

/// <p>List all Elasticsearch instance types that are supported for given ElasticsearchVersion</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListElasticsearchInstanceTypes {
    _private: (),
}
impl ListElasticsearchInstanceTypes {
    /// Creates a new builder-style object to manufacture [`ListElasticsearchInstanceTypesInput`](crate::input::ListElasticsearchInstanceTypesInput)
    pub fn builder() -> crate::input::list_elasticsearch_instance_types_input::Builder {
        crate::input::list_elasticsearch_instance_types_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListElasticsearchInstanceTypes {
    type Output = std::result::Result<
        crate::output::ListElasticsearchInstanceTypesOutput,
        crate::error::ListElasticsearchInstanceTypesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_elasticsearch_instance_types_error(response)
        } else {
            crate::operation_deser::parse_list_elasticsearch_instance_types_response(response)
        }
    }
}

/// <p>List all supported Elasticsearch versions</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListElasticsearchVersions {
    _private: (),
}
impl ListElasticsearchVersions {
    /// Creates a new builder-style object to manufacture [`ListElasticsearchVersionsInput`](crate::input::ListElasticsearchVersionsInput)
    pub fn builder() -> crate::input::list_elasticsearch_versions_input::Builder {
        crate::input::list_elasticsearch_versions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListElasticsearchVersions {
    type Output = std::result::Result<
        crate::output::ListElasticsearchVersionsOutput,
        crate::error::ListElasticsearchVersionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_elasticsearch_versions_error(response)
        } else {
            crate::operation_deser::parse_list_elasticsearch_versions_response(response)
        }
    }
}

/// <p>Lists all packages associated with the Amazon ES domain.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListPackagesForDomain {
    _private: (),
}
impl ListPackagesForDomain {
    /// Creates a new builder-style object to manufacture [`ListPackagesForDomainInput`](crate::input::ListPackagesForDomainInput)
    pub fn builder() -> crate::input::list_packages_for_domain_input::Builder {
        crate::input::list_packages_for_domain_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListPackagesForDomain {
    type Output = std::result::Result<
        crate::output::ListPackagesForDomainOutput,
        crate::error::ListPackagesForDomainError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_packages_for_domain_error(response)
        } else {
            crate::operation_deser::parse_list_packages_for_domain_response(response)
        }
    }
}

/// <p>Returns all tags for the given Elasticsearch domain.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTags {
    _private: (),
}
impl ListTags {
    /// Creates a new builder-style object to manufacture [`ListTagsInput`](crate::input::ListTagsInput)
    pub fn builder() -> crate::input::list_tags_input::Builder {
        crate::input::list_tags_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTags {
    type Output = std::result::Result<crate::output::ListTagsOutput, crate::error::ListTagsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_tags_error(response)
        } else {
            crate::operation_deser::parse_list_tags_response(response)
        }
    }
}

/// <p>Allows you to purchase reserved Elasticsearch instances.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PurchaseReservedElasticsearchInstanceOffering {
    _private: (),
}
impl PurchaseReservedElasticsearchInstanceOffering {
    /// Creates a new builder-style object to manufacture [`PurchaseReservedElasticsearchInstanceOfferingInput`](crate::input::PurchaseReservedElasticsearchInstanceOfferingInput)
    pub fn builder(
    ) -> crate::input::purchase_reserved_elasticsearch_instance_offering_input::Builder {
        crate::input::purchase_reserved_elasticsearch_instance_offering_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PurchaseReservedElasticsearchInstanceOffering {
    type Output = std::result::Result<
        crate::output::PurchaseReservedElasticsearchInstanceOfferingOutput,
        crate::error::PurchaseReservedElasticsearchInstanceOfferingError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_purchase_reserved_elasticsearch_instance_offering_error(
                response,
            )
        } else {
            crate::operation_deser::parse_purchase_reserved_elasticsearch_instance_offering_response(
                response,
            )
        }
    }
}

/// <p>Allows the destination domain owner to reject an inbound cross-cluster search connection request.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct RejectInboundCrossClusterSearchConnection {
    _private: (),
}
impl RejectInboundCrossClusterSearchConnection {
    /// Creates a new builder-style object to manufacture [`RejectInboundCrossClusterSearchConnectionInput`](crate::input::RejectInboundCrossClusterSearchConnectionInput)
    pub fn builder() -> crate::input::reject_inbound_cross_cluster_search_connection_input::Builder
    {
        crate::input::reject_inbound_cross_cluster_search_connection_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for RejectInboundCrossClusterSearchConnection {
    type Output = std::result::Result<
        crate::output::RejectInboundCrossClusterSearchConnectionOutput,
        crate::error::RejectInboundCrossClusterSearchConnectionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_reject_inbound_cross_cluster_search_connection_error(
                response,
            )
        } else {
            crate::operation_deser::parse_reject_inbound_cross_cluster_search_connection_response(
                response,
            )
        }
    }
}

/// <p>Removes the specified set of tags from the specified Elasticsearch domain.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct RemoveTags {
    _private: (),
}
impl RemoveTags {
    /// Creates a new builder-style object to manufacture [`RemoveTagsInput`](crate::input::RemoveTagsInput)
    pub fn builder() -> crate::input::remove_tags_input::Builder {
        crate::input::remove_tags_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for RemoveTags {
    type Output =
        std::result::Result<crate::output::RemoveTagsOutput, crate::error::RemoveTagsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_remove_tags_error(response)
        } else {
            crate::operation_deser::parse_remove_tags_response(response)
        }
    }
}

/// <p>Schedules a service software update for an Amazon ES domain.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StartElasticsearchServiceSoftwareUpdate {
    _private: (),
}
impl StartElasticsearchServiceSoftwareUpdate {
    /// Creates a new builder-style object to manufacture [`StartElasticsearchServiceSoftwareUpdateInput`](crate::input::StartElasticsearchServiceSoftwareUpdateInput)
    pub fn builder() -> crate::input::start_elasticsearch_service_software_update_input::Builder {
        crate::input::start_elasticsearch_service_software_update_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StartElasticsearchServiceSoftwareUpdate {
    type Output = std::result::Result<
        crate::output::StartElasticsearchServiceSoftwareUpdateOutput,
        crate::error::StartElasticsearchServiceSoftwareUpdateError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_start_elasticsearch_service_software_update_error(
                response,
            )
        } else {
            crate::operation_deser::parse_start_elasticsearch_service_software_update_response(
                response,
            )
        }
    }
}

/// <p>Modifies the cluster configuration of the specified Elasticsearch domain, setting as setting the instance type and the number of instances. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateElasticsearchDomainConfig {
    _private: (),
}
impl UpdateElasticsearchDomainConfig {
    /// Creates a new builder-style object to manufacture [`UpdateElasticsearchDomainConfigInput`](crate::input::UpdateElasticsearchDomainConfigInput)
    pub fn builder() -> crate::input::update_elasticsearch_domain_config_input::Builder {
        crate::input::update_elasticsearch_domain_config_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateElasticsearchDomainConfig {
    type Output = std::result::Result<
        crate::output::UpdateElasticsearchDomainConfigOutput,
        crate::error::UpdateElasticsearchDomainConfigError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_elasticsearch_domain_config_error(response)
        } else {
            crate::operation_deser::parse_update_elasticsearch_domain_config_response(response)
        }
    }
}

/// <p>Updates a package for use with Amazon ES domains.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdatePackage {
    _private: (),
}
impl UpdatePackage {
    /// Creates a new builder-style object to manufacture [`UpdatePackageInput`](crate::input::UpdatePackageInput)
    pub fn builder() -> crate::input::update_package_input::Builder {
        crate::input::update_package_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdatePackage {
    type Output =
        std::result::Result<crate::output::UpdatePackageOutput, crate::error::UpdatePackageError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_package_error(response)
        } else {
            crate::operation_deser::parse_update_package_response(response)
        }
    }
}

/// <p>Allows you to either upgrade your domain or perform an Upgrade eligibility check to a compatible Elasticsearch version.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpgradeElasticsearchDomain {
    _private: (),
}
impl UpgradeElasticsearchDomain {
    /// Creates a new builder-style object to manufacture [`UpgradeElasticsearchDomainInput`](crate::input::UpgradeElasticsearchDomainInput)
    pub fn builder() -> crate::input::upgrade_elasticsearch_domain_input::Builder {
        crate::input::upgrade_elasticsearch_domain_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpgradeElasticsearchDomain {
    type Output = std::result::Result<
        crate::output::UpgradeElasticsearchDomainOutput,
        crate::error::UpgradeElasticsearchDomainError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_upgrade_elasticsearch_domain_error(response)
        } else {
            crate::operation_deser::parse_upgrade_elasticsearch_domain_response(response)
        }
    }
}
