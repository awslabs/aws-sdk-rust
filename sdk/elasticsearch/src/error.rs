// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type UpgradeElasticsearchDomainErrorKind = UpgradeElasticsearchDomainError;
/// Error type for the `UpgradeElasticsearchDomainError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpgradeElasticsearchDomainError {
    /// <p>An error occurred while processing the request.</p>
    BaseException(crate::error::BaseException),
    /// <p>An error occured because the client wanted to access a not supported operation. Gives http status code of 409.</p>
    DisabledOperationException(crate::error::DisabledOperationException),
    /// <p>The request processing has failed because of an unknown error, exception or failure (the failure is internal to the service) . Gives http status code of 500.</p>
    InternalException(crate::error::InternalException),
    /// <p>An exception for creating a resource that already exists. Gives http status code of 400.</p>
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    /// <p>An exception for accessing or deleting a resource that does not exist. Gives http status code of 400.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>An exception for missing / invalid input fields. Gives http status code of 400.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UpgradeElasticsearchDomainError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for UpgradeElasticsearchDomainError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BaseException(_inner) =>
            _inner.fmt(f)
            ,
            Self::DisabledOperationException(_inner) =>
            _inner.fmt(f)
            ,
            Self::InternalException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ResourceAlreadyExistsException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UpgradeElasticsearchDomainError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BaseException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::DisabledOperationException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::InternalException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ResourceAlreadyExistsException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ResourceNotFoundException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ValidationException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UpgradeElasticsearchDomainError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for UpgradeElasticsearchDomainError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpgradeElasticsearchDomainError {
    /// Creates the `UpgradeElasticsearchDomainError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `UpgradeElasticsearchDomainError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BaseException(e) => e.meta(),
            Self::DisabledOperationException(e) => e.meta(),
            Self::InternalException(e) => e.meta(),
            Self::ResourceAlreadyExistsException(e) => e.meta(),
            Self::ResourceNotFoundException(e) => e.meta(),
            Self::ValidationException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UpgradeElasticsearchDomainError::BaseException`.
    pub fn is_base_exception(&self) -> bool {
        matches!(self, Self::BaseException(_))
    }
    /// Returns `true` if the error kind is `UpgradeElasticsearchDomainError::DisabledOperationException`.
    pub fn is_disabled_operation_exception(&self) -> bool {
        matches!(self, Self::DisabledOperationException(_))
    }
    /// Returns `true` if the error kind is `UpgradeElasticsearchDomainError::InternalException`.
    pub fn is_internal_exception(&self) -> bool {
        matches!(self, Self::InternalException(_))
    }
    /// Returns `true` if the error kind is `UpgradeElasticsearchDomainError::ResourceAlreadyExistsException`.
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(self, Self::ResourceAlreadyExistsException(_))
    }
    /// Returns `true` if the error kind is `UpgradeElasticsearchDomainError::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(self, Self::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `UpgradeElasticsearchDomainError::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(self, Self::ValidationException(_))
    }
}
impl std::error::Error for UpgradeElasticsearchDomainError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BaseException(_inner) =>
            Some(_inner)
            ,
            Self::DisabledOperationException(_inner) =>
            Some(_inner)
            ,
            Self::InternalException(_inner) =>
            Some(_inner)
            ,
            Self::ResourceAlreadyExistsException(_inner) =>
            Some(_inner)
            ,
            Self::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            Self::ValidationException(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// <p>An exception for missing / invalid input fields. Gives http status code of 400.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ValidationException  {
    /// <p>A description of the error.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ValidationException {
    /// Creates a new builder-style object to manufacture [`ValidationException`](crate::error::ValidationException).
    pub fn builder() -> crate::error::validation_exception::Builder {
        crate::error::validation_exception::Builder::default()
    }
}
/// See [`ValidationException`](crate::error::ValidationException).
pub mod validation_exception {
    
    /// A builder for [`ValidationException`](crate::error::ValidationException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A description of the error.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A description of the error.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Sets error metadata
                                            pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
                                                self.meta = Some(meta);
                                                self
                                            }
        
                                            /// Sets error metadata
                                            pub fn set_meta(&mut self, meta: Option<aws_smithy_types::error::ErrorMetadata>) -> &mut Self {
                                                self.meta = meta;
                                                self
                                            }
        /// Consumes the builder and constructs a [`ValidationException`](crate::error::ValidationException).
        pub fn build(self) -> crate::error::ValidationException {
            crate::error::ValidationException {
                message: self.message
                ,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
    
    
}
impl ValidationException {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for ValidationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ValidationException")?;
        if let Some(inner_1) = &self.message {
             {
                write!(f, ": {}", inner_1)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ValidationException {}
impl aws_http::request_id::RequestId for crate::error::ValidationException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ValidationException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata { &self.meta }
}

/// <p>An exception for accessing or deleting a resource that does not exist. Gives http status code of 400.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ResourceNotFoundException  {
    /// <p>A description of the error.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ResourceNotFoundException {
    /// Creates a new builder-style object to manufacture [`ResourceNotFoundException`](crate::error::ResourceNotFoundException).
    pub fn builder() -> crate::error::resource_not_found_exception::Builder {
        crate::error::resource_not_found_exception::Builder::default()
    }
}
/// See [`ResourceNotFoundException`](crate::error::ResourceNotFoundException).
pub mod resource_not_found_exception {
    
    /// A builder for [`ResourceNotFoundException`](crate::error::ResourceNotFoundException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A description of the error.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A description of the error.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Sets error metadata
                                            pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
                                                self.meta = Some(meta);
                                                self
                                            }
        
                                            /// Sets error metadata
                                            pub fn set_meta(&mut self, meta: Option<aws_smithy_types::error::ErrorMetadata>) -> &mut Self {
                                                self.meta = meta;
                                                self
                                            }
        /// Consumes the builder and constructs a [`ResourceNotFoundException`](crate::error::ResourceNotFoundException).
        pub fn build(self) -> crate::error::ResourceNotFoundException {
            crate::error::ResourceNotFoundException {
                message: self.message
                ,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
    
    
}
impl ResourceNotFoundException {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for ResourceNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceNotFoundException")?;
        if let Some(inner_2) = &self.message {
             {
                write!(f, ": {}", inner_2)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ResourceNotFoundException {}
impl aws_http::request_id::RequestId for crate::error::ResourceNotFoundException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ResourceNotFoundException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata { &self.meta }
}

/// <p>An exception for creating a resource that already exists. Gives http status code of 400.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ResourceAlreadyExistsException  {
    /// <p>A description of the error.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ResourceAlreadyExistsException {
    /// Creates a new builder-style object to manufacture [`ResourceAlreadyExistsException`](crate::error::ResourceAlreadyExistsException).
    pub fn builder() -> crate::error::resource_already_exists_exception::Builder {
        crate::error::resource_already_exists_exception::Builder::default()
    }
}
/// See [`ResourceAlreadyExistsException`](crate::error::ResourceAlreadyExistsException).
pub mod resource_already_exists_exception {
    
    /// A builder for [`ResourceAlreadyExistsException`](crate::error::ResourceAlreadyExistsException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A description of the error.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A description of the error.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Sets error metadata
                                            pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
                                                self.meta = Some(meta);
                                                self
                                            }
        
                                            /// Sets error metadata
                                            pub fn set_meta(&mut self, meta: Option<aws_smithy_types::error::ErrorMetadata>) -> &mut Self {
                                                self.meta = meta;
                                                self
                                            }
        /// Consumes the builder and constructs a [`ResourceAlreadyExistsException`](crate::error::ResourceAlreadyExistsException).
        pub fn build(self) -> crate::error::ResourceAlreadyExistsException {
            crate::error::ResourceAlreadyExistsException {
                message: self.message
                ,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
    
    
}
impl ResourceAlreadyExistsException {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for ResourceAlreadyExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceAlreadyExistsException")?;
        if let Some(inner_3) = &self.message {
             {
                write!(f, ": {}", inner_3)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ResourceAlreadyExistsException {}
impl aws_http::request_id::RequestId for crate::error::ResourceAlreadyExistsException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ResourceAlreadyExistsException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata { &self.meta }
}

/// <p>The request processing has failed because of an unknown error, exception or failure (the failure is internal to the service) . Gives http status code of 500.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InternalException  {
    /// <p>A description of the error.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InternalException {
    /// Creates a new builder-style object to manufacture [`InternalException`](crate::error::InternalException).
    pub fn builder() -> crate::error::internal_exception::Builder {
        crate::error::internal_exception::Builder::default()
    }
}
/// See [`InternalException`](crate::error::InternalException).
pub mod internal_exception {
    
    /// A builder for [`InternalException`](crate::error::InternalException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A description of the error.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A description of the error.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Sets error metadata
                                            pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
                                                self.meta = Some(meta);
                                                self
                                            }
        
                                            /// Sets error metadata
                                            pub fn set_meta(&mut self, meta: Option<aws_smithy_types::error::ErrorMetadata>) -> &mut Self {
                                                self.meta = meta;
                                                self
                                            }
        /// Consumes the builder and constructs a [`InternalException`](crate::error::InternalException).
        pub fn build(self) -> crate::error::InternalException {
            crate::error::InternalException {
                message: self.message
                ,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
    
    
}
impl InternalException {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for InternalException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InternalException")?;
        if let Some(inner_4) = &self.message {
             {
                write!(f, ": {}", inner_4)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InternalException {}
impl aws_http::request_id::RequestId for crate::error::InternalException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InternalException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata { &self.meta }
}

/// <p>An error occured because the client wanted to access a not supported operation. Gives http status code of 409.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DisabledOperationException  {
    /// <p>A description of the error.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl DisabledOperationException {
    /// Creates a new builder-style object to manufacture [`DisabledOperationException`](crate::error::DisabledOperationException).
    pub fn builder() -> crate::error::disabled_operation_exception::Builder {
        crate::error::disabled_operation_exception::Builder::default()
    }
}
/// See [`DisabledOperationException`](crate::error::DisabledOperationException).
pub mod disabled_operation_exception {
    
    /// A builder for [`DisabledOperationException`](crate::error::DisabledOperationException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A description of the error.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A description of the error.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Sets error metadata
                                            pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
                                                self.meta = Some(meta);
                                                self
                                            }
        
                                            /// Sets error metadata
                                            pub fn set_meta(&mut self, meta: Option<aws_smithy_types::error::ErrorMetadata>) -> &mut Self {
                                                self.meta = meta;
                                                self
                                            }
        /// Consumes the builder and constructs a [`DisabledOperationException`](crate::error::DisabledOperationException).
        pub fn build(self) -> crate::error::DisabledOperationException {
            crate::error::DisabledOperationException {
                message: self.message
                ,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
    
    
}
impl DisabledOperationException {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for DisabledOperationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DisabledOperationException")?;
        if let Some(inner_5) = &self.message {
             {
                write!(f, ": {}", inner_5)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DisabledOperationException {}
impl aws_http::request_id::RequestId for crate::error::DisabledOperationException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DisabledOperationException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata { &self.meta }
}

/// <p>An error occurred while processing the request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BaseException  {
    /// <p>A description of the error.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl BaseException {
    /// Creates a new builder-style object to manufacture [`BaseException`](crate::error::BaseException).
    pub fn builder() -> crate::error::base_exception::Builder {
        crate::error::base_exception::Builder::default()
    }
}
/// See [`BaseException`](crate::error::BaseException).
pub mod base_exception {
    
    /// A builder for [`BaseException`](crate::error::BaseException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A description of the error.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A description of the error.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Sets error metadata
                                            pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
                                                self.meta = Some(meta);
                                                self
                                            }
        
                                            /// Sets error metadata
                                            pub fn set_meta(&mut self, meta: Option<aws_smithy_types::error::ErrorMetadata>) -> &mut Self {
                                                self.meta = meta;
                                                self
                                            }
        /// Consumes the builder and constructs a [`BaseException`](crate::error::BaseException).
        pub fn build(self) -> crate::error::BaseException {
            crate::error::BaseException {
                message: self.message
                ,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
    
    
}
impl BaseException {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for BaseException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "BaseException")?;
        if let Some(inner_6) = &self.message {
             {
                write!(f, ": {}", inner_6)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for BaseException {}
impl aws_http::request_id::RequestId for crate::error::BaseException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for BaseException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata { &self.meta }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type UpdateVpcEndpointErrorKind = UpdateVpcEndpointError;
/// Error type for the `UpdateVpcEndpointError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateVpcEndpointError {
    /// <p>An error occurred while processing the request.</p>
    BaseException(crate::error::BaseException),
    /// <p>An error occurred because the client attempts to remove a resource that is currently in use. Returns HTTP status code 409.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>An error occured because the client wanted to access a not supported operation. Gives http status code of 409.</p>
    DisabledOperationException(crate::error::DisabledOperationException),
    /// <p>The request processing has failed because of an unknown error, exception or failure (the failure is internal to the service) . Gives http status code of 500.</p>
    InternalException(crate::error::InternalException),
    /// <p>An exception for accessing or deleting a resource that does not exist. Gives http status code of 400.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>An exception for missing / invalid input fields. Gives http status code of 400.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateVpcEndpointError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for UpdateVpcEndpointError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BaseException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ConflictException(_inner) =>
            _inner.fmt(f)
            ,
            Self::DisabledOperationException(_inner) =>
            _inner.fmt(f)
            ,
            Self::InternalException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UpdateVpcEndpointError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BaseException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ConflictException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::DisabledOperationException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::InternalException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ResourceNotFoundException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ValidationException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UpdateVpcEndpointError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for UpdateVpcEndpointError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateVpcEndpointError {
    /// Creates the `UpdateVpcEndpointError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `UpdateVpcEndpointError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BaseException(e) => e.meta(),
            Self::ConflictException(e) => e.meta(),
            Self::DisabledOperationException(e) => e.meta(),
            Self::InternalException(e) => e.meta(),
            Self::ResourceNotFoundException(e) => e.meta(),
            Self::ValidationException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UpdateVpcEndpointError::BaseException`.
    pub fn is_base_exception(&self) -> bool {
        matches!(self, Self::BaseException(_))
    }
    /// Returns `true` if the error kind is `UpdateVpcEndpointError::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(self, Self::ConflictException(_))
    }
    /// Returns `true` if the error kind is `UpdateVpcEndpointError::DisabledOperationException`.
    pub fn is_disabled_operation_exception(&self) -> bool {
        matches!(self, Self::DisabledOperationException(_))
    }
    /// Returns `true` if the error kind is `UpdateVpcEndpointError::InternalException`.
    pub fn is_internal_exception(&self) -> bool {
        matches!(self, Self::InternalException(_))
    }
    /// Returns `true` if the error kind is `UpdateVpcEndpointError::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(self, Self::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `UpdateVpcEndpointError::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(self, Self::ValidationException(_))
    }
}
impl std::error::Error for UpdateVpcEndpointError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BaseException(_inner) =>
            Some(_inner)
            ,
            Self::ConflictException(_inner) =>
            Some(_inner)
            ,
            Self::DisabledOperationException(_inner) =>
            Some(_inner)
            ,
            Self::InternalException(_inner) =>
            Some(_inner)
            ,
            Self::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            Self::ValidationException(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// <p>An error occurred because the client attempts to remove a resource that is currently in use. Returns HTTP status code 409.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConflictException  {
    /// <p>A description of the error.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ConflictException {
    /// Creates a new builder-style object to manufacture [`ConflictException`](crate::error::ConflictException).
    pub fn builder() -> crate::error::conflict_exception::Builder {
        crate::error::conflict_exception::Builder::default()
    }
}
/// See [`ConflictException`](crate::error::ConflictException).
pub mod conflict_exception {
    
    /// A builder for [`ConflictException`](crate::error::ConflictException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A description of the error.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A description of the error.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Sets error metadata
                                            pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
                                                self.meta = Some(meta);
                                                self
                                            }
        
                                            /// Sets error metadata
                                            pub fn set_meta(&mut self, meta: Option<aws_smithy_types::error::ErrorMetadata>) -> &mut Self {
                                                self.meta = meta;
                                                self
                                            }
        /// Consumes the builder and constructs a [`ConflictException`](crate::error::ConflictException).
        pub fn build(self) -> crate::error::ConflictException {
            crate::error::ConflictException {
                message: self.message
                ,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
    
    
}
impl ConflictException {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for ConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ConflictException")?;
        if let Some(inner_7) = &self.message {
             {
                write!(f, ": {}", inner_7)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ConflictException {}
impl aws_http::request_id::RequestId for crate::error::ConflictException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ConflictException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata { &self.meta }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type UpdatePackageErrorKind = UpdatePackageError;
/// Error type for the `UpdatePackageError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdatePackageError {
    /// <p>An error occurred because user does not have permissions to access the resource. Returns HTTP status code 403.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>An error occurred while processing the request.</p>
    BaseException(crate::error::BaseException),
    /// <p>The request processing has failed because of an unknown error, exception or failure (the failure is internal to the service) . Gives http status code of 500.</p>
    InternalException(crate::error::InternalException),
    /// <p>An exception for trying to create more than allowed resources or sub-resources. Gives http status code of 409.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>An exception for accessing or deleting a resource that does not exist. Gives http status code of 400.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>An exception for missing / invalid input fields. Gives http status code of 400.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UpdatePackageError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for UpdatePackageError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            Self::BaseException(_inner) =>
            _inner.fmt(f)
            ,
            Self::InternalException(_inner) =>
            _inner.fmt(f)
            ,
            Self::LimitExceededException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UpdatePackageError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDeniedException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::BaseException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::InternalException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::LimitExceededException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ResourceNotFoundException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ValidationException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UpdatePackageError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for UpdatePackageError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdatePackageError {
    /// Creates the `UpdatePackageError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `UpdatePackageError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDeniedException(e) => e.meta(),
            Self::BaseException(e) => e.meta(),
            Self::InternalException(e) => e.meta(),
            Self::LimitExceededException(e) => e.meta(),
            Self::ResourceNotFoundException(e) => e.meta(),
            Self::ValidationException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UpdatePackageError::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(self, Self::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `UpdatePackageError::BaseException`.
    pub fn is_base_exception(&self) -> bool {
        matches!(self, Self::BaseException(_))
    }
    /// Returns `true` if the error kind is `UpdatePackageError::InternalException`.
    pub fn is_internal_exception(&self) -> bool {
        matches!(self, Self::InternalException(_))
    }
    /// Returns `true` if the error kind is `UpdatePackageError::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::LimitExceededException(_))
    }
    /// Returns `true` if the error kind is `UpdatePackageError::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(self, Self::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `UpdatePackageError::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(self, Self::ValidationException(_))
    }
}
impl std::error::Error for UpdatePackageError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            Self::BaseException(_inner) =>
            Some(_inner)
            ,
            Self::InternalException(_inner) =>
            Some(_inner)
            ,
            Self::LimitExceededException(_inner) =>
            Some(_inner)
            ,
            Self::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            Self::ValidationException(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// <p>An exception for trying to create more than allowed resources or sub-resources. Gives http status code of 409.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LimitExceededException  {
    /// <p>A description of the error.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl LimitExceededException {
    /// Creates a new builder-style object to manufacture [`LimitExceededException`](crate::error::LimitExceededException).
    pub fn builder() -> crate::error::limit_exceeded_exception::Builder {
        crate::error::limit_exceeded_exception::Builder::default()
    }
}
/// See [`LimitExceededException`](crate::error::LimitExceededException).
pub mod limit_exceeded_exception {
    
    /// A builder for [`LimitExceededException`](crate::error::LimitExceededException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A description of the error.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A description of the error.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Sets error metadata
                                            pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
                                                self.meta = Some(meta);
                                                self
                                            }
        
                                            /// Sets error metadata
                                            pub fn set_meta(&mut self, meta: Option<aws_smithy_types::error::ErrorMetadata>) -> &mut Self {
                                                self.meta = meta;
                                                self
                                            }
        /// Consumes the builder and constructs a [`LimitExceededException`](crate::error::LimitExceededException).
        pub fn build(self) -> crate::error::LimitExceededException {
            crate::error::LimitExceededException {
                message: self.message
                ,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
    
    
}
impl LimitExceededException {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for LimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "LimitExceededException")?;
        if let Some(inner_8) = &self.message {
             {
                write!(f, ": {}", inner_8)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for LimitExceededException {}
impl aws_http::request_id::RequestId for crate::error::LimitExceededException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for LimitExceededException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata { &self.meta }
}

/// <p>An error occurred because user does not have permissions to access the resource. Returns HTTP status code 403.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AccessDeniedException  {
    /// <p>A description of the error.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl AccessDeniedException {
    /// Creates a new builder-style object to manufacture [`AccessDeniedException`](crate::error::AccessDeniedException).
    pub fn builder() -> crate::error::access_denied_exception::Builder {
        crate::error::access_denied_exception::Builder::default()
    }
}
/// See [`AccessDeniedException`](crate::error::AccessDeniedException).
pub mod access_denied_exception {
    
    /// A builder for [`AccessDeniedException`](crate::error::AccessDeniedException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A description of the error.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A description of the error.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Sets error metadata
                                            pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
                                                self.meta = Some(meta);
                                                self
                                            }
        
                                            /// Sets error metadata
                                            pub fn set_meta(&mut self, meta: Option<aws_smithy_types::error::ErrorMetadata>) -> &mut Self {
                                                self.meta = meta;
                                                self
                                            }
        /// Consumes the builder and constructs a [`AccessDeniedException`](crate::error::AccessDeniedException).
        pub fn build(self) -> crate::error::AccessDeniedException {
            crate::error::AccessDeniedException {
                message: self.message
                ,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
    
    
}
impl AccessDeniedException {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for AccessDeniedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AccessDeniedException")?;
        if let Some(inner_9) = &self.message {
             {
                write!(f, ": {}", inner_9)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for AccessDeniedException {}
impl aws_http::request_id::RequestId for crate::error::AccessDeniedException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for AccessDeniedException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata { &self.meta }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type UpdateElasticsearchDomainConfigErrorKind = UpdateElasticsearchDomainConfigError;
/// Error type for the `UpdateElasticsearchDomainConfigError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateElasticsearchDomainConfigError {
    /// <p>An error occurred while processing the request.</p>
    BaseException(crate::error::BaseException),
    /// <p>The request processing has failed because of an unknown error, exception or failure (the failure is internal to the service) . Gives http status code of 500.</p>
    InternalException(crate::error::InternalException),
    /// <p>An exception for trying to create or access sub-resource that is either invalid or not supported. Gives http status code of 409.</p>
    InvalidTypeException(crate::error::InvalidTypeException),
    /// <p>An exception for trying to create more than allowed resources or sub-resources. Gives http status code of 409.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>An exception for accessing or deleting a resource that does not exist. Gives http status code of 400.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>An exception for missing / invalid input fields. Gives http status code of 400.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateElasticsearchDomainConfigError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for UpdateElasticsearchDomainConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BaseException(_inner) =>
            _inner.fmt(f)
            ,
            Self::InternalException(_inner) =>
            _inner.fmt(f)
            ,
            Self::InvalidTypeException(_inner) =>
            _inner.fmt(f)
            ,
            Self::LimitExceededException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UpdateElasticsearchDomainConfigError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BaseException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::InternalException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::InvalidTypeException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::LimitExceededException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ResourceNotFoundException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ValidationException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UpdateElasticsearchDomainConfigError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for UpdateElasticsearchDomainConfigError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateElasticsearchDomainConfigError {
    /// Creates the `UpdateElasticsearchDomainConfigError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `UpdateElasticsearchDomainConfigError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BaseException(e) => e.meta(),
            Self::InternalException(e) => e.meta(),
            Self::InvalidTypeException(e) => e.meta(),
            Self::LimitExceededException(e) => e.meta(),
            Self::ResourceNotFoundException(e) => e.meta(),
            Self::ValidationException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UpdateElasticsearchDomainConfigError::BaseException`.
    pub fn is_base_exception(&self) -> bool {
        matches!(self, Self::BaseException(_))
    }
    /// Returns `true` if the error kind is `UpdateElasticsearchDomainConfigError::InternalException`.
    pub fn is_internal_exception(&self) -> bool {
        matches!(self, Self::InternalException(_))
    }
    /// Returns `true` if the error kind is `UpdateElasticsearchDomainConfigError::InvalidTypeException`.
    pub fn is_invalid_type_exception(&self) -> bool {
        matches!(self, Self::InvalidTypeException(_))
    }
    /// Returns `true` if the error kind is `UpdateElasticsearchDomainConfigError::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::LimitExceededException(_))
    }
    /// Returns `true` if the error kind is `UpdateElasticsearchDomainConfigError::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(self, Self::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `UpdateElasticsearchDomainConfigError::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(self, Self::ValidationException(_))
    }
}
impl std::error::Error for UpdateElasticsearchDomainConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BaseException(_inner) =>
            Some(_inner)
            ,
            Self::InternalException(_inner) =>
            Some(_inner)
            ,
            Self::InvalidTypeException(_inner) =>
            Some(_inner)
            ,
            Self::LimitExceededException(_inner) =>
            Some(_inner)
            ,
            Self::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            Self::ValidationException(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// <p>An exception for trying to create or access sub-resource that is either invalid or not supported. Gives http status code of 409.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidTypeException  {
    /// <p>A description of the error.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidTypeException {
    /// Creates a new builder-style object to manufacture [`InvalidTypeException`](crate::error::InvalidTypeException).
    pub fn builder() -> crate::error::invalid_type_exception::Builder {
        crate::error::invalid_type_exception::Builder::default()
    }
}
/// See [`InvalidTypeException`](crate::error::InvalidTypeException).
pub mod invalid_type_exception {
    
    /// A builder for [`InvalidTypeException`](crate::error::InvalidTypeException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A description of the error.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A description of the error.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Sets error metadata
                                            pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
                                                self.meta = Some(meta);
                                                self
                                            }
        
                                            /// Sets error metadata
                                            pub fn set_meta(&mut self, meta: Option<aws_smithy_types::error::ErrorMetadata>) -> &mut Self {
                                                self.meta = meta;
                                                self
                                            }
        /// Consumes the builder and constructs a [`InvalidTypeException`](crate::error::InvalidTypeException).
        pub fn build(self) -> crate::error::InvalidTypeException {
            crate::error::InvalidTypeException {
                message: self.message
                ,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
    
    
}
impl InvalidTypeException {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for InvalidTypeException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidTypeException")?;
        if let Some(inner_10) = &self.message {
             {
                write!(f, ": {}", inner_10)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidTypeException {}
impl aws_http::request_id::RequestId for crate::error::InvalidTypeException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidTypeException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata { &self.meta }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type StartElasticsearchServiceSoftwareUpdateErrorKind = StartElasticsearchServiceSoftwareUpdateError;
/// Error type for the `StartElasticsearchServiceSoftwareUpdateError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartElasticsearchServiceSoftwareUpdateError {
    /// <p>An error occurred while processing the request.</p>
    BaseException(crate::error::BaseException),
    /// <p>The request processing has failed because of an unknown error, exception or failure (the failure is internal to the service) . Gives http status code of 500.</p>
    InternalException(crate::error::InternalException),
    /// <p>An exception for accessing or deleting a resource that does not exist. Gives http status code of 400.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>An exception for missing / invalid input fields. Gives http status code of 400.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for StartElasticsearchServiceSoftwareUpdateError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for StartElasticsearchServiceSoftwareUpdateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BaseException(_inner) =>
            _inner.fmt(f)
            ,
            Self::InternalException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for StartElasticsearchServiceSoftwareUpdateError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BaseException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::InternalException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ResourceNotFoundException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ValidationException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::StartElasticsearchServiceSoftwareUpdateError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for StartElasticsearchServiceSoftwareUpdateError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartElasticsearchServiceSoftwareUpdateError {
    /// Creates the `StartElasticsearchServiceSoftwareUpdateError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `StartElasticsearchServiceSoftwareUpdateError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BaseException(e) => e.meta(),
            Self::InternalException(e) => e.meta(),
            Self::ResourceNotFoundException(e) => e.meta(),
            Self::ValidationException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `StartElasticsearchServiceSoftwareUpdateError::BaseException`.
    pub fn is_base_exception(&self) -> bool {
        matches!(self, Self::BaseException(_))
    }
    /// Returns `true` if the error kind is `StartElasticsearchServiceSoftwareUpdateError::InternalException`.
    pub fn is_internal_exception(&self) -> bool {
        matches!(self, Self::InternalException(_))
    }
    /// Returns `true` if the error kind is `StartElasticsearchServiceSoftwareUpdateError::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(self, Self::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `StartElasticsearchServiceSoftwareUpdateError::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(self, Self::ValidationException(_))
    }
}
impl std::error::Error for StartElasticsearchServiceSoftwareUpdateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BaseException(_inner) =>
            Some(_inner)
            ,
            Self::InternalException(_inner) =>
            Some(_inner)
            ,
            Self::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            Self::ValidationException(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type RevokeVpcEndpointAccessErrorKind = RevokeVpcEndpointAccessError;
/// Error type for the `RevokeVpcEndpointAccessError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RevokeVpcEndpointAccessError {
    /// <p>An error occurred while processing the request.</p>
    BaseException(crate::error::BaseException),
    /// <p>An error occured because the client wanted to access a not supported operation. Gives http status code of 409.</p>
    DisabledOperationException(crate::error::DisabledOperationException),
    /// <p>The request processing has failed because of an unknown error, exception or failure (the failure is internal to the service) . Gives http status code of 500.</p>
    InternalException(crate::error::InternalException),
    /// <p>An exception for accessing or deleting a resource that does not exist. Gives http status code of 400.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>An exception for missing / invalid input fields. Gives http status code of 400.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for RevokeVpcEndpointAccessError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for RevokeVpcEndpointAccessError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BaseException(_inner) =>
            _inner.fmt(f)
            ,
            Self::DisabledOperationException(_inner) =>
            _inner.fmt(f)
            ,
            Self::InternalException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for RevokeVpcEndpointAccessError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BaseException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::DisabledOperationException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::InternalException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ResourceNotFoundException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ValidationException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::RevokeVpcEndpointAccessError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for RevokeVpcEndpointAccessError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl RevokeVpcEndpointAccessError {
    /// Creates the `RevokeVpcEndpointAccessError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `RevokeVpcEndpointAccessError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BaseException(e) => e.meta(),
            Self::DisabledOperationException(e) => e.meta(),
            Self::InternalException(e) => e.meta(),
            Self::ResourceNotFoundException(e) => e.meta(),
            Self::ValidationException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `RevokeVpcEndpointAccessError::BaseException`.
    pub fn is_base_exception(&self) -> bool {
        matches!(self, Self::BaseException(_))
    }
    /// Returns `true` if the error kind is `RevokeVpcEndpointAccessError::DisabledOperationException`.
    pub fn is_disabled_operation_exception(&self) -> bool {
        matches!(self, Self::DisabledOperationException(_))
    }
    /// Returns `true` if the error kind is `RevokeVpcEndpointAccessError::InternalException`.
    pub fn is_internal_exception(&self) -> bool {
        matches!(self, Self::InternalException(_))
    }
    /// Returns `true` if the error kind is `RevokeVpcEndpointAccessError::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(self, Self::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `RevokeVpcEndpointAccessError::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(self, Self::ValidationException(_))
    }
}
impl std::error::Error for RevokeVpcEndpointAccessError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BaseException(_inner) =>
            Some(_inner)
            ,
            Self::DisabledOperationException(_inner) =>
            Some(_inner)
            ,
            Self::InternalException(_inner) =>
            Some(_inner)
            ,
            Self::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            Self::ValidationException(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type RemoveTagsErrorKind = RemoveTagsError;
/// Error type for the `RemoveTagsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RemoveTagsError {
    /// <p>An error occurred while processing the request.</p>
    BaseException(crate::error::BaseException),
    /// <p>The request processing has failed because of an unknown error, exception or failure (the failure is internal to the service) . Gives http status code of 500.</p>
    InternalException(crate::error::InternalException),
    /// <p>An exception for missing / invalid input fields. Gives http status code of 400.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for RemoveTagsError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for RemoveTagsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BaseException(_inner) =>
            _inner.fmt(f)
            ,
            Self::InternalException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for RemoveTagsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BaseException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::InternalException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ValidationException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::RemoveTagsError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for RemoveTagsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl RemoveTagsError {
    /// Creates the `RemoveTagsError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `RemoveTagsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BaseException(e) => e.meta(),
            Self::InternalException(e) => e.meta(),
            Self::ValidationException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `RemoveTagsError::BaseException`.
    pub fn is_base_exception(&self) -> bool {
        matches!(self, Self::BaseException(_))
    }
    /// Returns `true` if the error kind is `RemoveTagsError::InternalException`.
    pub fn is_internal_exception(&self) -> bool {
        matches!(self, Self::InternalException(_))
    }
    /// Returns `true` if the error kind is `RemoveTagsError::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(self, Self::ValidationException(_))
    }
}
impl std::error::Error for RemoveTagsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BaseException(_inner) =>
            Some(_inner)
            ,
            Self::InternalException(_inner) =>
            Some(_inner)
            ,
            Self::ValidationException(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type RejectInboundCrossClusterSearchConnectionErrorKind = RejectInboundCrossClusterSearchConnectionError;
/// Error type for the `RejectInboundCrossClusterSearchConnectionError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RejectInboundCrossClusterSearchConnectionError {
    /// <p>An error occured because the client wanted to access a not supported operation. Gives http status code of 409.</p>
    DisabledOperationException(crate::error::DisabledOperationException),
    /// <p>An exception for accessing or deleting a resource that does not exist. Gives http status code of 400.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for RejectInboundCrossClusterSearchConnectionError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for RejectInboundCrossClusterSearchConnectionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DisabledOperationException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for RejectInboundCrossClusterSearchConnectionError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DisabledOperationException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ResourceNotFoundException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::RejectInboundCrossClusterSearchConnectionError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for RejectInboundCrossClusterSearchConnectionError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl RejectInboundCrossClusterSearchConnectionError {
    /// Creates the `RejectInboundCrossClusterSearchConnectionError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `RejectInboundCrossClusterSearchConnectionError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DisabledOperationException(e) => e.meta(),
            Self::ResourceNotFoundException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `RejectInboundCrossClusterSearchConnectionError::DisabledOperationException`.
    pub fn is_disabled_operation_exception(&self) -> bool {
        matches!(self, Self::DisabledOperationException(_))
    }
    /// Returns `true` if the error kind is `RejectInboundCrossClusterSearchConnectionError::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(self, Self::ResourceNotFoundException(_))
    }
}
impl std::error::Error for RejectInboundCrossClusterSearchConnectionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DisabledOperationException(_inner) =>
            Some(_inner)
            ,
            Self::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type PurchaseReservedElasticsearchInstanceOfferingErrorKind = PurchaseReservedElasticsearchInstanceOfferingError;
/// Error type for the `PurchaseReservedElasticsearchInstanceOfferingError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PurchaseReservedElasticsearchInstanceOfferingError {
    /// <p>An error occured because the client wanted to access a not supported operation. Gives http status code of 409.</p>
    DisabledOperationException(crate::error::DisabledOperationException),
    /// <p>The request processing has failed because of an unknown error, exception or failure (the failure is internal to the service) . Gives http status code of 500.</p>
    InternalException(crate::error::InternalException),
    /// <p>An exception for trying to create more than allowed resources or sub-resources. Gives http status code of 409.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>An exception for creating a resource that already exists. Gives http status code of 400.</p>
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    /// <p>An exception for accessing or deleting a resource that does not exist. Gives http status code of 400.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>An exception for missing / invalid input fields. Gives http status code of 400.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for PurchaseReservedElasticsearchInstanceOfferingError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for PurchaseReservedElasticsearchInstanceOfferingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DisabledOperationException(_inner) =>
            _inner.fmt(f)
            ,
            Self::InternalException(_inner) =>
            _inner.fmt(f)
            ,
            Self::LimitExceededException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ResourceAlreadyExistsException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for PurchaseReservedElasticsearchInstanceOfferingError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DisabledOperationException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::InternalException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::LimitExceededException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ResourceAlreadyExistsException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ResourceNotFoundException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ValidationException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::PurchaseReservedElasticsearchInstanceOfferingError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for PurchaseReservedElasticsearchInstanceOfferingError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl PurchaseReservedElasticsearchInstanceOfferingError {
    /// Creates the `PurchaseReservedElasticsearchInstanceOfferingError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `PurchaseReservedElasticsearchInstanceOfferingError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DisabledOperationException(e) => e.meta(),
            Self::InternalException(e) => e.meta(),
            Self::LimitExceededException(e) => e.meta(),
            Self::ResourceAlreadyExistsException(e) => e.meta(),
            Self::ResourceNotFoundException(e) => e.meta(),
            Self::ValidationException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `PurchaseReservedElasticsearchInstanceOfferingError::DisabledOperationException`.
    pub fn is_disabled_operation_exception(&self) -> bool {
        matches!(self, Self::DisabledOperationException(_))
    }
    /// Returns `true` if the error kind is `PurchaseReservedElasticsearchInstanceOfferingError::InternalException`.
    pub fn is_internal_exception(&self) -> bool {
        matches!(self, Self::InternalException(_))
    }
    /// Returns `true` if the error kind is `PurchaseReservedElasticsearchInstanceOfferingError::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::LimitExceededException(_))
    }
    /// Returns `true` if the error kind is `PurchaseReservedElasticsearchInstanceOfferingError::ResourceAlreadyExistsException`.
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(self, Self::ResourceAlreadyExistsException(_))
    }
    /// Returns `true` if the error kind is `PurchaseReservedElasticsearchInstanceOfferingError::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(self, Self::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `PurchaseReservedElasticsearchInstanceOfferingError::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(self, Self::ValidationException(_))
    }
}
impl std::error::Error for PurchaseReservedElasticsearchInstanceOfferingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DisabledOperationException(_inner) =>
            Some(_inner)
            ,
            Self::InternalException(_inner) =>
            Some(_inner)
            ,
            Self::LimitExceededException(_inner) =>
            Some(_inner)
            ,
            Self::ResourceAlreadyExistsException(_inner) =>
            Some(_inner)
            ,
            Self::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            Self::ValidationException(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type ListVpcEndpointsForDomainErrorKind = ListVpcEndpointsForDomainError;
/// Error type for the `ListVpcEndpointsForDomainError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListVpcEndpointsForDomainError {
    /// <p>An error occurred while processing the request.</p>
    BaseException(crate::error::BaseException),
    /// <p>An error occured because the client wanted to access a not supported operation. Gives http status code of 409.</p>
    DisabledOperationException(crate::error::DisabledOperationException),
    /// <p>The request processing has failed because of an unknown error, exception or failure (the failure is internal to the service) . Gives http status code of 500.</p>
    InternalException(crate::error::InternalException),
    /// <p>An exception for accessing or deleting a resource that does not exist. Gives http status code of 400.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListVpcEndpointsForDomainError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for ListVpcEndpointsForDomainError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BaseException(_inner) =>
            _inner.fmt(f)
            ,
            Self::DisabledOperationException(_inner) =>
            _inner.fmt(f)
            ,
            Self::InternalException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListVpcEndpointsForDomainError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BaseException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::DisabledOperationException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::InternalException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ResourceNotFoundException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListVpcEndpointsForDomainError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for ListVpcEndpointsForDomainError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListVpcEndpointsForDomainError {
    /// Creates the `ListVpcEndpointsForDomainError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `ListVpcEndpointsForDomainError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BaseException(e) => e.meta(),
            Self::DisabledOperationException(e) => e.meta(),
            Self::InternalException(e) => e.meta(),
            Self::ResourceNotFoundException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListVpcEndpointsForDomainError::BaseException`.
    pub fn is_base_exception(&self) -> bool {
        matches!(self, Self::BaseException(_))
    }
    /// Returns `true` if the error kind is `ListVpcEndpointsForDomainError::DisabledOperationException`.
    pub fn is_disabled_operation_exception(&self) -> bool {
        matches!(self, Self::DisabledOperationException(_))
    }
    /// Returns `true` if the error kind is `ListVpcEndpointsForDomainError::InternalException`.
    pub fn is_internal_exception(&self) -> bool {
        matches!(self, Self::InternalException(_))
    }
    /// Returns `true` if the error kind is `ListVpcEndpointsForDomainError::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(self, Self::ResourceNotFoundException(_))
    }
}
impl std::error::Error for ListVpcEndpointsForDomainError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BaseException(_inner) =>
            Some(_inner)
            ,
            Self::DisabledOperationException(_inner) =>
            Some(_inner)
            ,
            Self::InternalException(_inner) =>
            Some(_inner)
            ,
            Self::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type ListVpcEndpointsErrorKind = ListVpcEndpointsError;
/// Error type for the `ListVpcEndpointsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListVpcEndpointsError {
    /// <p>An error occurred while processing the request.</p>
    BaseException(crate::error::BaseException),
    /// <p>An error occured because the client wanted to access a not supported operation. Gives http status code of 409.</p>
    DisabledOperationException(crate::error::DisabledOperationException),
    /// <p>The request processing has failed because of an unknown error, exception or failure (the failure is internal to the service) . Gives http status code of 500.</p>
    InternalException(crate::error::InternalException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListVpcEndpointsError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for ListVpcEndpointsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BaseException(_inner) =>
            _inner.fmt(f)
            ,
            Self::DisabledOperationException(_inner) =>
            _inner.fmt(f)
            ,
            Self::InternalException(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListVpcEndpointsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BaseException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::DisabledOperationException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::InternalException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListVpcEndpointsError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for ListVpcEndpointsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListVpcEndpointsError {
    /// Creates the `ListVpcEndpointsError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `ListVpcEndpointsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BaseException(e) => e.meta(),
            Self::DisabledOperationException(e) => e.meta(),
            Self::InternalException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListVpcEndpointsError::BaseException`.
    pub fn is_base_exception(&self) -> bool {
        matches!(self, Self::BaseException(_))
    }
    /// Returns `true` if the error kind is `ListVpcEndpointsError::DisabledOperationException`.
    pub fn is_disabled_operation_exception(&self) -> bool {
        matches!(self, Self::DisabledOperationException(_))
    }
    /// Returns `true` if the error kind is `ListVpcEndpointsError::InternalException`.
    pub fn is_internal_exception(&self) -> bool {
        matches!(self, Self::InternalException(_))
    }
}
impl std::error::Error for ListVpcEndpointsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BaseException(_inner) =>
            Some(_inner)
            ,
            Self::DisabledOperationException(_inner) =>
            Some(_inner)
            ,
            Self::InternalException(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type ListVpcEndpointAccessErrorKind = ListVpcEndpointAccessError;
/// Error type for the `ListVpcEndpointAccessError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListVpcEndpointAccessError {
    /// <p>An error occurred while processing the request.</p>
    BaseException(crate::error::BaseException),
    /// <p>An error occured because the client wanted to access a not supported operation. Gives http status code of 409.</p>
    DisabledOperationException(crate::error::DisabledOperationException),
    /// <p>The request processing has failed because of an unknown error, exception or failure (the failure is internal to the service) . Gives http status code of 500.</p>
    InternalException(crate::error::InternalException),
    /// <p>An exception for accessing or deleting a resource that does not exist. Gives http status code of 400.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListVpcEndpointAccessError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for ListVpcEndpointAccessError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BaseException(_inner) =>
            _inner.fmt(f)
            ,
            Self::DisabledOperationException(_inner) =>
            _inner.fmt(f)
            ,
            Self::InternalException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListVpcEndpointAccessError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BaseException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::DisabledOperationException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::InternalException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ResourceNotFoundException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListVpcEndpointAccessError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for ListVpcEndpointAccessError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListVpcEndpointAccessError {
    /// Creates the `ListVpcEndpointAccessError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `ListVpcEndpointAccessError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BaseException(e) => e.meta(),
            Self::DisabledOperationException(e) => e.meta(),
            Self::InternalException(e) => e.meta(),
            Self::ResourceNotFoundException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListVpcEndpointAccessError::BaseException`.
    pub fn is_base_exception(&self) -> bool {
        matches!(self, Self::BaseException(_))
    }
    /// Returns `true` if the error kind is `ListVpcEndpointAccessError::DisabledOperationException`.
    pub fn is_disabled_operation_exception(&self) -> bool {
        matches!(self, Self::DisabledOperationException(_))
    }
    /// Returns `true` if the error kind is `ListVpcEndpointAccessError::InternalException`.
    pub fn is_internal_exception(&self) -> bool {
        matches!(self, Self::InternalException(_))
    }
    /// Returns `true` if the error kind is `ListVpcEndpointAccessError::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(self, Self::ResourceNotFoundException(_))
    }
}
impl std::error::Error for ListVpcEndpointAccessError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BaseException(_inner) =>
            Some(_inner)
            ,
            Self::DisabledOperationException(_inner) =>
            Some(_inner)
            ,
            Self::InternalException(_inner) =>
            Some(_inner)
            ,
            Self::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type ListTagsErrorKind = ListTagsError;
/// Error type for the `ListTagsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTagsError {
    /// <p>An error occurred while processing the request.</p>
    BaseException(crate::error::BaseException),
    /// <p>The request processing has failed because of an unknown error, exception or failure (the failure is internal to the service) . Gives http status code of 500.</p>
    InternalException(crate::error::InternalException),
    /// <p>An exception for accessing or deleting a resource that does not exist. Gives http status code of 400.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>An exception for missing / invalid input fields. Gives http status code of 400.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListTagsError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for ListTagsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BaseException(_inner) =>
            _inner.fmt(f)
            ,
            Self::InternalException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListTagsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BaseException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::InternalException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ResourceNotFoundException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ValidationException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListTagsError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for ListTagsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTagsError {
    /// Creates the `ListTagsError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `ListTagsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BaseException(e) => e.meta(),
            Self::InternalException(e) => e.meta(),
            Self::ResourceNotFoundException(e) => e.meta(),
            Self::ValidationException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListTagsError::BaseException`.
    pub fn is_base_exception(&self) -> bool {
        matches!(self, Self::BaseException(_))
    }
    /// Returns `true` if the error kind is `ListTagsError::InternalException`.
    pub fn is_internal_exception(&self) -> bool {
        matches!(self, Self::InternalException(_))
    }
    /// Returns `true` if the error kind is `ListTagsError::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(self, Self::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `ListTagsError::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(self, Self::ValidationException(_))
    }
}
impl std::error::Error for ListTagsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BaseException(_inner) =>
            Some(_inner)
            ,
            Self::InternalException(_inner) =>
            Some(_inner)
            ,
            Self::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            Self::ValidationException(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type ListPackagesForDomainErrorKind = ListPackagesForDomainError;
/// Error type for the `ListPackagesForDomainError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListPackagesForDomainError {
    /// <p>An error occurred because user does not have permissions to access the resource. Returns HTTP status code 403.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>An error occurred while processing the request.</p>
    BaseException(crate::error::BaseException),
    /// <p>The request processing has failed because of an unknown error, exception or failure (the failure is internal to the service) . Gives http status code of 500.</p>
    InternalException(crate::error::InternalException),
    /// <p>An exception for accessing or deleting a resource that does not exist. Gives http status code of 400.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>An exception for missing / invalid input fields. Gives http status code of 400.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListPackagesForDomainError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for ListPackagesForDomainError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            Self::BaseException(_inner) =>
            _inner.fmt(f)
            ,
            Self::InternalException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListPackagesForDomainError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDeniedException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::BaseException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::InternalException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ResourceNotFoundException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ValidationException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListPackagesForDomainError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for ListPackagesForDomainError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListPackagesForDomainError {
    /// Creates the `ListPackagesForDomainError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `ListPackagesForDomainError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDeniedException(e) => e.meta(),
            Self::BaseException(e) => e.meta(),
            Self::InternalException(e) => e.meta(),
            Self::ResourceNotFoundException(e) => e.meta(),
            Self::ValidationException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListPackagesForDomainError::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(self, Self::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `ListPackagesForDomainError::BaseException`.
    pub fn is_base_exception(&self) -> bool {
        matches!(self, Self::BaseException(_))
    }
    /// Returns `true` if the error kind is `ListPackagesForDomainError::InternalException`.
    pub fn is_internal_exception(&self) -> bool {
        matches!(self, Self::InternalException(_))
    }
    /// Returns `true` if the error kind is `ListPackagesForDomainError::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(self, Self::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `ListPackagesForDomainError::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(self, Self::ValidationException(_))
    }
}
impl std::error::Error for ListPackagesForDomainError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            Self::BaseException(_inner) =>
            Some(_inner)
            ,
            Self::InternalException(_inner) =>
            Some(_inner)
            ,
            Self::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            Self::ValidationException(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type ListElasticsearchVersionsErrorKind = ListElasticsearchVersionsError;
/// Error type for the `ListElasticsearchVersionsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListElasticsearchVersionsError {
    /// <p>An error occurred while processing the request.</p>
    BaseException(crate::error::BaseException),
    /// <p>The request processing has failed because of an unknown error, exception or failure (the failure is internal to the service) . Gives http status code of 500.</p>
    InternalException(crate::error::InternalException),
    /// <p>An exception for accessing or deleting a resource that does not exist. Gives http status code of 400.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>An exception for missing / invalid input fields. Gives http status code of 400.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListElasticsearchVersionsError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for ListElasticsearchVersionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BaseException(_inner) =>
            _inner.fmt(f)
            ,
            Self::InternalException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListElasticsearchVersionsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BaseException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::InternalException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ResourceNotFoundException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ValidationException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListElasticsearchVersionsError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for ListElasticsearchVersionsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListElasticsearchVersionsError {
    /// Creates the `ListElasticsearchVersionsError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `ListElasticsearchVersionsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BaseException(e) => e.meta(),
            Self::InternalException(e) => e.meta(),
            Self::ResourceNotFoundException(e) => e.meta(),
            Self::ValidationException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListElasticsearchVersionsError::BaseException`.
    pub fn is_base_exception(&self) -> bool {
        matches!(self, Self::BaseException(_))
    }
    /// Returns `true` if the error kind is `ListElasticsearchVersionsError::InternalException`.
    pub fn is_internal_exception(&self) -> bool {
        matches!(self, Self::InternalException(_))
    }
    /// Returns `true` if the error kind is `ListElasticsearchVersionsError::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(self, Self::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `ListElasticsearchVersionsError::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(self, Self::ValidationException(_))
    }
}
impl std::error::Error for ListElasticsearchVersionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BaseException(_inner) =>
            Some(_inner)
            ,
            Self::InternalException(_inner) =>
            Some(_inner)
            ,
            Self::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            Self::ValidationException(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type ListElasticsearchInstanceTypesErrorKind = ListElasticsearchInstanceTypesError;
/// Error type for the `ListElasticsearchInstanceTypesError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListElasticsearchInstanceTypesError {
    /// <p>An error occurred while processing the request.</p>
    BaseException(crate::error::BaseException),
    /// <p>The request processing has failed because of an unknown error, exception or failure (the failure is internal to the service) . Gives http status code of 500.</p>
    InternalException(crate::error::InternalException),
    /// <p>An exception for accessing or deleting a resource that does not exist. Gives http status code of 400.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>An exception for missing / invalid input fields. Gives http status code of 400.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListElasticsearchInstanceTypesError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for ListElasticsearchInstanceTypesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BaseException(_inner) =>
            _inner.fmt(f)
            ,
            Self::InternalException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListElasticsearchInstanceTypesError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BaseException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::InternalException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ResourceNotFoundException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ValidationException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListElasticsearchInstanceTypesError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for ListElasticsearchInstanceTypesError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListElasticsearchInstanceTypesError {
    /// Creates the `ListElasticsearchInstanceTypesError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `ListElasticsearchInstanceTypesError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BaseException(e) => e.meta(),
            Self::InternalException(e) => e.meta(),
            Self::ResourceNotFoundException(e) => e.meta(),
            Self::ValidationException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListElasticsearchInstanceTypesError::BaseException`.
    pub fn is_base_exception(&self) -> bool {
        matches!(self, Self::BaseException(_))
    }
    /// Returns `true` if the error kind is `ListElasticsearchInstanceTypesError::InternalException`.
    pub fn is_internal_exception(&self) -> bool {
        matches!(self, Self::InternalException(_))
    }
    /// Returns `true` if the error kind is `ListElasticsearchInstanceTypesError::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(self, Self::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `ListElasticsearchInstanceTypesError::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(self, Self::ValidationException(_))
    }
}
impl std::error::Error for ListElasticsearchInstanceTypesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BaseException(_inner) =>
            Some(_inner)
            ,
            Self::InternalException(_inner) =>
            Some(_inner)
            ,
            Self::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            Self::ValidationException(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type ListDomainsForPackageErrorKind = ListDomainsForPackageError;
/// Error type for the `ListDomainsForPackageError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListDomainsForPackageError {
    /// <p>An error occurred because user does not have permissions to access the resource. Returns HTTP status code 403.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>An error occurred while processing the request.</p>
    BaseException(crate::error::BaseException),
    /// <p>The request processing has failed because of an unknown error, exception or failure (the failure is internal to the service) . Gives http status code of 500.</p>
    InternalException(crate::error::InternalException),
    /// <p>An exception for accessing or deleting a resource that does not exist. Gives http status code of 400.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>An exception for missing / invalid input fields. Gives http status code of 400.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListDomainsForPackageError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for ListDomainsForPackageError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            Self::BaseException(_inner) =>
            _inner.fmt(f)
            ,
            Self::InternalException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListDomainsForPackageError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDeniedException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::BaseException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::InternalException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ResourceNotFoundException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ValidationException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListDomainsForPackageError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for ListDomainsForPackageError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListDomainsForPackageError {
    /// Creates the `ListDomainsForPackageError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `ListDomainsForPackageError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDeniedException(e) => e.meta(),
            Self::BaseException(e) => e.meta(),
            Self::InternalException(e) => e.meta(),
            Self::ResourceNotFoundException(e) => e.meta(),
            Self::ValidationException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListDomainsForPackageError::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(self, Self::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `ListDomainsForPackageError::BaseException`.
    pub fn is_base_exception(&self) -> bool {
        matches!(self, Self::BaseException(_))
    }
    /// Returns `true` if the error kind is `ListDomainsForPackageError::InternalException`.
    pub fn is_internal_exception(&self) -> bool {
        matches!(self, Self::InternalException(_))
    }
    /// Returns `true` if the error kind is `ListDomainsForPackageError::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(self, Self::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `ListDomainsForPackageError::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(self, Self::ValidationException(_))
    }
}
impl std::error::Error for ListDomainsForPackageError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            Self::BaseException(_inner) =>
            Some(_inner)
            ,
            Self::InternalException(_inner) =>
            Some(_inner)
            ,
            Self::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            Self::ValidationException(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type ListDomainNamesErrorKind = ListDomainNamesError;
/// Error type for the `ListDomainNamesError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListDomainNamesError {
    /// <p>An error occurred while processing the request.</p>
    BaseException(crate::error::BaseException),
    /// <p>An exception for missing / invalid input fields. Gives http status code of 400.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListDomainNamesError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for ListDomainNamesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BaseException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListDomainNamesError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BaseException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ValidationException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListDomainNamesError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for ListDomainNamesError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListDomainNamesError {
    /// Creates the `ListDomainNamesError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `ListDomainNamesError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BaseException(e) => e.meta(),
            Self::ValidationException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListDomainNamesError::BaseException`.
    pub fn is_base_exception(&self) -> bool {
        matches!(self, Self::BaseException(_))
    }
    /// Returns `true` if the error kind is `ListDomainNamesError::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(self, Self::ValidationException(_))
    }
}
impl std::error::Error for ListDomainNamesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BaseException(_inner) =>
            Some(_inner)
            ,
            Self::ValidationException(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type GetUpgradeStatusErrorKind = GetUpgradeStatusError;
/// Error type for the `GetUpgradeStatusError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetUpgradeStatusError {
    /// <p>An error occurred while processing the request.</p>
    BaseException(crate::error::BaseException),
    /// <p>An error occured because the client wanted to access a not supported operation. Gives http status code of 409.</p>
    DisabledOperationException(crate::error::DisabledOperationException),
    /// <p>The request processing has failed because of an unknown error, exception or failure (the failure is internal to the service) . Gives http status code of 500.</p>
    InternalException(crate::error::InternalException),
    /// <p>An exception for accessing or deleting a resource that does not exist. Gives http status code of 400.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>An exception for missing / invalid input fields. Gives http status code of 400.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetUpgradeStatusError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for GetUpgradeStatusError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BaseException(_inner) =>
            _inner.fmt(f)
            ,
            Self::DisabledOperationException(_inner) =>
            _inner.fmt(f)
            ,
            Self::InternalException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetUpgradeStatusError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BaseException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::DisabledOperationException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::InternalException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ResourceNotFoundException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ValidationException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetUpgradeStatusError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for GetUpgradeStatusError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetUpgradeStatusError {
    /// Creates the `GetUpgradeStatusError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `GetUpgradeStatusError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BaseException(e) => e.meta(),
            Self::DisabledOperationException(e) => e.meta(),
            Self::InternalException(e) => e.meta(),
            Self::ResourceNotFoundException(e) => e.meta(),
            Self::ValidationException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetUpgradeStatusError::BaseException`.
    pub fn is_base_exception(&self) -> bool {
        matches!(self, Self::BaseException(_))
    }
    /// Returns `true` if the error kind is `GetUpgradeStatusError::DisabledOperationException`.
    pub fn is_disabled_operation_exception(&self) -> bool {
        matches!(self, Self::DisabledOperationException(_))
    }
    /// Returns `true` if the error kind is `GetUpgradeStatusError::InternalException`.
    pub fn is_internal_exception(&self) -> bool {
        matches!(self, Self::InternalException(_))
    }
    /// Returns `true` if the error kind is `GetUpgradeStatusError::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(self, Self::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `GetUpgradeStatusError::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(self, Self::ValidationException(_))
    }
}
impl std::error::Error for GetUpgradeStatusError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BaseException(_inner) =>
            Some(_inner)
            ,
            Self::DisabledOperationException(_inner) =>
            Some(_inner)
            ,
            Self::InternalException(_inner) =>
            Some(_inner)
            ,
            Self::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            Self::ValidationException(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type GetUpgradeHistoryErrorKind = GetUpgradeHistoryError;
/// Error type for the `GetUpgradeHistoryError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetUpgradeHistoryError {
    /// <p>An error occurred while processing the request.</p>
    BaseException(crate::error::BaseException),
    /// <p>An error occured because the client wanted to access a not supported operation. Gives http status code of 409.</p>
    DisabledOperationException(crate::error::DisabledOperationException),
    /// <p>The request processing has failed because of an unknown error, exception or failure (the failure is internal to the service) . Gives http status code of 500.</p>
    InternalException(crate::error::InternalException),
    /// <p>An exception for accessing or deleting a resource that does not exist. Gives http status code of 400.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>An exception for missing / invalid input fields. Gives http status code of 400.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetUpgradeHistoryError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for GetUpgradeHistoryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BaseException(_inner) =>
            _inner.fmt(f)
            ,
            Self::DisabledOperationException(_inner) =>
            _inner.fmt(f)
            ,
            Self::InternalException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetUpgradeHistoryError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BaseException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::DisabledOperationException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::InternalException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ResourceNotFoundException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ValidationException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetUpgradeHistoryError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for GetUpgradeHistoryError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetUpgradeHistoryError {
    /// Creates the `GetUpgradeHistoryError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `GetUpgradeHistoryError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BaseException(e) => e.meta(),
            Self::DisabledOperationException(e) => e.meta(),
            Self::InternalException(e) => e.meta(),
            Self::ResourceNotFoundException(e) => e.meta(),
            Self::ValidationException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetUpgradeHistoryError::BaseException`.
    pub fn is_base_exception(&self) -> bool {
        matches!(self, Self::BaseException(_))
    }
    /// Returns `true` if the error kind is `GetUpgradeHistoryError::DisabledOperationException`.
    pub fn is_disabled_operation_exception(&self) -> bool {
        matches!(self, Self::DisabledOperationException(_))
    }
    /// Returns `true` if the error kind is `GetUpgradeHistoryError::InternalException`.
    pub fn is_internal_exception(&self) -> bool {
        matches!(self, Self::InternalException(_))
    }
    /// Returns `true` if the error kind is `GetUpgradeHistoryError::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(self, Self::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `GetUpgradeHistoryError::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(self, Self::ValidationException(_))
    }
}
impl std::error::Error for GetUpgradeHistoryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BaseException(_inner) =>
            Some(_inner)
            ,
            Self::DisabledOperationException(_inner) =>
            Some(_inner)
            ,
            Self::InternalException(_inner) =>
            Some(_inner)
            ,
            Self::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            Self::ValidationException(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type GetPackageVersionHistoryErrorKind = GetPackageVersionHistoryError;
/// Error type for the `GetPackageVersionHistoryError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetPackageVersionHistoryError {
    /// <p>An error occurred because user does not have permissions to access the resource. Returns HTTP status code 403.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>An error occurred while processing the request.</p>
    BaseException(crate::error::BaseException),
    /// <p>The request processing has failed because of an unknown error, exception or failure (the failure is internal to the service) . Gives http status code of 500.</p>
    InternalException(crate::error::InternalException),
    /// <p>An exception for accessing or deleting a resource that does not exist. Gives http status code of 400.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>An exception for missing / invalid input fields. Gives http status code of 400.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetPackageVersionHistoryError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for GetPackageVersionHistoryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            Self::BaseException(_inner) =>
            _inner.fmt(f)
            ,
            Self::InternalException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetPackageVersionHistoryError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDeniedException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::BaseException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::InternalException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ResourceNotFoundException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ValidationException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetPackageVersionHistoryError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for GetPackageVersionHistoryError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetPackageVersionHistoryError {
    /// Creates the `GetPackageVersionHistoryError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `GetPackageVersionHistoryError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDeniedException(e) => e.meta(),
            Self::BaseException(e) => e.meta(),
            Self::InternalException(e) => e.meta(),
            Self::ResourceNotFoundException(e) => e.meta(),
            Self::ValidationException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetPackageVersionHistoryError::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(self, Self::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `GetPackageVersionHistoryError::BaseException`.
    pub fn is_base_exception(&self) -> bool {
        matches!(self, Self::BaseException(_))
    }
    /// Returns `true` if the error kind is `GetPackageVersionHistoryError::InternalException`.
    pub fn is_internal_exception(&self) -> bool {
        matches!(self, Self::InternalException(_))
    }
    /// Returns `true` if the error kind is `GetPackageVersionHistoryError::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(self, Self::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `GetPackageVersionHistoryError::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(self, Self::ValidationException(_))
    }
}
impl std::error::Error for GetPackageVersionHistoryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            Self::BaseException(_inner) =>
            Some(_inner)
            ,
            Self::InternalException(_inner) =>
            Some(_inner)
            ,
            Self::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            Self::ValidationException(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type GetCompatibleElasticsearchVersionsErrorKind = GetCompatibleElasticsearchVersionsError;
/// Error type for the `GetCompatibleElasticsearchVersionsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetCompatibleElasticsearchVersionsError {
    /// <p>An error occurred while processing the request.</p>
    BaseException(crate::error::BaseException),
    /// <p>An error occured because the client wanted to access a not supported operation. Gives http status code of 409.</p>
    DisabledOperationException(crate::error::DisabledOperationException),
    /// <p>The request processing has failed because of an unknown error, exception or failure (the failure is internal to the service) . Gives http status code of 500.</p>
    InternalException(crate::error::InternalException),
    /// <p>An exception for accessing or deleting a resource that does not exist. Gives http status code of 400.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>An exception for missing / invalid input fields. Gives http status code of 400.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetCompatibleElasticsearchVersionsError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for GetCompatibleElasticsearchVersionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BaseException(_inner) =>
            _inner.fmt(f)
            ,
            Self::DisabledOperationException(_inner) =>
            _inner.fmt(f)
            ,
            Self::InternalException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetCompatibleElasticsearchVersionsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BaseException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::DisabledOperationException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::InternalException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ResourceNotFoundException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ValidationException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetCompatibleElasticsearchVersionsError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for GetCompatibleElasticsearchVersionsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetCompatibleElasticsearchVersionsError {
    /// Creates the `GetCompatibleElasticsearchVersionsError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `GetCompatibleElasticsearchVersionsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BaseException(e) => e.meta(),
            Self::DisabledOperationException(e) => e.meta(),
            Self::InternalException(e) => e.meta(),
            Self::ResourceNotFoundException(e) => e.meta(),
            Self::ValidationException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetCompatibleElasticsearchVersionsError::BaseException`.
    pub fn is_base_exception(&self) -> bool {
        matches!(self, Self::BaseException(_))
    }
    /// Returns `true` if the error kind is `GetCompatibleElasticsearchVersionsError::DisabledOperationException`.
    pub fn is_disabled_operation_exception(&self) -> bool {
        matches!(self, Self::DisabledOperationException(_))
    }
    /// Returns `true` if the error kind is `GetCompatibleElasticsearchVersionsError::InternalException`.
    pub fn is_internal_exception(&self) -> bool {
        matches!(self, Self::InternalException(_))
    }
    /// Returns `true` if the error kind is `GetCompatibleElasticsearchVersionsError::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(self, Self::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `GetCompatibleElasticsearchVersionsError::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(self, Self::ValidationException(_))
    }
}
impl std::error::Error for GetCompatibleElasticsearchVersionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BaseException(_inner) =>
            Some(_inner)
            ,
            Self::DisabledOperationException(_inner) =>
            Some(_inner)
            ,
            Self::InternalException(_inner) =>
            Some(_inner)
            ,
            Self::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            Self::ValidationException(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type DissociatePackageErrorKind = DissociatePackageError;
/// Error type for the `DissociatePackageError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DissociatePackageError {
    /// <p>An error occurred because user does not have permissions to access the resource. Returns HTTP status code 403.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>An error occurred while processing the request.</p>
    BaseException(crate::error::BaseException),
    /// <p>An error occurred because the client attempts to remove a resource that is currently in use. Returns HTTP status code 409.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>The request processing has failed because of an unknown error, exception or failure (the failure is internal to the service) . Gives http status code of 500.</p>
    InternalException(crate::error::InternalException),
    /// <p>An exception for accessing or deleting a resource that does not exist. Gives http status code of 400.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>An exception for missing / invalid input fields. Gives http status code of 400.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DissociatePackageError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for DissociatePackageError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            Self::BaseException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ConflictException(_inner) =>
            _inner.fmt(f)
            ,
            Self::InternalException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DissociatePackageError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDeniedException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::BaseException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ConflictException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::InternalException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ResourceNotFoundException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ValidationException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DissociatePackageError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for DissociatePackageError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DissociatePackageError {
    /// Creates the `DissociatePackageError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `DissociatePackageError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDeniedException(e) => e.meta(),
            Self::BaseException(e) => e.meta(),
            Self::ConflictException(e) => e.meta(),
            Self::InternalException(e) => e.meta(),
            Self::ResourceNotFoundException(e) => e.meta(),
            Self::ValidationException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DissociatePackageError::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(self, Self::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `DissociatePackageError::BaseException`.
    pub fn is_base_exception(&self) -> bool {
        matches!(self, Self::BaseException(_))
    }
    /// Returns `true` if the error kind is `DissociatePackageError::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(self, Self::ConflictException(_))
    }
    /// Returns `true` if the error kind is `DissociatePackageError::InternalException`.
    pub fn is_internal_exception(&self) -> bool {
        matches!(self, Self::InternalException(_))
    }
    /// Returns `true` if the error kind is `DissociatePackageError::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(self, Self::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `DissociatePackageError::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(self, Self::ValidationException(_))
    }
}
impl std::error::Error for DissociatePackageError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            Self::BaseException(_inner) =>
            Some(_inner)
            ,
            Self::ConflictException(_inner) =>
            Some(_inner)
            ,
            Self::InternalException(_inner) =>
            Some(_inner)
            ,
            Self::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            Self::ValidationException(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type DescribeVpcEndpointsErrorKind = DescribeVpcEndpointsError;
/// Error type for the `DescribeVpcEndpointsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeVpcEndpointsError {
    /// <p>An error occurred while processing the request.</p>
    BaseException(crate::error::BaseException),
    /// <p>An error occured because the client wanted to access a not supported operation. Gives http status code of 409.</p>
    DisabledOperationException(crate::error::DisabledOperationException),
    /// <p>The request processing has failed because of an unknown error, exception or failure (the failure is internal to the service) . Gives http status code of 500.</p>
    InternalException(crate::error::InternalException),
    /// <p>An exception for missing / invalid input fields. Gives http status code of 400.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeVpcEndpointsError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for DescribeVpcEndpointsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BaseException(_inner) =>
            _inner.fmt(f)
            ,
            Self::DisabledOperationException(_inner) =>
            _inner.fmt(f)
            ,
            Self::InternalException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeVpcEndpointsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BaseException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::DisabledOperationException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::InternalException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ValidationException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeVpcEndpointsError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for DescribeVpcEndpointsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeVpcEndpointsError {
    /// Creates the `DescribeVpcEndpointsError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `DescribeVpcEndpointsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BaseException(e) => e.meta(),
            Self::DisabledOperationException(e) => e.meta(),
            Self::InternalException(e) => e.meta(),
            Self::ValidationException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeVpcEndpointsError::BaseException`.
    pub fn is_base_exception(&self) -> bool {
        matches!(self, Self::BaseException(_))
    }
    /// Returns `true` if the error kind is `DescribeVpcEndpointsError::DisabledOperationException`.
    pub fn is_disabled_operation_exception(&self) -> bool {
        matches!(self, Self::DisabledOperationException(_))
    }
    /// Returns `true` if the error kind is `DescribeVpcEndpointsError::InternalException`.
    pub fn is_internal_exception(&self) -> bool {
        matches!(self, Self::InternalException(_))
    }
    /// Returns `true` if the error kind is `DescribeVpcEndpointsError::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(self, Self::ValidationException(_))
    }
}
impl std::error::Error for DescribeVpcEndpointsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BaseException(_inner) =>
            Some(_inner)
            ,
            Self::DisabledOperationException(_inner) =>
            Some(_inner)
            ,
            Self::InternalException(_inner) =>
            Some(_inner)
            ,
            Self::ValidationException(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type DescribeReservedElasticsearchInstancesErrorKind = DescribeReservedElasticsearchInstancesError;
/// Error type for the `DescribeReservedElasticsearchInstancesError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeReservedElasticsearchInstancesError {
    /// <p>An error occured because the client wanted to access a not supported operation. Gives http status code of 409.</p>
    DisabledOperationException(crate::error::DisabledOperationException),
    /// <p>The request processing has failed because of an unknown error, exception or failure (the failure is internal to the service) . Gives http status code of 500.</p>
    InternalException(crate::error::InternalException),
    /// <p>An exception for accessing or deleting a resource that does not exist. Gives http status code of 400.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>An exception for missing / invalid input fields. Gives http status code of 400.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeReservedElasticsearchInstancesError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for DescribeReservedElasticsearchInstancesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DisabledOperationException(_inner) =>
            _inner.fmt(f)
            ,
            Self::InternalException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeReservedElasticsearchInstancesError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DisabledOperationException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::InternalException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ResourceNotFoundException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ValidationException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeReservedElasticsearchInstancesError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for DescribeReservedElasticsearchInstancesError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeReservedElasticsearchInstancesError {
    /// Creates the `DescribeReservedElasticsearchInstancesError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `DescribeReservedElasticsearchInstancesError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DisabledOperationException(e) => e.meta(),
            Self::InternalException(e) => e.meta(),
            Self::ResourceNotFoundException(e) => e.meta(),
            Self::ValidationException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeReservedElasticsearchInstancesError::DisabledOperationException`.
    pub fn is_disabled_operation_exception(&self) -> bool {
        matches!(self, Self::DisabledOperationException(_))
    }
    /// Returns `true` if the error kind is `DescribeReservedElasticsearchInstancesError::InternalException`.
    pub fn is_internal_exception(&self) -> bool {
        matches!(self, Self::InternalException(_))
    }
    /// Returns `true` if the error kind is `DescribeReservedElasticsearchInstancesError::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(self, Self::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `DescribeReservedElasticsearchInstancesError::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(self, Self::ValidationException(_))
    }
}
impl std::error::Error for DescribeReservedElasticsearchInstancesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DisabledOperationException(_inner) =>
            Some(_inner)
            ,
            Self::InternalException(_inner) =>
            Some(_inner)
            ,
            Self::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            Self::ValidationException(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type DescribeReservedElasticsearchInstanceOfferingsErrorKind = DescribeReservedElasticsearchInstanceOfferingsError;
/// Error type for the `DescribeReservedElasticsearchInstanceOfferingsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeReservedElasticsearchInstanceOfferingsError {
    /// <p>An error occured because the client wanted to access a not supported operation. Gives http status code of 409.</p>
    DisabledOperationException(crate::error::DisabledOperationException),
    /// <p>The request processing has failed because of an unknown error, exception or failure (the failure is internal to the service) . Gives http status code of 500.</p>
    InternalException(crate::error::InternalException),
    /// <p>An exception for accessing or deleting a resource that does not exist. Gives http status code of 400.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>An exception for missing / invalid input fields. Gives http status code of 400.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeReservedElasticsearchInstanceOfferingsError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for DescribeReservedElasticsearchInstanceOfferingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DisabledOperationException(_inner) =>
            _inner.fmt(f)
            ,
            Self::InternalException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeReservedElasticsearchInstanceOfferingsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DisabledOperationException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::InternalException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ResourceNotFoundException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ValidationException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeReservedElasticsearchInstanceOfferingsError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for DescribeReservedElasticsearchInstanceOfferingsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeReservedElasticsearchInstanceOfferingsError {
    /// Creates the `DescribeReservedElasticsearchInstanceOfferingsError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `DescribeReservedElasticsearchInstanceOfferingsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DisabledOperationException(e) => e.meta(),
            Self::InternalException(e) => e.meta(),
            Self::ResourceNotFoundException(e) => e.meta(),
            Self::ValidationException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeReservedElasticsearchInstanceOfferingsError::DisabledOperationException`.
    pub fn is_disabled_operation_exception(&self) -> bool {
        matches!(self, Self::DisabledOperationException(_))
    }
    /// Returns `true` if the error kind is `DescribeReservedElasticsearchInstanceOfferingsError::InternalException`.
    pub fn is_internal_exception(&self) -> bool {
        matches!(self, Self::InternalException(_))
    }
    /// Returns `true` if the error kind is `DescribeReservedElasticsearchInstanceOfferingsError::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(self, Self::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `DescribeReservedElasticsearchInstanceOfferingsError::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(self, Self::ValidationException(_))
    }
}
impl std::error::Error for DescribeReservedElasticsearchInstanceOfferingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DisabledOperationException(_inner) =>
            Some(_inner)
            ,
            Self::InternalException(_inner) =>
            Some(_inner)
            ,
            Self::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            Self::ValidationException(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type DescribePackagesErrorKind = DescribePackagesError;
/// Error type for the `DescribePackagesError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribePackagesError {
    /// <p>An error occurred because user does not have permissions to access the resource. Returns HTTP status code 403.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>An error occurred while processing the request.</p>
    BaseException(crate::error::BaseException),
    /// <p>The request processing has failed because of an unknown error, exception or failure (the failure is internal to the service) . Gives http status code of 500.</p>
    InternalException(crate::error::InternalException),
    /// <p>An exception for accessing or deleting a resource that does not exist. Gives http status code of 400.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>An exception for missing / invalid input fields. Gives http status code of 400.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribePackagesError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for DescribePackagesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            Self::BaseException(_inner) =>
            _inner.fmt(f)
            ,
            Self::InternalException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribePackagesError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDeniedException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::BaseException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::InternalException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ResourceNotFoundException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ValidationException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribePackagesError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for DescribePackagesError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribePackagesError {
    /// Creates the `DescribePackagesError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `DescribePackagesError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDeniedException(e) => e.meta(),
            Self::BaseException(e) => e.meta(),
            Self::InternalException(e) => e.meta(),
            Self::ResourceNotFoundException(e) => e.meta(),
            Self::ValidationException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribePackagesError::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(self, Self::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `DescribePackagesError::BaseException`.
    pub fn is_base_exception(&self) -> bool {
        matches!(self, Self::BaseException(_))
    }
    /// Returns `true` if the error kind is `DescribePackagesError::InternalException`.
    pub fn is_internal_exception(&self) -> bool {
        matches!(self, Self::InternalException(_))
    }
    /// Returns `true` if the error kind is `DescribePackagesError::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(self, Self::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `DescribePackagesError::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(self, Self::ValidationException(_))
    }
}
impl std::error::Error for DescribePackagesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            Self::BaseException(_inner) =>
            Some(_inner)
            ,
            Self::InternalException(_inner) =>
            Some(_inner)
            ,
            Self::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            Self::ValidationException(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type DescribeOutboundCrossClusterSearchConnectionsErrorKind = DescribeOutboundCrossClusterSearchConnectionsError;
/// Error type for the `DescribeOutboundCrossClusterSearchConnectionsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeOutboundCrossClusterSearchConnectionsError {
    /// <p>An error occured because the client wanted to access a not supported operation. Gives http status code of 409.</p>
    DisabledOperationException(crate::error::DisabledOperationException),
    /// <p>The request processing has failed because of invalid pagination token provided by customer. Returns an HTTP status code of 400. </p>
    InvalidPaginationTokenException(crate::error::InvalidPaginationTokenException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeOutboundCrossClusterSearchConnectionsError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for DescribeOutboundCrossClusterSearchConnectionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DisabledOperationException(_inner) =>
            _inner.fmt(f)
            ,
            Self::InvalidPaginationTokenException(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeOutboundCrossClusterSearchConnectionsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DisabledOperationException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::InvalidPaginationTokenException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeOutboundCrossClusterSearchConnectionsError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for DescribeOutboundCrossClusterSearchConnectionsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeOutboundCrossClusterSearchConnectionsError {
    /// Creates the `DescribeOutboundCrossClusterSearchConnectionsError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `DescribeOutboundCrossClusterSearchConnectionsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DisabledOperationException(e) => e.meta(),
            Self::InvalidPaginationTokenException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeOutboundCrossClusterSearchConnectionsError::DisabledOperationException`.
    pub fn is_disabled_operation_exception(&self) -> bool {
        matches!(self, Self::DisabledOperationException(_))
    }
    /// Returns `true` if the error kind is `DescribeOutboundCrossClusterSearchConnectionsError::InvalidPaginationTokenException`.
    pub fn is_invalid_pagination_token_exception(&self) -> bool {
        matches!(self, Self::InvalidPaginationTokenException(_))
    }
}
impl std::error::Error for DescribeOutboundCrossClusterSearchConnectionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DisabledOperationException(_inner) =>
            Some(_inner)
            ,
            Self::InvalidPaginationTokenException(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// <p>The request processing has failed because of invalid pagination token provided by customer. Returns an HTTP status code of 400. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidPaginationTokenException  {
    /// <p>A description of the error.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidPaginationTokenException {
    /// Creates a new builder-style object to manufacture [`InvalidPaginationTokenException`](crate::error::InvalidPaginationTokenException).
    pub fn builder() -> crate::error::invalid_pagination_token_exception::Builder {
        crate::error::invalid_pagination_token_exception::Builder::default()
    }
}
/// See [`InvalidPaginationTokenException`](crate::error::InvalidPaginationTokenException).
pub mod invalid_pagination_token_exception {
    
    /// A builder for [`InvalidPaginationTokenException`](crate::error::InvalidPaginationTokenException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>A description of the error.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A description of the error.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Sets error metadata
                                            pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
                                                self.meta = Some(meta);
                                                self
                                            }
        
                                            /// Sets error metadata
                                            pub fn set_meta(&mut self, meta: Option<aws_smithy_types::error::ErrorMetadata>) -> &mut Self {
                                                self.meta = meta;
                                                self
                                            }
        /// Consumes the builder and constructs a [`InvalidPaginationTokenException`](crate::error::InvalidPaginationTokenException).
        pub fn build(self) -> crate::error::InvalidPaginationTokenException {
            crate::error::InvalidPaginationTokenException {
                message: self.message
                ,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
    
    
}
impl InvalidPaginationTokenException {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for InvalidPaginationTokenException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidPaginationTokenException")?;
        if let Some(inner_11) = &self.message {
             {
                write!(f, ": {}", inner_11)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidPaginationTokenException {}
impl aws_http::request_id::RequestId for crate::error::InvalidPaginationTokenException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidPaginationTokenException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata { &self.meta }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type DescribeInboundCrossClusterSearchConnectionsErrorKind = DescribeInboundCrossClusterSearchConnectionsError;
/// Error type for the `DescribeInboundCrossClusterSearchConnectionsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeInboundCrossClusterSearchConnectionsError {
    /// <p>An error occured because the client wanted to access a not supported operation. Gives http status code of 409.</p>
    DisabledOperationException(crate::error::DisabledOperationException),
    /// <p>The request processing has failed because of invalid pagination token provided by customer. Returns an HTTP status code of 400. </p>
    InvalidPaginationTokenException(crate::error::InvalidPaginationTokenException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeInboundCrossClusterSearchConnectionsError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for DescribeInboundCrossClusterSearchConnectionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DisabledOperationException(_inner) =>
            _inner.fmt(f)
            ,
            Self::InvalidPaginationTokenException(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeInboundCrossClusterSearchConnectionsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DisabledOperationException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::InvalidPaginationTokenException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeInboundCrossClusterSearchConnectionsError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for DescribeInboundCrossClusterSearchConnectionsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeInboundCrossClusterSearchConnectionsError {
    /// Creates the `DescribeInboundCrossClusterSearchConnectionsError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `DescribeInboundCrossClusterSearchConnectionsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DisabledOperationException(e) => e.meta(),
            Self::InvalidPaginationTokenException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeInboundCrossClusterSearchConnectionsError::DisabledOperationException`.
    pub fn is_disabled_operation_exception(&self) -> bool {
        matches!(self, Self::DisabledOperationException(_))
    }
    /// Returns `true` if the error kind is `DescribeInboundCrossClusterSearchConnectionsError::InvalidPaginationTokenException`.
    pub fn is_invalid_pagination_token_exception(&self) -> bool {
        matches!(self, Self::InvalidPaginationTokenException(_))
    }
}
impl std::error::Error for DescribeInboundCrossClusterSearchConnectionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DisabledOperationException(_inner) =>
            Some(_inner)
            ,
            Self::InvalidPaginationTokenException(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type DescribeElasticsearchInstanceTypeLimitsErrorKind = DescribeElasticsearchInstanceTypeLimitsError;
/// Error type for the `DescribeElasticsearchInstanceTypeLimitsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeElasticsearchInstanceTypeLimitsError {
    /// <p>An error occurred while processing the request.</p>
    BaseException(crate::error::BaseException),
    /// <p>The request processing has failed because of an unknown error, exception or failure (the failure is internal to the service) . Gives http status code of 500.</p>
    InternalException(crate::error::InternalException),
    /// <p>An exception for trying to create or access sub-resource that is either invalid or not supported. Gives http status code of 409.</p>
    InvalidTypeException(crate::error::InvalidTypeException),
    /// <p>An exception for trying to create more than allowed resources or sub-resources. Gives http status code of 409.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>An exception for accessing or deleting a resource that does not exist. Gives http status code of 400.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>An exception for missing / invalid input fields. Gives http status code of 400.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeElasticsearchInstanceTypeLimitsError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for DescribeElasticsearchInstanceTypeLimitsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BaseException(_inner) =>
            _inner.fmt(f)
            ,
            Self::InternalException(_inner) =>
            _inner.fmt(f)
            ,
            Self::InvalidTypeException(_inner) =>
            _inner.fmt(f)
            ,
            Self::LimitExceededException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeElasticsearchInstanceTypeLimitsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BaseException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::InternalException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::InvalidTypeException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::LimitExceededException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ResourceNotFoundException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ValidationException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeElasticsearchInstanceTypeLimitsError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for DescribeElasticsearchInstanceTypeLimitsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeElasticsearchInstanceTypeLimitsError {
    /// Creates the `DescribeElasticsearchInstanceTypeLimitsError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `DescribeElasticsearchInstanceTypeLimitsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BaseException(e) => e.meta(),
            Self::InternalException(e) => e.meta(),
            Self::InvalidTypeException(e) => e.meta(),
            Self::LimitExceededException(e) => e.meta(),
            Self::ResourceNotFoundException(e) => e.meta(),
            Self::ValidationException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeElasticsearchInstanceTypeLimitsError::BaseException`.
    pub fn is_base_exception(&self) -> bool {
        matches!(self, Self::BaseException(_))
    }
    /// Returns `true` if the error kind is `DescribeElasticsearchInstanceTypeLimitsError::InternalException`.
    pub fn is_internal_exception(&self) -> bool {
        matches!(self, Self::InternalException(_))
    }
    /// Returns `true` if the error kind is `DescribeElasticsearchInstanceTypeLimitsError::InvalidTypeException`.
    pub fn is_invalid_type_exception(&self) -> bool {
        matches!(self, Self::InvalidTypeException(_))
    }
    /// Returns `true` if the error kind is `DescribeElasticsearchInstanceTypeLimitsError::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::LimitExceededException(_))
    }
    /// Returns `true` if the error kind is `DescribeElasticsearchInstanceTypeLimitsError::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(self, Self::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `DescribeElasticsearchInstanceTypeLimitsError::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(self, Self::ValidationException(_))
    }
}
impl std::error::Error for DescribeElasticsearchInstanceTypeLimitsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BaseException(_inner) =>
            Some(_inner)
            ,
            Self::InternalException(_inner) =>
            Some(_inner)
            ,
            Self::InvalidTypeException(_inner) =>
            Some(_inner)
            ,
            Self::LimitExceededException(_inner) =>
            Some(_inner)
            ,
            Self::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            Self::ValidationException(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type DescribeElasticsearchDomainsErrorKind = DescribeElasticsearchDomainsError;
/// Error type for the `DescribeElasticsearchDomainsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeElasticsearchDomainsError {
    /// <p>An error occurred while processing the request.</p>
    BaseException(crate::error::BaseException),
    /// <p>The request processing has failed because of an unknown error, exception or failure (the failure is internal to the service) . Gives http status code of 500.</p>
    InternalException(crate::error::InternalException),
    /// <p>An exception for missing / invalid input fields. Gives http status code of 400.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeElasticsearchDomainsError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for DescribeElasticsearchDomainsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BaseException(_inner) =>
            _inner.fmt(f)
            ,
            Self::InternalException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeElasticsearchDomainsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BaseException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::InternalException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ValidationException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeElasticsearchDomainsError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for DescribeElasticsearchDomainsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeElasticsearchDomainsError {
    /// Creates the `DescribeElasticsearchDomainsError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `DescribeElasticsearchDomainsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BaseException(e) => e.meta(),
            Self::InternalException(e) => e.meta(),
            Self::ValidationException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeElasticsearchDomainsError::BaseException`.
    pub fn is_base_exception(&self) -> bool {
        matches!(self, Self::BaseException(_))
    }
    /// Returns `true` if the error kind is `DescribeElasticsearchDomainsError::InternalException`.
    pub fn is_internal_exception(&self) -> bool {
        matches!(self, Self::InternalException(_))
    }
    /// Returns `true` if the error kind is `DescribeElasticsearchDomainsError::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(self, Self::ValidationException(_))
    }
}
impl std::error::Error for DescribeElasticsearchDomainsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BaseException(_inner) =>
            Some(_inner)
            ,
            Self::InternalException(_inner) =>
            Some(_inner)
            ,
            Self::ValidationException(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type DescribeElasticsearchDomainConfigErrorKind = DescribeElasticsearchDomainConfigError;
/// Error type for the `DescribeElasticsearchDomainConfigError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeElasticsearchDomainConfigError {
    /// <p>An error occurred while processing the request.</p>
    BaseException(crate::error::BaseException),
    /// <p>The request processing has failed because of an unknown error, exception or failure (the failure is internal to the service) . Gives http status code of 500.</p>
    InternalException(crate::error::InternalException),
    /// <p>An exception for accessing or deleting a resource that does not exist. Gives http status code of 400.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>An exception for missing / invalid input fields. Gives http status code of 400.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeElasticsearchDomainConfigError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for DescribeElasticsearchDomainConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BaseException(_inner) =>
            _inner.fmt(f)
            ,
            Self::InternalException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeElasticsearchDomainConfigError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BaseException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::InternalException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ResourceNotFoundException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ValidationException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeElasticsearchDomainConfigError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for DescribeElasticsearchDomainConfigError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeElasticsearchDomainConfigError {
    /// Creates the `DescribeElasticsearchDomainConfigError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `DescribeElasticsearchDomainConfigError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BaseException(e) => e.meta(),
            Self::InternalException(e) => e.meta(),
            Self::ResourceNotFoundException(e) => e.meta(),
            Self::ValidationException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeElasticsearchDomainConfigError::BaseException`.
    pub fn is_base_exception(&self) -> bool {
        matches!(self, Self::BaseException(_))
    }
    /// Returns `true` if the error kind is `DescribeElasticsearchDomainConfigError::InternalException`.
    pub fn is_internal_exception(&self) -> bool {
        matches!(self, Self::InternalException(_))
    }
    /// Returns `true` if the error kind is `DescribeElasticsearchDomainConfigError::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(self, Self::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `DescribeElasticsearchDomainConfigError::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(self, Self::ValidationException(_))
    }
}
impl std::error::Error for DescribeElasticsearchDomainConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BaseException(_inner) =>
            Some(_inner)
            ,
            Self::InternalException(_inner) =>
            Some(_inner)
            ,
            Self::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            Self::ValidationException(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type DescribeElasticsearchDomainErrorKind = DescribeElasticsearchDomainError;
/// Error type for the `DescribeElasticsearchDomainError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeElasticsearchDomainError {
    /// <p>An error occurred while processing the request.</p>
    BaseException(crate::error::BaseException),
    /// <p>The request processing has failed because of an unknown error, exception or failure (the failure is internal to the service) . Gives http status code of 500.</p>
    InternalException(crate::error::InternalException),
    /// <p>An exception for accessing or deleting a resource that does not exist. Gives http status code of 400.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>An exception for missing / invalid input fields. Gives http status code of 400.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeElasticsearchDomainError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for DescribeElasticsearchDomainError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BaseException(_inner) =>
            _inner.fmt(f)
            ,
            Self::InternalException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeElasticsearchDomainError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BaseException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::InternalException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ResourceNotFoundException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ValidationException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeElasticsearchDomainError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for DescribeElasticsearchDomainError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeElasticsearchDomainError {
    /// Creates the `DescribeElasticsearchDomainError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `DescribeElasticsearchDomainError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BaseException(e) => e.meta(),
            Self::InternalException(e) => e.meta(),
            Self::ResourceNotFoundException(e) => e.meta(),
            Self::ValidationException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeElasticsearchDomainError::BaseException`.
    pub fn is_base_exception(&self) -> bool {
        matches!(self, Self::BaseException(_))
    }
    /// Returns `true` if the error kind is `DescribeElasticsearchDomainError::InternalException`.
    pub fn is_internal_exception(&self) -> bool {
        matches!(self, Self::InternalException(_))
    }
    /// Returns `true` if the error kind is `DescribeElasticsearchDomainError::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(self, Self::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `DescribeElasticsearchDomainError::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(self, Self::ValidationException(_))
    }
}
impl std::error::Error for DescribeElasticsearchDomainError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BaseException(_inner) =>
            Some(_inner)
            ,
            Self::InternalException(_inner) =>
            Some(_inner)
            ,
            Self::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            Self::ValidationException(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type DescribeDomainChangeProgressErrorKind = DescribeDomainChangeProgressError;
/// Error type for the `DescribeDomainChangeProgressError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDomainChangeProgressError {
    /// <p>An error occurred while processing the request.</p>
    BaseException(crate::error::BaseException),
    /// <p>The request processing has failed because of an unknown error, exception or failure (the failure is internal to the service) . Gives http status code of 500.</p>
    InternalException(crate::error::InternalException),
    /// <p>An exception for accessing or deleting a resource that does not exist. Gives http status code of 400.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>An exception for missing / invalid input fields. Gives http status code of 400.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeDomainChangeProgressError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for DescribeDomainChangeProgressError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BaseException(_inner) =>
            _inner.fmt(f)
            ,
            Self::InternalException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeDomainChangeProgressError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BaseException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::InternalException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ResourceNotFoundException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ValidationException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeDomainChangeProgressError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for DescribeDomainChangeProgressError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDomainChangeProgressError {
    /// Creates the `DescribeDomainChangeProgressError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `DescribeDomainChangeProgressError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BaseException(e) => e.meta(),
            Self::InternalException(e) => e.meta(),
            Self::ResourceNotFoundException(e) => e.meta(),
            Self::ValidationException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeDomainChangeProgressError::BaseException`.
    pub fn is_base_exception(&self) -> bool {
        matches!(self, Self::BaseException(_))
    }
    /// Returns `true` if the error kind is `DescribeDomainChangeProgressError::InternalException`.
    pub fn is_internal_exception(&self) -> bool {
        matches!(self, Self::InternalException(_))
    }
    /// Returns `true` if the error kind is `DescribeDomainChangeProgressError::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(self, Self::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `DescribeDomainChangeProgressError::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(self, Self::ValidationException(_))
    }
}
impl std::error::Error for DescribeDomainChangeProgressError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BaseException(_inner) =>
            Some(_inner)
            ,
            Self::InternalException(_inner) =>
            Some(_inner)
            ,
            Self::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            Self::ValidationException(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type DescribeDomainAutoTunesErrorKind = DescribeDomainAutoTunesError;
/// Error type for the `DescribeDomainAutoTunesError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDomainAutoTunesError {
    /// <p>An error occurred while processing the request.</p>
    BaseException(crate::error::BaseException),
    /// <p>The request processing has failed because of an unknown error, exception or failure (the failure is internal to the service) . Gives http status code of 500.</p>
    InternalException(crate::error::InternalException),
    /// <p>An exception for accessing or deleting a resource that does not exist. Gives http status code of 400.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>An exception for missing / invalid input fields. Gives http status code of 400.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeDomainAutoTunesError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for DescribeDomainAutoTunesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BaseException(_inner) =>
            _inner.fmt(f)
            ,
            Self::InternalException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeDomainAutoTunesError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BaseException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::InternalException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ResourceNotFoundException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ValidationException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeDomainAutoTunesError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for DescribeDomainAutoTunesError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDomainAutoTunesError {
    /// Creates the `DescribeDomainAutoTunesError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `DescribeDomainAutoTunesError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BaseException(e) => e.meta(),
            Self::InternalException(e) => e.meta(),
            Self::ResourceNotFoundException(e) => e.meta(),
            Self::ValidationException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeDomainAutoTunesError::BaseException`.
    pub fn is_base_exception(&self) -> bool {
        matches!(self, Self::BaseException(_))
    }
    /// Returns `true` if the error kind is `DescribeDomainAutoTunesError::InternalException`.
    pub fn is_internal_exception(&self) -> bool {
        matches!(self, Self::InternalException(_))
    }
    /// Returns `true` if the error kind is `DescribeDomainAutoTunesError::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(self, Self::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `DescribeDomainAutoTunesError::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(self, Self::ValidationException(_))
    }
}
impl std::error::Error for DescribeDomainAutoTunesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BaseException(_inner) =>
            Some(_inner)
            ,
            Self::InternalException(_inner) =>
            Some(_inner)
            ,
            Self::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            Self::ValidationException(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type DeleteVpcEndpointErrorKind = DeleteVpcEndpointError;
/// Error type for the `DeleteVpcEndpointError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteVpcEndpointError {
    /// <p>An error occurred while processing the request.</p>
    BaseException(crate::error::BaseException),
    /// <p>An error occured because the client wanted to access a not supported operation. Gives http status code of 409.</p>
    DisabledOperationException(crate::error::DisabledOperationException),
    /// <p>The request processing has failed because of an unknown error, exception or failure (the failure is internal to the service) . Gives http status code of 500.</p>
    InternalException(crate::error::InternalException),
    /// <p>An exception for accessing or deleting a resource that does not exist. Gives http status code of 400.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteVpcEndpointError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for DeleteVpcEndpointError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BaseException(_inner) =>
            _inner.fmt(f)
            ,
            Self::DisabledOperationException(_inner) =>
            _inner.fmt(f)
            ,
            Self::InternalException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteVpcEndpointError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BaseException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::DisabledOperationException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::InternalException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ResourceNotFoundException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteVpcEndpointError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for DeleteVpcEndpointError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteVpcEndpointError {
    /// Creates the `DeleteVpcEndpointError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `DeleteVpcEndpointError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BaseException(e) => e.meta(),
            Self::DisabledOperationException(e) => e.meta(),
            Self::InternalException(e) => e.meta(),
            Self::ResourceNotFoundException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteVpcEndpointError::BaseException`.
    pub fn is_base_exception(&self) -> bool {
        matches!(self, Self::BaseException(_))
    }
    /// Returns `true` if the error kind is `DeleteVpcEndpointError::DisabledOperationException`.
    pub fn is_disabled_operation_exception(&self) -> bool {
        matches!(self, Self::DisabledOperationException(_))
    }
    /// Returns `true` if the error kind is `DeleteVpcEndpointError::InternalException`.
    pub fn is_internal_exception(&self) -> bool {
        matches!(self, Self::InternalException(_))
    }
    /// Returns `true` if the error kind is `DeleteVpcEndpointError::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(self, Self::ResourceNotFoundException(_))
    }
}
impl std::error::Error for DeleteVpcEndpointError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BaseException(_inner) =>
            Some(_inner)
            ,
            Self::DisabledOperationException(_inner) =>
            Some(_inner)
            ,
            Self::InternalException(_inner) =>
            Some(_inner)
            ,
            Self::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type DeletePackageErrorKind = DeletePackageError;
/// Error type for the `DeletePackageError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeletePackageError {
    /// <p>An error occurred because user does not have permissions to access the resource. Returns HTTP status code 403.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>An error occurred while processing the request.</p>
    BaseException(crate::error::BaseException),
    /// <p>An error occurred because the client attempts to remove a resource that is currently in use. Returns HTTP status code 409.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>The request processing has failed because of an unknown error, exception or failure (the failure is internal to the service) . Gives http status code of 500.</p>
    InternalException(crate::error::InternalException),
    /// <p>An exception for accessing or deleting a resource that does not exist. Gives http status code of 400.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>An exception for missing / invalid input fields. Gives http status code of 400.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeletePackageError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for DeletePackageError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            Self::BaseException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ConflictException(_inner) =>
            _inner.fmt(f)
            ,
            Self::InternalException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeletePackageError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDeniedException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::BaseException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ConflictException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::InternalException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ResourceNotFoundException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ValidationException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeletePackageError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for DeletePackageError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeletePackageError {
    /// Creates the `DeletePackageError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `DeletePackageError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDeniedException(e) => e.meta(),
            Self::BaseException(e) => e.meta(),
            Self::ConflictException(e) => e.meta(),
            Self::InternalException(e) => e.meta(),
            Self::ResourceNotFoundException(e) => e.meta(),
            Self::ValidationException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeletePackageError::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(self, Self::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `DeletePackageError::BaseException`.
    pub fn is_base_exception(&self) -> bool {
        matches!(self, Self::BaseException(_))
    }
    /// Returns `true` if the error kind is `DeletePackageError::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(self, Self::ConflictException(_))
    }
    /// Returns `true` if the error kind is `DeletePackageError::InternalException`.
    pub fn is_internal_exception(&self) -> bool {
        matches!(self, Self::InternalException(_))
    }
    /// Returns `true` if the error kind is `DeletePackageError::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(self, Self::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `DeletePackageError::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(self, Self::ValidationException(_))
    }
}
impl std::error::Error for DeletePackageError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            Self::BaseException(_inner) =>
            Some(_inner)
            ,
            Self::ConflictException(_inner) =>
            Some(_inner)
            ,
            Self::InternalException(_inner) =>
            Some(_inner)
            ,
            Self::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            Self::ValidationException(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type DeleteOutboundCrossClusterSearchConnectionErrorKind = DeleteOutboundCrossClusterSearchConnectionError;
/// Error type for the `DeleteOutboundCrossClusterSearchConnectionError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteOutboundCrossClusterSearchConnectionError {
    /// <p>An error occured because the client wanted to access a not supported operation. Gives http status code of 409.</p>
    DisabledOperationException(crate::error::DisabledOperationException),
    /// <p>An exception for accessing or deleting a resource that does not exist. Gives http status code of 400.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteOutboundCrossClusterSearchConnectionError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for DeleteOutboundCrossClusterSearchConnectionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DisabledOperationException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteOutboundCrossClusterSearchConnectionError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DisabledOperationException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ResourceNotFoundException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteOutboundCrossClusterSearchConnectionError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for DeleteOutboundCrossClusterSearchConnectionError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteOutboundCrossClusterSearchConnectionError {
    /// Creates the `DeleteOutboundCrossClusterSearchConnectionError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `DeleteOutboundCrossClusterSearchConnectionError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DisabledOperationException(e) => e.meta(),
            Self::ResourceNotFoundException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteOutboundCrossClusterSearchConnectionError::DisabledOperationException`.
    pub fn is_disabled_operation_exception(&self) -> bool {
        matches!(self, Self::DisabledOperationException(_))
    }
    /// Returns `true` if the error kind is `DeleteOutboundCrossClusterSearchConnectionError::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(self, Self::ResourceNotFoundException(_))
    }
}
impl std::error::Error for DeleteOutboundCrossClusterSearchConnectionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DisabledOperationException(_inner) =>
            Some(_inner)
            ,
            Self::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type DeleteInboundCrossClusterSearchConnectionErrorKind = DeleteInboundCrossClusterSearchConnectionError;
/// Error type for the `DeleteInboundCrossClusterSearchConnectionError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteInboundCrossClusterSearchConnectionError {
    /// <p>An error occured because the client wanted to access a not supported operation. Gives http status code of 409.</p>
    DisabledOperationException(crate::error::DisabledOperationException),
    /// <p>An exception for accessing or deleting a resource that does not exist. Gives http status code of 400.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteInboundCrossClusterSearchConnectionError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for DeleteInboundCrossClusterSearchConnectionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DisabledOperationException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteInboundCrossClusterSearchConnectionError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DisabledOperationException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ResourceNotFoundException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteInboundCrossClusterSearchConnectionError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for DeleteInboundCrossClusterSearchConnectionError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteInboundCrossClusterSearchConnectionError {
    /// Creates the `DeleteInboundCrossClusterSearchConnectionError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `DeleteInboundCrossClusterSearchConnectionError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DisabledOperationException(e) => e.meta(),
            Self::ResourceNotFoundException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteInboundCrossClusterSearchConnectionError::DisabledOperationException`.
    pub fn is_disabled_operation_exception(&self) -> bool {
        matches!(self, Self::DisabledOperationException(_))
    }
    /// Returns `true` if the error kind is `DeleteInboundCrossClusterSearchConnectionError::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(self, Self::ResourceNotFoundException(_))
    }
}
impl std::error::Error for DeleteInboundCrossClusterSearchConnectionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DisabledOperationException(_inner) =>
            Some(_inner)
            ,
            Self::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type DeleteElasticsearchServiceRoleErrorKind = DeleteElasticsearchServiceRoleError;
/// Error type for the `DeleteElasticsearchServiceRoleError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteElasticsearchServiceRoleError {
    /// <p>An error occurred while processing the request.</p>
    BaseException(crate::error::BaseException),
    /// <p>The request processing has failed because of an unknown error, exception or failure (the failure is internal to the service) . Gives http status code of 500.</p>
    InternalException(crate::error::InternalException),
    /// <p>An exception for missing / invalid input fields. Gives http status code of 400.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteElasticsearchServiceRoleError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for DeleteElasticsearchServiceRoleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BaseException(_inner) =>
            _inner.fmt(f)
            ,
            Self::InternalException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteElasticsearchServiceRoleError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BaseException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::InternalException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ValidationException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteElasticsearchServiceRoleError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for DeleteElasticsearchServiceRoleError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteElasticsearchServiceRoleError {
    /// Creates the `DeleteElasticsearchServiceRoleError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `DeleteElasticsearchServiceRoleError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BaseException(e) => e.meta(),
            Self::InternalException(e) => e.meta(),
            Self::ValidationException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteElasticsearchServiceRoleError::BaseException`.
    pub fn is_base_exception(&self) -> bool {
        matches!(self, Self::BaseException(_))
    }
    /// Returns `true` if the error kind is `DeleteElasticsearchServiceRoleError::InternalException`.
    pub fn is_internal_exception(&self) -> bool {
        matches!(self, Self::InternalException(_))
    }
    /// Returns `true` if the error kind is `DeleteElasticsearchServiceRoleError::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(self, Self::ValidationException(_))
    }
}
impl std::error::Error for DeleteElasticsearchServiceRoleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BaseException(_inner) =>
            Some(_inner)
            ,
            Self::InternalException(_inner) =>
            Some(_inner)
            ,
            Self::ValidationException(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type DeleteElasticsearchDomainErrorKind = DeleteElasticsearchDomainError;
/// Error type for the `DeleteElasticsearchDomainError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteElasticsearchDomainError {
    /// <p>An error occurred while processing the request.</p>
    BaseException(crate::error::BaseException),
    /// <p>The request processing has failed because of an unknown error, exception or failure (the failure is internal to the service) . Gives http status code of 500.</p>
    InternalException(crate::error::InternalException),
    /// <p>An exception for accessing or deleting a resource that does not exist. Gives http status code of 400.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>An exception for missing / invalid input fields. Gives http status code of 400.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteElasticsearchDomainError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for DeleteElasticsearchDomainError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BaseException(_inner) =>
            _inner.fmt(f)
            ,
            Self::InternalException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteElasticsearchDomainError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BaseException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::InternalException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ResourceNotFoundException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ValidationException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteElasticsearchDomainError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for DeleteElasticsearchDomainError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteElasticsearchDomainError {
    /// Creates the `DeleteElasticsearchDomainError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `DeleteElasticsearchDomainError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BaseException(e) => e.meta(),
            Self::InternalException(e) => e.meta(),
            Self::ResourceNotFoundException(e) => e.meta(),
            Self::ValidationException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteElasticsearchDomainError::BaseException`.
    pub fn is_base_exception(&self) -> bool {
        matches!(self, Self::BaseException(_))
    }
    /// Returns `true` if the error kind is `DeleteElasticsearchDomainError::InternalException`.
    pub fn is_internal_exception(&self) -> bool {
        matches!(self, Self::InternalException(_))
    }
    /// Returns `true` if the error kind is `DeleteElasticsearchDomainError::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(self, Self::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `DeleteElasticsearchDomainError::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(self, Self::ValidationException(_))
    }
}
impl std::error::Error for DeleteElasticsearchDomainError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BaseException(_inner) =>
            Some(_inner)
            ,
            Self::InternalException(_inner) =>
            Some(_inner)
            ,
            Self::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            Self::ValidationException(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type CreateVpcEndpointErrorKind = CreateVpcEndpointError;
/// Error type for the `CreateVpcEndpointError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateVpcEndpointError {
    /// <p>An error occurred while processing the request.</p>
    BaseException(crate::error::BaseException),
    /// <p>An error occurred because the client attempts to remove a resource that is currently in use. Returns HTTP status code 409.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>An error occured because the client wanted to access a not supported operation. Gives http status code of 409.</p>
    DisabledOperationException(crate::error::DisabledOperationException),
    /// <p>The request processing has failed because of an unknown error, exception or failure (the failure is internal to the service) . Gives http status code of 500.</p>
    InternalException(crate::error::InternalException),
    /// <p>An exception for trying to create more than allowed resources or sub-resources. Gives http status code of 409.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>An exception for missing / invalid input fields. Gives http status code of 400.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateVpcEndpointError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for CreateVpcEndpointError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BaseException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ConflictException(_inner) =>
            _inner.fmt(f)
            ,
            Self::DisabledOperationException(_inner) =>
            _inner.fmt(f)
            ,
            Self::InternalException(_inner) =>
            _inner.fmt(f)
            ,
            Self::LimitExceededException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateVpcEndpointError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BaseException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ConflictException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::DisabledOperationException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::InternalException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::LimitExceededException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ValidationException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateVpcEndpointError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for CreateVpcEndpointError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateVpcEndpointError {
    /// Creates the `CreateVpcEndpointError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `CreateVpcEndpointError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BaseException(e) => e.meta(),
            Self::ConflictException(e) => e.meta(),
            Self::DisabledOperationException(e) => e.meta(),
            Self::InternalException(e) => e.meta(),
            Self::LimitExceededException(e) => e.meta(),
            Self::ValidationException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateVpcEndpointError::BaseException`.
    pub fn is_base_exception(&self) -> bool {
        matches!(self, Self::BaseException(_))
    }
    /// Returns `true` if the error kind is `CreateVpcEndpointError::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(self, Self::ConflictException(_))
    }
    /// Returns `true` if the error kind is `CreateVpcEndpointError::DisabledOperationException`.
    pub fn is_disabled_operation_exception(&self) -> bool {
        matches!(self, Self::DisabledOperationException(_))
    }
    /// Returns `true` if the error kind is `CreateVpcEndpointError::InternalException`.
    pub fn is_internal_exception(&self) -> bool {
        matches!(self, Self::InternalException(_))
    }
    /// Returns `true` if the error kind is `CreateVpcEndpointError::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::LimitExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateVpcEndpointError::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(self, Self::ValidationException(_))
    }
}
impl std::error::Error for CreateVpcEndpointError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BaseException(_inner) =>
            Some(_inner)
            ,
            Self::ConflictException(_inner) =>
            Some(_inner)
            ,
            Self::DisabledOperationException(_inner) =>
            Some(_inner)
            ,
            Self::InternalException(_inner) =>
            Some(_inner)
            ,
            Self::LimitExceededException(_inner) =>
            Some(_inner)
            ,
            Self::ValidationException(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type CreatePackageErrorKind = CreatePackageError;
/// Error type for the `CreatePackageError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreatePackageError {
    /// <p>An error occurred because user does not have permissions to access the resource. Returns HTTP status code 403.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>An error occurred while processing the request.</p>
    BaseException(crate::error::BaseException),
    /// <p>The request processing has failed because of an unknown error, exception or failure (the failure is internal to the service) . Gives http status code of 500.</p>
    InternalException(crate::error::InternalException),
    /// <p>An exception for trying to create or access sub-resource that is either invalid or not supported. Gives http status code of 409.</p>
    InvalidTypeException(crate::error::InvalidTypeException),
    /// <p>An exception for trying to create more than allowed resources or sub-resources. Gives http status code of 409.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>An exception for creating a resource that already exists. Gives http status code of 400.</p>
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    /// <p>An exception for missing / invalid input fields. Gives http status code of 400.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreatePackageError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for CreatePackageError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            Self::BaseException(_inner) =>
            _inner.fmt(f)
            ,
            Self::InternalException(_inner) =>
            _inner.fmt(f)
            ,
            Self::InvalidTypeException(_inner) =>
            _inner.fmt(f)
            ,
            Self::LimitExceededException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ResourceAlreadyExistsException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreatePackageError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDeniedException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::BaseException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::InternalException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::InvalidTypeException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::LimitExceededException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ResourceAlreadyExistsException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ValidationException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreatePackageError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for CreatePackageError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreatePackageError {
    /// Creates the `CreatePackageError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `CreatePackageError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDeniedException(e) => e.meta(),
            Self::BaseException(e) => e.meta(),
            Self::InternalException(e) => e.meta(),
            Self::InvalidTypeException(e) => e.meta(),
            Self::LimitExceededException(e) => e.meta(),
            Self::ResourceAlreadyExistsException(e) => e.meta(),
            Self::ValidationException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreatePackageError::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(self, Self::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `CreatePackageError::BaseException`.
    pub fn is_base_exception(&self) -> bool {
        matches!(self, Self::BaseException(_))
    }
    /// Returns `true` if the error kind is `CreatePackageError::InternalException`.
    pub fn is_internal_exception(&self) -> bool {
        matches!(self, Self::InternalException(_))
    }
    /// Returns `true` if the error kind is `CreatePackageError::InvalidTypeException`.
    pub fn is_invalid_type_exception(&self) -> bool {
        matches!(self, Self::InvalidTypeException(_))
    }
    /// Returns `true` if the error kind is `CreatePackageError::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::LimitExceededException(_))
    }
    /// Returns `true` if the error kind is `CreatePackageError::ResourceAlreadyExistsException`.
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(self, Self::ResourceAlreadyExistsException(_))
    }
    /// Returns `true` if the error kind is `CreatePackageError::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(self, Self::ValidationException(_))
    }
}
impl std::error::Error for CreatePackageError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            Self::BaseException(_inner) =>
            Some(_inner)
            ,
            Self::InternalException(_inner) =>
            Some(_inner)
            ,
            Self::InvalidTypeException(_inner) =>
            Some(_inner)
            ,
            Self::LimitExceededException(_inner) =>
            Some(_inner)
            ,
            Self::ResourceAlreadyExistsException(_inner) =>
            Some(_inner)
            ,
            Self::ValidationException(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type CreateOutboundCrossClusterSearchConnectionErrorKind = CreateOutboundCrossClusterSearchConnectionError;
/// Error type for the `CreateOutboundCrossClusterSearchConnectionError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateOutboundCrossClusterSearchConnectionError {
    /// <p>An error occured because the client wanted to access a not supported operation. Gives http status code of 409.</p>
    DisabledOperationException(crate::error::DisabledOperationException),
    /// <p>The request processing has failed because of an unknown error, exception or failure (the failure is internal to the service) . Gives http status code of 500.</p>
    InternalException(crate::error::InternalException),
    /// <p>An exception for trying to create more than allowed resources or sub-resources. Gives http status code of 409.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>An exception for creating a resource that already exists. Gives http status code of 400.</p>
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateOutboundCrossClusterSearchConnectionError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for CreateOutboundCrossClusterSearchConnectionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DisabledOperationException(_inner) =>
            _inner.fmt(f)
            ,
            Self::InternalException(_inner) =>
            _inner.fmt(f)
            ,
            Self::LimitExceededException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ResourceAlreadyExistsException(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateOutboundCrossClusterSearchConnectionError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DisabledOperationException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::InternalException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::LimitExceededException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ResourceAlreadyExistsException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateOutboundCrossClusterSearchConnectionError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for CreateOutboundCrossClusterSearchConnectionError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateOutboundCrossClusterSearchConnectionError {
    /// Creates the `CreateOutboundCrossClusterSearchConnectionError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `CreateOutboundCrossClusterSearchConnectionError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DisabledOperationException(e) => e.meta(),
            Self::InternalException(e) => e.meta(),
            Self::LimitExceededException(e) => e.meta(),
            Self::ResourceAlreadyExistsException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateOutboundCrossClusterSearchConnectionError::DisabledOperationException`.
    pub fn is_disabled_operation_exception(&self) -> bool {
        matches!(self, Self::DisabledOperationException(_))
    }
    /// Returns `true` if the error kind is `CreateOutboundCrossClusterSearchConnectionError::InternalException`.
    pub fn is_internal_exception(&self) -> bool {
        matches!(self, Self::InternalException(_))
    }
    /// Returns `true` if the error kind is `CreateOutboundCrossClusterSearchConnectionError::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::LimitExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateOutboundCrossClusterSearchConnectionError::ResourceAlreadyExistsException`.
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(self, Self::ResourceAlreadyExistsException(_))
    }
}
impl std::error::Error for CreateOutboundCrossClusterSearchConnectionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DisabledOperationException(_inner) =>
            Some(_inner)
            ,
            Self::InternalException(_inner) =>
            Some(_inner)
            ,
            Self::LimitExceededException(_inner) =>
            Some(_inner)
            ,
            Self::ResourceAlreadyExistsException(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type CreateElasticsearchDomainErrorKind = CreateElasticsearchDomainError;
/// Error type for the `CreateElasticsearchDomainError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateElasticsearchDomainError {
    /// <p>An error occurred while processing the request.</p>
    BaseException(crate::error::BaseException),
    /// <p>An error occured because the client wanted to access a not supported operation. Gives http status code of 409.</p>
    DisabledOperationException(crate::error::DisabledOperationException),
    /// <p>The request processing has failed because of an unknown error, exception or failure (the failure is internal to the service) . Gives http status code of 500.</p>
    InternalException(crate::error::InternalException),
    /// <p>An exception for trying to create or access sub-resource that is either invalid or not supported. Gives http status code of 409.</p>
    InvalidTypeException(crate::error::InvalidTypeException),
    /// <p>An exception for trying to create more than allowed resources or sub-resources. Gives http status code of 409.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>An exception for creating a resource that already exists. Gives http status code of 400.</p>
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    /// <p>An exception for missing / invalid input fields. Gives http status code of 400.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateElasticsearchDomainError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for CreateElasticsearchDomainError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BaseException(_inner) =>
            _inner.fmt(f)
            ,
            Self::DisabledOperationException(_inner) =>
            _inner.fmt(f)
            ,
            Self::InternalException(_inner) =>
            _inner.fmt(f)
            ,
            Self::InvalidTypeException(_inner) =>
            _inner.fmt(f)
            ,
            Self::LimitExceededException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ResourceAlreadyExistsException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateElasticsearchDomainError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BaseException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::DisabledOperationException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::InternalException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::InvalidTypeException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::LimitExceededException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ResourceAlreadyExistsException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ValidationException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateElasticsearchDomainError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for CreateElasticsearchDomainError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateElasticsearchDomainError {
    /// Creates the `CreateElasticsearchDomainError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `CreateElasticsearchDomainError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BaseException(e) => e.meta(),
            Self::DisabledOperationException(e) => e.meta(),
            Self::InternalException(e) => e.meta(),
            Self::InvalidTypeException(e) => e.meta(),
            Self::LimitExceededException(e) => e.meta(),
            Self::ResourceAlreadyExistsException(e) => e.meta(),
            Self::ValidationException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateElasticsearchDomainError::BaseException`.
    pub fn is_base_exception(&self) -> bool {
        matches!(self, Self::BaseException(_))
    }
    /// Returns `true` if the error kind is `CreateElasticsearchDomainError::DisabledOperationException`.
    pub fn is_disabled_operation_exception(&self) -> bool {
        matches!(self, Self::DisabledOperationException(_))
    }
    /// Returns `true` if the error kind is `CreateElasticsearchDomainError::InternalException`.
    pub fn is_internal_exception(&self) -> bool {
        matches!(self, Self::InternalException(_))
    }
    /// Returns `true` if the error kind is `CreateElasticsearchDomainError::InvalidTypeException`.
    pub fn is_invalid_type_exception(&self) -> bool {
        matches!(self, Self::InvalidTypeException(_))
    }
    /// Returns `true` if the error kind is `CreateElasticsearchDomainError::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::LimitExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateElasticsearchDomainError::ResourceAlreadyExistsException`.
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(self, Self::ResourceAlreadyExistsException(_))
    }
    /// Returns `true` if the error kind is `CreateElasticsearchDomainError::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(self, Self::ValidationException(_))
    }
}
impl std::error::Error for CreateElasticsearchDomainError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BaseException(_inner) =>
            Some(_inner)
            ,
            Self::DisabledOperationException(_inner) =>
            Some(_inner)
            ,
            Self::InternalException(_inner) =>
            Some(_inner)
            ,
            Self::InvalidTypeException(_inner) =>
            Some(_inner)
            ,
            Self::LimitExceededException(_inner) =>
            Some(_inner)
            ,
            Self::ResourceAlreadyExistsException(_inner) =>
            Some(_inner)
            ,
            Self::ValidationException(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type CancelElasticsearchServiceSoftwareUpdateErrorKind = CancelElasticsearchServiceSoftwareUpdateError;
/// Error type for the `CancelElasticsearchServiceSoftwareUpdateError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CancelElasticsearchServiceSoftwareUpdateError {
    /// <p>An error occurred while processing the request.</p>
    BaseException(crate::error::BaseException),
    /// <p>The request processing has failed because of an unknown error, exception or failure (the failure is internal to the service) . Gives http status code of 500.</p>
    InternalException(crate::error::InternalException),
    /// <p>An exception for accessing or deleting a resource that does not exist. Gives http status code of 400.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>An exception for missing / invalid input fields. Gives http status code of 400.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CancelElasticsearchServiceSoftwareUpdateError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for CancelElasticsearchServiceSoftwareUpdateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BaseException(_inner) =>
            _inner.fmt(f)
            ,
            Self::InternalException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CancelElasticsearchServiceSoftwareUpdateError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BaseException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::InternalException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ResourceNotFoundException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ValidationException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CancelElasticsearchServiceSoftwareUpdateError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for CancelElasticsearchServiceSoftwareUpdateError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CancelElasticsearchServiceSoftwareUpdateError {
    /// Creates the `CancelElasticsearchServiceSoftwareUpdateError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `CancelElasticsearchServiceSoftwareUpdateError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BaseException(e) => e.meta(),
            Self::InternalException(e) => e.meta(),
            Self::ResourceNotFoundException(e) => e.meta(),
            Self::ValidationException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CancelElasticsearchServiceSoftwareUpdateError::BaseException`.
    pub fn is_base_exception(&self) -> bool {
        matches!(self, Self::BaseException(_))
    }
    /// Returns `true` if the error kind is `CancelElasticsearchServiceSoftwareUpdateError::InternalException`.
    pub fn is_internal_exception(&self) -> bool {
        matches!(self, Self::InternalException(_))
    }
    /// Returns `true` if the error kind is `CancelElasticsearchServiceSoftwareUpdateError::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(self, Self::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `CancelElasticsearchServiceSoftwareUpdateError::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(self, Self::ValidationException(_))
    }
}
impl std::error::Error for CancelElasticsearchServiceSoftwareUpdateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BaseException(_inner) =>
            Some(_inner)
            ,
            Self::InternalException(_inner) =>
            Some(_inner)
            ,
            Self::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            Self::ValidationException(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type AuthorizeVpcEndpointAccessErrorKind = AuthorizeVpcEndpointAccessError;
/// Error type for the `AuthorizeVpcEndpointAccessError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AuthorizeVpcEndpointAccessError {
    /// <p>An error occurred while processing the request.</p>
    BaseException(crate::error::BaseException),
    /// <p>An error occured because the client wanted to access a not supported operation. Gives http status code of 409.</p>
    DisabledOperationException(crate::error::DisabledOperationException),
    /// <p>The request processing has failed because of an unknown error, exception or failure (the failure is internal to the service) . Gives http status code of 500.</p>
    InternalException(crate::error::InternalException),
    /// <p>An exception for trying to create more than allowed resources or sub-resources. Gives http status code of 409.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>An exception for accessing or deleting a resource that does not exist. Gives http status code of 400.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>An exception for missing / invalid input fields. Gives http status code of 400.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for AuthorizeVpcEndpointAccessError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for AuthorizeVpcEndpointAccessError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BaseException(_inner) =>
            _inner.fmt(f)
            ,
            Self::DisabledOperationException(_inner) =>
            _inner.fmt(f)
            ,
            Self::InternalException(_inner) =>
            _inner.fmt(f)
            ,
            Self::LimitExceededException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for AuthorizeVpcEndpointAccessError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BaseException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::DisabledOperationException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::InternalException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::LimitExceededException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ResourceNotFoundException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ValidationException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::AuthorizeVpcEndpointAccessError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for AuthorizeVpcEndpointAccessError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl AuthorizeVpcEndpointAccessError {
    /// Creates the `AuthorizeVpcEndpointAccessError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `AuthorizeVpcEndpointAccessError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BaseException(e) => e.meta(),
            Self::DisabledOperationException(e) => e.meta(),
            Self::InternalException(e) => e.meta(),
            Self::LimitExceededException(e) => e.meta(),
            Self::ResourceNotFoundException(e) => e.meta(),
            Self::ValidationException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `AuthorizeVpcEndpointAccessError::BaseException`.
    pub fn is_base_exception(&self) -> bool {
        matches!(self, Self::BaseException(_))
    }
    /// Returns `true` if the error kind is `AuthorizeVpcEndpointAccessError::DisabledOperationException`.
    pub fn is_disabled_operation_exception(&self) -> bool {
        matches!(self, Self::DisabledOperationException(_))
    }
    /// Returns `true` if the error kind is `AuthorizeVpcEndpointAccessError::InternalException`.
    pub fn is_internal_exception(&self) -> bool {
        matches!(self, Self::InternalException(_))
    }
    /// Returns `true` if the error kind is `AuthorizeVpcEndpointAccessError::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::LimitExceededException(_))
    }
    /// Returns `true` if the error kind is `AuthorizeVpcEndpointAccessError::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(self, Self::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `AuthorizeVpcEndpointAccessError::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(self, Self::ValidationException(_))
    }
}
impl std::error::Error for AuthorizeVpcEndpointAccessError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BaseException(_inner) =>
            Some(_inner)
            ,
            Self::DisabledOperationException(_inner) =>
            Some(_inner)
            ,
            Self::InternalException(_inner) =>
            Some(_inner)
            ,
            Self::LimitExceededException(_inner) =>
            Some(_inner)
            ,
            Self::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            Self::ValidationException(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type AssociatePackageErrorKind = AssociatePackageError;
/// Error type for the `AssociatePackageError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AssociatePackageError {
    /// <p>An error occurred because user does not have permissions to access the resource. Returns HTTP status code 403.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>An error occurred while processing the request.</p>
    BaseException(crate::error::BaseException),
    /// <p>An error occurred because the client attempts to remove a resource that is currently in use. Returns HTTP status code 409.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>The request processing has failed because of an unknown error, exception or failure (the failure is internal to the service) . Gives http status code of 500.</p>
    InternalException(crate::error::InternalException),
    /// <p>An exception for accessing or deleting a resource that does not exist. Gives http status code of 400.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>An exception for missing / invalid input fields. Gives http status code of 400.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for AssociatePackageError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for AssociatePackageError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            Self::BaseException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ConflictException(_inner) =>
            _inner.fmt(f)
            ,
            Self::InternalException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for AssociatePackageError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AccessDeniedException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::BaseException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ConflictException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::InternalException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ResourceNotFoundException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ValidationException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::AssociatePackageError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for AssociatePackageError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl AssociatePackageError {
    /// Creates the `AssociatePackageError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `AssociatePackageError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AccessDeniedException(e) => e.meta(),
            Self::BaseException(e) => e.meta(),
            Self::ConflictException(e) => e.meta(),
            Self::InternalException(e) => e.meta(),
            Self::ResourceNotFoundException(e) => e.meta(),
            Self::ValidationException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `AssociatePackageError::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(self, Self::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `AssociatePackageError::BaseException`.
    pub fn is_base_exception(&self) -> bool {
        matches!(self, Self::BaseException(_))
    }
    /// Returns `true` if the error kind is `AssociatePackageError::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(self, Self::ConflictException(_))
    }
    /// Returns `true` if the error kind is `AssociatePackageError::InternalException`.
    pub fn is_internal_exception(&self) -> bool {
        matches!(self, Self::InternalException(_))
    }
    /// Returns `true` if the error kind is `AssociatePackageError::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(self, Self::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `AssociatePackageError::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(self, Self::ValidationException(_))
    }
}
impl std::error::Error for AssociatePackageError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            Self::BaseException(_inner) =>
            Some(_inner)
            ,
            Self::ConflictException(_inner) =>
            Some(_inner)
            ,
            Self::InternalException(_inner) =>
            Some(_inner)
            ,
            Self::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            Self::ValidationException(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type AddTagsErrorKind = AddTagsError;
/// Error type for the `AddTagsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AddTagsError {
    /// <p>An error occurred while processing the request.</p>
    BaseException(crate::error::BaseException),
    /// <p>The request processing has failed because of an unknown error, exception or failure (the failure is internal to the service) . Gives http status code of 500.</p>
    InternalException(crate::error::InternalException),
    /// <p>An exception for trying to create more than allowed resources or sub-resources. Gives http status code of 409.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>An exception for missing / invalid input fields. Gives http status code of 400.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for AddTagsError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for AddTagsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BaseException(_inner) =>
            _inner.fmt(f)
            ,
            Self::InternalException(_inner) =>
            _inner.fmt(f)
            ,
            Self::LimitExceededException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for AddTagsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BaseException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::InternalException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::LimitExceededException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ValidationException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::AddTagsError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for AddTagsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl AddTagsError {
    /// Creates the `AddTagsError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `AddTagsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BaseException(e) => e.meta(),
            Self::InternalException(e) => e.meta(),
            Self::LimitExceededException(e) => e.meta(),
            Self::ValidationException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `AddTagsError::BaseException`.
    pub fn is_base_exception(&self) -> bool {
        matches!(self, Self::BaseException(_))
    }
    /// Returns `true` if the error kind is `AddTagsError::InternalException`.
    pub fn is_internal_exception(&self) -> bool {
        matches!(self, Self::InternalException(_))
    }
    /// Returns `true` if the error kind is `AddTagsError::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::LimitExceededException(_))
    }
    /// Returns `true` if the error kind is `AddTagsError::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(self, Self::ValidationException(_))
    }
}
impl std::error::Error for AddTagsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BaseException(_inner) =>
            Some(_inner)
            ,
            Self::InternalException(_inner) =>
            Some(_inner)
            ,
            Self::LimitExceededException(_inner) =>
            Some(_inner)
            ,
            Self::ValidationException(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type AcceptInboundCrossClusterSearchConnectionErrorKind = AcceptInboundCrossClusterSearchConnectionError;
/// Error type for the `AcceptInboundCrossClusterSearchConnectionError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AcceptInboundCrossClusterSearchConnectionError {
    /// <p>An error occured because the client wanted to access a not supported operation. Gives http status code of 409.</p>
    DisabledOperationException(crate::error::DisabledOperationException),
    /// <p>An exception for trying to create more than allowed resources or sub-resources. Gives http status code of 409.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>An exception for accessing or deleting a resource that does not exist. Gives http status code of 400.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for AcceptInboundCrossClusterSearchConnectionError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for AcceptInboundCrossClusterSearchConnectionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DisabledOperationException(_inner) =>
            _inner.fmt(f)
            ,
            Self::LimitExceededException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for AcceptInboundCrossClusterSearchConnectionError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DisabledOperationException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::LimitExceededException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ResourceNotFoundException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::AcceptInboundCrossClusterSearchConnectionError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for AcceptInboundCrossClusterSearchConnectionError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl AcceptInboundCrossClusterSearchConnectionError {
    /// Creates the `AcceptInboundCrossClusterSearchConnectionError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `AcceptInboundCrossClusterSearchConnectionError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DisabledOperationException(e) => e.meta(),
            Self::LimitExceededException(e) => e.meta(),
            Self::ResourceNotFoundException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `AcceptInboundCrossClusterSearchConnectionError::DisabledOperationException`.
    pub fn is_disabled_operation_exception(&self) -> bool {
        matches!(self, Self::DisabledOperationException(_))
    }
    /// Returns `true` if the error kind is `AcceptInboundCrossClusterSearchConnectionError::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::LimitExceededException(_))
    }
    /// Returns `true` if the error kind is `AcceptInboundCrossClusterSearchConnectionError::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(self, Self::ResourceNotFoundException(_))
    }
}
impl std::error::Error for AcceptInboundCrossClusterSearchConnectionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DisabledOperationException(_inner) =>
            Some(_inner)
            ,
            Self::LimitExceededException(_inner) =>
            Some(_inner)
            ,
            Self::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

