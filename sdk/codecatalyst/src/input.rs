// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use std::fmt::Write;

/// See [`CreateAccessTokenInput`](crate::input::CreateAccessTokenInput).
pub mod create_access_token_input {

    /// A builder for [`CreateAccessTokenInput`](crate::input::CreateAccessTokenInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) expires_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The friendly name of the personal access token.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The friendly name of the personal access token.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The date and time the personal access token expires, in coordinated universal time (UTC) timestamp format as specified in <a href="https://www.rfc-editor.org/rfc/rfc3339#section-5.6">RFC 3339</a>.</p>
        pub fn expires_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.expires_time = Some(input);
            self
        }
        /// <p>The date and time the personal access token expires, in coordinated universal time (UTC) timestamp format as specified in <a href="https://www.rfc-editor.org/rfc/rfc3339#section-5.6">RFC 3339</a>.</p>
        pub fn set_expires_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.expires_time = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateAccessTokenInput`](crate::input::CreateAccessTokenInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::CreateAccessTokenInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::CreateAccessTokenInput {
                name: self.name,
                expires_time: self.expires_time,
            })
        }
    }
}
impl CreateAccessTokenInput {
    /// Consumes the builder and constructs an Operation<[`CreateAccessToken`](crate::operation::CreateAccessToken)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateAccessToken,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_use_fips(_config.use_fips)
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateAccessTokenInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/v1/accessTokens").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateAccessTokenInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_access_token(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateAccessToken::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateAccessToken",
            "codecatalyst",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateAccessTokenInput`](crate::input::CreateAccessTokenInput).
    pub fn builder() -> crate::input::create_access_token_input::Builder {
        crate::input::create_access_token_input::Builder::default()
    }
}

/// See [`CreateDevEnvironmentInput`](crate::input::CreateDevEnvironmentInput).
pub mod create_dev_environment_input {

    /// A builder for [`CreateDevEnvironmentInput`](crate::input::CreateDevEnvironmentInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) space_name: std::option::Option<std::string::String>,
        pub(crate) project_name: std::option::Option<std::string::String>,
        pub(crate) repositories: std::option::Option<std::vec::Vec<crate::model::RepositoryInput>>,
        pub(crate) client_token: std::option::Option<std::string::String>,
        pub(crate) alias: std::option::Option<std::string::String>,
        pub(crate) ides: std::option::Option<std::vec::Vec<crate::model::IdeConfiguration>>,
        pub(crate) instance_type: std::option::Option<crate::model::InstanceType>,
        pub(crate) inactivity_timeout_minutes: std::option::Option<i32>,
        pub(crate) persistent_storage:
            std::option::Option<crate::model::PersistentStorageConfiguration>,
    }
    impl Builder {
        /// <p>The name of the space.</p>
        pub fn space_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.space_name = Some(input.into());
            self
        }
        /// <p>The name of the space.</p>
        pub fn set_space_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.space_name = input;
            self
        }
        /// <p>The name of the project in the space.</p>
        pub fn project_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.project_name = Some(input.into());
            self
        }
        /// <p>The name of the project in the space.</p>
        pub fn set_project_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.project_name = input;
            self
        }
        /// Appends an item to `repositories`.
        ///
        /// To override the contents of this collection use [`set_repositories`](Self::set_repositories).
        ///
        /// <p>The source repository that contains the branch to clone into the Dev Environment. </p>
        pub fn repositories(mut self, input: crate::model::RepositoryInput) -> Self {
            let mut v = self.repositories.unwrap_or_default();
            v.push(input);
            self.repositories = Some(v);
            self
        }
        /// <p>The source repository that contains the branch to clone into the Dev Environment. </p>
        pub fn set_repositories(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RepositoryInput>>,
        ) -> Self {
            self.repositories = input;
            self
        }
        /// <p>A user-specified idempotency token. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, the subsequent retries return the result from the original successful request and have no additional effect.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        /// <p>A user-specified idempotency token. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, the subsequent retries return the result from the original successful request and have no additional effect.</p>
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input;
            self
        }
        /// <p>The user-defined alias for a Dev Environment.</p>
        pub fn alias(mut self, input: impl Into<std::string::String>) -> Self {
            self.alias = Some(input.into());
            self
        }
        /// <p>The user-defined alias for a Dev Environment.</p>
        pub fn set_alias(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.alias = input;
            self
        }
        /// Appends an item to `ides`.
        ///
        /// To override the contents of this collection use [`set_ides`](Self::set_ides).
        ///
        /// <p>Information about the integrated development environment (IDE) configured for a Dev Environment.</p> <note>
        /// <p>An IDE is required to create a Dev Environment. For Dev Environment creation, this field contains configuration information and must be provided.</p>
        /// </note>
        pub fn ides(mut self, input: crate::model::IdeConfiguration) -> Self {
            let mut v = self.ides.unwrap_or_default();
            v.push(input);
            self.ides = Some(v);
            self
        }
        /// <p>Information about the integrated development environment (IDE) configured for a Dev Environment.</p> <note>
        /// <p>An IDE is required to create a Dev Environment. For Dev Environment creation, this field contains configuration information and must be provided.</p>
        /// </note>
        pub fn set_ides(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::IdeConfiguration>>,
        ) -> Self {
            self.ides = input;
            self
        }
        /// <p>The Amazon EC2 instace type to use for the Dev Environment. </p>
        pub fn instance_type(mut self, input: crate::model::InstanceType) -> Self {
            self.instance_type = Some(input);
            self
        }
        /// <p>The Amazon EC2 instace type to use for the Dev Environment. </p>
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<crate::model::InstanceType>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        /// <p>The amount of time the Dev Environment will run without any activity detected before stopping, in minutes. Only whole integers are allowed. Dev Environments consume compute minutes when running.</p>
        pub fn inactivity_timeout_minutes(mut self, input: i32) -> Self {
            self.inactivity_timeout_minutes = Some(input);
            self
        }
        /// <p>The amount of time the Dev Environment will run without any activity detected before stopping, in minutes. Only whole integers are allowed. Dev Environments consume compute minutes when running.</p>
        pub fn set_inactivity_timeout_minutes(mut self, input: std::option::Option<i32>) -> Self {
            self.inactivity_timeout_minutes = input;
            self
        }
        /// <p>Information about the amount of storage allocated to the Dev Environment. By default, a Dev Environment is configured to have 16GB of persistent storage.</p> <note>
        /// <p>Valid values for persistent storage are based on memory sizes in 16GB increments. Valid values are 16, 32, and 64.</p>
        /// </note>
        pub fn persistent_storage(
            mut self,
            input: crate::model::PersistentStorageConfiguration,
        ) -> Self {
            self.persistent_storage = Some(input);
            self
        }
        /// <p>Information about the amount of storage allocated to the Dev Environment. By default, a Dev Environment is configured to have 16GB of persistent storage.</p> <note>
        /// <p>Valid values for persistent storage are based on memory sizes in 16GB increments. Valid values are 16, 32, and 64.</p>
        /// </note>
        pub fn set_persistent_storage(
            mut self,
            input: std::option::Option<crate::model::PersistentStorageConfiguration>,
        ) -> Self {
            self.persistent_storage = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateDevEnvironmentInput`](crate::input::CreateDevEnvironmentInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::CreateDevEnvironmentInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::CreateDevEnvironmentInput {
                space_name: self.space_name,
                project_name: self.project_name,
                repositories: self.repositories,
                client_token: self.client_token,
                alias: self.alias,
                ides: self.ides,
                instance_type: self.instance_type,
                inactivity_timeout_minutes: self.inactivity_timeout_minutes.unwrap_or_default(),
                persistent_storage: self.persistent_storage,
            })
        }
    }
}
impl CreateDevEnvironmentInput {
    /// Consumes the builder and constructs an Operation<[`CreateDevEnvironment`](crate::operation::CreateDevEnvironment)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateDevEnvironment,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_use_fips(_config.use_fips)
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateDevEnvironmentInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_1 = &_input.space_name;
                let input_1 = input_1.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "space_name",
                        "cannot be empty or unset",
                    )
                })?;
                let space_name = aws_smithy_http::label::fmt_string(
                    input_1,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if space_name.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "space_name",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_2 = &_input.project_name;
                let input_2 = input_2.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "project_name",
                        "cannot be empty or unset",
                    )
                })?;
                let project_name = aws_smithy_http::label::fmt_string(
                    input_2,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if project_name.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "project_name",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/v1/spaces/{spaceName}/projects/{projectName}/devEnvironments",
                    spaceName = space_name,
                    projectName = project_name
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateDevEnvironmentInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_dev_environment(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateDevEnvironment::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateDevEnvironment",
            "codecatalyst",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateDevEnvironmentInput`](crate::input::CreateDevEnvironmentInput).
    pub fn builder() -> crate::input::create_dev_environment_input::Builder {
        crate::input::create_dev_environment_input::Builder::default()
    }
}

/// See [`CreateProjectInput`](crate::input::CreateProjectInput).
pub mod create_project_input {

    /// A builder for [`CreateProjectInput`](crate::input::CreateProjectInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) space_name: std::option::Option<std::string::String>,
        pub(crate) display_name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the space.</p>
        pub fn space_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.space_name = Some(input.into());
            self
        }
        /// <p>The name of the space.</p>
        pub fn set_space_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.space_name = input;
            self
        }
        /// <p>The friendly name of the project that will be displayed to users.</p>
        pub fn display_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.display_name = Some(input.into());
            self
        }
        /// <p>The friendly name of the project that will be displayed to users.</p>
        pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.display_name = input;
            self
        }
        /// <p>The description of the project. This description will be displayed to all users of the project. We recommend providing a brief description of the project and its intended purpose.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the project. This description will be displayed to all users of the project. We recommend providing a brief description of the project and its intended purpose.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateProjectInput`](crate::input::CreateProjectInput).
        pub fn build(
            self,
        ) -> Result<crate::input::CreateProjectInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::CreateProjectInput {
                space_name: self.space_name,
                display_name: self.display_name,
                description: self.description,
            })
        }
    }
}
impl CreateProjectInput {
    /// Consumes the builder and constructs an Operation<[`CreateProject`](crate::operation::CreateProject)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateProject,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_use_fips(_config.use_fips)
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateProjectInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_3 = &_input.space_name;
                let input_3 = input_3.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "space_name",
                        "cannot be empty or unset",
                    )
                })?;
                let space_name = aws_smithy_http::label::fmt_string(
                    input_3,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if space_name.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "space_name",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/v1/spaces/{spaceName}/projects",
                    spaceName = space_name
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateProjectInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_project(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateProject::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateProject",
            "codecatalyst",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateProjectInput`](crate::input::CreateProjectInput).
    pub fn builder() -> crate::input::create_project_input::Builder {
        crate::input::create_project_input::Builder::default()
    }
}

/// See [`CreateSourceRepositoryBranchInput`](crate::input::CreateSourceRepositoryBranchInput).
pub mod create_source_repository_branch_input {

    /// A builder for [`CreateSourceRepositoryBranchInput`](crate::input::CreateSourceRepositoryBranchInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) space_name: std::option::Option<std::string::String>,
        pub(crate) project_name: std::option::Option<std::string::String>,
        pub(crate) source_repository_name: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) head_commit_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the space.</p>
        pub fn space_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.space_name = Some(input.into());
            self
        }
        /// <p>The name of the space.</p>
        pub fn set_space_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.space_name = input;
            self
        }
        /// <p>The name of the project in the space.</p>
        pub fn project_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.project_name = Some(input.into());
            self
        }
        /// <p>The name of the project in the space.</p>
        pub fn set_project_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.project_name = input;
            self
        }
        /// <p>The name of the repository where you want to create a branch.</p>
        pub fn source_repository_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_repository_name = Some(input.into());
            self
        }
        /// <p>The name of the repository where you want to create a branch.</p>
        pub fn set_source_repository_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_repository_name = input;
            self
        }
        /// <p>The name for the branch you're creating.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name for the branch you're creating.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The commit ID in an existing branch from which you want to create the new branch.</p>
        pub fn head_commit_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.head_commit_id = Some(input.into());
            self
        }
        /// <p>The commit ID in an existing branch from which you want to create the new branch.</p>
        pub fn set_head_commit_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.head_commit_id = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateSourceRepositoryBranchInput`](crate::input::CreateSourceRepositoryBranchInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::CreateSourceRepositoryBranchInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::CreateSourceRepositoryBranchInput {
                space_name: self.space_name,
                project_name: self.project_name,
                source_repository_name: self.source_repository_name,
                name: self.name,
                head_commit_id: self.head_commit_id,
            })
        }
    }
}
impl CreateSourceRepositoryBranchInput {
    /// Consumes the builder and constructs an Operation<[`CreateSourceRepositoryBranch`](crate::operation::CreateSourceRepositoryBranch)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateSourceRepositoryBranch,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_use_fips(_config.use_fips)
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateSourceRepositoryBranchInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_4 = &_input.space_name;
                let input_4 = input_4.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "space_name",
                        "cannot be empty or unset",
                    )
                })?;
                let space_name = aws_smithy_http::label::fmt_string(
                    input_4,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if space_name.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "space_name",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_5 = &_input.project_name;
                let input_5 = input_5.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "project_name",
                        "cannot be empty or unset",
                    )
                })?;
                let project_name = aws_smithy_http::label::fmt_string(
                    input_5,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if project_name.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "project_name",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_6 = &_input.source_repository_name;
                let input_6 = input_6.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "source_repository_name",
                        "cannot be empty or unset",
                    )
                })?;
                let source_repository_name = aws_smithy_http::label::fmt_string(
                    input_6,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if source_repository_name.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "source_repository_name",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_7 = &_input.name;
                let input_7 = input_7.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "name",
                        "cannot be empty or unset",
                    )
                })?;
                let name = aws_smithy_http::label::fmt_string(
                    input_7,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if name.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "name",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(output, "/v1/spaces/{spaceName}/projects/{projectName}/sourceRepositories/{sourceRepositoryName}/branches/{name}", spaceName = space_name, projectName = project_name, sourceRepositoryName = source_repository_name, name = name).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateSourceRepositoryBranchInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_source_repository_branch(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateSourceRepositoryBranch::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateSourceRepositoryBranch",
            "codecatalyst",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateSourceRepositoryBranchInput`](crate::input::CreateSourceRepositoryBranchInput).
    pub fn builder() -> crate::input::create_source_repository_branch_input::Builder {
        crate::input::create_source_repository_branch_input::Builder::default()
    }
}

/// See [`DeleteAccessTokenInput`](crate::input::DeleteAccessTokenInput).
pub mod delete_access_token_input {

    /// A builder for [`DeleteAccessTokenInput`](crate::input::DeleteAccessTokenInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the personal access token to delete. You can find the IDs of all PATs associated with your user account by calling <code>ListAccessTokens</code>.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The ID of the personal access token to delete. You can find the IDs of all PATs associated with your user account by calling <code>ListAccessTokens</code>.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteAccessTokenInput`](crate::input::DeleteAccessTokenInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::DeleteAccessTokenInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::DeleteAccessTokenInput { id: self.id })
        }
    }
}
impl DeleteAccessTokenInput {
    /// Consumes the builder and constructs an Operation<[`DeleteAccessToken`](crate::operation::DeleteAccessToken)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteAccessToken,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_use_fips(_config.use_fips)
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteAccessTokenInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_8 = &_input.id;
                let input_8 = input_8.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "id",
                        "cannot be empty or unset",
                    )
                })?;
                let id = aws_smithy_http::label::fmt_string(
                    input_8,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(output, "/v1/accessTokens/{id}", id = id)
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteAccessTokenInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteAccessToken::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteAccessToken",
            "codecatalyst",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteAccessTokenInput`](crate::input::DeleteAccessTokenInput).
    pub fn builder() -> crate::input::delete_access_token_input::Builder {
        crate::input::delete_access_token_input::Builder::default()
    }
}

/// See [`DeleteDevEnvironmentInput`](crate::input::DeleteDevEnvironmentInput).
pub mod delete_dev_environment_input {

    /// A builder for [`DeleteDevEnvironmentInput`](crate::input::DeleteDevEnvironmentInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) space_name: std::option::Option<std::string::String>,
        pub(crate) project_name: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the space.</p>
        pub fn space_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.space_name = Some(input.into());
            self
        }
        /// <p>The name of the space.</p>
        pub fn set_space_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.space_name = input;
            self
        }
        /// <p>The name of the project in the space.</p>
        pub fn project_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.project_name = Some(input.into());
            self
        }
        /// <p>The name of the project in the space.</p>
        pub fn set_project_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.project_name = input;
            self
        }
        /// <p>The system-generated unique ID of the Dev Environment you want to delete. To retrieve a list of Dev Environment IDs, use <code>ListDevEnvironments</code>.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The system-generated unique ID of the Dev Environment you want to delete. To retrieve a list of Dev Environment IDs, use <code>ListDevEnvironments</code>.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteDevEnvironmentInput`](crate::input::DeleteDevEnvironmentInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::DeleteDevEnvironmentInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::DeleteDevEnvironmentInput {
                space_name: self.space_name,
                project_name: self.project_name,
                id: self.id,
            })
        }
    }
}
impl DeleteDevEnvironmentInput {
    /// Consumes the builder and constructs an Operation<[`DeleteDevEnvironment`](crate::operation::DeleteDevEnvironment)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteDevEnvironment,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_use_fips(_config.use_fips)
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteDevEnvironmentInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_9 = &_input.space_name;
                let input_9 = input_9.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "space_name",
                        "cannot be empty or unset",
                    )
                })?;
                let space_name = aws_smithy_http::label::fmt_string(
                    input_9,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if space_name.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "space_name",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_10 = &_input.project_name;
                let input_10 = input_10.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "project_name",
                        "cannot be empty or unset",
                    )
                })?;
                let project_name = aws_smithy_http::label::fmt_string(
                    input_10,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if project_name.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "project_name",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_11 = &_input.id;
                let input_11 = input_11.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "id",
                        "cannot be empty or unset",
                    )
                })?;
                let id = aws_smithy_http::label::fmt_string(
                    input_11,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/v1/spaces/{spaceName}/projects/{projectName}/devEnvironments/{id}",
                    spaceName = space_name,
                    projectName = project_name,
                    id = id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteDevEnvironmentInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteDevEnvironment::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteDevEnvironment",
            "codecatalyst",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteDevEnvironmentInput`](crate::input::DeleteDevEnvironmentInput).
    pub fn builder() -> crate::input::delete_dev_environment_input::Builder {
        crate::input::delete_dev_environment_input::Builder::default()
    }
}

/// See [`GetDevEnvironmentInput`](crate::input::GetDevEnvironmentInput).
pub mod get_dev_environment_input {

    /// A builder for [`GetDevEnvironmentInput`](crate::input::GetDevEnvironmentInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) space_name: std::option::Option<std::string::String>,
        pub(crate) project_name: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the space.</p>
        pub fn space_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.space_name = Some(input.into());
            self
        }
        /// <p>The name of the space.</p>
        pub fn set_space_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.space_name = input;
            self
        }
        /// <p>The name of the project in the space.</p>
        pub fn project_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.project_name = Some(input.into());
            self
        }
        /// <p>The name of the project in the space.</p>
        pub fn set_project_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.project_name = input;
            self
        }
        /// <p>The system-generated unique ID of the Dev Environment for which you want to view information. To retrieve a list of Dev Environment IDs, use <code>ListDevEnvironments</code>.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The system-generated unique ID of the Dev Environment for which you want to view information. To retrieve a list of Dev Environment IDs, use <code>ListDevEnvironments</code>.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetDevEnvironmentInput`](crate::input::GetDevEnvironmentInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::GetDevEnvironmentInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::GetDevEnvironmentInput {
                space_name: self.space_name,
                project_name: self.project_name,
                id: self.id,
            })
        }
    }
}
impl GetDevEnvironmentInput {
    /// Consumes the builder and constructs an Operation<[`GetDevEnvironment`](crate::operation::GetDevEnvironment)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetDevEnvironment,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_use_fips(_config.use_fips)
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetDevEnvironmentInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_12 = &_input.space_name;
                let input_12 = input_12.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "space_name",
                        "cannot be empty or unset",
                    )
                })?;
                let space_name = aws_smithy_http::label::fmt_string(
                    input_12,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if space_name.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "space_name",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_13 = &_input.project_name;
                let input_13 = input_13.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "project_name",
                        "cannot be empty or unset",
                    )
                })?;
                let project_name = aws_smithy_http::label::fmt_string(
                    input_13,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if project_name.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "project_name",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_14 = &_input.id;
                let input_14 = input_14.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "id",
                        "cannot be empty or unset",
                    )
                })?;
                let id = aws_smithy_http::label::fmt_string(
                    input_14,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/v1/spaces/{spaceName}/projects/{projectName}/devEnvironments/{id}",
                    spaceName = space_name,
                    projectName = project_name,
                    id = id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetDevEnvironmentInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetDevEnvironment::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetDevEnvironment",
            "codecatalyst",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetDevEnvironmentInput`](crate::input::GetDevEnvironmentInput).
    pub fn builder() -> crate::input::get_dev_environment_input::Builder {
        crate::input::get_dev_environment_input::Builder::default()
    }
}

/// See [`GetProjectInput`](crate::input::GetProjectInput).
pub mod get_project_input {

    /// A builder for [`GetProjectInput`](crate::input::GetProjectInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) space_name: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the space.</p>
        pub fn space_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.space_name = Some(input.into());
            self
        }
        /// <p>The name of the space.</p>
        pub fn set_space_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.space_name = input;
            self
        }
        /// <p>The name of the project in the space.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the project in the space.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`GetProjectInput`](crate::input::GetProjectInput).
        pub fn build(
            self,
        ) -> Result<crate::input::GetProjectInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::GetProjectInput {
                space_name: self.space_name,
                name: self.name,
            })
        }
    }
}
impl GetProjectInput {
    /// Consumes the builder and constructs an Operation<[`GetProject`](crate::operation::GetProject)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetProject,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_use_fips(_config.use_fips)
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetProjectInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_15 = &_input.space_name;
                let input_15 = input_15.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "space_name",
                        "cannot be empty or unset",
                    )
                })?;
                let space_name = aws_smithy_http::label::fmt_string(
                    input_15,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if space_name.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "space_name",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_16 = &_input.name;
                let input_16 = input_16.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "name",
                        "cannot be empty or unset",
                    )
                })?;
                let name = aws_smithy_http::label::fmt_string(
                    input_16,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if name.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "name",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/v1/spaces/{spaceName}/projects/{name}",
                    spaceName = space_name,
                    name = name
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetProjectInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetProject::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetProject",
            "codecatalyst",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetProjectInput`](crate::input::GetProjectInput).
    pub fn builder() -> crate::input::get_project_input::Builder {
        crate::input::get_project_input::Builder::default()
    }
}

/// See [`GetSourceRepositoryCloneUrlsInput`](crate::input::GetSourceRepositoryCloneUrlsInput).
pub mod get_source_repository_clone_urls_input {

    /// A builder for [`GetSourceRepositoryCloneUrlsInput`](crate::input::GetSourceRepositoryCloneUrlsInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) space_name: std::option::Option<std::string::String>,
        pub(crate) project_name: std::option::Option<std::string::String>,
        pub(crate) source_repository_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the space.</p>
        pub fn space_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.space_name = Some(input.into());
            self
        }
        /// <p>The name of the space.</p>
        pub fn set_space_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.space_name = input;
            self
        }
        /// <p>The name of the project in the space.</p>
        pub fn project_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.project_name = Some(input.into());
            self
        }
        /// <p>The name of the project in the space.</p>
        pub fn set_project_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.project_name = input;
            self
        }
        /// <p>The name of the source repository.</p>
        pub fn source_repository_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_repository_name = Some(input.into());
            self
        }
        /// <p>The name of the source repository.</p>
        pub fn set_source_repository_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_repository_name = input;
            self
        }
        /// Consumes the builder and constructs a [`GetSourceRepositoryCloneUrlsInput`](crate::input::GetSourceRepositoryCloneUrlsInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::GetSourceRepositoryCloneUrlsInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::GetSourceRepositoryCloneUrlsInput {
                space_name: self.space_name,
                project_name: self.project_name,
                source_repository_name: self.source_repository_name,
            })
        }
    }
}
impl GetSourceRepositoryCloneUrlsInput {
    /// Consumes the builder and constructs an Operation<[`GetSourceRepositoryCloneUrls`](crate::operation::GetSourceRepositoryCloneUrls)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetSourceRepositoryCloneUrls,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_use_fips(_config.use_fips)
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetSourceRepositoryCloneUrlsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_17 = &_input.space_name;
                let input_17 = input_17.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "space_name",
                        "cannot be empty or unset",
                    )
                })?;
                let space_name = aws_smithy_http::label::fmt_string(
                    input_17,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if space_name.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "space_name",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_18 = &_input.project_name;
                let input_18 = input_18.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "project_name",
                        "cannot be empty or unset",
                    )
                })?;
                let project_name = aws_smithy_http::label::fmt_string(
                    input_18,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if project_name.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "project_name",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_19 = &_input.source_repository_name;
                let input_19 = input_19.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "source_repository_name",
                        "cannot be empty or unset",
                    )
                })?;
                let source_repository_name = aws_smithy_http::label::fmt_string(
                    input_19,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if source_repository_name.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "source_repository_name",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(output, "/v1/spaces/{spaceName}/projects/{projectName}/sourceRepositories/{sourceRepositoryName}/cloneUrls", spaceName = space_name, projectName = project_name, sourceRepositoryName = source_repository_name).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetSourceRepositoryCloneUrlsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetSourceRepositoryCloneUrls::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetSourceRepositoryCloneUrls",
            "codecatalyst",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetSourceRepositoryCloneUrlsInput`](crate::input::GetSourceRepositoryCloneUrlsInput).
    pub fn builder() -> crate::input::get_source_repository_clone_urls_input::Builder {
        crate::input::get_source_repository_clone_urls_input::Builder::default()
    }
}

/// See [`GetSpaceInput`](crate::input::GetSpaceInput).
pub mod get_space_input {

    /// A builder for [`GetSpaceInput`](crate::input::GetSpaceInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the space.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the space.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`GetSpaceInput`](crate::input::GetSpaceInput).
        pub fn build(
            self,
        ) -> Result<crate::input::GetSpaceInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::GetSpaceInput { name: self.name })
        }
    }
}
impl GetSpaceInput {
    /// Consumes the builder and constructs an Operation<[`GetSpace`](crate::operation::GetSpace)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetSpace,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_use_fips(_config.use_fips)
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetSpaceInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_20 = &_input.name;
                let input_20 = input_20.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "name",
                        "cannot be empty or unset",
                    )
                })?;
                let name = aws_smithy_http::label::fmt_string(
                    input_20,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if name.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "name",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(output, "/v1/spaces/{name}", name = name)
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetSpaceInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op =
            aws_smithy_http::operation::Operation::new(request, crate::operation::GetSpace::new())
                .with_metadata(aws_smithy_http::operation::Metadata::new(
                    "GetSpace",
                    "codecatalyst",
                ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetSpaceInput`](crate::input::GetSpaceInput).
    pub fn builder() -> crate::input::get_space_input::Builder {
        crate::input::get_space_input::Builder::default()
    }
}

/// See [`GetSubscriptionInput`](crate::input::GetSubscriptionInput).
pub mod get_subscription_input {

    /// A builder for [`GetSubscriptionInput`](crate::input::GetSubscriptionInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) space_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the space.</p>
        pub fn space_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.space_name = Some(input.into());
            self
        }
        /// <p>The name of the space.</p>
        pub fn set_space_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.space_name = input;
            self
        }
        /// Consumes the builder and constructs a [`GetSubscriptionInput`](crate::input::GetSubscriptionInput).
        pub fn build(
            self,
        ) -> Result<crate::input::GetSubscriptionInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::GetSubscriptionInput {
                space_name: self.space_name,
            })
        }
    }
}
impl GetSubscriptionInput {
    /// Consumes the builder and constructs an Operation<[`GetSubscription`](crate::operation::GetSubscription)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetSubscription,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_use_fips(_config.use_fips)
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetSubscriptionInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_21 = &_input.space_name;
                let input_21 = input_21.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "space_name",
                        "cannot be empty or unset",
                    )
                })?;
                let space_name = aws_smithy_http::label::fmt_string(
                    input_21,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if space_name.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "space_name",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/v1/spaces/{spaceName}/subscription",
                    spaceName = space_name
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetSubscriptionInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetSubscription::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetSubscription",
            "codecatalyst",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetSubscriptionInput`](crate::input::GetSubscriptionInput).
    pub fn builder() -> crate::input::get_subscription_input::Builder {
        crate::input::get_subscription_input::Builder::default()
    }
}

/// See [`GetUserDetailsInput`](crate::input::GetUserDetailsInput).
pub mod get_user_details_input {

    /// A builder for [`GetUserDetailsInput`](crate::input::GetUserDetailsInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) user_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The system-generated unique ID of the user. </p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The system-generated unique ID of the user. </p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The name of the user as displayed in Amazon CodeCatalyst.</p>
        pub fn user_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_name = Some(input.into());
            self
        }
        /// <p>The name of the user as displayed in Amazon CodeCatalyst.</p>
        pub fn set_user_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.user_name = input;
            self
        }
        /// Consumes the builder and constructs a [`GetUserDetailsInput`](crate::input::GetUserDetailsInput).
        pub fn build(
            self,
        ) -> Result<crate::input::GetUserDetailsInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::GetUserDetailsInput {
                id: self.id,
                user_name: self.user_name,
            })
        }
    }
}
impl GetUserDetailsInput {
    /// Consumes the builder and constructs an Operation<[`GetUserDetails`](crate::operation::GetUserDetails)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetUserDetails,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_use_fips(_config.use_fips)
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetUserDetailsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/userDetails").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::GetUserDetailsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_22) = &_input.id {
                    {
                        query.push_kv("id", &aws_smithy_http::query::fmt_string(&inner_22));
                    }
                }
                if let Some(inner_23) = &_input.user_name {
                    {
                        query.push_kv("userName", &aws_smithy_http::query::fmt_string(&inner_23));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetUserDetailsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetUserDetails::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetUserDetails",
            "codecatalyst",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetUserDetailsInput`](crate::input::GetUserDetailsInput).
    pub fn builder() -> crate::input::get_user_details_input::Builder {
        crate::input::get_user_details_input::Builder::default()
    }
}

/// See [`ListAccessTokensInput`](crate::input::ListAccessTokensInput).
pub mod list_access_tokens_input {

    /// A builder for [`ListAccessTokensInput`](crate::input::ListAccessTokensInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The maximum number of results to show in a single call to this API. If the number of results is larger than the number you specified, the response will include a <code>NextToken</code> element, which you can use to obtain additional results.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to show in a single call to this API. If the number of results is larger than the number you specified, the response will include a <code>NextToken</code> element, which you can use to obtain additional results.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>A token returned from a call to this API to indicate the next batch of results to return, if any.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>A token returned from a call to this API to indicate the next batch of results to return, if any.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListAccessTokensInput`](crate::input::ListAccessTokensInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::ListAccessTokensInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::ListAccessTokensInput {
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}
impl ListAccessTokensInput {
    /// Consumes the builder and constructs an Operation<[`ListAccessTokens`](crate::operation::ListAccessTokens)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListAccessTokens,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_use_fips(_config.use_fips)
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListAccessTokensInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/v1/accessTokens").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListAccessTokensInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_list_access_tokens(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListAccessTokens::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListAccessTokens",
            "codecatalyst",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListAccessTokensInput`](crate::input::ListAccessTokensInput).
    pub fn builder() -> crate::input::list_access_tokens_input::Builder {
        crate::input::list_access_tokens_input::Builder::default()
    }
}

/// See [`ListDevEnvironmentsInput`](crate::input::ListDevEnvironmentsInput).
pub mod list_dev_environments_input {

    /// A builder for [`ListDevEnvironmentsInput`](crate::input::ListDevEnvironmentsInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) space_name: std::option::Option<std::string::String>,
        pub(crate) project_name: std::option::Option<std::string::String>,
        pub(crate) filters: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The name of the space.</p>
        pub fn space_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.space_name = Some(input.into());
            self
        }
        /// <p>The name of the space.</p>
        pub fn set_space_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.space_name = input;
            self
        }
        /// <p>The name of the project in the space.</p>
        pub fn project_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.project_name = Some(input.into());
            self
        }
        /// <p>The name of the project in the space.</p>
        pub fn set_project_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.project_name = input;
            self
        }
        /// Appends an item to `filters`.
        ///
        /// To override the contents of this collection use [`set_filters`](Self::set_filters).
        ///
        /// <p>Information about filters to apply to narrow the results returned in the list.</p>
        pub fn filters(mut self, input: crate::model::Filter) -> Self {
            let mut v = self.filters.unwrap_or_default();
            v.push(input);
            self.filters = Some(v);
            self
        }
        /// <p>Information about filters to apply to narrow the results returned in the list.</p>
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.filters = input;
            self
        }
        /// <p>A token returned from a call to this API to indicate the next batch of results to return, if any.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>A token returned from a call to this API to indicate the next batch of results to return, if any.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to show in a single call to this API. If the number of results is larger than the number you specified, the response will include a <code>NextToken</code> element, which you can use to obtain additional results.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to show in a single call to this API. If the number of results is larger than the number you specified, the response will include a <code>NextToken</code> element, which you can use to obtain additional results.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListDevEnvironmentsInput`](crate::input::ListDevEnvironmentsInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::ListDevEnvironmentsInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::ListDevEnvironmentsInput {
                space_name: self.space_name,
                project_name: self.project_name,
                filters: self.filters,
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}
impl ListDevEnvironmentsInput {
    /// Consumes the builder and constructs an Operation<[`ListDevEnvironments`](crate::operation::ListDevEnvironments)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListDevEnvironments,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_use_fips(_config.use_fips)
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListDevEnvironmentsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_24 = &_input.space_name;
                let input_24 = input_24.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "space_name",
                        "cannot be empty or unset",
                    )
                })?;
                let space_name = aws_smithy_http::label::fmt_string(
                    input_24,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if space_name.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "space_name",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_25 = &_input.project_name;
                let input_25 = input_25.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "project_name",
                        "cannot be empty or unset",
                    )
                })?;
                let project_name = aws_smithy_http::label::fmt_string(
                    input_25,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if project_name.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "project_name",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/v1/spaces/{spaceName}/projects/{projectName}/devEnvironments",
                    spaceName = space_name,
                    projectName = project_name
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListDevEnvironmentsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_list_dev_environments(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListDevEnvironments::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListDevEnvironments",
            "codecatalyst",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListDevEnvironmentsInput`](crate::input::ListDevEnvironmentsInput).
    pub fn builder() -> crate::input::list_dev_environments_input::Builder {
        crate::input::list_dev_environments_input::Builder::default()
    }
}

/// See [`ListEventLogsInput`](crate::input::ListEventLogsInput).
pub mod list_event_logs_input {

    /// A builder for [`ListEventLogsInput`](crate::input::ListEventLogsInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) space_name: std::option::Option<std::string::String>,
        pub(crate) start_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) end_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) event_name: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The name of the space.</p>
        pub fn space_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.space_name = Some(input.into());
            self
        }
        /// <p>The name of the space.</p>
        pub fn set_space_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.space_name = input;
            self
        }
        /// <p>The date and time when you want to start retrieving events, in coordinated universal time (UTC) timestamp format as specified in <a href="https://www.rfc-editor.org/rfc/rfc3339#section-5.6">RFC 3339</a>.</p>
        pub fn start_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>The date and time when you want to start retrieving events, in coordinated universal time (UTC) timestamp format as specified in <a href="https://www.rfc-editor.org/rfc/rfc3339#section-5.6">RFC 3339</a>.</p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// <p>The time after which you do not want any events retrieved, in coordinated universal time (UTC) timestamp format as specified in <a href="https://www.rfc-editor.org/rfc/rfc3339#section-5.6">RFC 3339</a>.</p>
        pub fn end_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.end_time = Some(input);
            self
        }
        /// <p>The time after which you do not want any events retrieved, in coordinated universal time (UTC) timestamp format as specified in <a href="https://www.rfc-editor.org/rfc/rfc3339#section-5.6">RFC 3339</a>.</p>
        pub fn set_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.end_time = input;
            self
        }
        /// <p>The name of the event.</p>
        pub fn event_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.event_name = Some(input.into());
            self
        }
        /// <p>The name of the event.</p>
        pub fn set_event_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.event_name = input;
            self
        }
        /// <p>A token returned from a call to this API to indicate the next batch of results to return, if any.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>A token returned from a call to this API to indicate the next batch of results to return, if any.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to show in a single call to this API. If the number of results is larger than the number you specified, the response will include a <code>NextToken</code> element, which you can use to obtain additional results.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to show in a single call to this API. If the number of results is larger than the number you specified, the response will include a <code>NextToken</code> element, which you can use to obtain additional results.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListEventLogsInput`](crate::input::ListEventLogsInput).
        pub fn build(
            self,
        ) -> Result<crate::input::ListEventLogsInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::ListEventLogsInput {
                space_name: self.space_name,
                start_time: self.start_time,
                end_time: self.end_time,
                event_name: self.event_name,
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}
impl ListEventLogsInput {
    /// Consumes the builder and constructs an Operation<[`ListEventLogs`](crate::operation::ListEventLogs)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListEventLogs,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_use_fips(_config.use_fips)
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListEventLogsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_26 = &_input.space_name;
                let input_26 = input_26.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "space_name",
                        "cannot be empty or unset",
                    )
                })?;
                let space_name = aws_smithy_http::label::fmt_string(
                    input_26,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if space_name.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "space_name",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/v1/spaces/{spaceName}/eventLogs",
                    spaceName = space_name
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListEventLogsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_list_event_logs(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListEventLogs::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListEventLogs",
            "codecatalyst",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListEventLogsInput`](crate::input::ListEventLogsInput).
    pub fn builder() -> crate::input::list_event_logs_input::Builder {
        crate::input::list_event_logs_input::Builder::default()
    }
}

/// See [`ListProjectsInput`](crate::input::ListProjectsInput).
pub mod list_projects_input {

    /// A builder for [`ListProjectsInput`](crate::input::ListProjectsInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) space_name: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) filters: std::option::Option<std::vec::Vec<crate::model::ProjectListFilter>>,
    }
    impl Builder {
        /// <p>The name of the space.</p>
        pub fn space_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.space_name = Some(input.into());
            self
        }
        /// <p>The name of the space.</p>
        pub fn set_space_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.space_name = input;
            self
        }
        /// <p>A token returned from a call to this API to indicate the next batch of results to return, if any.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>A token returned from a call to this API to indicate the next batch of results to return, if any.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to show in a single call to this API. If the number of results is larger than the number you specified, the response will include a <code>NextToken</code> element, which you can use to obtain additional results.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to show in a single call to this API. If the number of results is larger than the number you specified, the response will include a <code>NextToken</code> element, which you can use to obtain additional results.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Appends an item to `filters`.
        ///
        /// To override the contents of this collection use [`set_filters`](Self::set_filters).
        ///
        /// <p>Information about filters to apply to narrow the results returned in the list.</p>
        pub fn filters(mut self, input: crate::model::ProjectListFilter) -> Self {
            let mut v = self.filters.unwrap_or_default();
            v.push(input);
            self.filters = Some(v);
            self
        }
        /// <p>Information about filters to apply to narrow the results returned in the list.</p>
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ProjectListFilter>>,
        ) -> Self {
            self.filters = input;
            self
        }
        /// Consumes the builder and constructs a [`ListProjectsInput`](crate::input::ListProjectsInput).
        pub fn build(
            self,
        ) -> Result<crate::input::ListProjectsInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::ListProjectsInput {
                space_name: self.space_name,
                next_token: self.next_token,
                max_results: self.max_results,
                filters: self.filters,
            })
        }
    }
}
impl ListProjectsInput {
    /// Consumes the builder and constructs an Operation<[`ListProjects`](crate::operation::ListProjects)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListProjects,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_use_fips(_config.use_fips)
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListProjectsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_27 = &_input.space_name;
                let input_27 = input_27.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "space_name",
                        "cannot be empty or unset",
                    )
                })?;
                let space_name = aws_smithy_http::label::fmt_string(
                    input_27,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if space_name.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "space_name",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/v1/spaces/{spaceName}/projects",
                    spaceName = space_name
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListProjectsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_list_projects(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListProjects::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListProjects",
            "codecatalyst",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListProjectsInput`](crate::input::ListProjectsInput).
    pub fn builder() -> crate::input::list_projects_input::Builder {
        crate::input::list_projects_input::Builder::default()
    }
}

/// See [`ListSourceRepositoriesInput`](crate::input::ListSourceRepositoriesInput).
pub mod list_source_repositories_input {

    /// A builder for [`ListSourceRepositoriesInput`](crate::input::ListSourceRepositoriesInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) space_name: std::option::Option<std::string::String>,
        pub(crate) project_name: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The name of the space.</p>
        pub fn space_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.space_name = Some(input.into());
            self
        }
        /// <p>The name of the space.</p>
        pub fn set_space_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.space_name = input;
            self
        }
        /// <p>The name of the project in the space.</p>
        pub fn project_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.project_name = Some(input.into());
            self
        }
        /// <p>The name of the project in the space.</p>
        pub fn set_project_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.project_name = input;
            self
        }
        /// <p>A token returned from a call to this API to indicate the next batch of results to return, if any.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>A token returned from a call to this API to indicate the next batch of results to return, if any.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to show in a single call to this API. If the number of results is larger than the number you specified, the response will include a <code>NextToken</code> element, which you can use to obtain additional results.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to show in a single call to this API. If the number of results is larger than the number you specified, the response will include a <code>NextToken</code> element, which you can use to obtain additional results.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListSourceRepositoriesInput`](crate::input::ListSourceRepositoriesInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::ListSourceRepositoriesInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::ListSourceRepositoriesInput {
                space_name: self.space_name,
                project_name: self.project_name,
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}
impl ListSourceRepositoriesInput {
    /// Consumes the builder and constructs an Operation<[`ListSourceRepositories`](crate::operation::ListSourceRepositories)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListSourceRepositories,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_use_fips(_config.use_fips)
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListSourceRepositoriesInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_28 = &_input.space_name;
                let input_28 = input_28.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "space_name",
                        "cannot be empty or unset",
                    )
                })?;
                let space_name = aws_smithy_http::label::fmt_string(
                    input_28,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if space_name.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "space_name",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_29 = &_input.project_name;
                let input_29 = input_29.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "project_name",
                        "cannot be empty or unset",
                    )
                })?;
                let project_name = aws_smithy_http::label::fmt_string(
                    input_29,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if project_name.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "project_name",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/v1/spaces/{spaceName}/projects/{projectName}/sourceRepositories",
                    spaceName = space_name,
                    projectName = project_name
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListSourceRepositoriesInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_list_source_repositories(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListSourceRepositories::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListSourceRepositories",
            "codecatalyst",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListSourceRepositoriesInput`](crate::input::ListSourceRepositoriesInput).
    pub fn builder() -> crate::input::list_source_repositories_input::Builder {
        crate::input::list_source_repositories_input::Builder::default()
    }
}

/// See [`ListSourceRepositoryBranchesInput`](crate::input::ListSourceRepositoryBranchesInput).
pub mod list_source_repository_branches_input {

    /// A builder for [`ListSourceRepositoryBranchesInput`](crate::input::ListSourceRepositoryBranchesInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) space_name: std::option::Option<std::string::String>,
        pub(crate) project_name: std::option::Option<std::string::String>,
        pub(crate) source_repository_name: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The name of the space.</p>
        pub fn space_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.space_name = Some(input.into());
            self
        }
        /// <p>The name of the space.</p>
        pub fn set_space_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.space_name = input;
            self
        }
        /// <p>The name of the project in the space.</p>
        pub fn project_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.project_name = Some(input.into());
            self
        }
        /// <p>The name of the project in the space.</p>
        pub fn set_project_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.project_name = input;
            self
        }
        /// <p>The name of the source repository.</p>
        pub fn source_repository_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_repository_name = Some(input.into());
            self
        }
        /// <p>The name of the source repository.</p>
        pub fn set_source_repository_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_repository_name = input;
            self
        }
        /// <p>A token returned from a call to this API to indicate the next batch of results to return, if any.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>A token returned from a call to this API to indicate the next batch of results to return, if any.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of results to show in a single call to this API. If the number of results is larger than the number you specified, the response will include a <code>NextToken</code> element, which you can use to obtain additional results.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to show in a single call to this API. If the number of results is larger than the number you specified, the response will include a <code>NextToken</code> element, which you can use to obtain additional results.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListSourceRepositoryBranchesInput`](crate::input::ListSourceRepositoryBranchesInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::ListSourceRepositoryBranchesInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::ListSourceRepositoryBranchesInput {
                space_name: self.space_name,
                project_name: self.project_name,
                source_repository_name: self.source_repository_name,
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}
impl ListSourceRepositoryBranchesInput {
    /// Consumes the builder and constructs an Operation<[`ListSourceRepositoryBranches`](crate::operation::ListSourceRepositoryBranches)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListSourceRepositoryBranches,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_use_fips(_config.use_fips)
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListSourceRepositoryBranchesInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_30 = &_input.space_name;
                let input_30 = input_30.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "space_name",
                        "cannot be empty or unset",
                    )
                })?;
                let space_name = aws_smithy_http::label::fmt_string(
                    input_30,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if space_name.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "space_name",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_31 = &_input.project_name;
                let input_31 = input_31.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "project_name",
                        "cannot be empty or unset",
                    )
                })?;
                let project_name = aws_smithy_http::label::fmt_string(
                    input_31,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if project_name.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "project_name",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_32 = &_input.source_repository_name;
                let input_32 = input_32.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "source_repository_name",
                        "cannot be empty or unset",
                    )
                })?;
                let source_repository_name = aws_smithy_http::label::fmt_string(
                    input_32,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if source_repository_name.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "source_repository_name",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(output, "/v1/spaces/{spaceName}/projects/{projectName}/sourceRepositories/{sourceRepositoryName}/branches", spaceName = space_name, projectName = project_name, sourceRepositoryName = source_repository_name).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListSourceRepositoryBranchesInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_list_source_repository_branches(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListSourceRepositoryBranches::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListSourceRepositoryBranches",
            "codecatalyst",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListSourceRepositoryBranchesInput`](crate::input::ListSourceRepositoryBranchesInput).
    pub fn builder() -> crate::input::list_source_repository_branches_input::Builder {
        crate::input::list_source_repository_branches_input::Builder::default()
    }
}

/// See [`ListSpacesInput`](crate::input::ListSpacesInput).
pub mod list_spaces_input {

    /// A builder for [`ListSpacesInput`](crate::input::ListSpacesInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A token returned from a call to this API to indicate the next batch of results to return, if any.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>A token returned from a call to this API to indicate the next batch of results to return, if any.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListSpacesInput`](crate::input::ListSpacesInput).
        pub fn build(
            self,
        ) -> Result<crate::input::ListSpacesInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::ListSpacesInput {
                next_token: self.next_token,
            })
        }
    }
}
impl ListSpacesInput {
    /// Consumes the builder and constructs an Operation<[`ListSpaces`](crate::operation::ListSpaces)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListSpaces,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_use_fips(_config.use_fips)
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListSpacesInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/v1/spaces").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListSpacesInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_list_spaces(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListSpaces::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListSpaces",
            "codecatalyst",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListSpacesInput`](crate::input::ListSpacesInput).
    pub fn builder() -> crate::input::list_spaces_input::Builder {
        crate::input::list_spaces_input::Builder::default()
    }
}

/// See [`StartDevEnvironmentInput`](crate::input::StartDevEnvironmentInput).
pub mod start_dev_environment_input {

    /// A builder for [`StartDevEnvironmentInput`](crate::input::StartDevEnvironmentInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) space_name: std::option::Option<std::string::String>,
        pub(crate) project_name: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) ides: std::option::Option<std::vec::Vec<crate::model::IdeConfiguration>>,
        pub(crate) instance_type: std::option::Option<crate::model::InstanceType>,
        pub(crate) inactivity_timeout_minutes: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The name of the space.</p>
        pub fn space_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.space_name = Some(input.into());
            self
        }
        /// <p>The name of the space.</p>
        pub fn set_space_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.space_name = input;
            self
        }
        /// <p>The name of the project in the space.</p>
        pub fn project_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.project_name = Some(input.into());
            self
        }
        /// <p>The name of the project in the space.</p>
        pub fn set_project_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.project_name = input;
            self
        }
        /// <p>The system-generated unique ID of the Dev Environment. </p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The system-generated unique ID of the Dev Environment. </p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// Appends an item to `ides`.
        ///
        /// To override the contents of this collection use [`set_ides`](Self::set_ides).
        ///
        /// <p>Information about the integrated development environment (IDE) configured for a Dev Environment. </p>
        pub fn ides(mut self, input: crate::model::IdeConfiguration) -> Self {
            let mut v = self.ides.unwrap_or_default();
            v.push(input);
            self.ides = Some(v);
            self
        }
        /// <p>Information about the integrated development environment (IDE) configured for a Dev Environment. </p>
        pub fn set_ides(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::IdeConfiguration>>,
        ) -> Self {
            self.ides = input;
            self
        }
        /// <p>The Amazon EC2 instace type to use for the Dev Environment. </p>
        pub fn instance_type(mut self, input: crate::model::InstanceType) -> Self {
            self.instance_type = Some(input);
            self
        }
        /// <p>The Amazon EC2 instace type to use for the Dev Environment. </p>
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<crate::model::InstanceType>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        /// <p>The amount of time the Dev Environment will run without any activity detected before stopping, in minutes. Only whole integers are allowed. Dev Environments consume compute minutes when running.</p>
        pub fn inactivity_timeout_minutes(mut self, input: i32) -> Self {
            self.inactivity_timeout_minutes = Some(input);
            self
        }
        /// <p>The amount of time the Dev Environment will run without any activity detected before stopping, in minutes. Only whole integers are allowed. Dev Environments consume compute minutes when running.</p>
        pub fn set_inactivity_timeout_minutes(mut self, input: std::option::Option<i32>) -> Self {
            self.inactivity_timeout_minutes = input;
            self
        }
        /// Consumes the builder and constructs a [`StartDevEnvironmentInput`](crate::input::StartDevEnvironmentInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::StartDevEnvironmentInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::StartDevEnvironmentInput {
                space_name: self.space_name,
                project_name: self.project_name,
                id: self.id,
                ides: self.ides,
                instance_type: self.instance_type,
                inactivity_timeout_minutes: self.inactivity_timeout_minutes.unwrap_or_default(),
            })
        }
    }
}
impl StartDevEnvironmentInput {
    /// Consumes the builder and constructs an Operation<[`StartDevEnvironment`](crate::operation::StartDevEnvironment)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::StartDevEnvironment,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_use_fips(_config.use_fips)
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::StartDevEnvironmentInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_33 = &_input.space_name;
                let input_33 = input_33.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "space_name",
                        "cannot be empty or unset",
                    )
                })?;
                let space_name = aws_smithy_http::label::fmt_string(
                    input_33,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if space_name.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "space_name",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_34 = &_input.project_name;
                let input_34 = input_34.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "project_name",
                        "cannot be empty or unset",
                    )
                })?;
                let project_name = aws_smithy_http::label::fmt_string(
                    input_34,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if project_name.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "project_name",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_35 = &_input.id;
                let input_35 = input_35.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "id",
                        "cannot be empty or unset",
                    )
                })?;
                let id = aws_smithy_http::label::fmt_string(
                    input_35,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/v1/spaces/{spaceName}/projects/{projectName}/devEnvironments/{id}/start",
                    spaceName = space_name,
                    projectName = project_name,
                    id = id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::StartDevEnvironmentInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_start_dev_environment(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::StartDevEnvironment::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "StartDevEnvironment",
            "codecatalyst",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`StartDevEnvironmentInput`](crate::input::StartDevEnvironmentInput).
    pub fn builder() -> crate::input::start_dev_environment_input::Builder {
        crate::input::start_dev_environment_input::Builder::default()
    }
}

/// See [`StartDevEnvironmentSessionInput`](crate::input::StartDevEnvironmentSessionInput).
pub mod start_dev_environment_session_input {

    /// A builder for [`StartDevEnvironmentSessionInput`](crate::input::StartDevEnvironmentSessionInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) space_name: std::option::Option<std::string::String>,
        pub(crate) project_name: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) session_configuration:
            std::option::Option<crate::model::DevEnvironmentSessionConfiguration>,
    }
    impl Builder {
        /// <p>The name of the space.</p>
        pub fn space_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.space_name = Some(input.into());
            self
        }
        /// <p>The name of the space.</p>
        pub fn set_space_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.space_name = input;
            self
        }
        /// <p>The name of the project in the space.</p>
        pub fn project_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.project_name = Some(input.into());
            self
        }
        /// <p>The name of the project in the space.</p>
        pub fn set_project_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.project_name = input;
            self
        }
        /// <p>The system-generated unique ID of the Dev Environment.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The system-generated unique ID of the Dev Environment.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>Information about the configuration of a Dev Environment session.</p>
        pub fn session_configuration(
            mut self,
            input: crate::model::DevEnvironmentSessionConfiguration,
        ) -> Self {
            self.session_configuration = Some(input);
            self
        }
        /// <p>Information about the configuration of a Dev Environment session.</p>
        pub fn set_session_configuration(
            mut self,
            input: std::option::Option<crate::model::DevEnvironmentSessionConfiguration>,
        ) -> Self {
            self.session_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`StartDevEnvironmentSessionInput`](crate::input::StartDevEnvironmentSessionInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::StartDevEnvironmentSessionInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::StartDevEnvironmentSessionInput {
                space_name: self.space_name,
                project_name: self.project_name,
                id: self.id,
                session_configuration: self.session_configuration,
            })
        }
    }
}
impl StartDevEnvironmentSessionInput {
    /// Consumes the builder and constructs an Operation<[`StartDevEnvironmentSession`](crate::operation::StartDevEnvironmentSession)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::StartDevEnvironmentSession,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_use_fips(_config.use_fips)
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::StartDevEnvironmentSessionInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_36 = &_input.space_name;
                let input_36 = input_36.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "space_name",
                        "cannot be empty or unset",
                    )
                })?;
                let space_name = aws_smithy_http::label::fmt_string(
                    input_36,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if space_name.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "space_name",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_37 = &_input.project_name;
                let input_37 = input_37.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "project_name",
                        "cannot be empty or unset",
                    )
                })?;
                let project_name = aws_smithy_http::label::fmt_string(
                    input_37,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if project_name.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "project_name",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_38 = &_input.id;
                let input_38 = input_38.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "id",
                        "cannot be empty or unset",
                    )
                })?;
                let id = aws_smithy_http::label::fmt_string(
                    input_38,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/v1/spaces/{spaceName}/projects/{projectName}/devEnvironments/{id}/session",
                    spaceName = space_name,
                    projectName = project_name,
                    id = id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::StartDevEnvironmentSessionInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_start_dev_environment_session(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::StartDevEnvironmentSession::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "StartDevEnvironmentSession",
            "codecatalyst",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`StartDevEnvironmentSessionInput`](crate::input::StartDevEnvironmentSessionInput).
    pub fn builder() -> crate::input::start_dev_environment_session_input::Builder {
        crate::input::start_dev_environment_session_input::Builder::default()
    }
}

/// See [`StopDevEnvironmentInput`](crate::input::StopDevEnvironmentInput).
pub mod stop_dev_environment_input {

    /// A builder for [`StopDevEnvironmentInput`](crate::input::StopDevEnvironmentInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) space_name: std::option::Option<std::string::String>,
        pub(crate) project_name: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the space.</p>
        pub fn space_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.space_name = Some(input.into());
            self
        }
        /// <p>The name of the space.</p>
        pub fn set_space_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.space_name = input;
            self
        }
        /// <p>The name of the project in the space.</p>
        pub fn project_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.project_name = Some(input.into());
            self
        }
        /// <p>The name of the project in the space.</p>
        pub fn set_project_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.project_name = input;
            self
        }
        /// <p>The system-generated unique ID of the Dev Environment. </p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The system-generated unique ID of the Dev Environment. </p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// Consumes the builder and constructs a [`StopDevEnvironmentInput`](crate::input::StopDevEnvironmentInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::StopDevEnvironmentInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::StopDevEnvironmentInput {
                space_name: self.space_name,
                project_name: self.project_name,
                id: self.id,
            })
        }
    }
}
impl StopDevEnvironmentInput {
    /// Consumes the builder and constructs an Operation<[`StopDevEnvironment`](crate::operation::StopDevEnvironment)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::StopDevEnvironment,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_use_fips(_config.use_fips)
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::StopDevEnvironmentInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_39 = &_input.space_name;
                let input_39 = input_39.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "space_name",
                        "cannot be empty or unset",
                    )
                })?;
                let space_name = aws_smithy_http::label::fmt_string(
                    input_39,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if space_name.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "space_name",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_40 = &_input.project_name;
                let input_40 = input_40.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "project_name",
                        "cannot be empty or unset",
                    )
                })?;
                let project_name = aws_smithy_http::label::fmt_string(
                    input_40,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if project_name.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "project_name",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_41 = &_input.id;
                let input_41 = input_41.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "id",
                        "cannot be empty or unset",
                    )
                })?;
                let id = aws_smithy_http::label::fmt_string(
                    input_41,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/v1/spaces/{spaceName}/projects/{projectName}/devEnvironments/{id}/stop",
                    spaceName = space_name,
                    projectName = project_name,
                    id = id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::StopDevEnvironmentInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::StopDevEnvironment::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "StopDevEnvironment",
            "codecatalyst",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`StopDevEnvironmentInput`](crate::input::StopDevEnvironmentInput).
    pub fn builder() -> crate::input::stop_dev_environment_input::Builder {
        crate::input::stop_dev_environment_input::Builder::default()
    }
}

/// See [`UpdateDevEnvironmentInput`](crate::input::UpdateDevEnvironmentInput).
pub mod update_dev_environment_input {

    /// A builder for [`UpdateDevEnvironmentInput`](crate::input::UpdateDevEnvironmentInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) space_name: std::option::Option<std::string::String>,
        pub(crate) project_name: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) alias: std::option::Option<std::string::String>,
        pub(crate) ides: std::option::Option<std::vec::Vec<crate::model::IdeConfiguration>>,
        pub(crate) instance_type: std::option::Option<crate::model::InstanceType>,
        pub(crate) inactivity_timeout_minutes: std::option::Option<i32>,
        pub(crate) client_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the space.</p>
        pub fn space_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.space_name = Some(input.into());
            self
        }
        /// <p>The name of the space.</p>
        pub fn set_space_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.space_name = input;
            self
        }
        /// <p>The name of the project in the space.</p>
        pub fn project_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.project_name = Some(input.into());
            self
        }
        /// <p>The name of the project in the space.</p>
        pub fn set_project_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.project_name = input;
            self
        }
        /// <p>The system-generated unique ID of the Dev Environment. </p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The system-generated unique ID of the Dev Environment. </p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The user-specified alias for the Dev Environment. Changing this value will not cause a restart.</p>
        pub fn alias(mut self, input: impl Into<std::string::String>) -> Self {
            self.alias = Some(input.into());
            self
        }
        /// <p>The user-specified alias for the Dev Environment. Changing this value will not cause a restart.</p>
        pub fn set_alias(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.alias = input;
            self
        }
        /// Appends an item to `ides`.
        ///
        /// To override the contents of this collection use [`set_ides`](Self::set_ides).
        ///
        /// <p>Information about the integrated development environment (IDE) configured for a Dev Environment.</p>
        pub fn ides(mut self, input: crate::model::IdeConfiguration) -> Self {
            let mut v = self.ides.unwrap_or_default();
            v.push(input);
            self.ides = Some(v);
            self
        }
        /// <p>Information about the integrated development environment (IDE) configured for a Dev Environment.</p>
        pub fn set_ides(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::IdeConfiguration>>,
        ) -> Self {
            self.ides = input;
            self
        }
        /// <p>The Amazon EC2 instace type to use for the Dev Environment. </p> <note>
        /// <p>Changing this value will cause a restart of the Dev Environment if it is running.</p>
        /// </note>
        pub fn instance_type(mut self, input: crate::model::InstanceType) -> Self {
            self.instance_type = Some(input);
            self
        }
        /// <p>The Amazon EC2 instace type to use for the Dev Environment. </p> <note>
        /// <p>Changing this value will cause a restart of the Dev Environment if it is running.</p>
        /// </note>
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<crate::model::InstanceType>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        /// <p>The amount of time the Dev Environment will run without any activity detected before stopping, in minutes. Only whole integers are allowed. Dev Environments consume compute minutes when running.</p> <note>
        /// <p>Changing this value will cause a restart of the Dev Environment if it is running.</p>
        /// </note>
        pub fn inactivity_timeout_minutes(mut self, input: i32) -> Self {
            self.inactivity_timeout_minutes = Some(input);
            self
        }
        /// <p>The amount of time the Dev Environment will run without any activity detected before stopping, in minutes. Only whole integers are allowed. Dev Environments consume compute minutes when running.</p> <note>
        /// <p>Changing this value will cause a restart of the Dev Environment if it is running.</p>
        /// </note>
        pub fn set_inactivity_timeout_minutes(mut self, input: std::option::Option<i32>) -> Self {
            self.inactivity_timeout_minutes = input;
            self
        }
        /// <p>A user-specified idempotency token. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, the subsequent retries return the result from the original successful request and have no additional effect.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        /// <p>A user-specified idempotency token. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, the subsequent retries return the result from the original successful request and have no additional effect.</p>
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateDevEnvironmentInput`](crate::input::UpdateDevEnvironmentInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::UpdateDevEnvironmentInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::UpdateDevEnvironmentInput {
                space_name: self.space_name,
                project_name: self.project_name,
                id: self.id,
                alias: self.alias,
                ides: self.ides,
                instance_type: self.instance_type,
                inactivity_timeout_minutes: self.inactivity_timeout_minutes.unwrap_or_default(),
                client_token: self.client_token,
            })
        }
    }
}
impl UpdateDevEnvironmentInput {
    /// Consumes the builder and constructs an Operation<[`UpdateDevEnvironment`](crate::operation::UpdateDevEnvironment)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateDevEnvironment,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_use_fips(_config.use_fips)
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateDevEnvironmentInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_42 = &_input.space_name;
                let input_42 = input_42.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "space_name",
                        "cannot be empty or unset",
                    )
                })?;
                let space_name = aws_smithy_http::label::fmt_string(
                    input_42,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if space_name.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "space_name",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_43 = &_input.project_name;
                let input_43 = input_43.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "project_name",
                        "cannot be empty or unset",
                    )
                })?;
                let project_name = aws_smithy_http::label::fmt_string(
                    input_43,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if project_name.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "project_name",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_44 = &_input.id;
                let input_44 = input_44.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "id",
                        "cannot be empty or unset",
                    )
                })?;
                let id = aws_smithy_http::label::fmt_string(
                    input_44,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/v1/spaces/{spaceName}/projects/{projectName}/devEnvironments/{id}",
                    spaceName = space_name,
                    projectName = project_name,
                    id = id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateDevEnvironmentInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PATCH").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_dev_environment(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateDevEnvironment::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateDevEnvironment",
            "codecatalyst",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateDevEnvironmentInput`](crate::input::UpdateDevEnvironmentInput).
    pub fn builder() -> crate::input::update_dev_environment_input::Builder {
        crate::input::update_dev_environment_input::Builder::default()
    }
}

/// See [`VerifySessionInput`](crate::input::VerifySessionInput).
pub mod verify_session_input {

    /// A builder for [`VerifySessionInput`](crate::input::VerifySessionInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`VerifySessionInput`](crate::input::VerifySessionInput).
        pub fn build(
            self,
        ) -> Result<crate::input::VerifySessionInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::VerifySessionInput {})
        }
    }
}
impl VerifySessionInput {
    /// Consumes the builder and constructs an Operation<[`VerifySession`](crate::operation::VerifySession)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::VerifySession,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_use_fips(_config.use_fips)
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::VerifySessionInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/session").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::VerifySessionInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::VerifySession::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "VerifySession",
            "codecatalyst",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`VerifySessionInput`](crate::input::VerifySessionInput).
    pub fn builder() -> crate::input::verify_session_input::Builder {
        crate::input::verify_session_input::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListSpacesInput {
    /// <p>A token returned from a call to this API to indicate the next batch of results to return, if any.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl ListSpacesInput {
    /// <p>A token returned from a call to this API to indicate the next batch of results to return, if any.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetSpaceInput {
    /// <p>The name of the space.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
}
impl GetSpaceInput {
    /// <p>The name of the space.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetSubscriptionInput {
    /// <p>The name of the space.</p>
    #[doc(hidden)]
    pub space_name: std::option::Option<std::string::String>,
}
impl GetSubscriptionInput {
    /// <p>The name of the space.</p>
    pub fn space_name(&self) -> std::option::Option<&str> {
        self.space_name.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListProjectsInput {
    /// <p>The name of the space.</p>
    #[doc(hidden)]
    pub space_name: std::option::Option<std::string::String>,
    /// <p>A token returned from a call to this API to indicate the next batch of results to return, if any.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to show in a single call to this API. If the number of results is larger than the number you specified, the response will include a <code>NextToken</code> element, which you can use to obtain additional results.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>Information about filters to apply to narrow the results returned in the list.</p>
    #[doc(hidden)]
    pub filters: std::option::Option<std::vec::Vec<crate::model::ProjectListFilter>>,
}
impl ListProjectsInput {
    /// <p>The name of the space.</p>
    pub fn space_name(&self) -> std::option::Option<&str> {
        self.space_name.as_deref()
    }
    /// <p>A token returned from a call to this API to indicate the next batch of results to return, if any.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to show in a single call to this API. If the number of results is larger than the number you specified, the response will include a <code>NextToken</code> element, which you can use to obtain additional results.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>Information about filters to apply to narrow the results returned in the list.</p>
    pub fn filters(&self) -> std::option::Option<&[crate::model::ProjectListFilter]> {
        self.filters.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateProjectInput {
    /// <p>The name of the space.</p>
    #[doc(hidden)]
    pub space_name: std::option::Option<std::string::String>,
    /// <p>The friendly name of the project that will be displayed to users.</p>
    #[doc(hidden)]
    pub display_name: std::option::Option<std::string::String>,
    /// <p>The description of the project. This description will be displayed to all users of the project. We recommend providing a brief description of the project and its intended purpose.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
}
impl CreateProjectInput {
    /// <p>The name of the space.</p>
    pub fn space_name(&self) -> std::option::Option<&str> {
        self.space_name.as_deref()
    }
    /// <p>The friendly name of the project that will be displayed to users.</p>
    pub fn display_name(&self) -> std::option::Option<&str> {
        self.display_name.as_deref()
    }
    /// <p>The description of the project. This description will be displayed to all users of the project. We recommend providing a brief description of the project and its intended purpose.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetProjectInput {
    /// <p>The name of the space.</p>
    #[doc(hidden)]
    pub space_name: std::option::Option<std::string::String>,
    /// <p>The name of the project in the space.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
}
impl GetProjectInput {
    /// <p>The name of the space.</p>
    pub fn space_name(&self) -> std::option::Option<&str> {
        self.space_name.as_deref()
    }
    /// <p>The name of the project in the space.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetSourceRepositoryCloneUrlsInput {
    /// <p>The name of the space.</p>
    #[doc(hidden)]
    pub space_name: std::option::Option<std::string::String>,
    /// <p>The name of the project in the space.</p>
    #[doc(hidden)]
    pub project_name: std::option::Option<std::string::String>,
    /// <p>The name of the source repository.</p>
    #[doc(hidden)]
    pub source_repository_name: std::option::Option<std::string::String>,
}
impl GetSourceRepositoryCloneUrlsInput {
    /// <p>The name of the space.</p>
    pub fn space_name(&self) -> std::option::Option<&str> {
        self.space_name.as_deref()
    }
    /// <p>The name of the project in the space.</p>
    pub fn project_name(&self) -> std::option::Option<&str> {
        self.project_name.as_deref()
    }
    /// <p>The name of the source repository.</p>
    pub fn source_repository_name(&self) -> std::option::Option<&str> {
        self.source_repository_name.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListSourceRepositoriesInput {
    /// <p>The name of the space.</p>
    #[doc(hidden)]
    pub space_name: std::option::Option<std::string::String>,
    /// <p>The name of the project in the space.</p>
    #[doc(hidden)]
    pub project_name: std::option::Option<std::string::String>,
    /// <p>A token returned from a call to this API to indicate the next batch of results to return, if any.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to show in a single call to this API. If the number of results is larger than the number you specified, the response will include a <code>NextToken</code> element, which you can use to obtain additional results.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl ListSourceRepositoriesInput {
    /// <p>The name of the space.</p>
    pub fn space_name(&self) -> std::option::Option<&str> {
        self.space_name.as_deref()
    }
    /// <p>The name of the project in the space.</p>
    pub fn project_name(&self) -> std::option::Option<&str> {
        self.project_name.as_deref()
    }
    /// <p>A token returned from a call to this API to indicate the next batch of results to return, if any.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to show in a single call to this API. If the number of results is larger than the number you specified, the response will include a <code>NextToken</code> element, which you can use to obtain additional results.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListSourceRepositoryBranchesInput {
    /// <p>The name of the space.</p>
    #[doc(hidden)]
    pub space_name: std::option::Option<std::string::String>,
    /// <p>The name of the project in the space.</p>
    #[doc(hidden)]
    pub project_name: std::option::Option<std::string::String>,
    /// <p>The name of the source repository.</p>
    #[doc(hidden)]
    pub source_repository_name: std::option::Option<std::string::String>,
    /// <p>A token returned from a call to this API to indicate the next batch of results to return, if any.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to show in a single call to this API. If the number of results is larger than the number you specified, the response will include a <code>NextToken</code> element, which you can use to obtain additional results.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl ListSourceRepositoryBranchesInput {
    /// <p>The name of the space.</p>
    pub fn space_name(&self) -> std::option::Option<&str> {
        self.space_name.as_deref()
    }
    /// <p>The name of the project in the space.</p>
    pub fn project_name(&self) -> std::option::Option<&str> {
        self.project_name.as_deref()
    }
    /// <p>The name of the source repository.</p>
    pub fn source_repository_name(&self) -> std::option::Option<&str> {
        self.source_repository_name.as_deref()
    }
    /// <p>A token returned from a call to this API to indicate the next batch of results to return, if any.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to show in a single call to this API. If the number of results is larger than the number you specified, the response will include a <code>NextToken</code> element, which you can use to obtain additional results.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateSourceRepositoryBranchInput {
    /// <p>The name of the space.</p>
    #[doc(hidden)]
    pub space_name: std::option::Option<std::string::String>,
    /// <p>The name of the project in the space.</p>
    #[doc(hidden)]
    pub project_name: std::option::Option<std::string::String>,
    /// <p>The name of the repository where you want to create a branch.</p>
    #[doc(hidden)]
    pub source_repository_name: std::option::Option<std::string::String>,
    /// <p>The name for the branch you're creating.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The commit ID in an existing branch from which you want to create the new branch.</p>
    #[doc(hidden)]
    pub head_commit_id: std::option::Option<std::string::String>,
}
impl CreateSourceRepositoryBranchInput {
    /// <p>The name of the space.</p>
    pub fn space_name(&self) -> std::option::Option<&str> {
        self.space_name.as_deref()
    }
    /// <p>The name of the project in the space.</p>
    pub fn project_name(&self) -> std::option::Option<&str> {
        self.project_name.as_deref()
    }
    /// <p>The name of the repository where you want to create a branch.</p>
    pub fn source_repository_name(&self) -> std::option::Option<&str> {
        self.source_repository_name.as_deref()
    }
    /// <p>The name for the branch you're creating.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The commit ID in an existing branch from which you want to create the new branch.</p>
    pub fn head_commit_id(&self) -> std::option::Option<&str> {
        self.head_commit_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StopDevEnvironmentInput {
    /// <p>The name of the space.</p>
    #[doc(hidden)]
    pub space_name: std::option::Option<std::string::String>,
    /// <p>The name of the project in the space.</p>
    #[doc(hidden)]
    pub project_name: std::option::Option<std::string::String>,
    /// <p>The system-generated unique ID of the Dev Environment. </p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
}
impl StopDevEnvironmentInput {
    /// <p>The name of the space.</p>
    pub fn space_name(&self) -> std::option::Option<&str> {
        self.space_name.as_deref()
    }
    /// <p>The name of the project in the space.</p>
    pub fn project_name(&self) -> std::option::Option<&str> {
        self.project_name.as_deref()
    }
    /// <p>The system-generated unique ID of the Dev Environment. </p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StartDevEnvironmentSessionInput {
    /// <p>The name of the space.</p>
    #[doc(hidden)]
    pub space_name: std::option::Option<std::string::String>,
    /// <p>The name of the project in the space.</p>
    #[doc(hidden)]
    pub project_name: std::option::Option<std::string::String>,
    /// <p>The system-generated unique ID of the Dev Environment.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>Information about the configuration of a Dev Environment session.</p>
    #[doc(hidden)]
    pub session_configuration:
        std::option::Option<crate::model::DevEnvironmentSessionConfiguration>,
}
impl StartDevEnvironmentSessionInput {
    /// <p>The name of the space.</p>
    pub fn space_name(&self) -> std::option::Option<&str> {
        self.space_name.as_deref()
    }
    /// <p>The name of the project in the space.</p>
    pub fn project_name(&self) -> std::option::Option<&str> {
        self.project_name.as_deref()
    }
    /// <p>The system-generated unique ID of the Dev Environment.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>Information about the configuration of a Dev Environment session.</p>
    pub fn session_configuration(
        &self,
    ) -> std::option::Option<&crate::model::DevEnvironmentSessionConfiguration> {
        self.session_configuration.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StartDevEnvironmentInput {
    /// <p>The name of the space.</p>
    #[doc(hidden)]
    pub space_name: std::option::Option<std::string::String>,
    /// <p>The name of the project in the space.</p>
    #[doc(hidden)]
    pub project_name: std::option::Option<std::string::String>,
    /// <p>The system-generated unique ID of the Dev Environment. </p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>Information about the integrated development environment (IDE) configured for a Dev Environment. </p>
    #[doc(hidden)]
    pub ides: std::option::Option<std::vec::Vec<crate::model::IdeConfiguration>>,
    /// <p>The Amazon EC2 instace type to use for the Dev Environment. </p>
    #[doc(hidden)]
    pub instance_type: std::option::Option<crate::model::InstanceType>,
    /// <p>The amount of time the Dev Environment will run without any activity detected before stopping, in minutes. Only whole integers are allowed. Dev Environments consume compute minutes when running.</p>
    #[doc(hidden)]
    pub inactivity_timeout_minutes: i32,
}
impl StartDevEnvironmentInput {
    /// <p>The name of the space.</p>
    pub fn space_name(&self) -> std::option::Option<&str> {
        self.space_name.as_deref()
    }
    /// <p>The name of the project in the space.</p>
    pub fn project_name(&self) -> std::option::Option<&str> {
        self.project_name.as_deref()
    }
    /// <p>The system-generated unique ID of the Dev Environment. </p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>Information about the integrated development environment (IDE) configured for a Dev Environment. </p>
    pub fn ides(&self) -> std::option::Option<&[crate::model::IdeConfiguration]> {
        self.ides.as_deref()
    }
    /// <p>The Amazon EC2 instace type to use for the Dev Environment. </p>
    pub fn instance_type(&self) -> std::option::Option<&crate::model::InstanceType> {
        self.instance_type.as_ref()
    }
    /// <p>The amount of time the Dev Environment will run without any activity detected before stopping, in minutes. Only whole integers are allowed. Dev Environments consume compute minutes when running.</p>
    pub fn inactivity_timeout_minutes(&self) -> i32 {
        self.inactivity_timeout_minutes
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListDevEnvironmentsInput {
    /// <p>The name of the space.</p>
    #[doc(hidden)]
    pub space_name: std::option::Option<std::string::String>,
    /// <p>The name of the project in the space.</p>
    #[doc(hidden)]
    pub project_name: std::option::Option<std::string::String>,
    /// <p>Information about filters to apply to narrow the results returned in the list.</p>
    #[doc(hidden)]
    pub filters: std::option::Option<std::vec::Vec<crate::model::Filter>>,
    /// <p>A token returned from a call to this API to indicate the next batch of results to return, if any.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to show in a single call to this API. If the number of results is larger than the number you specified, the response will include a <code>NextToken</code> element, which you can use to obtain additional results.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl ListDevEnvironmentsInput {
    /// <p>The name of the space.</p>
    pub fn space_name(&self) -> std::option::Option<&str> {
        self.space_name.as_deref()
    }
    /// <p>The name of the project in the space.</p>
    pub fn project_name(&self) -> std::option::Option<&str> {
        self.project_name.as_deref()
    }
    /// <p>Information about filters to apply to narrow the results returned in the list.</p>
    pub fn filters(&self) -> std::option::Option<&[crate::model::Filter]> {
        self.filters.as_deref()
    }
    /// <p>A token returned from a call to this API to indicate the next batch of results to return, if any.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to show in a single call to this API. If the number of results is larger than the number you specified, the response will include a <code>NextToken</code> element, which you can use to obtain additional results.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateDevEnvironmentInput {
    /// <p>The name of the space.</p>
    #[doc(hidden)]
    pub space_name: std::option::Option<std::string::String>,
    /// <p>The name of the project in the space.</p>
    #[doc(hidden)]
    pub project_name: std::option::Option<std::string::String>,
    /// <p>The source repository that contains the branch to clone into the Dev Environment. </p>
    #[doc(hidden)]
    pub repositories: std::option::Option<std::vec::Vec<crate::model::RepositoryInput>>,
    /// <p>A user-specified idempotency token. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, the subsequent retries return the result from the original successful request and have no additional effect.</p>
    #[doc(hidden)]
    pub client_token: std::option::Option<std::string::String>,
    /// <p>The user-defined alias for a Dev Environment.</p>
    #[doc(hidden)]
    pub alias: std::option::Option<std::string::String>,
    /// <p>Information about the integrated development environment (IDE) configured for a Dev Environment.</p> <note>
    /// <p>An IDE is required to create a Dev Environment. For Dev Environment creation, this field contains configuration information and must be provided.</p>
    /// </note>
    #[doc(hidden)]
    pub ides: std::option::Option<std::vec::Vec<crate::model::IdeConfiguration>>,
    /// <p>The Amazon EC2 instace type to use for the Dev Environment. </p>
    #[doc(hidden)]
    pub instance_type: std::option::Option<crate::model::InstanceType>,
    /// <p>The amount of time the Dev Environment will run without any activity detected before stopping, in minutes. Only whole integers are allowed. Dev Environments consume compute minutes when running.</p>
    #[doc(hidden)]
    pub inactivity_timeout_minutes: i32,
    /// <p>Information about the amount of storage allocated to the Dev Environment. By default, a Dev Environment is configured to have 16GB of persistent storage.</p> <note>
    /// <p>Valid values for persistent storage are based on memory sizes in 16GB increments. Valid values are 16, 32, and 64.</p>
    /// </note>
    #[doc(hidden)]
    pub persistent_storage: std::option::Option<crate::model::PersistentStorageConfiguration>,
}
impl CreateDevEnvironmentInput {
    /// <p>The name of the space.</p>
    pub fn space_name(&self) -> std::option::Option<&str> {
        self.space_name.as_deref()
    }
    /// <p>The name of the project in the space.</p>
    pub fn project_name(&self) -> std::option::Option<&str> {
        self.project_name.as_deref()
    }
    /// <p>The source repository that contains the branch to clone into the Dev Environment. </p>
    pub fn repositories(&self) -> std::option::Option<&[crate::model::RepositoryInput]> {
        self.repositories.as_deref()
    }
    /// <p>A user-specified idempotency token. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, the subsequent retries return the result from the original successful request and have no additional effect.</p>
    pub fn client_token(&self) -> std::option::Option<&str> {
        self.client_token.as_deref()
    }
    /// <p>The user-defined alias for a Dev Environment.</p>
    pub fn alias(&self) -> std::option::Option<&str> {
        self.alias.as_deref()
    }
    /// <p>Information about the integrated development environment (IDE) configured for a Dev Environment.</p> <note>
    /// <p>An IDE is required to create a Dev Environment. For Dev Environment creation, this field contains configuration information and must be provided.</p>
    /// </note>
    pub fn ides(&self) -> std::option::Option<&[crate::model::IdeConfiguration]> {
        self.ides.as_deref()
    }
    /// <p>The Amazon EC2 instace type to use for the Dev Environment. </p>
    pub fn instance_type(&self) -> std::option::Option<&crate::model::InstanceType> {
        self.instance_type.as_ref()
    }
    /// <p>The amount of time the Dev Environment will run without any activity detected before stopping, in minutes. Only whole integers are allowed. Dev Environments consume compute minutes when running.</p>
    pub fn inactivity_timeout_minutes(&self) -> i32 {
        self.inactivity_timeout_minutes
    }
    /// <p>Information about the amount of storage allocated to the Dev Environment. By default, a Dev Environment is configured to have 16GB of persistent storage.</p> <note>
    /// <p>Valid values for persistent storage are based on memory sizes in 16GB increments. Valid values are 16, 32, and 64.</p>
    /// </note>
    pub fn persistent_storage(
        &self,
    ) -> std::option::Option<&crate::model::PersistentStorageConfiguration> {
        self.persistent_storage.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteDevEnvironmentInput {
    /// <p>The name of the space.</p>
    #[doc(hidden)]
    pub space_name: std::option::Option<std::string::String>,
    /// <p>The name of the project in the space.</p>
    #[doc(hidden)]
    pub project_name: std::option::Option<std::string::String>,
    /// <p>The system-generated unique ID of the Dev Environment you want to delete. To retrieve a list of Dev Environment IDs, use <code>ListDevEnvironments</code>.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
}
impl DeleteDevEnvironmentInput {
    /// <p>The name of the space.</p>
    pub fn space_name(&self) -> std::option::Option<&str> {
        self.space_name.as_deref()
    }
    /// <p>The name of the project in the space.</p>
    pub fn project_name(&self) -> std::option::Option<&str> {
        self.project_name.as_deref()
    }
    /// <p>The system-generated unique ID of the Dev Environment you want to delete. To retrieve a list of Dev Environment IDs, use <code>ListDevEnvironments</code>.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateDevEnvironmentInput {
    /// <p>The name of the space.</p>
    #[doc(hidden)]
    pub space_name: std::option::Option<std::string::String>,
    /// <p>The name of the project in the space.</p>
    #[doc(hidden)]
    pub project_name: std::option::Option<std::string::String>,
    /// <p>The system-generated unique ID of the Dev Environment. </p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The user-specified alias for the Dev Environment. Changing this value will not cause a restart.</p>
    #[doc(hidden)]
    pub alias: std::option::Option<std::string::String>,
    /// <p>Information about the integrated development environment (IDE) configured for a Dev Environment.</p>
    #[doc(hidden)]
    pub ides: std::option::Option<std::vec::Vec<crate::model::IdeConfiguration>>,
    /// <p>The Amazon EC2 instace type to use for the Dev Environment. </p> <note>
    /// <p>Changing this value will cause a restart of the Dev Environment if it is running.</p>
    /// </note>
    #[doc(hidden)]
    pub instance_type: std::option::Option<crate::model::InstanceType>,
    /// <p>The amount of time the Dev Environment will run without any activity detected before stopping, in minutes. Only whole integers are allowed. Dev Environments consume compute minutes when running.</p> <note>
    /// <p>Changing this value will cause a restart of the Dev Environment if it is running.</p>
    /// </note>
    #[doc(hidden)]
    pub inactivity_timeout_minutes: i32,
    /// <p>A user-specified idempotency token. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, the subsequent retries return the result from the original successful request and have no additional effect.</p>
    #[doc(hidden)]
    pub client_token: std::option::Option<std::string::String>,
}
impl UpdateDevEnvironmentInput {
    /// <p>The name of the space.</p>
    pub fn space_name(&self) -> std::option::Option<&str> {
        self.space_name.as_deref()
    }
    /// <p>The name of the project in the space.</p>
    pub fn project_name(&self) -> std::option::Option<&str> {
        self.project_name.as_deref()
    }
    /// <p>The system-generated unique ID of the Dev Environment. </p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The user-specified alias for the Dev Environment. Changing this value will not cause a restart.</p>
    pub fn alias(&self) -> std::option::Option<&str> {
        self.alias.as_deref()
    }
    /// <p>Information about the integrated development environment (IDE) configured for a Dev Environment.</p>
    pub fn ides(&self) -> std::option::Option<&[crate::model::IdeConfiguration]> {
        self.ides.as_deref()
    }
    /// <p>The Amazon EC2 instace type to use for the Dev Environment. </p> <note>
    /// <p>Changing this value will cause a restart of the Dev Environment if it is running.</p>
    /// </note>
    pub fn instance_type(&self) -> std::option::Option<&crate::model::InstanceType> {
        self.instance_type.as_ref()
    }
    /// <p>The amount of time the Dev Environment will run without any activity detected before stopping, in minutes. Only whole integers are allowed. Dev Environments consume compute minutes when running.</p> <note>
    /// <p>Changing this value will cause a restart of the Dev Environment if it is running.</p>
    /// </note>
    pub fn inactivity_timeout_minutes(&self) -> i32 {
        self.inactivity_timeout_minutes
    }
    /// <p>A user-specified idempotency token. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, the subsequent retries return the result from the original successful request and have no additional effect.</p>
    pub fn client_token(&self) -> std::option::Option<&str> {
        self.client_token.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetDevEnvironmentInput {
    /// <p>The name of the space.</p>
    #[doc(hidden)]
    pub space_name: std::option::Option<std::string::String>,
    /// <p>The name of the project in the space.</p>
    #[doc(hidden)]
    pub project_name: std::option::Option<std::string::String>,
    /// <p>The system-generated unique ID of the Dev Environment for which you want to view information. To retrieve a list of Dev Environment IDs, use <code>ListDevEnvironments</code>.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
}
impl GetDevEnvironmentInput {
    /// <p>The name of the space.</p>
    pub fn space_name(&self) -> std::option::Option<&str> {
        self.space_name.as_deref()
    }
    /// <p>The name of the project in the space.</p>
    pub fn project_name(&self) -> std::option::Option<&str> {
        self.project_name.as_deref()
    }
    /// <p>The system-generated unique ID of the Dev Environment for which you want to view information. To retrieve a list of Dev Environment IDs, use <code>ListDevEnvironments</code>.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListEventLogsInput {
    /// <p>The name of the space.</p>
    #[doc(hidden)]
    pub space_name: std::option::Option<std::string::String>,
    /// <p>The date and time when you want to start retrieving events, in coordinated universal time (UTC) timestamp format as specified in <a href="https://www.rfc-editor.org/rfc/rfc3339#section-5.6">RFC 3339</a>.</p>
    #[doc(hidden)]
    pub start_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time after which you do not want any events retrieved, in coordinated universal time (UTC) timestamp format as specified in <a href="https://www.rfc-editor.org/rfc/rfc3339#section-5.6">RFC 3339</a>.</p>
    #[doc(hidden)]
    pub end_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The name of the event.</p>
    #[doc(hidden)]
    pub event_name: std::option::Option<std::string::String>,
    /// <p>A token returned from a call to this API to indicate the next batch of results to return, if any.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to show in a single call to this API. If the number of results is larger than the number you specified, the response will include a <code>NextToken</code> element, which you can use to obtain additional results.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl ListEventLogsInput {
    /// <p>The name of the space.</p>
    pub fn space_name(&self) -> std::option::Option<&str> {
        self.space_name.as_deref()
    }
    /// <p>The date and time when you want to start retrieving events, in coordinated universal time (UTC) timestamp format as specified in <a href="https://www.rfc-editor.org/rfc/rfc3339#section-5.6">RFC 3339</a>.</p>
    pub fn start_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.start_time.as_ref()
    }
    /// <p>The time after which you do not want any events retrieved, in coordinated universal time (UTC) timestamp format as specified in <a href="https://www.rfc-editor.org/rfc/rfc3339#section-5.6">RFC 3339</a>.</p>
    pub fn end_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.end_time.as_ref()
    }
    /// <p>The name of the event.</p>
    pub fn event_name(&self) -> std::option::Option<&str> {
        self.event_name.as_deref()
    }
    /// <p>A token returned from a call to this API to indicate the next batch of results to return, if any.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of results to show in a single call to this API. If the number of results is larger than the number you specified, the response will include a <code>NextToken</code> element, which you can use to obtain additional results.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListAccessTokensInput {
    /// <p>The maximum number of results to show in a single call to this API. If the number of results is larger than the number you specified, the response will include a <code>NextToken</code> element, which you can use to obtain additional results.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>A token returned from a call to this API to indicate the next batch of results to return, if any.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl ListAccessTokensInput {
    /// <p>The maximum number of results to show in a single call to this API. If the number of results is larger than the number you specified, the response will include a <code>NextToken</code> element, which you can use to obtain additional results.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>A token returned from a call to this API to indicate the next batch of results to return, if any.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateAccessTokenInput {
    /// <p>The friendly name of the personal access token.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The date and time the personal access token expires, in coordinated universal time (UTC) timestamp format as specified in <a href="https://www.rfc-editor.org/rfc/rfc3339#section-5.6">RFC 3339</a>.</p>
    #[doc(hidden)]
    pub expires_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl CreateAccessTokenInput {
    /// <p>The friendly name of the personal access token.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The date and time the personal access token expires, in coordinated universal time (UTC) timestamp format as specified in <a href="https://www.rfc-editor.org/rfc/rfc3339#section-5.6">RFC 3339</a>.</p>
    pub fn expires_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.expires_time.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteAccessTokenInput {
    /// <p>The ID of the personal access token to delete. You can find the IDs of all PATs associated with your user account by calling <code>ListAccessTokens</code>.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
}
impl DeleteAccessTokenInput {
    /// <p>The ID of the personal access token to delete. You can find the IDs of all PATs associated with your user account by calling <code>ListAccessTokens</code>.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct VerifySessionInput {}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetUserDetailsInput {
    /// <p>The system-generated unique ID of the user. </p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The name of the user as displayed in Amazon CodeCatalyst.</p>
    #[doc(hidden)]
    pub user_name: std::option::Option<std::string::String>,
}
impl GetUserDetailsInput {
    /// <p>The system-generated unique ID of the user. </p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The name of the user as displayed in Amazon CodeCatalyst.</p>
    pub fn user_name(&self) -> std::option::Option<&str> {
        self.user_name.as_deref()
    }
}
