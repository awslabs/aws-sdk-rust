// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(std::fmt::Debug)]
pub(crate) struct Handle<C = aws_hyper::DynConnector> {
    client: aws_hyper::Client<C>,
    conf: crate::Config,
}

#[derive(Clone, std::fmt::Debug)]
pub struct Client<C = aws_hyper::DynConnector> {
    handle: std::sync::Arc<Handle<C>>,
}
impl<C> Client<C> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl Client {
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_env() -> Self {
        Self::from_conf(crate::Config::builder().build())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let client = aws_hyper::Client::https();
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl<C> Client<C>
where
    C: aws_hyper::SmithyConnector,
{
    pub fn associate_kms_key(&self) -> fluent_builders::AssociateKmsKey<C> {
        fluent_builders::AssociateKmsKey::new(self.handle.clone())
    }
    pub fn cancel_export_task(&self) -> fluent_builders::CancelExportTask<C> {
        fluent_builders::CancelExportTask::new(self.handle.clone())
    }
    pub fn create_export_task(&self) -> fluent_builders::CreateExportTask<C> {
        fluent_builders::CreateExportTask::new(self.handle.clone())
    }
    pub fn create_log_group(&self) -> fluent_builders::CreateLogGroup<C> {
        fluent_builders::CreateLogGroup::new(self.handle.clone())
    }
    pub fn create_log_stream(&self) -> fluent_builders::CreateLogStream<C> {
        fluent_builders::CreateLogStream::new(self.handle.clone())
    }
    pub fn delete_destination(&self) -> fluent_builders::DeleteDestination<C> {
        fluent_builders::DeleteDestination::new(self.handle.clone())
    }
    pub fn delete_log_group(&self) -> fluent_builders::DeleteLogGroup<C> {
        fluent_builders::DeleteLogGroup::new(self.handle.clone())
    }
    pub fn delete_log_stream(&self) -> fluent_builders::DeleteLogStream<C> {
        fluent_builders::DeleteLogStream::new(self.handle.clone())
    }
    pub fn delete_metric_filter(&self) -> fluent_builders::DeleteMetricFilter<C> {
        fluent_builders::DeleteMetricFilter::new(self.handle.clone())
    }
    pub fn delete_query_definition(&self) -> fluent_builders::DeleteQueryDefinition<C> {
        fluent_builders::DeleteQueryDefinition::new(self.handle.clone())
    }
    pub fn delete_resource_policy(&self) -> fluent_builders::DeleteResourcePolicy<C> {
        fluent_builders::DeleteResourcePolicy::new(self.handle.clone())
    }
    pub fn delete_retention_policy(&self) -> fluent_builders::DeleteRetentionPolicy<C> {
        fluent_builders::DeleteRetentionPolicy::new(self.handle.clone())
    }
    pub fn delete_subscription_filter(&self) -> fluent_builders::DeleteSubscriptionFilter<C> {
        fluent_builders::DeleteSubscriptionFilter::new(self.handle.clone())
    }
    pub fn describe_destinations(&self) -> fluent_builders::DescribeDestinations<C> {
        fluent_builders::DescribeDestinations::new(self.handle.clone())
    }
    pub fn describe_export_tasks(&self) -> fluent_builders::DescribeExportTasks<C> {
        fluent_builders::DescribeExportTasks::new(self.handle.clone())
    }
    pub fn describe_log_groups(&self) -> fluent_builders::DescribeLogGroups<C> {
        fluent_builders::DescribeLogGroups::new(self.handle.clone())
    }
    pub fn describe_log_streams(&self) -> fluent_builders::DescribeLogStreams<C> {
        fluent_builders::DescribeLogStreams::new(self.handle.clone())
    }
    pub fn describe_metric_filters(&self) -> fluent_builders::DescribeMetricFilters<C> {
        fluent_builders::DescribeMetricFilters::new(self.handle.clone())
    }
    pub fn describe_queries(&self) -> fluent_builders::DescribeQueries<C> {
        fluent_builders::DescribeQueries::new(self.handle.clone())
    }
    pub fn describe_query_definitions(&self) -> fluent_builders::DescribeQueryDefinitions<C> {
        fluent_builders::DescribeQueryDefinitions::new(self.handle.clone())
    }
    pub fn describe_resource_policies(&self) -> fluent_builders::DescribeResourcePolicies<C> {
        fluent_builders::DescribeResourcePolicies::new(self.handle.clone())
    }
    pub fn describe_subscription_filters(&self) -> fluent_builders::DescribeSubscriptionFilters<C> {
        fluent_builders::DescribeSubscriptionFilters::new(self.handle.clone())
    }
    pub fn disassociate_kms_key(&self) -> fluent_builders::DisassociateKmsKey<C> {
        fluent_builders::DisassociateKmsKey::new(self.handle.clone())
    }
    pub fn filter_log_events(&self) -> fluent_builders::FilterLogEvents<C> {
        fluent_builders::FilterLogEvents::new(self.handle.clone())
    }
    pub fn get_log_events(&self) -> fluent_builders::GetLogEvents<C> {
        fluent_builders::GetLogEvents::new(self.handle.clone())
    }
    pub fn get_log_group_fields(&self) -> fluent_builders::GetLogGroupFields<C> {
        fluent_builders::GetLogGroupFields::new(self.handle.clone())
    }
    pub fn get_log_record(&self) -> fluent_builders::GetLogRecord<C> {
        fluent_builders::GetLogRecord::new(self.handle.clone())
    }
    pub fn get_query_results(&self) -> fluent_builders::GetQueryResults<C> {
        fluent_builders::GetQueryResults::new(self.handle.clone())
    }
    pub fn list_tags_log_group(&self) -> fluent_builders::ListTagsLogGroup<C> {
        fluent_builders::ListTagsLogGroup::new(self.handle.clone())
    }
    pub fn put_destination(&self) -> fluent_builders::PutDestination<C> {
        fluent_builders::PutDestination::new(self.handle.clone())
    }
    pub fn put_destination_policy(&self) -> fluent_builders::PutDestinationPolicy<C> {
        fluent_builders::PutDestinationPolicy::new(self.handle.clone())
    }
    pub fn put_log_events(&self) -> fluent_builders::PutLogEvents<C> {
        fluent_builders::PutLogEvents::new(self.handle.clone())
    }
    pub fn put_metric_filter(&self) -> fluent_builders::PutMetricFilter<C> {
        fluent_builders::PutMetricFilter::new(self.handle.clone())
    }
    pub fn put_query_definition(&self) -> fluent_builders::PutQueryDefinition<C> {
        fluent_builders::PutQueryDefinition::new(self.handle.clone())
    }
    pub fn put_resource_policy(&self) -> fluent_builders::PutResourcePolicy<C> {
        fluent_builders::PutResourcePolicy::new(self.handle.clone())
    }
    pub fn put_retention_policy(&self) -> fluent_builders::PutRetentionPolicy<C> {
        fluent_builders::PutRetentionPolicy::new(self.handle.clone())
    }
    pub fn put_subscription_filter(&self) -> fluent_builders::PutSubscriptionFilter<C> {
        fluent_builders::PutSubscriptionFilter::new(self.handle.clone())
    }
    pub fn start_query(&self) -> fluent_builders::StartQuery<C> {
        fluent_builders::StartQuery::new(self.handle.clone())
    }
    pub fn stop_query(&self) -> fluent_builders::StopQuery<C> {
        fluent_builders::StopQuery::new(self.handle.clone())
    }
    pub fn tag_log_group(&self) -> fluent_builders::TagLogGroup<C> {
        fluent_builders::TagLogGroup::new(self.handle.clone())
    }
    pub fn test_metric_filter(&self) -> fluent_builders::TestMetricFilter<C> {
        fluent_builders::TestMetricFilter::new(self.handle.clone())
    }
    pub fn untag_log_group(&self) -> fluent_builders::UntagLogGroup<C> {
        fluent_builders::UntagLogGroup::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct AssociateKmsKey<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::associate_kms_key_input::Builder,
    }
    impl<C> AssociateKmsKey<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AssociateKmsKeyOutput,
            smithy_http::result::SdkError<crate::error::AssociateKmsKeyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the log group.</p>
        pub fn log_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_group_name(input);
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_log_group_name(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the CMK to use when encrypting log data. This must be a symmetric CMK.
        /// For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-kms">Amazon Resource Names - Key Management Service</a> and <a href="https://docs.aws.amazon.com/kms/latest/developerguide/symmetric-asymmetric.html">Using Symmetric and Asymmetric Keys</a>.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.kms_key_id(input);
            self
        }
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_kms_key_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CancelExportTask<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::cancel_export_task_input::Builder,
    }
    impl<C> CancelExportTask<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CancelExportTaskOutput,
            smithy_http::result::SdkError<crate::error::CancelExportTaskError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the export task.</p>
        pub fn task_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.task_id(input);
            self
        }
        pub fn set_task_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_task_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateExportTask<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_export_task_input::Builder,
    }
    impl<C> CreateExportTask<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateExportTaskOutput,
            smithy_http::result::SdkError<crate::error::CreateExportTaskError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the export task.</p>
        pub fn task_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.task_name(input);
            self
        }
        pub fn set_task_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_task_name(input);
            self
        }
        /// <p>The name of the log group.</p>
        pub fn log_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_group_name(input);
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_log_group_name(input);
            self
        }
        /// <p>Export only log streams that match the provided prefix. If you don't
        /// specify a value, no prefix filter is applied.</p>
        pub fn log_stream_name_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_stream_name_prefix(input);
            self
        }
        pub fn set_log_stream_name_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_log_stream_name_prefix(input);
            self
        }
        /// <p>The start time of the range for the request, expressed as the number of milliseconds
        /// after Jan 1, 1970 00:00:00 UTC. Events with a timestamp earlier than this time are not
        /// exported.</p>
        pub fn from(mut self, input: i64) -> Self {
            self.inner = self.inner.from(input);
            self
        }
        pub fn set_from(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_from(input);
            self
        }
        /// <p>The end time of the range for the request, expreswatchlogsdocused as the number of milliseconds
        /// after Jan 1, 1970 00:00:00 UTC. Events with a timestamp later than this time are not
        /// exported.</p>
        pub fn to(mut self, input: i64) -> Self {
            self.inner = self.inner.to(input);
            self
        }
        pub fn set_to(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_to(input);
            self
        }
        /// <p>The name of S3 bucket for the exported log data. The bucket must be in the same Amazon Web Services region.</p>
        pub fn destination(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.destination(input);
            self
        }
        pub fn set_destination(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_destination(input);
            self
        }
        /// <p>The prefix used as the start of the key for every object exported. If you don't
        /// specify a value, the default is <code>exportedlogs</code>.</p>
        pub fn destination_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.destination_prefix(input);
            self
        }
        pub fn set_destination_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_destination_prefix(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateLogGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_log_group_input::Builder,
    }
    impl<C> CreateLogGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateLogGroupOutput,
            smithy_http::result::SdkError<crate::error::CreateLogGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the log group.</p>
        pub fn log_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_group_name(input);
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_log_group_name(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the CMK to use when encrypting log data.
        /// For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-kms">Amazon Resource Names - Key Management Service</a>.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.kms_key_id(input);
            self
        }
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_kms_key_id(input);
            self
        }
        /// <p>The key-value pairs to use for the tags.</p>
        /// <p>CloudWatch Logs doesnâ€™t support IAM policies that prevent users from assigning specified tags to
        /// log groups using the <code>aws:Resource/<i>key-name</i>
        /// </code> or <code>aws:TagKeys</code> condition keys.
        /// For more information about using tags to control access, see
        /// <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_tags.html">Controlling access to Amazon Web Services resources using tags</a>.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateLogStream<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_log_stream_input::Builder,
    }
    impl<C> CreateLogStream<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateLogStreamOutput,
            smithy_http::result::SdkError<crate::error::CreateLogStreamError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the log group.</p>
        pub fn log_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_group_name(input);
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_log_group_name(input);
            self
        }
        /// <p>The name of the log stream.</p>
        pub fn log_stream_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_stream_name(input);
            self
        }
        pub fn set_log_stream_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_log_stream_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteDestination<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_destination_input::Builder,
    }
    impl<C> DeleteDestination<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteDestinationOutput,
            smithy_http::result::SdkError<crate::error::DeleteDestinationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the destination.</p>
        pub fn destination_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.destination_name(input);
            self
        }
        pub fn set_destination_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_destination_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteLogGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_log_group_input::Builder,
    }
    impl<C> DeleteLogGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteLogGroupOutput,
            smithy_http::result::SdkError<crate::error::DeleteLogGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the log group.</p>
        pub fn log_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_group_name(input);
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_log_group_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteLogStream<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_log_stream_input::Builder,
    }
    impl<C> DeleteLogStream<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteLogStreamOutput,
            smithy_http::result::SdkError<crate::error::DeleteLogStreamError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the log group.</p>
        pub fn log_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_group_name(input);
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_log_group_name(input);
            self
        }
        /// <p>The name of the log stream.</p>
        pub fn log_stream_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_stream_name(input);
            self
        }
        pub fn set_log_stream_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_log_stream_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteMetricFilter<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_metric_filter_input::Builder,
    }
    impl<C> DeleteMetricFilter<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteMetricFilterOutput,
            smithy_http::result::SdkError<crate::error::DeleteMetricFilterError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the log group.</p>
        pub fn log_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_group_name(input);
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_log_group_name(input);
            self
        }
        /// <p>The name of the metric filter.</p>
        pub fn filter_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.filter_name(input);
            self
        }
        pub fn set_filter_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_filter_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteQueryDefinition<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_query_definition_input::Builder,
    }
    impl<C> DeleteQueryDefinition<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteQueryDefinitionOutput,
            smithy_http::result::SdkError<crate::error::DeleteQueryDefinitionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the query definition that you want to delete. You can use <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_DescribeQueryDefinitions.html">DescribeQueryDefinitions</a> to retrieve the
        /// IDs of your saved query definitions.</p>
        pub fn query_definition_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.query_definition_id(input);
            self
        }
        pub fn set_query_definition_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_query_definition_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteResourcePolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_resource_policy_input::Builder,
    }
    impl<C> DeleteResourcePolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteResourcePolicyOutput,
            smithy_http::result::SdkError<crate::error::DeleteResourcePolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the policy to be revoked. This parameter is required.</p>
        pub fn policy_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_name(input);
            self
        }
        pub fn set_policy_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteRetentionPolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_retention_policy_input::Builder,
    }
    impl<C> DeleteRetentionPolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteRetentionPolicyOutput,
            smithy_http::result::SdkError<crate::error::DeleteRetentionPolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the log group.</p>
        pub fn log_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_group_name(input);
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_log_group_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteSubscriptionFilter<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_subscription_filter_input::Builder,
    }
    impl<C> DeleteSubscriptionFilter<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteSubscriptionFilterOutput,
            smithy_http::result::SdkError<crate::error::DeleteSubscriptionFilterError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the log group.</p>
        pub fn log_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_group_name(input);
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_log_group_name(input);
            self
        }
        /// <p>The name of the subscription filter.</p>
        pub fn filter_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.filter_name(input);
            self
        }
        pub fn set_filter_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_filter_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeDestinations<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_destinations_input::Builder,
    }
    impl<C> DescribeDestinations<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeDestinationsOutput,
            smithy_http::result::SdkError<crate::error::DescribeDestinationsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The prefix to match. If you don't specify a value, no prefix filter is applied.</p>
        pub fn destination_name_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.destination_name_prefix(input);
            self
        }
        pub fn set_destination_name_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_destination_name_prefix(input);
            self
        }
        /// <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of items returned. If you don't specify a value, the default is up to 50 items.</p>
        pub fn limit(mut self, input: i32) -> Self {
            self.inner = self.inner.limit(input);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeExportTasks<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_export_tasks_input::Builder,
    }
    impl<C> DescribeExportTasks<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeExportTasksOutput,
            smithy_http::result::SdkError<crate::error::DescribeExportTasksError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the export task. Specifying a task ID filters the results to zero or one export tasks.</p>
        pub fn task_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.task_id(input);
            self
        }
        pub fn set_task_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_task_id(input);
            self
        }
        /// <p>The status code of the export task. Specifying a status code filters the results to zero or more export tasks.</p>
        pub fn status_code(mut self, input: crate::model::ExportTaskStatusCode) -> Self {
            self.inner = self.inner.status_code(input);
            self
        }
        pub fn set_status_code(
            mut self,
            input: std::option::Option<crate::model::ExportTaskStatusCode>,
        ) -> Self {
            self.inner = self.inner.set_status_code(input);
            self
        }
        /// <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of items returned. If you don't specify a value, the default is up to 50 items.</p>
        pub fn limit(mut self, input: i32) -> Self {
            self.inner = self.inner.limit(input);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeLogGroups<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_log_groups_input::Builder,
    }
    impl<C> DescribeLogGroups<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeLogGroupsOutput,
            smithy_http::result::SdkError<crate::error::DescribeLogGroupsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The prefix to match.</p>
        pub fn log_group_name_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_group_name_prefix(input);
            self
        }
        pub fn set_log_group_name_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_log_group_name_prefix(input);
            self
        }
        /// <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of items returned. If you don't specify a value, the default is up to 50 items.</p>
        pub fn limit(mut self, input: i32) -> Self {
            self.inner = self.inner.limit(input);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeLogStreams<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_log_streams_input::Builder,
    }
    impl<C> DescribeLogStreams<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeLogStreamsOutput,
            smithy_http::result::SdkError<crate::error::DescribeLogStreamsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the log group.</p>
        pub fn log_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_group_name(input);
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_log_group_name(input);
            self
        }
        /// <p>The prefix to match.</p>
        /// <p>If <code>orderBy</code> is <code>LastEventTime</code>, you cannot specify this
        /// parameter.</p>
        pub fn log_stream_name_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_stream_name_prefix(input);
            self
        }
        pub fn set_log_stream_name_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_log_stream_name_prefix(input);
            self
        }
        /// <p>If the value is <code>LogStreamName</code>, the results are ordered by log stream name.
        /// If the value is <code>LastEventTime</code>, the results are ordered by the event time.
        /// The default value is <code>LogStreamName</code>.</p>
        /// <p>If you order the results by event time, you cannot specify the <code>logStreamNamePrefix</code> parameter.</p>
        /// <p>
        /// <code>lastEventTimestamp</code> represents the time of the most recent log event in the
        /// log stream in CloudWatch Logs. This number is expressed as the number of milliseconds after
        /// Jan 1, 1970 00:00:00 UTC. <code>lastEventTimestamp</code> updates on an eventual consistency
        /// basis. It typically updates in less than an hour from ingestion, but in rare situations might
        /// take longer.</p>
        pub fn order_by(mut self, input: crate::model::OrderBy) -> Self {
            self.inner = self.inner.order_by(input);
            self
        }
        pub fn set_order_by(mut self, input: std::option::Option<crate::model::OrderBy>) -> Self {
            self.inner = self.inner.set_order_by(input);
            self
        }
        /// <p>If the value is true, results are returned in descending order.
        /// If the value is to false, results are returned in ascending order.
        /// The default value is false.</p>
        pub fn descending(mut self, input: bool) -> Self {
            self.inner = self.inner.descending(input);
            self
        }
        pub fn set_descending(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_descending(input);
            self
        }
        /// <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of items returned. If you don't specify a value, the default is up to 50 items.</p>
        pub fn limit(mut self, input: i32) -> Self {
            self.inner = self.inner.limit(input);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeMetricFilters<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_metric_filters_input::Builder,
    }
    impl<C> DescribeMetricFilters<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeMetricFiltersOutput,
            smithy_http::result::SdkError<crate::error::DescribeMetricFiltersError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the log group.</p>
        pub fn log_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_group_name(input);
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_log_group_name(input);
            self
        }
        /// <p>The prefix to match. CloudWatch Logs uses the value you set here
        /// only if you also include the <code>logGroupName</code> parameter in your request.</p>
        pub fn filter_name_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.filter_name_prefix(input);
            self
        }
        pub fn set_filter_name_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_filter_name_prefix(input);
            self
        }
        /// <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of items returned. If you don't specify a value, the default is up to 50 items.</p>
        pub fn limit(mut self, input: i32) -> Self {
            self.inner = self.inner.limit(input);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
        /// <p>Filters results to include only those with the specified metric name. If you include this parameter in your request, you
        /// must also include the <code>metricNamespace</code> parameter.</p>
        pub fn metric_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.metric_name(input);
            self
        }
        pub fn set_metric_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_metric_name(input);
            self
        }
        /// <p>Filters results to include only those in the specified namespace. If you include this parameter in your request, you
        /// must also include the <code>metricName</code> parameter.</p>
        pub fn metric_namespace(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.metric_namespace(input);
            self
        }
        pub fn set_metric_namespace(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_metric_namespace(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeQueries<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_queries_input::Builder,
    }
    impl<C> DescribeQueries<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeQueriesOutput,
            smithy_http::result::SdkError<crate::error::DescribeQueriesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Limits the returned queries to only those for the specified log group.</p>
        pub fn log_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_group_name(input);
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_log_group_name(input);
            self
        }
        /// <p>Limits the returned queries to only those that have the specified status. Valid values are <code>Cancelled</code>,
        /// <code>Complete</code>, <code>Failed</code>, <code>Running</code>, and <code>Scheduled</code>.</p>
        pub fn status(mut self, input: crate::model::QueryStatus) -> Self {
            self.inner = self.inner.status(input);
            self
        }
        pub fn set_status(mut self, input: std::option::Option<crate::model::QueryStatus>) -> Self {
            self.inner = self.inner.set_status(input);
            self
        }
        /// <p>Limits the number of returned queries to the specified number.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token for the next set of items to return. The token expires after 24 hours.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeQueryDefinitions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_query_definitions_input::Builder,
    }
    impl<C> DescribeQueryDefinitions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeQueryDefinitionsOutput,
            smithy_http::result::SdkError<crate::error::DescribeQueryDefinitionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Use this parameter to filter your results to only the query definitions that have names that start with the prefix you specify.</p>
        pub fn query_definition_name_prefix(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.query_definition_name_prefix(input);
            self
        }
        pub fn set_query_definition_name_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_query_definition_name_prefix(input);
            self
        }
        /// <p>Limits the number of returned query definitions to the specified number.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token for the next set of items to return. The token expires after 24 hours.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeResourcePolicies<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_resource_policies_input::Builder,
    }
    impl<C> DescribeResourcePolicies<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeResourcePoliciesOutput,
            smithy_http::result::SdkError<crate::error::DescribeResourcePoliciesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The token for the next set of items to return. The token expires after 24 hours.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of resource policies to be displayed with one call of this API.</p>
        pub fn limit(mut self, input: i32) -> Self {
            self.inner = self.inner.limit(input);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeSubscriptionFilters<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_subscription_filters_input::Builder,
    }
    impl<C> DescribeSubscriptionFilters<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeSubscriptionFiltersOutput,
            smithy_http::result::SdkError<crate::error::DescribeSubscriptionFiltersError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the log group.</p>
        pub fn log_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_group_name(input);
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_log_group_name(input);
            self
        }
        /// <p>The prefix to match. If you don't specify a value, no prefix filter is applied.</p>
        pub fn filter_name_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.filter_name_prefix(input);
            self
        }
        pub fn set_filter_name_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_filter_name_prefix(input);
            self
        }
        /// <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of items returned. If you don't specify a value, the default is up to 50 items.</p>
        pub fn limit(mut self, input: i32) -> Self {
            self.inner = self.inner.limit(input);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DisassociateKmsKey<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::disassociate_kms_key_input::Builder,
    }
    impl<C> DisassociateKmsKey<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DisassociateKmsKeyOutput,
            smithy_http::result::SdkError<crate::error::DisassociateKmsKeyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the log group.</p>
        pub fn log_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_group_name(input);
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_log_group_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct FilterLogEvents<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::filter_log_events_input::Builder,
    }
    impl<C> FilterLogEvents<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::FilterLogEventsOutput,
            smithy_http::result::SdkError<crate::error::FilterLogEventsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the log group to search.</p>
        pub fn log_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_group_name(input);
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_log_group_name(input);
            self
        }
        /// <p>Filters the results to only logs from the log streams in this list.</p>
        /// <p>If you specify a value for both <code>logStreamNamePrefix</code> and <code>logStreamNames</code>, the action
        /// returns an <code>InvalidParameterException</code> error.</p>
        pub fn log_stream_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_stream_names(inp);
            self
        }
        pub fn set_log_stream_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_log_stream_names(input);
            self
        }
        /// <p>Filters the results to include only events from log streams that have names starting with this prefix.</p>
        /// <p>If you specify a value for both <code>logStreamNamePrefix</code> and <code>logStreamNames</code>, but the value for
        /// <code>logStreamNamePrefix</code> does not match any log stream names specified in <code>logStreamNames</code>, the action
        /// returns an <code>InvalidParameterException</code> error.</p>
        pub fn log_stream_name_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_stream_name_prefix(input);
            self
        }
        pub fn set_log_stream_name_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_log_stream_name_prefix(input);
            self
        }
        /// <p>The start of the time range, expressed as the number of milliseconds after Jan 1, 1970
        /// 00:00:00 UTC. Events with a timestamp before this time are not returned.</p>
        pub fn start_time(mut self, input: i64) -> Self {
            self.inner = self.inner.start_time(input);
            self
        }
        pub fn set_start_time(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_start_time(input);
            self
        }
        /// <p>The end of the time range, expressed as the number of milliseconds after Jan 1, 1970
        /// 00:00:00 UTC. Events with a timestamp later than this time are not returned.</p>
        pub fn end_time(mut self, input: i64) -> Self {
            self.inner = self.inner.end_time(input);
            self
        }
        pub fn set_end_time(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_end_time(input);
            self
        }
        /// <p>The filter pattern to use. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/FilterAndPatternSyntax.html">Filter and Pattern Syntax</a>.</p>
        /// <p>If not provided, all the events are matched.</p>
        pub fn filter_pattern(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.filter_pattern(input);
            self
        }
        pub fn set_filter_pattern(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_filter_pattern(input);
            self
        }
        /// <p>The token for the next set of events to return. (You received this token from a previous call.)</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of events to return. The default is 10,000 events.</p>
        pub fn limit(mut self, input: i32) -> Self {
            self.inner = self.inner.limit(input);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
        /// <p>If the value is true, the operation makes a best effort to provide responses that
        /// contain events from multiple log streams within the log group, interleaved in a single
        /// response. If the value is false, all the matched log events in the first log stream are
        /// searched first, then those in the next log stream, and so on. The default is false.</p>
        /// <p>
        /// <b>Important:</b> Starting on June 17, 2019, this parameter
        /// is ignored and the value is assumed to be true. The response from this operation always
        /// interleaves events from multiple log streams within a log group.</p>
        pub fn interleaved(mut self, input: bool) -> Self {
            self.inner = self.inner.interleaved(input);
            self
        }
        pub fn set_interleaved(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_interleaved(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetLogEvents<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_log_events_input::Builder,
    }
    impl<C> GetLogEvents<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetLogEventsOutput,
            smithy_http::result::SdkError<crate::error::GetLogEventsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the log group.</p>
        pub fn log_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_group_name(input);
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_log_group_name(input);
            self
        }
        /// <p>The name of the log stream.</p>
        pub fn log_stream_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_stream_name(input);
            self
        }
        pub fn set_log_stream_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_log_stream_name(input);
            self
        }
        /// <p>The start of the time range, expressed as the number of milliseconds after Jan 1, 1970
        /// 00:00:00 UTC. Events with a timestamp equal to this time or later than this time are included.
        /// Events with a timestamp earlier than this time are not included.</p>
        pub fn start_time(mut self, input: i64) -> Self {
            self.inner = self.inner.start_time(input);
            self
        }
        pub fn set_start_time(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_start_time(input);
            self
        }
        /// <p>The end of the time range, expressed as the number of milliseconds after Jan 1, 1970
        /// 00:00:00 UTC. Events with a timestamp equal to or later than this time are not
        /// included.</p>
        pub fn end_time(mut self, input: i64) -> Self {
            self.inner = self.inner.end_time(input);
            self
        }
        pub fn set_end_time(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_end_time(input);
            self
        }
        /// <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of log events returned. If you don't specify a value, the maximum is
        /// as many log events as can fit in a response size of 1 MB, up to 10,000 log events.</p>
        pub fn limit(mut self, input: i32) -> Self {
            self.inner = self.inner.limit(input);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
        /// <p>If the value is true, the earliest log events are returned first.
        /// If the value is false, the latest log events are returned first.
        /// The default value is false.</p>
        /// <p>If you are using a previous <code>nextForwardToken</code> value as the <code>nextToken</code> in this operation,
        /// you must specify <code>true</code> for <code>startFromHead</code>.</p>
        pub fn start_from_head(mut self, input: bool) -> Self {
            self.inner = self.inner.start_from_head(input);
            self
        }
        pub fn set_start_from_head(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_start_from_head(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetLogGroupFields<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_log_group_fields_input::Builder,
    }
    impl<C> GetLogGroupFields<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetLogGroupFieldsOutput,
            smithy_http::result::SdkError<crate::error::GetLogGroupFieldsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the log group to search.</p>
        pub fn log_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_group_name(input);
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_log_group_name(input);
            self
        }
        /// <p>The time to set as the center of the query. If you specify <code>time</code>, the 15 minutes
        /// before this time are queries. If you omit <code>time</code> the 8
        /// minutes before and 8 minutes after this time are searched.</p>
        /// <p>The <code>time</code> value is specified as epoch time, the number of seconds since
        /// January 1, 1970, 00:00:00 UTC.</p>
        pub fn time(mut self, input: i64) -> Self {
            self.inner = self.inner.time(input);
            self
        }
        pub fn set_time(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_time(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetLogRecord<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_log_record_input::Builder,
    }
    impl<C> GetLogRecord<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetLogRecordOutput,
            smithy_http::result::SdkError<crate::error::GetLogRecordError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The pointer corresponding to the log event record you want to retrieve. You get this from
        /// the response of a <code>GetQueryResults</code> operation. In that response, the value of the
        /// <code>@ptr</code> field for a log event is the value to use as <code>logRecordPointer</code>
        /// to retrieve that complete log event record.</p>
        pub fn log_record_pointer(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_record_pointer(input);
            self
        }
        pub fn set_log_record_pointer(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_log_record_pointer(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetQueryResults<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_query_results_input::Builder,
    }
    impl<C> GetQueryResults<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetQueryResultsOutput,
            smithy_http::result::SdkError<crate::error::GetQueryResultsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID number of the query.</p>
        pub fn query_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.query_id(input);
            self
        }
        pub fn set_query_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_query_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTagsLogGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_tags_log_group_input::Builder,
    }
    impl<C> ListTagsLogGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTagsLogGroupOutput,
            smithy_http::result::SdkError<crate::error::ListTagsLogGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the log group.</p>
        pub fn log_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_group_name(input);
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_log_group_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutDestination<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_destination_input::Builder,
    }
    impl<C> PutDestination<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutDestinationOutput,
            smithy_http::result::SdkError<crate::error::PutDestinationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A name for the destination.</p>
        pub fn destination_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.destination_name(input);
            self
        }
        pub fn set_destination_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_destination_name(input);
            self
        }
        /// <p>The ARN of an Amazon Kinesis stream to which to deliver matching log events.</p>
        pub fn target_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.target_arn(input);
            self
        }
        pub fn set_target_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_target_arn(input);
            self
        }
        /// <p>The ARN of an IAM role that grants CloudWatch Logs permissions to call the Amazon
        /// Kinesis <code>PutRecord</code> operation on the destination stream.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_arn(input);
            self
        }
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutDestinationPolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_destination_policy_input::Builder,
    }
    impl<C> PutDestinationPolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutDestinationPolicyOutput,
            smithy_http::result::SdkError<crate::error::PutDestinationPolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A name for an existing destination.</p>
        pub fn destination_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.destination_name(input);
            self
        }
        pub fn set_destination_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_destination_name(input);
            self
        }
        /// <p>An IAM policy document that authorizes cross-account users to deliver their log events
        /// to the associated destination. This can be up to 5120 bytes.</p>
        pub fn access_policy(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.access_policy(input);
            self
        }
        pub fn set_access_policy(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_access_policy(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutLogEvents<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_log_events_input::Builder,
    }
    impl<C> PutLogEvents<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutLogEventsOutput,
            smithy_http::result::SdkError<crate::error::PutLogEventsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the log group.</p>
        pub fn log_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_group_name(input);
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_log_group_name(input);
            self
        }
        /// <p>The name of the log stream.</p>
        pub fn log_stream_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_stream_name(input);
            self
        }
        pub fn set_log_stream_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_log_stream_name(input);
            self
        }
        /// <p>The log events.</p>
        pub fn log_events(mut self, inp: impl Into<crate::model::InputLogEvent>) -> Self {
            self.inner = self.inner.log_events(inp);
            self
        }
        pub fn set_log_events(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::InputLogEvent>>,
        ) -> Self {
            self.inner = self.inner.set_log_events(input);
            self
        }
        /// <p>The sequence token obtained from the response of the previous <code>PutLogEvents</code>
        /// call. An upload in a newly created log stream does not require a sequence token. You can also
        /// get the sequence token using <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_DescribeLogStreams.html">DescribeLogStreams</a>. If you call <code>PutLogEvents</code> twice within a narrow
        /// time period using the same value for <code>sequenceToken</code>, both calls might be
        /// successful or one might be rejected.</p>
        pub fn sequence_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.sequence_token(input);
            self
        }
        pub fn set_sequence_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_sequence_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutMetricFilter<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_metric_filter_input::Builder,
    }
    impl<C> PutMetricFilter<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutMetricFilterOutput,
            smithy_http::result::SdkError<crate::error::PutMetricFilterError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the log group.</p>
        pub fn log_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_group_name(input);
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_log_group_name(input);
            self
        }
        /// <p>A name for the metric filter.</p>
        pub fn filter_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.filter_name(input);
            self
        }
        pub fn set_filter_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_filter_name(input);
            self
        }
        /// <p>A filter pattern for extracting metric data out of ingested log events.</p>
        pub fn filter_pattern(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.filter_pattern(input);
            self
        }
        pub fn set_filter_pattern(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_filter_pattern(input);
            self
        }
        /// <p>A collection of information that defines how metric data gets emitted.</p>
        pub fn metric_transformations(
            mut self,
            inp: impl Into<crate::model::MetricTransformation>,
        ) -> Self {
            self.inner = self.inner.metric_transformations(inp);
            self
        }
        pub fn set_metric_transformations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MetricTransformation>>,
        ) -> Self {
            self.inner = self.inner.set_metric_transformations(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutQueryDefinition<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_query_definition_input::Builder,
    }
    impl<C> PutQueryDefinition<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutQueryDefinitionOutput,
            smithy_http::result::SdkError<crate::error::PutQueryDefinitionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A name for the query definition. If you are saving a lot of query definitions, we
        /// recommend that you name them so that you can easily find the ones you want by using the first
        /// part of the name as a filter in the <code>queryDefinitionNamePrefix</code> parameter of <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_DescribeQueryDefinitions.html">DescribeQueryDefinitions</a>.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>If you are updating a query definition, use this parameter to specify the ID of the query
        /// definition that you want to update. You can use <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_DescribeQueryDefinitions.html">DescribeQueryDefinitions</a> to retrieve the IDs of your saved query
        /// definitions.</p>
        /// <p>If you are creating a query definition, do not specify this parameter. CloudWatch
        /// generates a unique ID for the new query definition and include it in the response to this
        /// operation.</p>
        pub fn query_definition_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.query_definition_id(input);
            self
        }
        pub fn set_query_definition_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_query_definition_id(input);
            self
        }
        /// <p>Use this parameter to include specific log groups as part of your query definition.</p>
        /// <p>If you are updating a query definition and you omit this parameter, then the updated
        /// definition will contain no log groups.</p>
        pub fn log_group_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_group_names(inp);
            self
        }
        pub fn set_log_group_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_log_group_names(input);
            self
        }
        /// <p>The query string to use for this definition.
        /// For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CWL_QuerySyntax.html">CloudWatch Logs Insights Query Syntax</a>.</p>
        pub fn query_string(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.query_string(input);
            self
        }
        pub fn set_query_string(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_query_string(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutResourcePolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_resource_policy_input::Builder,
    }
    impl<C> PutResourcePolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutResourcePolicyOutput,
            smithy_http::result::SdkError<crate::error::PutResourcePolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Name of the new policy. This parameter is required.</p>
        pub fn policy_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_name(input);
            self
        }
        pub fn set_policy_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy_name(input);
            self
        }
        /// <p>Details of the new policy, including the identity of the principal that is enabled to put logs to this account. This is formatted as a JSON string.
        /// This parameter is required.</p>
        /// <p>The following example creates a resource policy enabling the Route 53 service to put
        /// DNS query logs in to the specified log group. Replace <code>"logArn"</code> with the ARN of
        /// your CloudWatch Logs resource, such as a log group or log stream.</p>
        /// <p>CloudWatch Logs also supports <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_condition-keys.html#condition-keys-sourcearn">aws:SourceArn</a>
        /// and <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_condition-keys.html#condition-keys-sourceaccount">aws:SourceAccount</a>
        /// condition context keys.</p>
        /// <p>In the example resource policy, you would replace the value of <code>SourceArn</code> with the resource making the
        /// call from Route 53 to CloudWatch Logs and replace the value of <code>SourceAccount</code> with
        /// the Amazon Web Services account ID making that call.</p>
        /// <p></p>
        /// <p>
        /// <code>{
        /// "Version": "2012-10-17",
        /// "Statement": [
        /// {
        /// "Sid": "Route53LogsToCloudWatchLogs",
        /// "Effect": "Allow",
        /// "Principal": {
        /// "Service": [
        /// "route53.amazonaws.com"
        /// ]
        /// },
        /// "Action": "logs:PutLogEvents",
        /// "Resource": "logArn",
        /// "Condition": {
        /// "ArnLike": {
        /// "aws:SourceArn": "myRoute53ResourceArn"
        /// },
        /// "StringEquals": {
        /// "aws:SourceAccount": "myAwsAccountId"
        /// }
        /// }
        /// }
        /// ]
        /// }</code>
        /// </p>
        pub fn policy_document(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_document(input);
            self
        }
        pub fn set_policy_document(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_policy_document(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutRetentionPolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_retention_policy_input::Builder,
    }
    impl<C> PutRetentionPolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutRetentionPolicyOutput,
            smithy_http::result::SdkError<crate::error::PutRetentionPolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the log group.</p>
        pub fn log_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_group_name(input);
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_log_group_name(input);
            self
        }
        /// <p>The number of days to retain the log events in the specified log group.
        /// Possible values are: 1, 3, 5, 7, 14, 30, 60, 90, 120, 150, 180, 365, 400, 545, 731, 1827, and 3653.</p>
        /// <p>To set a log group to never have log events expire, use
        /// <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_DeleteRetentionPolicy.html">DeleteRetentionPolicy</a>.
        /// </p>
        pub fn retention_in_days(mut self, input: i32) -> Self {
            self.inner = self.inner.retention_in_days(input);
            self
        }
        pub fn set_retention_in_days(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_retention_in_days(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutSubscriptionFilter<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_subscription_filter_input::Builder,
    }
    impl<C> PutSubscriptionFilter<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutSubscriptionFilterOutput,
            smithy_http::result::SdkError<crate::error::PutSubscriptionFilterError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the log group.</p>
        pub fn log_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_group_name(input);
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_log_group_name(input);
            self
        }
        /// <p>A name for the subscription filter. If you are updating an existing filter, you must
        /// specify the correct name in <code>filterName</code>. To find the name of the filter currently
        /// associated with a log group, use <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_DescribeSubscriptionFilters.html">DescribeSubscriptionFilters</a>.</p>
        pub fn filter_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.filter_name(input);
            self
        }
        pub fn set_filter_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_filter_name(input);
            self
        }
        /// <p>A filter pattern for subscribing to a filtered stream of log events.</p>
        pub fn filter_pattern(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.filter_pattern(input);
            self
        }
        pub fn set_filter_pattern(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_filter_pattern(input);
            self
        }
        /// <p>The ARN of the destination to deliver matching log events to. Currently, the supported
        /// destinations are:</p>
        /// <ul>
        /// <li>
        /// <p>An Amazon Kinesis stream belonging to the same account as the subscription filter,
        /// for same-account delivery.</p>
        /// </li>
        /// <li>
        /// <p>A logical destination (specified using an ARN) belonging to a different account,
        /// for cross-account delivery.</p>
        /// <p>If you are setting up a cross-account subscription, the destination must have an
        /// IAM policy associated with it that allows the sender to send logs to the destination.
        /// For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_PutDestinationPolicy.html">PutDestinationPolicy</a>.</p>
        /// </li>
        /// <li>
        /// <p>An Amazon Kinesis Firehose delivery stream belonging to the same account as the
        /// subscription filter, for same-account delivery.</p>
        /// </li>
        /// <li>
        /// <p>A Lambda function belonging to the same account as the subscription filter,
        /// for same-account delivery.</p>
        /// </li>
        /// </ul>
        pub fn destination_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.destination_arn(input);
            self
        }
        pub fn set_destination_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_destination_arn(input);
            self
        }
        /// <p>The ARN of an IAM role that grants CloudWatch Logs permissions to deliver ingested log
        /// events to the destination stream. You don't need to provide the ARN when you are working with
        /// a logical destination for cross-account delivery.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_arn(input);
            self
        }
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_arn(input);
            self
        }
        /// <p>The method used to distribute log data to the destination. By default, log data is
        /// grouped by log stream, but the grouping can be set to random for a more even distribution.
        /// This property is only applicable when the destination is an Amazon Kinesis stream. </p>
        pub fn distribution(mut self, input: crate::model::Distribution) -> Self {
            self.inner = self.inner.distribution(input);
            self
        }
        pub fn set_distribution(
            mut self,
            input: std::option::Option<crate::model::Distribution>,
        ) -> Self {
            self.inner = self.inner.set_distribution(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StartQuery<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::start_query_input::Builder,
    }
    impl<C> StartQuery<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StartQueryOutput,
            smithy_http::result::SdkError<crate::error::StartQueryError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The log group on which to perform the query.</p>
        /// <p>A <code>StartQuery</code> operation must include a <code>logGroupNames</code> or a <code>logGroupName</code> parameter, but
        /// not both.</p>
        pub fn log_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_group_name(input);
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_log_group_name(input);
            self
        }
        /// <p>The list of log groups to be queried. You can include up to 20 log groups.</p>
        /// <p>A <code>StartQuery</code> operation must include a <code>logGroupNames</code> or a <code>logGroupName</code> parameter, but
        /// not both.</p>
        pub fn log_group_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_group_names(inp);
            self
        }
        pub fn set_log_group_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_log_group_names(input);
            self
        }
        /// <p>The beginning of the time range to query. The range is inclusive, so the specified
        /// start time is included in the query. Specified as epoch time, the
        /// number of seconds since January 1, 1970, 00:00:00 UTC.</p>
        pub fn start_time(mut self, input: i64) -> Self {
            self.inner = self.inner.start_time(input);
            self
        }
        pub fn set_start_time(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_start_time(input);
            self
        }
        /// <p>The end of the time range to query. The range is inclusive, so the specified
        /// end time is included in the query. Specified as epoch
        /// time, the number of seconds since January 1, 1970, 00:00:00 UTC.</p>
        pub fn end_time(mut self, input: i64) -> Self {
            self.inner = self.inner.end_time(input);
            self
        }
        pub fn set_end_time(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_end_time(input);
            self
        }
        /// <p>The query string to use.
        /// For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CWL_QuerySyntax.html">CloudWatch Logs Insights Query Syntax</a>.</p>
        pub fn query_string(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.query_string(input);
            self
        }
        pub fn set_query_string(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_query_string(input);
            self
        }
        /// <p>The maximum number of log events to return in the query. If the query string uses the <code>fields</code> command,
        /// only the specified fields and their values are returned. The default is 1000.</p>
        pub fn limit(mut self, input: i32) -> Self {
            self.inner = self.inner.limit(input);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StopQuery<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::stop_query_input::Builder,
    }
    impl<C> StopQuery<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StopQueryOutput,
            smithy_http::result::SdkError<crate::error::StopQueryError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID number of the query to stop. To find this ID number, use
        /// <code>DescribeQueries</code>.</p>
        pub fn query_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.query_id(input);
            self
        }
        pub fn set_query_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_query_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TagLogGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::tag_log_group_input::Builder,
    }
    impl<C> TagLogGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::TagLogGroupOutput,
            smithy_http::result::SdkError<crate::error::TagLogGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the log group.</p>
        pub fn log_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_group_name(input);
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_log_group_name(input);
            self
        }
        /// <p>The key-value pairs to use for the tags.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TestMetricFilter<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::test_metric_filter_input::Builder,
    }
    impl<C> TestMetricFilter<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::TestMetricFilterOutput,
            smithy_http::result::SdkError<crate::error::TestMetricFilterError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A symbolic description of how CloudWatch Logs should interpret the data in each log
        /// event. For example, a log event can contain timestamps, IP addresses, strings, and so on. You
        /// use the filter pattern to specify what to look for in the log event message.</p>
        pub fn filter_pattern(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.filter_pattern(input);
            self
        }
        pub fn set_filter_pattern(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_filter_pattern(input);
            self
        }
        /// <p>The log event messages to test.</p>
        pub fn log_event_messages(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_event_messages(inp);
            self
        }
        pub fn set_log_event_messages(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_log_event_messages(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UntagLogGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::untag_log_group_input::Builder,
    }
    impl<C> UntagLogGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UntagLogGroupOutput,
            smithy_http::result::SdkError<crate::error::UntagLogGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the log group.</p>
        pub fn log_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_group_name(input);
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_log_group_name(input);
            self
        }
        /// <p>The tag keys. The corresponding tags are removed from the log group.</p>
        pub fn tags(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
}
