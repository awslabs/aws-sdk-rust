// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(Debug)]
pub(crate) struct Handle<
    C = smithy_client::erase::DynConnector,
    M = aws_hyper::AwsMiddleware,
    R = smithy_client::retry::Standard,
> {
    client: smithy_client::Client<C, M, R>,
    conf: crate::Config,
}

/// An ergonomic service client for `Logs_20140328`.
///
/// This client allows ergonomic access to a `Logs_20140328`-shaped service.
/// Each method corresponds to an endpoint defined in the service's Smithy model,
/// and the request and response shapes are auto-generated from that same model.
///
/// # Using a Client
///
/// Once you have a client set up, you can access the service's endpoints
/// by calling the appropriate method on [`Client`]. Each such method
/// returns a request builder for that endpoint, with methods for setting
/// the various fields of the request. Once your request is complete, use
/// the `send` method to send the request. `send` returns a future, which
/// you then have to `.await` to get the service's response.
///
/// [builder pattern]: https://rust-lang.github.io/api-guidelines/type-safety.html#c-builder
/// [SigV4-signed requests]: https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html
#[derive(std::fmt::Debug)]
pub struct Client<
    C = smithy_client::erase::DynConnector,
    M = aws_hyper::AwsMiddleware,
    R = smithy_client::retry::Standard,
> {
    handle: std::sync::Arc<Handle<C, M, R>>,
}

impl<C, M, R> std::clone::Clone for Client<C, M, R> {
    fn clone(&self) -> Self {
        Self {
            handle: self.handle.clone(),
        }
    }
}

#[doc(inline)]
pub use smithy_client::Builder;

impl<C, M, R> From<smithy_client::Client<C, M, R>> for Client<C, M, R> {
    fn from(client: smithy_client::Client<C, M, R>) -> Self {
        Self::with_config(client, crate::Config::builder().build())
    }
}

impl<C, M, R> Client<C, M, R> {
    pub fn with_config(client: smithy_client::Client<C, M, R>, conf: crate::Config) -> Self {
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl<C, M, R> Client<C, M, R>
where
    C: smithy_client::bounds::SmithyConnector,
    M: smithy_client::bounds::SmithyMiddleware<C>,
    R: smithy_client::retry::NewRequestPolicy,
{
    pub fn associate_kms_key(&self) -> fluent_builders::AssociateKmsKey<C, M, R> {
        fluent_builders::AssociateKmsKey::new(self.handle.clone())
    }
    pub fn cancel_export_task(&self) -> fluent_builders::CancelExportTask<C, M, R> {
        fluent_builders::CancelExportTask::new(self.handle.clone())
    }
    pub fn create_export_task(&self) -> fluent_builders::CreateExportTask<C, M, R> {
        fluent_builders::CreateExportTask::new(self.handle.clone())
    }
    pub fn create_log_group(&self) -> fluent_builders::CreateLogGroup<C, M, R> {
        fluent_builders::CreateLogGroup::new(self.handle.clone())
    }
    pub fn create_log_stream(&self) -> fluent_builders::CreateLogStream<C, M, R> {
        fluent_builders::CreateLogStream::new(self.handle.clone())
    }
    pub fn delete_destination(&self) -> fluent_builders::DeleteDestination<C, M, R> {
        fluent_builders::DeleteDestination::new(self.handle.clone())
    }
    pub fn delete_log_group(&self) -> fluent_builders::DeleteLogGroup<C, M, R> {
        fluent_builders::DeleteLogGroup::new(self.handle.clone())
    }
    pub fn delete_log_stream(&self) -> fluent_builders::DeleteLogStream<C, M, R> {
        fluent_builders::DeleteLogStream::new(self.handle.clone())
    }
    pub fn delete_metric_filter(&self) -> fluent_builders::DeleteMetricFilter<C, M, R> {
        fluent_builders::DeleteMetricFilter::new(self.handle.clone())
    }
    pub fn delete_query_definition(&self) -> fluent_builders::DeleteQueryDefinition<C, M, R> {
        fluent_builders::DeleteQueryDefinition::new(self.handle.clone())
    }
    pub fn delete_resource_policy(&self) -> fluent_builders::DeleteResourcePolicy<C, M, R> {
        fluent_builders::DeleteResourcePolicy::new(self.handle.clone())
    }
    pub fn delete_retention_policy(&self) -> fluent_builders::DeleteRetentionPolicy<C, M, R> {
        fluent_builders::DeleteRetentionPolicy::new(self.handle.clone())
    }
    pub fn delete_subscription_filter(&self) -> fluent_builders::DeleteSubscriptionFilter<C, M, R> {
        fluent_builders::DeleteSubscriptionFilter::new(self.handle.clone())
    }
    pub fn describe_destinations(&self) -> fluent_builders::DescribeDestinations<C, M, R> {
        fluent_builders::DescribeDestinations::new(self.handle.clone())
    }
    pub fn describe_export_tasks(&self) -> fluent_builders::DescribeExportTasks<C, M, R> {
        fluent_builders::DescribeExportTasks::new(self.handle.clone())
    }
    pub fn describe_log_groups(&self) -> fluent_builders::DescribeLogGroups<C, M, R> {
        fluent_builders::DescribeLogGroups::new(self.handle.clone())
    }
    pub fn describe_log_streams(&self) -> fluent_builders::DescribeLogStreams<C, M, R> {
        fluent_builders::DescribeLogStreams::new(self.handle.clone())
    }
    pub fn describe_metric_filters(&self) -> fluent_builders::DescribeMetricFilters<C, M, R> {
        fluent_builders::DescribeMetricFilters::new(self.handle.clone())
    }
    pub fn describe_queries(&self) -> fluent_builders::DescribeQueries<C, M, R> {
        fluent_builders::DescribeQueries::new(self.handle.clone())
    }
    pub fn describe_query_definitions(&self) -> fluent_builders::DescribeQueryDefinitions<C, M, R> {
        fluent_builders::DescribeQueryDefinitions::new(self.handle.clone())
    }
    pub fn describe_resource_policies(&self) -> fluent_builders::DescribeResourcePolicies<C, M, R> {
        fluent_builders::DescribeResourcePolicies::new(self.handle.clone())
    }
    pub fn describe_subscription_filters(
        &self,
    ) -> fluent_builders::DescribeSubscriptionFilters<C, M, R> {
        fluent_builders::DescribeSubscriptionFilters::new(self.handle.clone())
    }
    pub fn disassociate_kms_key(&self) -> fluent_builders::DisassociateKmsKey<C, M, R> {
        fluent_builders::DisassociateKmsKey::new(self.handle.clone())
    }
    pub fn filter_log_events(&self) -> fluent_builders::FilterLogEvents<C, M, R> {
        fluent_builders::FilterLogEvents::new(self.handle.clone())
    }
    pub fn get_log_events(&self) -> fluent_builders::GetLogEvents<C, M, R> {
        fluent_builders::GetLogEvents::new(self.handle.clone())
    }
    pub fn get_log_group_fields(&self) -> fluent_builders::GetLogGroupFields<C, M, R> {
        fluent_builders::GetLogGroupFields::new(self.handle.clone())
    }
    pub fn get_log_record(&self) -> fluent_builders::GetLogRecord<C, M, R> {
        fluent_builders::GetLogRecord::new(self.handle.clone())
    }
    pub fn get_query_results(&self) -> fluent_builders::GetQueryResults<C, M, R> {
        fluent_builders::GetQueryResults::new(self.handle.clone())
    }
    pub fn list_tags_log_group(&self) -> fluent_builders::ListTagsLogGroup<C, M, R> {
        fluent_builders::ListTagsLogGroup::new(self.handle.clone())
    }
    pub fn put_destination(&self) -> fluent_builders::PutDestination<C, M, R> {
        fluent_builders::PutDestination::new(self.handle.clone())
    }
    pub fn put_destination_policy(&self) -> fluent_builders::PutDestinationPolicy<C, M, R> {
        fluent_builders::PutDestinationPolicy::new(self.handle.clone())
    }
    pub fn put_log_events(&self) -> fluent_builders::PutLogEvents<C, M, R> {
        fluent_builders::PutLogEvents::new(self.handle.clone())
    }
    pub fn put_metric_filter(&self) -> fluent_builders::PutMetricFilter<C, M, R> {
        fluent_builders::PutMetricFilter::new(self.handle.clone())
    }
    pub fn put_query_definition(&self) -> fluent_builders::PutQueryDefinition<C, M, R> {
        fluent_builders::PutQueryDefinition::new(self.handle.clone())
    }
    pub fn put_resource_policy(&self) -> fluent_builders::PutResourcePolicy<C, M, R> {
        fluent_builders::PutResourcePolicy::new(self.handle.clone())
    }
    pub fn put_retention_policy(&self) -> fluent_builders::PutRetentionPolicy<C, M, R> {
        fluent_builders::PutRetentionPolicy::new(self.handle.clone())
    }
    pub fn put_subscription_filter(&self) -> fluent_builders::PutSubscriptionFilter<C, M, R> {
        fluent_builders::PutSubscriptionFilter::new(self.handle.clone())
    }
    pub fn start_query(&self) -> fluent_builders::StartQuery<C, M, R> {
        fluent_builders::StartQuery::new(self.handle.clone())
    }
    pub fn stop_query(&self) -> fluent_builders::StopQuery<C, M, R> {
        fluent_builders::StopQuery::new(self.handle.clone())
    }
    pub fn tag_log_group(&self) -> fluent_builders::TagLogGroup<C, M, R> {
        fluent_builders::TagLogGroup::new(self.handle.clone())
    }
    pub fn test_metric_filter(&self) -> fluent_builders::TestMetricFilter<C, M, R> {
        fluent_builders::TestMetricFilter::new(self.handle.clone())
    }
    pub fn untag_log_group(&self) -> fluent_builders::UntagLogGroup<C, M, R> {
        fluent_builders::UntagLogGroup::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct AssociateKmsKey<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::associate_kms_key_input::Builder,
    }
    impl<C, M, R> AssociateKmsKey<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AssociateKmsKeyOutput,
            smithy_http::result::SdkError<crate::error::AssociateKmsKeyError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::AssociateKmsKeyInputOperationOutputAlias,
                crate::output::AssociateKmsKeyOutput,
                crate::error::AssociateKmsKeyError,
                crate::input::AssociateKmsKeyInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the log group.</p>
        pub fn log_group_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_group_name(inp);
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_log_group_name(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the CMK to use when encrypting log data. This must be a symmetric CMK.
        /// For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-kms">Amazon Resource Names - Key Management Service</a> and <a href="https://docs.aws.amazon.com/kms/latest/developerguide/symmetric-asymmetric.html">Using Symmetric and Asymmetric Keys</a>.</p>
        pub fn kms_key_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.kms_key_id(inp);
            self
        }
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_kms_key_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CancelExportTask<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::cancel_export_task_input::Builder,
    }
    impl<C, M, R> CancelExportTask<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CancelExportTaskOutput,
            smithy_http::result::SdkError<crate::error::CancelExportTaskError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CancelExportTaskInputOperationOutputAlias,
                crate::output::CancelExportTaskOutput,
                crate::error::CancelExportTaskError,
                crate::input::CancelExportTaskInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the export task.</p>
        pub fn task_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.task_id(inp);
            self
        }
        pub fn set_task_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_task_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateExportTask<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_export_task_input::Builder,
    }
    impl<C, M, R> CreateExportTask<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateExportTaskOutput,
            smithy_http::result::SdkError<crate::error::CreateExportTaskError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateExportTaskInputOperationOutputAlias,
                crate::output::CreateExportTaskOutput,
                crate::error::CreateExportTaskError,
                crate::input::CreateExportTaskInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the export task.</p>
        pub fn task_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.task_name(inp);
            self
        }
        pub fn set_task_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_task_name(input);
            self
        }
        /// <p>The name of the log group.</p>
        pub fn log_group_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_group_name(inp);
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_log_group_name(input);
            self
        }
        /// <p>Export only log streams that match the provided prefix. If you don't
        /// specify a value, no prefix filter is applied.</p>
        pub fn log_stream_name_prefix(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_stream_name_prefix(inp);
            self
        }
        pub fn set_log_stream_name_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_log_stream_name_prefix(input);
            self
        }
        /// <p>The start time of the range for the request, expressed as the number of milliseconds
        /// after Jan 1, 1970 00:00:00 UTC. Events with a timestamp earlier than this time are not
        /// exported.</p>
        pub fn from(mut self, inp: i64) -> Self {
            self.inner = self.inner.from(inp);
            self
        }
        pub fn set_from(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_from(input);
            self
        }
        /// <p>The end time of the range for the request, expreswatchlogsdocused as the number of milliseconds
        /// after Jan 1, 1970 00:00:00 UTC. Events with a timestamp later than this time are not
        /// exported.</p>
        pub fn to(mut self, inp: i64) -> Self {
            self.inner = self.inner.to(inp);
            self
        }
        pub fn set_to(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_to(input);
            self
        }
        /// <p>The name of S3 bucket for the exported log data. The bucket must be in the same Amazon Web Services region.</p>
        pub fn destination(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.destination(inp);
            self
        }
        pub fn set_destination(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_destination(input);
            self
        }
        /// <p>The prefix used as the start of the key for every object exported. If you don't
        /// specify a value, the default is <code>exportedlogs</code>.</p>
        pub fn destination_prefix(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.destination_prefix(inp);
            self
        }
        pub fn set_destination_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_destination_prefix(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateLogGroup<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_log_group_input::Builder,
    }
    impl<C, M, R> CreateLogGroup<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateLogGroupOutput,
            smithy_http::result::SdkError<crate::error::CreateLogGroupError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateLogGroupInputOperationOutputAlias,
                crate::output::CreateLogGroupOutput,
                crate::error::CreateLogGroupError,
                crate::input::CreateLogGroupInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the log group.</p>
        pub fn log_group_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_group_name(inp);
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_log_group_name(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the CMK to use when encrypting log data.
        /// For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-kms">Amazon Resource Names - Key Management Service</a>.</p>
        pub fn kms_key_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.kms_key_id(inp);
            self
        }
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_kms_key_id(input);
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        /// <p>The key-value pairs to use for the tags.</p>
        /// <p>CloudWatch Logs doesnâ€™t support IAM policies that prevent users from assigning specified tags to
        /// log groups using the <code>aws:Resource/<i>key-name</i>
        /// </code> or <code>aws:TagKeys</code> condition keys.
        /// For more information about using tags to control access, see
        /// <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_tags.html">Controlling access to Amazon Web Services resources using tags</a>.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateLogStream<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_log_stream_input::Builder,
    }
    impl<C, M, R> CreateLogStream<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateLogStreamOutput,
            smithy_http::result::SdkError<crate::error::CreateLogStreamError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateLogStreamInputOperationOutputAlias,
                crate::output::CreateLogStreamOutput,
                crate::error::CreateLogStreamError,
                crate::input::CreateLogStreamInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the log group.</p>
        pub fn log_group_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_group_name(inp);
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_log_group_name(input);
            self
        }
        /// <p>The name of the log stream.</p>
        pub fn log_stream_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_stream_name(inp);
            self
        }
        pub fn set_log_stream_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_log_stream_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteDestination<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_destination_input::Builder,
    }
    impl<C, M, R> DeleteDestination<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteDestinationOutput,
            smithy_http::result::SdkError<crate::error::DeleteDestinationError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteDestinationInputOperationOutputAlias,
                crate::output::DeleteDestinationOutput,
                crate::error::DeleteDestinationError,
                crate::input::DeleteDestinationInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the destination.</p>
        pub fn destination_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.destination_name(inp);
            self
        }
        pub fn set_destination_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_destination_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteLogGroup<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_log_group_input::Builder,
    }
    impl<C, M, R> DeleteLogGroup<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteLogGroupOutput,
            smithy_http::result::SdkError<crate::error::DeleteLogGroupError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteLogGroupInputOperationOutputAlias,
                crate::output::DeleteLogGroupOutput,
                crate::error::DeleteLogGroupError,
                crate::input::DeleteLogGroupInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the log group.</p>
        pub fn log_group_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_group_name(inp);
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_log_group_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteLogStream<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_log_stream_input::Builder,
    }
    impl<C, M, R> DeleteLogStream<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteLogStreamOutput,
            smithy_http::result::SdkError<crate::error::DeleteLogStreamError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteLogStreamInputOperationOutputAlias,
                crate::output::DeleteLogStreamOutput,
                crate::error::DeleteLogStreamError,
                crate::input::DeleteLogStreamInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the log group.</p>
        pub fn log_group_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_group_name(inp);
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_log_group_name(input);
            self
        }
        /// <p>The name of the log stream.</p>
        pub fn log_stream_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_stream_name(inp);
            self
        }
        pub fn set_log_stream_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_log_stream_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteMetricFilter<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_metric_filter_input::Builder,
    }
    impl<C, M, R> DeleteMetricFilter<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteMetricFilterOutput,
            smithy_http::result::SdkError<crate::error::DeleteMetricFilterError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteMetricFilterInputOperationOutputAlias,
                crate::output::DeleteMetricFilterOutput,
                crate::error::DeleteMetricFilterError,
                crate::input::DeleteMetricFilterInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the log group.</p>
        pub fn log_group_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_group_name(inp);
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_log_group_name(input);
            self
        }
        /// <p>The name of the metric filter.</p>
        pub fn filter_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.filter_name(inp);
            self
        }
        pub fn set_filter_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_filter_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteQueryDefinition<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_query_definition_input::Builder,
    }
    impl<C, M, R> DeleteQueryDefinition<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteQueryDefinitionOutput,
            smithy_http::result::SdkError<crate::error::DeleteQueryDefinitionError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteQueryDefinitionInputOperationOutputAlias,
                crate::output::DeleteQueryDefinitionOutput,
                crate::error::DeleteQueryDefinitionError,
                crate::input::DeleteQueryDefinitionInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the query definition that you want to delete. You can use <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_DescribeQueryDefinitions.html">DescribeQueryDefinitions</a> to retrieve the
        /// IDs of your saved query definitions.</p>
        pub fn query_definition_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.query_definition_id(inp);
            self
        }
        pub fn set_query_definition_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_query_definition_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteResourcePolicy<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_resource_policy_input::Builder,
    }
    impl<C, M, R> DeleteResourcePolicy<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteResourcePolicyOutput,
            smithy_http::result::SdkError<crate::error::DeleteResourcePolicyError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteResourcePolicyInputOperationOutputAlias,
                crate::output::DeleteResourcePolicyOutput,
                crate::error::DeleteResourcePolicyError,
                crate::input::DeleteResourcePolicyInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the policy to be revoked. This parameter is required.</p>
        pub fn policy_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_name(inp);
            self
        }
        pub fn set_policy_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteRetentionPolicy<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_retention_policy_input::Builder,
    }
    impl<C, M, R> DeleteRetentionPolicy<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteRetentionPolicyOutput,
            smithy_http::result::SdkError<crate::error::DeleteRetentionPolicyError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteRetentionPolicyInputOperationOutputAlias,
                crate::output::DeleteRetentionPolicyOutput,
                crate::error::DeleteRetentionPolicyError,
                crate::input::DeleteRetentionPolicyInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the log group.</p>
        pub fn log_group_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_group_name(inp);
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_log_group_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteSubscriptionFilter<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_subscription_filter_input::Builder,
    }
    impl<C, M, R> DeleteSubscriptionFilter<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteSubscriptionFilterOutput,
            smithy_http::result::SdkError<crate::error::DeleteSubscriptionFilterError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteSubscriptionFilterInputOperationOutputAlias,
                crate::output::DeleteSubscriptionFilterOutput,
                crate::error::DeleteSubscriptionFilterError,
                crate::input::DeleteSubscriptionFilterInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the log group.</p>
        pub fn log_group_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_group_name(inp);
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_log_group_name(input);
            self
        }
        /// <p>The name of the subscription filter.</p>
        pub fn filter_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.filter_name(inp);
            self
        }
        pub fn set_filter_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_filter_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeDestinations<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_destinations_input::Builder,
    }
    impl<C, M, R> DescribeDestinations<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeDestinationsOutput,
            smithy_http::result::SdkError<crate::error::DescribeDestinationsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeDestinationsInputOperationOutputAlias,
                crate::output::DescribeDestinationsOutput,
                crate::error::DescribeDestinationsError,
                crate::input::DescribeDestinationsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The prefix to match. If you don't specify a value, no prefix filter is applied.</p>
        pub fn destination_name_prefix(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.destination_name_prefix(inp);
            self
        }
        pub fn set_destination_name_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_destination_name_prefix(input);
            self
        }
        /// <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of items returned. If you don't specify a value, the default is up to 50 items.</p>
        pub fn limit(mut self, inp: i32) -> Self {
            self.inner = self.inner.limit(inp);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeExportTasks<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_export_tasks_input::Builder,
    }
    impl<C, M, R> DescribeExportTasks<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeExportTasksOutput,
            smithy_http::result::SdkError<crate::error::DescribeExportTasksError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeExportTasksInputOperationOutputAlias,
                crate::output::DescribeExportTasksOutput,
                crate::error::DescribeExportTasksError,
                crate::input::DescribeExportTasksInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the export task. Specifying a task ID filters the results to zero or one export tasks.</p>
        pub fn task_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.task_id(inp);
            self
        }
        pub fn set_task_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_task_id(input);
            self
        }
        /// <p>The status code of the export task. Specifying a status code filters the results to zero or more export tasks.</p>
        pub fn status_code(mut self, inp: crate::model::ExportTaskStatusCode) -> Self {
            self.inner = self.inner.status_code(inp);
            self
        }
        pub fn set_status_code(
            mut self,
            input: std::option::Option<crate::model::ExportTaskStatusCode>,
        ) -> Self {
            self.inner = self.inner.set_status_code(input);
            self
        }
        /// <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of items returned. If you don't specify a value, the default is up to 50 items.</p>
        pub fn limit(mut self, inp: i32) -> Self {
            self.inner = self.inner.limit(inp);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeLogGroups<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_log_groups_input::Builder,
    }
    impl<C, M, R> DescribeLogGroups<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeLogGroupsOutput,
            smithy_http::result::SdkError<crate::error::DescribeLogGroupsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeLogGroupsInputOperationOutputAlias,
                crate::output::DescribeLogGroupsOutput,
                crate::error::DescribeLogGroupsError,
                crate::input::DescribeLogGroupsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The prefix to match.</p>
        pub fn log_group_name_prefix(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_group_name_prefix(inp);
            self
        }
        pub fn set_log_group_name_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_log_group_name_prefix(input);
            self
        }
        /// <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of items returned. If you don't specify a value, the default is up to 50 items.</p>
        pub fn limit(mut self, inp: i32) -> Self {
            self.inner = self.inner.limit(inp);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeLogStreams<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_log_streams_input::Builder,
    }
    impl<C, M, R> DescribeLogStreams<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeLogStreamsOutput,
            smithy_http::result::SdkError<crate::error::DescribeLogStreamsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeLogStreamsInputOperationOutputAlias,
                crate::output::DescribeLogStreamsOutput,
                crate::error::DescribeLogStreamsError,
                crate::input::DescribeLogStreamsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the log group.</p>
        pub fn log_group_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_group_name(inp);
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_log_group_name(input);
            self
        }
        /// <p>The prefix to match.</p>
        /// <p>If <code>orderBy</code> is <code>LastEventTime</code>, you cannot specify this
        /// parameter.</p>
        pub fn log_stream_name_prefix(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_stream_name_prefix(inp);
            self
        }
        pub fn set_log_stream_name_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_log_stream_name_prefix(input);
            self
        }
        /// <p>If the value is <code>LogStreamName</code>, the results are ordered by log stream name.
        /// If the value is <code>LastEventTime</code>, the results are ordered by the event time.
        /// The default value is <code>LogStreamName</code>.</p>
        /// <p>If you order the results by event time, you cannot specify the <code>logStreamNamePrefix</code> parameter.</p>
        /// <p>
        /// <code>lastEventTimestamp</code> represents the time of the most recent log event in the
        /// log stream in CloudWatch Logs. This number is expressed as the number of milliseconds after
        /// Jan 1, 1970 00:00:00 UTC. <code>lastEventTimestamp</code> updates on an eventual consistency
        /// basis. It typically updates in less than an hour from ingestion, but in rare situations might
        /// take longer.</p>
        pub fn order_by(mut self, inp: crate::model::OrderBy) -> Self {
            self.inner = self.inner.order_by(inp);
            self
        }
        pub fn set_order_by(mut self, input: std::option::Option<crate::model::OrderBy>) -> Self {
            self.inner = self.inner.set_order_by(input);
            self
        }
        /// <p>If the value is true, results are returned in descending order.
        /// If the value is to false, results are returned in ascending order.
        /// The default value is false.</p>
        pub fn descending(mut self, inp: bool) -> Self {
            self.inner = self.inner.descending(inp);
            self
        }
        pub fn set_descending(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_descending(input);
            self
        }
        /// <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of items returned. If you don't specify a value, the default is up to 50 items.</p>
        pub fn limit(mut self, inp: i32) -> Self {
            self.inner = self.inner.limit(inp);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeMetricFilters<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_metric_filters_input::Builder,
    }
    impl<C, M, R> DescribeMetricFilters<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeMetricFiltersOutput,
            smithy_http::result::SdkError<crate::error::DescribeMetricFiltersError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeMetricFiltersInputOperationOutputAlias,
                crate::output::DescribeMetricFiltersOutput,
                crate::error::DescribeMetricFiltersError,
                crate::input::DescribeMetricFiltersInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the log group.</p>
        pub fn log_group_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_group_name(inp);
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_log_group_name(input);
            self
        }
        /// <p>The prefix to match. CloudWatch Logs uses the value you set here
        /// only if you also include the <code>logGroupName</code> parameter in your request.</p>
        pub fn filter_name_prefix(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.filter_name_prefix(inp);
            self
        }
        pub fn set_filter_name_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_filter_name_prefix(input);
            self
        }
        /// <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of items returned. If you don't specify a value, the default is up to 50 items.</p>
        pub fn limit(mut self, inp: i32) -> Self {
            self.inner = self.inner.limit(inp);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
        /// <p>Filters results to include only those with the specified metric name. If you include this parameter in your request, you
        /// must also include the <code>metricNamespace</code> parameter.</p>
        pub fn metric_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.metric_name(inp);
            self
        }
        pub fn set_metric_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_metric_name(input);
            self
        }
        /// <p>Filters results to include only those in the specified namespace. If you include this parameter in your request, you
        /// must also include the <code>metricName</code> parameter.</p>
        pub fn metric_namespace(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.metric_namespace(inp);
            self
        }
        pub fn set_metric_namespace(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_metric_namespace(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeQueries<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_queries_input::Builder,
    }
    impl<C, M, R> DescribeQueries<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeQueriesOutput,
            smithy_http::result::SdkError<crate::error::DescribeQueriesError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeQueriesInputOperationOutputAlias,
                crate::output::DescribeQueriesOutput,
                crate::error::DescribeQueriesError,
                crate::input::DescribeQueriesInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Limits the returned queries to only those for the specified log group.</p>
        pub fn log_group_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_group_name(inp);
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_log_group_name(input);
            self
        }
        /// <p>Limits the returned queries to only those that have the specified status. Valid values are <code>Cancelled</code>,
        /// <code>Complete</code>, <code>Failed</code>, <code>Running</code>, and <code>Scheduled</code>.</p>
        pub fn status(mut self, inp: crate::model::QueryStatus) -> Self {
            self.inner = self.inner.status(inp);
            self
        }
        pub fn set_status(mut self, input: std::option::Option<crate::model::QueryStatus>) -> Self {
            self.inner = self.inner.set_status(input);
            self
        }
        /// <p>Limits the number of returned queries to the specified number.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token for the next set of items to return. The token expires after 24 hours.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeQueryDefinitions<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_query_definitions_input::Builder,
    }
    impl<C, M, R> DescribeQueryDefinitions<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeQueryDefinitionsOutput,
            smithy_http::result::SdkError<crate::error::DescribeQueryDefinitionsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeQueryDefinitionsInputOperationOutputAlias,
                crate::output::DescribeQueryDefinitionsOutput,
                crate::error::DescribeQueryDefinitionsError,
                crate::input::DescribeQueryDefinitionsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Use this parameter to filter your results to only the query definitions that have names that start with the prefix you specify.</p>
        pub fn query_definition_name_prefix(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.query_definition_name_prefix(inp);
            self
        }
        pub fn set_query_definition_name_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_query_definition_name_prefix(input);
            self
        }
        /// <p>Limits the number of returned query definitions to the specified number.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token for the next set of items to return. The token expires after 24 hours.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeResourcePolicies<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_resource_policies_input::Builder,
    }
    impl<C, M, R> DescribeResourcePolicies<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeResourcePoliciesOutput,
            smithy_http::result::SdkError<crate::error::DescribeResourcePoliciesError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeResourcePoliciesInputOperationOutputAlias,
                crate::output::DescribeResourcePoliciesOutput,
                crate::error::DescribeResourcePoliciesError,
                crate::input::DescribeResourcePoliciesInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The token for the next set of items to return. The token expires after 24 hours.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of resource policies to be displayed with one call of this API.</p>
        pub fn limit(mut self, inp: i32) -> Self {
            self.inner = self.inner.limit(inp);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeSubscriptionFilters<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_subscription_filters_input::Builder,
    }
    impl<C, M, R> DescribeSubscriptionFilters<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeSubscriptionFiltersOutput,
            smithy_http::result::SdkError<crate::error::DescribeSubscriptionFiltersError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeSubscriptionFiltersInputOperationOutputAlias,
                crate::output::DescribeSubscriptionFiltersOutput,
                crate::error::DescribeSubscriptionFiltersError,
                crate::input::DescribeSubscriptionFiltersInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the log group.</p>
        pub fn log_group_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_group_name(inp);
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_log_group_name(input);
            self
        }
        /// <p>The prefix to match. If you don't specify a value, no prefix filter is applied.</p>
        pub fn filter_name_prefix(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.filter_name_prefix(inp);
            self
        }
        pub fn set_filter_name_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_filter_name_prefix(input);
            self
        }
        /// <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of items returned. If you don't specify a value, the default is up to 50 items.</p>
        pub fn limit(mut self, inp: i32) -> Self {
            self.inner = self.inner.limit(inp);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DisassociateKmsKey<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::disassociate_kms_key_input::Builder,
    }
    impl<C, M, R> DisassociateKmsKey<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DisassociateKmsKeyOutput,
            smithy_http::result::SdkError<crate::error::DisassociateKmsKeyError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DisassociateKmsKeyInputOperationOutputAlias,
                crate::output::DisassociateKmsKeyOutput,
                crate::error::DisassociateKmsKeyError,
                crate::input::DisassociateKmsKeyInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the log group.</p>
        pub fn log_group_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_group_name(inp);
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_log_group_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct FilterLogEvents<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::filter_log_events_input::Builder,
    }
    impl<C, M, R> FilterLogEvents<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::FilterLogEventsOutput,
            smithy_http::result::SdkError<crate::error::FilterLogEventsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::FilterLogEventsInputOperationOutputAlias,
                crate::output::FilterLogEventsOutput,
                crate::error::FilterLogEventsError,
                crate::input::FilterLogEventsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the log group to search.</p>
        pub fn log_group_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_group_name(inp);
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_log_group_name(input);
            self
        }
        /// Appends an item to `logStreamNames`.
        ///
        /// To override the contents of this collection use [`set_log_stream_names`](Self::set_log_stream_names).
        /// <p>Filters the results to only logs from the log streams in this list.</p>
        /// <p>If you specify a value for both <code>logStreamNamePrefix</code> and <code>logStreamNames</code>, the action
        /// returns an <code>InvalidParameterException</code> error.</p>
        pub fn log_stream_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_stream_names(inp);
            self
        }
        pub fn set_log_stream_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_log_stream_names(input);
            self
        }
        /// <p>Filters the results to include only events from log streams that have names starting with this prefix.</p>
        /// <p>If you specify a value for both <code>logStreamNamePrefix</code> and <code>logStreamNames</code>, but the value for
        /// <code>logStreamNamePrefix</code> does not match any log stream names specified in <code>logStreamNames</code>, the action
        /// returns an <code>InvalidParameterException</code> error.</p>
        pub fn log_stream_name_prefix(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_stream_name_prefix(inp);
            self
        }
        pub fn set_log_stream_name_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_log_stream_name_prefix(input);
            self
        }
        /// <p>The start of the time range, expressed as the number of milliseconds after Jan 1, 1970
        /// 00:00:00 UTC. Events with a timestamp before this time are not returned.</p>
        pub fn start_time(mut self, inp: i64) -> Self {
            self.inner = self.inner.start_time(inp);
            self
        }
        pub fn set_start_time(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_start_time(input);
            self
        }
        /// <p>The end of the time range, expressed as the number of milliseconds after Jan 1, 1970
        /// 00:00:00 UTC. Events with a timestamp later than this time are not returned.</p>
        pub fn end_time(mut self, inp: i64) -> Self {
            self.inner = self.inner.end_time(inp);
            self
        }
        pub fn set_end_time(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_end_time(input);
            self
        }
        /// <p>The filter pattern to use. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/FilterAndPatternSyntax.html">Filter and Pattern Syntax</a>.</p>
        /// <p>If not provided, all the events are matched.</p>
        pub fn filter_pattern(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.filter_pattern(inp);
            self
        }
        pub fn set_filter_pattern(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_filter_pattern(input);
            self
        }
        /// <p>The token for the next set of events to return. (You received this token from a previous call.)</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of events to return. The default is 10,000 events.</p>
        pub fn limit(mut self, inp: i32) -> Self {
            self.inner = self.inner.limit(inp);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
        /// <p>If the value is true, the operation makes a best effort to provide responses that
        /// contain events from multiple log streams within the log group, interleaved in a single
        /// response. If the value is false, all the matched log events in the first log stream are
        /// searched first, then those in the next log stream, and so on. The default is false.</p>
        /// <p>
        /// <b>Important:</b> Starting on June 17, 2019, this parameter
        /// is ignored and the value is assumed to be true. The response from this operation always
        /// interleaves events from multiple log streams within a log group.</p>
        pub fn interleaved(mut self, inp: bool) -> Self {
            self.inner = self.inner.interleaved(inp);
            self
        }
        pub fn set_interleaved(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_interleaved(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetLogEvents<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_log_events_input::Builder,
    }
    impl<C, M, R> GetLogEvents<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetLogEventsOutput,
            smithy_http::result::SdkError<crate::error::GetLogEventsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetLogEventsInputOperationOutputAlias,
                crate::output::GetLogEventsOutput,
                crate::error::GetLogEventsError,
                crate::input::GetLogEventsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the log group.</p>
        pub fn log_group_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_group_name(inp);
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_log_group_name(input);
            self
        }
        /// <p>The name of the log stream.</p>
        pub fn log_stream_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_stream_name(inp);
            self
        }
        pub fn set_log_stream_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_log_stream_name(input);
            self
        }
        /// <p>The start of the time range, expressed as the number of milliseconds after Jan 1, 1970
        /// 00:00:00 UTC. Events with a timestamp equal to this time or later than this time are included.
        /// Events with a timestamp earlier than this time are not included.</p>
        pub fn start_time(mut self, inp: i64) -> Self {
            self.inner = self.inner.start_time(inp);
            self
        }
        pub fn set_start_time(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_start_time(input);
            self
        }
        /// <p>The end of the time range, expressed as the number of milliseconds after Jan 1, 1970
        /// 00:00:00 UTC. Events with a timestamp equal to or later than this time are not
        /// included.</p>
        pub fn end_time(mut self, inp: i64) -> Self {
            self.inner = self.inner.end_time(inp);
            self
        }
        pub fn set_end_time(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_end_time(input);
            self
        }
        /// <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of log events returned. If you don't specify a value, the maximum is
        /// as many log events as can fit in a response size of 1 MB, up to 10,000 log events.</p>
        pub fn limit(mut self, inp: i32) -> Self {
            self.inner = self.inner.limit(inp);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
        /// <p>If the value is true, the earliest log events are returned first.
        /// If the value is false, the latest log events are returned first.
        /// The default value is false.</p>
        /// <p>If you are using a previous <code>nextForwardToken</code> value as the <code>nextToken</code> in this operation,
        /// you must specify <code>true</code> for <code>startFromHead</code>.</p>
        pub fn start_from_head(mut self, inp: bool) -> Self {
            self.inner = self.inner.start_from_head(inp);
            self
        }
        pub fn set_start_from_head(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_start_from_head(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetLogGroupFields<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_log_group_fields_input::Builder,
    }
    impl<C, M, R> GetLogGroupFields<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetLogGroupFieldsOutput,
            smithy_http::result::SdkError<crate::error::GetLogGroupFieldsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetLogGroupFieldsInputOperationOutputAlias,
                crate::output::GetLogGroupFieldsOutput,
                crate::error::GetLogGroupFieldsError,
                crate::input::GetLogGroupFieldsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the log group to search.</p>
        pub fn log_group_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_group_name(inp);
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_log_group_name(input);
            self
        }
        /// <p>The time to set as the center of the query. If you specify <code>time</code>, the 15 minutes
        /// before this time are queries. If you omit <code>time</code> the 8
        /// minutes before and 8 minutes after this time are searched.</p>
        /// <p>The <code>time</code> value is specified as epoch time, the number of seconds since
        /// January 1, 1970, 00:00:00 UTC.</p>
        pub fn time(mut self, inp: i64) -> Self {
            self.inner = self.inner.time(inp);
            self
        }
        pub fn set_time(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_time(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetLogRecord<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_log_record_input::Builder,
    }
    impl<C, M, R> GetLogRecord<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetLogRecordOutput,
            smithy_http::result::SdkError<crate::error::GetLogRecordError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetLogRecordInputOperationOutputAlias,
                crate::output::GetLogRecordOutput,
                crate::error::GetLogRecordError,
                crate::input::GetLogRecordInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The pointer corresponding to the log event record you want to retrieve. You get this from
        /// the response of a <code>GetQueryResults</code> operation. In that response, the value of the
        /// <code>@ptr</code> field for a log event is the value to use as <code>logRecordPointer</code>
        /// to retrieve that complete log event record.</p>
        pub fn log_record_pointer(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_record_pointer(inp);
            self
        }
        pub fn set_log_record_pointer(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_log_record_pointer(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetQueryResults<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_query_results_input::Builder,
    }
    impl<C, M, R> GetQueryResults<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetQueryResultsOutput,
            smithy_http::result::SdkError<crate::error::GetQueryResultsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetQueryResultsInputOperationOutputAlias,
                crate::output::GetQueryResultsOutput,
                crate::error::GetQueryResultsError,
                crate::input::GetQueryResultsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID number of the query.</p>
        pub fn query_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.query_id(inp);
            self
        }
        pub fn set_query_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_query_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTagsLogGroup<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_tags_log_group_input::Builder,
    }
    impl<C, M, R> ListTagsLogGroup<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTagsLogGroupOutput,
            smithy_http::result::SdkError<crate::error::ListTagsLogGroupError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListTagsLogGroupInputOperationOutputAlias,
                crate::output::ListTagsLogGroupOutput,
                crate::error::ListTagsLogGroupError,
                crate::input::ListTagsLogGroupInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the log group.</p>
        pub fn log_group_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_group_name(inp);
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_log_group_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutDestination<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::put_destination_input::Builder,
    }
    impl<C, M, R> PutDestination<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutDestinationOutput,
            smithy_http::result::SdkError<crate::error::PutDestinationError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::PutDestinationInputOperationOutputAlias,
                crate::output::PutDestinationOutput,
                crate::error::PutDestinationError,
                crate::input::PutDestinationInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A name for the destination.</p>
        pub fn destination_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.destination_name(inp);
            self
        }
        pub fn set_destination_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_destination_name(input);
            self
        }
        /// <p>The ARN of an Amazon Kinesis stream to which to deliver matching log events.</p>
        pub fn target_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.target_arn(inp);
            self
        }
        pub fn set_target_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_target_arn(input);
            self
        }
        /// <p>The ARN of an IAM role that grants CloudWatch Logs permissions to call the Amazon
        /// Kinesis <code>PutRecord</code> operation on the destination stream.</p>
        pub fn role_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_arn(inp);
            self
        }
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutDestinationPolicy<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::put_destination_policy_input::Builder,
    }
    impl<C, M, R> PutDestinationPolicy<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutDestinationPolicyOutput,
            smithy_http::result::SdkError<crate::error::PutDestinationPolicyError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::PutDestinationPolicyInputOperationOutputAlias,
                crate::output::PutDestinationPolicyOutput,
                crate::error::PutDestinationPolicyError,
                crate::input::PutDestinationPolicyInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A name for an existing destination.</p>
        pub fn destination_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.destination_name(inp);
            self
        }
        pub fn set_destination_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_destination_name(input);
            self
        }
        /// <p>An IAM policy document that authorizes cross-account users to deliver their log events
        /// to the associated destination. This can be up to 5120 bytes.</p>
        pub fn access_policy(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.access_policy(inp);
            self
        }
        pub fn set_access_policy(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_access_policy(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutLogEvents<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::put_log_events_input::Builder,
    }
    impl<C, M, R> PutLogEvents<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutLogEventsOutput,
            smithy_http::result::SdkError<crate::error::PutLogEventsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::PutLogEventsInputOperationOutputAlias,
                crate::output::PutLogEventsOutput,
                crate::error::PutLogEventsError,
                crate::input::PutLogEventsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the log group.</p>
        pub fn log_group_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_group_name(inp);
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_log_group_name(input);
            self
        }
        /// <p>The name of the log stream.</p>
        pub fn log_stream_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_stream_name(inp);
            self
        }
        pub fn set_log_stream_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_log_stream_name(input);
            self
        }
        /// Appends an item to `logEvents`.
        ///
        /// To override the contents of this collection use [`set_log_events`](Self::set_log_events).
        /// <p>The log events.</p>
        pub fn log_events(mut self, inp: impl Into<crate::model::InputLogEvent>) -> Self {
            self.inner = self.inner.log_events(inp);
            self
        }
        pub fn set_log_events(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::InputLogEvent>>,
        ) -> Self {
            self.inner = self.inner.set_log_events(input);
            self
        }
        /// <p>The sequence token obtained from the response of the previous <code>PutLogEvents</code>
        /// call. An upload in a newly created log stream does not require a sequence token. You can also
        /// get the sequence token using <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_DescribeLogStreams.html">DescribeLogStreams</a>. If you call <code>PutLogEvents</code> twice within a narrow
        /// time period using the same value for <code>sequenceToken</code>, both calls might be
        /// successful or one might be rejected.</p>
        pub fn sequence_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.sequence_token(inp);
            self
        }
        pub fn set_sequence_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_sequence_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutMetricFilter<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::put_metric_filter_input::Builder,
    }
    impl<C, M, R> PutMetricFilter<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutMetricFilterOutput,
            smithy_http::result::SdkError<crate::error::PutMetricFilterError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::PutMetricFilterInputOperationOutputAlias,
                crate::output::PutMetricFilterOutput,
                crate::error::PutMetricFilterError,
                crate::input::PutMetricFilterInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the log group.</p>
        pub fn log_group_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_group_name(inp);
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_log_group_name(input);
            self
        }
        /// <p>A name for the metric filter.</p>
        pub fn filter_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.filter_name(inp);
            self
        }
        pub fn set_filter_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_filter_name(input);
            self
        }
        /// <p>A filter pattern for extracting metric data out of ingested log events.</p>
        pub fn filter_pattern(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.filter_pattern(inp);
            self
        }
        pub fn set_filter_pattern(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_filter_pattern(input);
            self
        }
        /// Appends an item to `metricTransformations`.
        ///
        /// To override the contents of this collection use [`set_metric_transformations`](Self::set_metric_transformations).
        /// <p>A collection of information that defines how metric data gets emitted.</p>
        pub fn metric_transformations(
            mut self,
            inp: impl Into<crate::model::MetricTransformation>,
        ) -> Self {
            self.inner = self.inner.metric_transformations(inp);
            self
        }
        pub fn set_metric_transformations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MetricTransformation>>,
        ) -> Self {
            self.inner = self.inner.set_metric_transformations(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutQueryDefinition<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::put_query_definition_input::Builder,
    }
    impl<C, M, R> PutQueryDefinition<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutQueryDefinitionOutput,
            smithy_http::result::SdkError<crate::error::PutQueryDefinitionError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::PutQueryDefinitionInputOperationOutputAlias,
                crate::output::PutQueryDefinitionOutput,
                crate::error::PutQueryDefinitionError,
                crate::input::PutQueryDefinitionInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A name for the query definition. If you are saving a lot of query definitions, we
        /// recommend that you name them so that you can easily find the ones you want by using the first
        /// part of the name as a filter in the <code>queryDefinitionNamePrefix</code> parameter of <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_DescribeQueryDefinitions.html">DescribeQueryDefinitions</a>.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>If you are updating a query definition, use this parameter to specify the ID of the query
        /// definition that you want to update. You can use <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_DescribeQueryDefinitions.html">DescribeQueryDefinitions</a> to retrieve the IDs of your saved query
        /// definitions.</p>
        /// <p>If you are creating a query definition, do not specify this parameter. CloudWatch
        /// generates a unique ID for the new query definition and include it in the response to this
        /// operation.</p>
        pub fn query_definition_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.query_definition_id(inp);
            self
        }
        pub fn set_query_definition_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_query_definition_id(input);
            self
        }
        /// Appends an item to `logGroupNames`.
        ///
        /// To override the contents of this collection use [`set_log_group_names`](Self::set_log_group_names).
        /// <p>Use this parameter to include specific log groups as part of your query definition.</p>
        /// <p>If you are updating a query definition and you omit this parameter, then the updated
        /// definition will contain no log groups.</p>
        pub fn log_group_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_group_names(inp);
            self
        }
        pub fn set_log_group_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_log_group_names(input);
            self
        }
        /// <p>The query string to use for this definition.
        /// For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CWL_QuerySyntax.html">CloudWatch Logs Insights Query Syntax</a>.</p>
        pub fn query_string(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.query_string(inp);
            self
        }
        pub fn set_query_string(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_query_string(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutResourcePolicy<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::put_resource_policy_input::Builder,
    }
    impl<C, M, R> PutResourcePolicy<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutResourcePolicyOutput,
            smithy_http::result::SdkError<crate::error::PutResourcePolicyError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::PutResourcePolicyInputOperationOutputAlias,
                crate::output::PutResourcePolicyOutput,
                crate::error::PutResourcePolicyError,
                crate::input::PutResourcePolicyInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Name of the new policy. This parameter is required.</p>
        pub fn policy_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_name(inp);
            self
        }
        pub fn set_policy_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy_name(input);
            self
        }
        /// <p>Details of the new policy, including the identity of the principal that is enabled to put logs to this account. This is formatted as a JSON string.
        /// This parameter is required.</p>
        /// <p>The following example creates a resource policy enabling the Route 53 service to put
        /// DNS query logs in to the specified log group. Replace <code>"logArn"</code> with the ARN of
        /// your CloudWatch Logs resource, such as a log group or log stream.</p>
        /// <p>CloudWatch Logs also supports <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_condition-keys.html#condition-keys-sourcearn">aws:SourceArn</a>
        /// and <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_condition-keys.html#condition-keys-sourceaccount">aws:SourceAccount</a>
        /// condition context keys.</p>
        /// <p>In the example resource policy, you would replace the value of <code>SourceArn</code> with the resource making the
        /// call from Route 53 to CloudWatch Logs and replace the value of <code>SourceAccount</code> with
        /// the Amazon Web Services account ID making that call.</p>
        /// <p></p>
        /// <p>
        /// <code>{
        /// "Version": "2012-10-17",
        /// "Statement": [
        /// {
        /// "Sid": "Route53LogsToCloudWatchLogs",
        /// "Effect": "Allow",
        /// "Principal": {
        /// "Service": [
        /// "route53.amazonaws.com"
        /// ]
        /// },
        /// "Action": "logs:PutLogEvents",
        /// "Resource": "logArn",
        /// "Condition": {
        /// "ArnLike": {
        /// "aws:SourceArn": "myRoute53ResourceArn"
        /// },
        /// "StringEquals": {
        /// "aws:SourceAccount": "myAwsAccountId"
        /// }
        /// }
        /// }
        /// ]
        /// }</code>
        /// </p>
        pub fn policy_document(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_document(inp);
            self
        }
        pub fn set_policy_document(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_policy_document(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutRetentionPolicy<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::put_retention_policy_input::Builder,
    }
    impl<C, M, R> PutRetentionPolicy<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutRetentionPolicyOutput,
            smithy_http::result::SdkError<crate::error::PutRetentionPolicyError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::PutRetentionPolicyInputOperationOutputAlias,
                crate::output::PutRetentionPolicyOutput,
                crate::error::PutRetentionPolicyError,
                crate::input::PutRetentionPolicyInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the log group.</p>
        pub fn log_group_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_group_name(inp);
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_log_group_name(input);
            self
        }
        /// <p>The number of days to retain the log events in the specified log group.
        /// Possible values are: 1, 3, 5, 7, 14, 30, 60, 90, 120, 150, 180, 365, 400, 545, 731, 1827, and 3653.</p>
        /// <p>To set a log group to never have log events expire, use
        /// <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_DeleteRetentionPolicy.html">DeleteRetentionPolicy</a>.
        /// </p>
        pub fn retention_in_days(mut self, inp: i32) -> Self {
            self.inner = self.inner.retention_in_days(inp);
            self
        }
        pub fn set_retention_in_days(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_retention_in_days(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutSubscriptionFilter<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::put_subscription_filter_input::Builder,
    }
    impl<C, M, R> PutSubscriptionFilter<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutSubscriptionFilterOutput,
            smithy_http::result::SdkError<crate::error::PutSubscriptionFilterError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::PutSubscriptionFilterInputOperationOutputAlias,
                crate::output::PutSubscriptionFilterOutput,
                crate::error::PutSubscriptionFilterError,
                crate::input::PutSubscriptionFilterInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the log group.</p>
        pub fn log_group_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_group_name(inp);
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_log_group_name(input);
            self
        }
        /// <p>A name for the subscription filter. If you are updating an existing filter, you must
        /// specify the correct name in <code>filterName</code>. To find the name of the filter currently
        /// associated with a log group, use <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_DescribeSubscriptionFilters.html">DescribeSubscriptionFilters</a>.</p>
        pub fn filter_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.filter_name(inp);
            self
        }
        pub fn set_filter_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_filter_name(input);
            self
        }
        /// <p>A filter pattern for subscribing to a filtered stream of log events.</p>
        pub fn filter_pattern(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.filter_pattern(inp);
            self
        }
        pub fn set_filter_pattern(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_filter_pattern(input);
            self
        }
        /// <p>The ARN of the destination to deliver matching log events to. Currently, the supported
        /// destinations are:</p>
        /// <ul>
        /// <li>
        /// <p>An Amazon Kinesis stream belonging to the same account as the subscription filter,
        /// for same-account delivery.</p>
        /// </li>
        /// <li>
        /// <p>A logical destination (specified using an ARN) belonging to a different account,
        /// for cross-account delivery.</p>
        /// <p>If you are setting up a cross-account subscription, the destination must have an
        /// IAM policy associated with it that allows the sender to send logs to the destination.
        /// For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_PutDestinationPolicy.html">PutDestinationPolicy</a>.</p>
        /// </li>
        /// <li>
        /// <p>An Amazon Kinesis Firehose delivery stream belonging to the same account as the
        /// subscription filter, for same-account delivery.</p>
        /// </li>
        /// <li>
        /// <p>A Lambda function belonging to the same account as the subscription filter,
        /// for same-account delivery.</p>
        /// </li>
        /// </ul>
        pub fn destination_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.destination_arn(inp);
            self
        }
        pub fn set_destination_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_destination_arn(input);
            self
        }
        /// <p>The ARN of an IAM role that grants CloudWatch Logs permissions to deliver ingested log
        /// events to the destination stream. You don't need to provide the ARN when you are working with
        /// a logical destination for cross-account delivery.</p>
        pub fn role_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_arn(inp);
            self
        }
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_arn(input);
            self
        }
        /// <p>The method used to distribute log data to the destination. By default, log data is
        /// grouped by log stream, but the grouping can be set to random for a more even distribution.
        /// This property is only applicable when the destination is an Amazon Kinesis stream. </p>
        pub fn distribution(mut self, inp: crate::model::Distribution) -> Self {
            self.inner = self.inner.distribution(inp);
            self
        }
        pub fn set_distribution(
            mut self,
            input: std::option::Option<crate::model::Distribution>,
        ) -> Self {
            self.inner = self.inner.set_distribution(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StartQuery<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::start_query_input::Builder,
    }
    impl<C, M, R> StartQuery<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StartQueryOutput,
            smithy_http::result::SdkError<crate::error::StartQueryError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::StartQueryInputOperationOutputAlias,
                crate::output::StartQueryOutput,
                crate::error::StartQueryError,
                crate::input::StartQueryInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The log group on which to perform the query.</p>
        /// <p>A <code>StartQuery</code> operation must include a <code>logGroupNames</code> or a <code>logGroupName</code> parameter, but
        /// not both.</p>
        pub fn log_group_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_group_name(inp);
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_log_group_name(input);
            self
        }
        /// Appends an item to `logGroupNames`.
        ///
        /// To override the contents of this collection use [`set_log_group_names`](Self::set_log_group_names).
        /// <p>The list of log groups to be queried. You can include up to 20 log groups.</p>
        /// <p>A <code>StartQuery</code> operation must include a <code>logGroupNames</code> or a <code>logGroupName</code> parameter, but
        /// not both.</p>
        pub fn log_group_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_group_names(inp);
            self
        }
        pub fn set_log_group_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_log_group_names(input);
            self
        }
        /// <p>The beginning of the time range to query. The range is inclusive, so the specified
        /// start time is included in the query. Specified as epoch time, the
        /// number of seconds since January 1, 1970, 00:00:00 UTC.</p>
        pub fn start_time(mut self, inp: i64) -> Self {
            self.inner = self.inner.start_time(inp);
            self
        }
        pub fn set_start_time(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_start_time(input);
            self
        }
        /// <p>The end of the time range to query. The range is inclusive, so the specified
        /// end time is included in the query. Specified as epoch
        /// time, the number of seconds since January 1, 1970, 00:00:00 UTC.</p>
        pub fn end_time(mut self, inp: i64) -> Self {
            self.inner = self.inner.end_time(inp);
            self
        }
        pub fn set_end_time(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_end_time(input);
            self
        }
        /// <p>The query string to use.
        /// For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CWL_QuerySyntax.html">CloudWatch Logs Insights Query Syntax</a>.</p>
        pub fn query_string(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.query_string(inp);
            self
        }
        pub fn set_query_string(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_query_string(input);
            self
        }
        /// <p>The maximum number of log events to return in the query. If the query string uses the <code>fields</code> command,
        /// only the specified fields and their values are returned. The default is 1000.</p>
        pub fn limit(mut self, inp: i32) -> Self {
            self.inner = self.inner.limit(inp);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_limit(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StopQuery<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::stop_query_input::Builder,
    }
    impl<C, M, R> StopQuery<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StopQueryOutput,
            smithy_http::result::SdkError<crate::error::StopQueryError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::StopQueryInputOperationOutputAlias,
                crate::output::StopQueryOutput,
                crate::error::StopQueryError,
                crate::input::StopQueryInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID number of the query to stop. To find this ID number, use
        /// <code>DescribeQueries</code>.</p>
        pub fn query_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.query_id(inp);
            self
        }
        pub fn set_query_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_query_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TagLogGroup<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::tag_log_group_input::Builder,
    }
    impl<C, M, R> TagLogGroup<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::TagLogGroupOutput,
            smithy_http::result::SdkError<crate::error::TagLogGroupError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::TagLogGroupInputOperationOutputAlias,
                crate::output::TagLogGroupOutput,
                crate::error::TagLogGroupError,
                crate::input::TagLogGroupInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the log group.</p>
        pub fn log_group_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_group_name(inp);
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_log_group_name(input);
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        /// <p>The key-value pairs to use for the tags.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TestMetricFilter<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::test_metric_filter_input::Builder,
    }
    impl<C, M, R> TestMetricFilter<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::TestMetricFilterOutput,
            smithy_http::result::SdkError<crate::error::TestMetricFilterError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::TestMetricFilterInputOperationOutputAlias,
                crate::output::TestMetricFilterOutput,
                crate::error::TestMetricFilterError,
                crate::input::TestMetricFilterInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A symbolic description of how CloudWatch Logs should interpret the data in each log
        /// event. For example, a log event can contain timestamps, IP addresses, strings, and so on. You
        /// use the filter pattern to specify what to look for in the log event message.</p>
        pub fn filter_pattern(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.filter_pattern(inp);
            self
        }
        pub fn set_filter_pattern(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_filter_pattern(input);
            self
        }
        /// Appends an item to `logEventMessages`.
        ///
        /// To override the contents of this collection use [`set_log_event_messages`](Self::set_log_event_messages).
        /// <p>The log event messages to test.</p>
        pub fn log_event_messages(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_event_messages(inp);
            self
        }
        pub fn set_log_event_messages(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_log_event_messages(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UntagLogGroup<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::untag_log_group_input::Builder,
    }
    impl<C, M, R> UntagLogGroup<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UntagLogGroupOutput,
            smithy_http::result::SdkError<crate::error::UntagLogGroupError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UntagLogGroupInputOperationOutputAlias,
                crate::output::UntagLogGroupOutput,
                crate::error::UntagLogGroupError,
                crate::input::UntagLogGroupInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the log group.</p>
        pub fn log_group_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.log_group_name(inp);
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_log_group_name(input);
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        /// <p>The tag keys. The corresponding tags are removed from the log group.</p>
        pub fn tags(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
}
impl<C> Client<C, aws_hyper::AwsMiddleware, smithy_client::retry::Standard> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let retry_config = conf.retry_config.as_ref().cloned().unwrap_or_default();
        let client = aws_hyper::Client::new(conn).with_retry_config(retry_config.into());
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl
    Client<
        smithy_client::erase::DynConnector,
        aws_hyper::AwsMiddleware,
        smithy_client::retry::Standard,
    >
{
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn new(config: &aws_types::config::Config) -> Self {
        Self::from_conf(config.into())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let retry_config = conf.retry_config.as_ref().cloned().unwrap_or_default();
        let client = aws_hyper::Client::https().with_retry_config(retry_config.into());
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
