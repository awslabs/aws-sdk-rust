// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>Associates the specified AWS Key Management Service (AWS KMS) customer master key (CMK) with the specified log group.</p>
/// <p>Associating an AWS KMS CMK with a log group overrides any existing associations between the log group and a CMK.
/// After a CMK is associated with a log group, all newly ingested data for the log group is encrypted using the CMK.
/// This association is stored as long as the data encrypted with the CMK is still within Amazon CloudWatch Logs.
/// This enables Amazon CloudWatch Logs to decrypt this data whenever it is requested.</p>
/// <important>
/// <p>CloudWatch Logs supports only symmetric CMKs. Do not use an associate an asymmetric CMK
/// with your log group. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/symmetric-asymmetric.html">Using Symmetric and Asymmetric
/// Keys</a>.</p>
/// </important>
/// <p>It can take up to 5 minutes for this operation to take effect.</p>
/// <p>If you attempt to associate a CMK with a log group but the CMK does not exist or the
/// CMK is disabled, you receive an <code>InvalidParameterException</code> error. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AssociateKmsKey {
    _private: (),
}
impl AssociateKmsKey {
    /// Creates a new builder-style object to manufacture [`AssociateKmsKeyInput`](crate::input::AssociateKmsKeyInput)
    pub fn builder() -> crate::input::associate_kms_key_input::Builder {
        crate::input::associate_kms_key_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AssociateKmsKey {
    type Output = std::result::Result<
        crate::output::AssociateKmsKeyOutput,
        crate::error::AssociateKmsKeyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_associate_kms_key_error(response)
        } else {
            crate::operation_deser::parse_associate_kms_key_response(response)
        }
    }
}

/// <p>Cancels the specified export task.</p>
/// <p>The task must be in the <code>PENDING</code> or <code>RUNNING</code> state.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CancelExportTask {
    _private: (),
}
impl CancelExportTask {
    /// Creates a new builder-style object to manufacture [`CancelExportTaskInput`](crate::input::CancelExportTaskInput)
    pub fn builder() -> crate::input::cancel_export_task_input::Builder {
        crate::input::cancel_export_task_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CancelExportTask {
    type Output = std::result::Result<
        crate::output::CancelExportTaskOutput,
        crate::error::CancelExportTaskError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_cancel_export_task_error(response)
        } else {
            crate::operation_deser::parse_cancel_export_task_response(response)
        }
    }
}

/// <p>Creates an export task, which allows you to efficiently export data from a
/// log group to an Amazon S3 bucket. When you perform a <code>CreateExportTask</code>
/// operation, you must use credentials that have permission to write to the S3 bucket
/// that you specify as the destination.</p>
/// <p>This is an asynchronous call. If all the required information is provided, this
/// operation initiates an export task and responds with the ID of the task. After the task has started,
/// you can use <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_DescribeExportTasks.html">DescribeExportTasks</a> to get the status of the export task. Each account can
/// only have one active (<code>RUNNING</code> or <code>PENDING</code>) export task at a time.
/// To cancel an export task, use <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_CancelExportTask.html">CancelExportTask</a>.</p>
/// <p>You can export logs from multiple log groups or multiple time ranges to the same S3
/// bucket. To separate out log data for each export task, you can specify a prefix to be used as
/// the Amazon S3 key prefix for all exported objects.</p>
/// <p>Exporting to S3 buckets that are encrypted with AES-256 is supported. Exporting to S3 buckets
/// encrypted with SSE-KMS is not supported. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateExportTask {
    _private: (),
}
impl CreateExportTask {
    /// Creates a new builder-style object to manufacture [`CreateExportTaskInput`](crate::input::CreateExportTaskInput)
    pub fn builder() -> crate::input::create_export_task_input::Builder {
        crate::input::create_export_task_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateExportTask {
    type Output = std::result::Result<
        crate::output::CreateExportTaskOutput,
        crate::error::CreateExportTaskError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_export_task_error(response)
        } else {
            crate::operation_deser::parse_create_export_task_response(response)
        }
    }
}

/// <p>Creates a log group with the specified name. You can create up to 20,000 log groups per account.</p>
/// <p>You must use the following guidelines when naming a log group:</p>
/// <ul>
/// <li>
/// <p>Log group names must be unique within a region for an AWS account.</p>
/// </li>
/// <li>
/// <p>Log group names can be between 1 and 512 characters long.</p>
/// </li>
/// <li>
/// <p>Log group names consist of the following characters: a-z, A-Z, 0-9, '_' (underscore), '-' (hyphen),
/// '/' (forward slash), '.' (period), and '#' (number sign)</p>
/// </li>
/// </ul>
/// <p>When you create a log group, by default the log events in the log group never expire. To set
/// a retention policy so that events expire and are deleted after a specified time, use
/// <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_PutRetentionPolicy.html">PutRetentionPolicy</a>.</p>
/// <p>If you associate a AWS Key Management Service (AWS KMS) customer master key (CMK) with the log group, ingested data is encrypted using the CMK.
/// This association is stored as long as the data encrypted with the CMK is still within Amazon CloudWatch Logs.
/// This enables Amazon CloudWatch Logs to decrypt this data whenever it is requested.</p>
/// <p>If you attempt to associate a CMK with the log group but the CMK does not exist or the
/// CMK is disabled, you receive an <code>InvalidParameterException</code> error. </p>
/// <important>
/// <p> CloudWatch Logs supports only symmetric CMKs. Do not associate an asymmetric CMK with
/// your log group. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/symmetric-asymmetric.html">Using Symmetric and Asymmetric
/// Keys</a>.</p>
/// </important>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateLogGroup {
    _private: (),
}
impl CreateLogGroup {
    /// Creates a new builder-style object to manufacture [`CreateLogGroupInput`](crate::input::CreateLogGroupInput)
    pub fn builder() -> crate::input::create_log_group_input::Builder {
        crate::input::create_log_group_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateLogGroup {
    type Output =
        std::result::Result<crate::output::CreateLogGroupOutput, crate::error::CreateLogGroupError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_log_group_error(response)
        } else {
            crate::operation_deser::parse_create_log_group_response(response)
        }
    }
}

/// <p>Creates a log stream for the specified log group. A log stream is a sequence of log events
/// that originate from a single source, such as an application instance or a resource that is
/// being monitored.</p>
/// <p>There is no limit on the number of log streams that you can create for a log group. There is a limit
/// of 50 TPS on <code>CreateLogStream</code> operations, after which transactions are throttled.</p>
/// <p>You must use the following guidelines when naming a log stream:</p>
/// <ul>
/// <li>
/// <p>Log stream names must be unique within the log group.</p>
/// </li>
/// <li>
/// <p>Log stream names can be between 1 and 512 characters long.</p>
/// </li>
/// <li>
/// <p>The ':' (colon) and '*' (asterisk) characters are not allowed.</p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateLogStream {
    _private: (),
}
impl CreateLogStream {
    /// Creates a new builder-style object to manufacture [`CreateLogStreamInput`](crate::input::CreateLogStreamInput)
    pub fn builder() -> crate::input::create_log_stream_input::Builder {
        crate::input::create_log_stream_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateLogStream {
    type Output = std::result::Result<
        crate::output::CreateLogStreamOutput,
        crate::error::CreateLogStreamError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_log_stream_error(response)
        } else {
            crate::operation_deser::parse_create_log_stream_response(response)
        }
    }
}

/// <p>Deletes the specified destination, and eventually disables all the
/// subscription filters that publish to it. This operation does not delete the
/// physical resource encapsulated by the destination.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteDestination {
    _private: (),
}
impl DeleteDestination {
    /// Creates a new builder-style object to manufacture [`DeleteDestinationInput`](crate::input::DeleteDestinationInput)
    pub fn builder() -> crate::input::delete_destination_input::Builder {
        crate::input::delete_destination_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteDestination {
    type Output = std::result::Result<
        crate::output::DeleteDestinationOutput,
        crate::error::DeleteDestinationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_destination_error(response)
        } else {
            crate::operation_deser::parse_delete_destination_response(response)
        }
    }
}

/// <p>Deletes the specified log group and permanently deletes all the archived
/// log events associated with the log group.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteLogGroup {
    _private: (),
}
impl DeleteLogGroup {
    /// Creates a new builder-style object to manufacture [`DeleteLogGroupInput`](crate::input::DeleteLogGroupInput)
    pub fn builder() -> crate::input::delete_log_group_input::Builder {
        crate::input::delete_log_group_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteLogGroup {
    type Output =
        std::result::Result<crate::output::DeleteLogGroupOutput, crate::error::DeleteLogGroupError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_log_group_error(response)
        } else {
            crate::operation_deser::parse_delete_log_group_response(response)
        }
    }
}

/// <p>Deletes the specified log stream and permanently deletes all the archived log events associated
/// with the log stream.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteLogStream {
    _private: (),
}
impl DeleteLogStream {
    /// Creates a new builder-style object to manufacture [`DeleteLogStreamInput`](crate::input::DeleteLogStreamInput)
    pub fn builder() -> crate::input::delete_log_stream_input::Builder {
        crate::input::delete_log_stream_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteLogStream {
    type Output = std::result::Result<
        crate::output::DeleteLogStreamOutput,
        crate::error::DeleteLogStreamError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_log_stream_error(response)
        } else {
            crate::operation_deser::parse_delete_log_stream_response(response)
        }
    }
}

/// <p>Deletes the specified metric filter.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteMetricFilter {
    _private: (),
}
impl DeleteMetricFilter {
    /// Creates a new builder-style object to manufacture [`DeleteMetricFilterInput`](crate::input::DeleteMetricFilterInput)
    pub fn builder() -> crate::input::delete_metric_filter_input::Builder {
        crate::input::delete_metric_filter_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteMetricFilter {
    type Output = std::result::Result<
        crate::output::DeleteMetricFilterOutput,
        crate::error::DeleteMetricFilterError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_metric_filter_error(response)
        } else {
            crate::operation_deser::parse_delete_metric_filter_response(response)
        }
    }
}

/// <p>Deletes a saved CloudWatch Logs Insights query definition.
/// A query definition contains details about a saved CloudWatch Logs Insights query.</p>
/// <p>Each <code>DeleteQueryDefinition</code> operation can delete one query definition.</p>
/// <p>You must have the <code>logs:DeleteQueryDefinition</code> permission to be able to perform
/// this operation.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteQueryDefinition {
    _private: (),
}
impl DeleteQueryDefinition {
    /// Creates a new builder-style object to manufacture [`DeleteQueryDefinitionInput`](crate::input::DeleteQueryDefinitionInput)
    pub fn builder() -> crate::input::delete_query_definition_input::Builder {
        crate::input::delete_query_definition_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteQueryDefinition {
    type Output = std::result::Result<
        crate::output::DeleteQueryDefinitionOutput,
        crate::error::DeleteQueryDefinitionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_query_definition_error(response)
        } else {
            crate::operation_deser::parse_delete_query_definition_response(response)
        }
    }
}

/// <p>Deletes a resource policy from this account. This revokes
/// the access of the identities in that policy to put log events to this account.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteResourcePolicy {
    _private: (),
}
impl DeleteResourcePolicy {
    /// Creates a new builder-style object to manufacture [`DeleteResourcePolicyInput`](crate::input::DeleteResourcePolicyInput)
    pub fn builder() -> crate::input::delete_resource_policy_input::Builder {
        crate::input::delete_resource_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteResourcePolicy {
    type Output = std::result::Result<
        crate::output::DeleteResourcePolicyOutput,
        crate::error::DeleteResourcePolicyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_resource_policy_error(response)
        } else {
            crate::operation_deser::parse_delete_resource_policy_response(response)
        }
    }
}

/// <p>Deletes the specified retention policy.</p>
/// <p>Log events do not expire if they belong to log groups without a retention policy.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteRetentionPolicy {
    _private: (),
}
impl DeleteRetentionPolicy {
    /// Creates a new builder-style object to manufacture [`DeleteRetentionPolicyInput`](crate::input::DeleteRetentionPolicyInput)
    pub fn builder() -> crate::input::delete_retention_policy_input::Builder {
        crate::input::delete_retention_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteRetentionPolicy {
    type Output = std::result::Result<
        crate::output::DeleteRetentionPolicyOutput,
        crate::error::DeleteRetentionPolicyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_retention_policy_error(response)
        } else {
            crate::operation_deser::parse_delete_retention_policy_response(response)
        }
    }
}

/// <p>Deletes the specified subscription filter.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteSubscriptionFilter {
    _private: (),
}
impl DeleteSubscriptionFilter {
    /// Creates a new builder-style object to manufacture [`DeleteSubscriptionFilterInput`](crate::input::DeleteSubscriptionFilterInput)
    pub fn builder() -> crate::input::delete_subscription_filter_input::Builder {
        crate::input::delete_subscription_filter_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteSubscriptionFilter {
    type Output = std::result::Result<
        crate::output::DeleteSubscriptionFilterOutput,
        crate::error::DeleteSubscriptionFilterError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_subscription_filter_error(response)
        } else {
            crate::operation_deser::parse_delete_subscription_filter_response(response)
        }
    }
}

/// <p>Lists all your destinations. The results are ASCII-sorted by destination name.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeDestinations {
    _private: (),
}
impl DescribeDestinations {
    /// Creates a new builder-style object to manufacture [`DescribeDestinationsInput`](crate::input::DescribeDestinationsInput)
    pub fn builder() -> crate::input::describe_destinations_input::Builder {
        crate::input::describe_destinations_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeDestinations {
    type Output = std::result::Result<
        crate::output::DescribeDestinationsOutput,
        crate::error::DescribeDestinationsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_destinations_error(response)
        } else {
            crate::operation_deser::parse_describe_destinations_response(response)
        }
    }
}

/// <p>Lists the specified export tasks. You can list all your export tasks or filter
/// the results based on task ID or task status.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeExportTasks {
    _private: (),
}
impl DescribeExportTasks {
    /// Creates a new builder-style object to manufacture [`DescribeExportTasksInput`](crate::input::DescribeExportTasksInput)
    pub fn builder() -> crate::input::describe_export_tasks_input::Builder {
        crate::input::describe_export_tasks_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeExportTasks {
    type Output = std::result::Result<
        crate::output::DescribeExportTasksOutput,
        crate::error::DescribeExportTasksError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_export_tasks_error(response)
        } else {
            crate::operation_deser::parse_describe_export_tasks_response(response)
        }
    }
}

/// <p>Lists the specified log groups. You can list all your log groups or filter the results by prefix.
/// The results are ASCII-sorted by log group name.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeLogGroups {
    _private: (),
}
impl DescribeLogGroups {
    /// Creates a new builder-style object to manufacture [`DescribeLogGroupsInput`](crate::input::DescribeLogGroupsInput)
    pub fn builder() -> crate::input::describe_log_groups_input::Builder {
        crate::input::describe_log_groups_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeLogGroups {
    type Output = std::result::Result<
        crate::output::DescribeLogGroupsOutput,
        crate::error::DescribeLogGroupsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_log_groups_error(response)
        } else {
            crate::operation_deser::parse_describe_log_groups_response(response)
        }
    }
}

/// <p>Lists the log streams for the specified log group.
/// You can list all the log streams or filter the results by prefix.
/// You can also control how the results are ordered.</p>
/// <p>This operation has a limit of five transactions per second, after which transactions are throttled.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeLogStreams {
    _private: (),
}
impl DescribeLogStreams {
    /// Creates a new builder-style object to manufacture [`DescribeLogStreamsInput`](crate::input::DescribeLogStreamsInput)
    pub fn builder() -> crate::input::describe_log_streams_input::Builder {
        crate::input::describe_log_streams_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeLogStreams {
    type Output = std::result::Result<
        crate::output::DescribeLogStreamsOutput,
        crate::error::DescribeLogStreamsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_log_streams_error(response)
        } else {
            crate::operation_deser::parse_describe_log_streams_response(response)
        }
    }
}

/// <p>Lists the specified metric filters. You can list all of the metric filters or filter
/// the results by log name, prefix, metric name, or metric namespace. The results are
/// ASCII-sorted by filter name.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeMetricFilters {
    _private: (),
}
impl DescribeMetricFilters {
    /// Creates a new builder-style object to manufacture [`DescribeMetricFiltersInput`](crate::input::DescribeMetricFiltersInput)
    pub fn builder() -> crate::input::describe_metric_filters_input::Builder {
        crate::input::describe_metric_filters_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeMetricFilters {
    type Output = std::result::Result<
        crate::output::DescribeMetricFiltersOutput,
        crate::error::DescribeMetricFiltersError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_metric_filters_error(response)
        } else {
            crate::operation_deser::parse_describe_metric_filters_response(response)
        }
    }
}

/// <p>Returns a list of CloudWatch Logs Insights queries that are scheduled, executing, or have
/// been executed recently in this account. You can request all queries or limit it to queries of
/// a specific log group or queries with a certain status.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeQueries {
    _private: (),
}
impl DescribeQueries {
    /// Creates a new builder-style object to manufacture [`DescribeQueriesInput`](crate::input::DescribeQueriesInput)
    pub fn builder() -> crate::input::describe_queries_input::Builder {
        crate::input::describe_queries_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeQueries {
    type Output = std::result::Result<
        crate::output::DescribeQueriesOutput,
        crate::error::DescribeQueriesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_queries_error(response)
        } else {
            crate::operation_deser::parse_describe_queries_response(response)
        }
    }
}

/// <p>This operation returns a paginated list of your saved CloudWatch Logs Insights query definitions.</p>
/// <p>You can use the <code>queryDefinitionNamePrefix</code> parameter to limit the results to only the
/// query definitions that have names that start with a certain string.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeQueryDefinitions {
    _private: (),
}
impl DescribeQueryDefinitions {
    /// Creates a new builder-style object to manufacture [`DescribeQueryDefinitionsInput`](crate::input::DescribeQueryDefinitionsInput)
    pub fn builder() -> crate::input::describe_query_definitions_input::Builder {
        crate::input::describe_query_definitions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeQueryDefinitions {
    type Output = std::result::Result<
        crate::output::DescribeQueryDefinitionsOutput,
        crate::error::DescribeQueryDefinitionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_query_definitions_error(response)
        } else {
            crate::operation_deser::parse_describe_query_definitions_response(response)
        }
    }
}

/// <p>Lists the resource policies in this account.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeResourcePolicies {
    _private: (),
}
impl DescribeResourcePolicies {
    /// Creates a new builder-style object to manufacture [`DescribeResourcePoliciesInput`](crate::input::DescribeResourcePoliciesInput)
    pub fn builder() -> crate::input::describe_resource_policies_input::Builder {
        crate::input::describe_resource_policies_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeResourcePolicies {
    type Output = std::result::Result<
        crate::output::DescribeResourcePoliciesOutput,
        crate::error::DescribeResourcePoliciesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_resource_policies_error(response)
        } else {
            crate::operation_deser::parse_describe_resource_policies_response(response)
        }
    }
}

/// <p>Lists the subscription filters for the specified log group. You can list all the subscription filters or filter the results by prefix.
/// The results are ASCII-sorted by filter name.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeSubscriptionFilters {
    _private: (),
}
impl DescribeSubscriptionFilters {
    /// Creates a new builder-style object to manufacture [`DescribeSubscriptionFiltersInput`](crate::input::DescribeSubscriptionFiltersInput)
    pub fn builder() -> crate::input::describe_subscription_filters_input::Builder {
        crate::input::describe_subscription_filters_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeSubscriptionFilters {
    type Output = std::result::Result<
        crate::output::DescribeSubscriptionFiltersOutput,
        crate::error::DescribeSubscriptionFiltersError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_subscription_filters_error(response)
        } else {
            crate::operation_deser::parse_describe_subscription_filters_response(response)
        }
    }
}

/// <p>Disassociates the associated AWS Key Management Service (AWS KMS) customer master key (CMK) from the specified log group.</p>
/// <p>After the AWS KMS CMK is disassociated from the log group, AWS CloudWatch Logs stops encrypting newly ingested data for the log group.
/// All previously ingested data remains encrypted, and AWS CloudWatch Logs requires permissions for the CMK whenever the encrypted data is requested.</p>
/// <p>Note that it can take up to 5 minutes for this operation to take effect.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DisassociateKmsKey {
    _private: (),
}
impl DisassociateKmsKey {
    /// Creates a new builder-style object to manufacture [`DisassociateKmsKeyInput`](crate::input::DisassociateKmsKeyInput)
    pub fn builder() -> crate::input::disassociate_kms_key_input::Builder {
        crate::input::disassociate_kms_key_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DisassociateKmsKey {
    type Output = std::result::Result<
        crate::output::DisassociateKmsKeyOutput,
        crate::error::DisassociateKmsKeyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_disassociate_kms_key_error(response)
        } else {
            crate::operation_deser::parse_disassociate_kms_key_response(response)
        }
    }
}

/// <p>Lists log events from the specified log group. You can list all the log events or filter the results
/// using a filter pattern, a time range, and the name of the log stream.</p>
/// <p>By default, this operation returns as many log events as can fit in 1 MB (up to 10,000
/// log events) or all the events found within the time range that you specify. If the results
/// include a token, then there are more log events available, and you can get additional results
/// by specifying the token in a subsequent call. This operation can return empty results
/// while there are more log events available through the token.</p>
/// <p>The returned log events are sorted by event timestamp, the timestamp when the event was ingested
/// by CloudWatch Logs, and the ID of the <code>PutLogEvents</code> request.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct FilterLogEvents {
    _private: (),
}
impl FilterLogEvents {
    /// Creates a new builder-style object to manufacture [`FilterLogEventsInput`](crate::input::FilterLogEventsInput)
    pub fn builder() -> crate::input::filter_log_events_input::Builder {
        crate::input::filter_log_events_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for FilterLogEvents {
    type Output = std::result::Result<
        crate::output::FilterLogEventsOutput,
        crate::error::FilterLogEventsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_filter_log_events_error(response)
        } else {
            crate::operation_deser::parse_filter_log_events_response(response)
        }
    }
}

/// <p>Lists log events from the specified log stream. You can list all of the log events or
/// filter using a time range.</p>
/// <p>By default, this operation returns as many log events as can fit in a response size of 1MB (up to 10,000 log events).
/// You can get additional log events by specifying one of the tokens in a subsequent call.
/// This operation can return empty results while there are more log events available through the token.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetLogEvents {
    _private: (),
}
impl GetLogEvents {
    /// Creates a new builder-style object to manufacture [`GetLogEventsInput`](crate::input::GetLogEventsInput)
    pub fn builder() -> crate::input::get_log_events_input::Builder {
        crate::input::get_log_events_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetLogEvents {
    type Output =
        std::result::Result<crate::output::GetLogEventsOutput, crate::error::GetLogEventsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_log_events_error(response)
        } else {
            crate::operation_deser::parse_get_log_events_response(response)
        }
    }
}

/// <p>Returns a list of the fields that are included in log events in the specified log group, along with the percentage of log events
/// that contain each field. The search is limited to a time period that you specify.</p>
/// <p>In the results, fields that start with @ are fields generated by CloudWatch Logs. For
/// example, <code>@timestamp</code> is the timestamp of each log event. For more information about the fields that are
/// generated by CloudWatch logs, see
/// <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CWL_AnalyzeLogData-discoverable-fields.html">Supported Logs and Discovered Fields</a>.</p>
/// <p>The response results are sorted by the frequency percentage, starting
/// with the highest percentage.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetLogGroupFields {
    _private: (),
}
impl GetLogGroupFields {
    /// Creates a new builder-style object to manufacture [`GetLogGroupFieldsInput`](crate::input::GetLogGroupFieldsInput)
    pub fn builder() -> crate::input::get_log_group_fields_input::Builder {
        crate::input::get_log_group_fields_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetLogGroupFields {
    type Output = std::result::Result<
        crate::output::GetLogGroupFieldsOutput,
        crate::error::GetLogGroupFieldsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_log_group_fields_error(response)
        } else {
            crate::operation_deser::parse_get_log_group_fields_response(response)
        }
    }
}

/// <p>Retrieves all of the fields and values of a single log event. All fields are retrieved,
/// even if the original query that produced the <code>logRecordPointer</code> retrieved only a
/// subset of fields. Fields are returned as field name/field value pairs.</p>
/// <p>The full unparsed log event is returned within <code>@message</code>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetLogRecord {
    _private: (),
}
impl GetLogRecord {
    /// Creates a new builder-style object to manufacture [`GetLogRecordInput`](crate::input::GetLogRecordInput)
    pub fn builder() -> crate::input::get_log_record_input::Builder {
        crate::input::get_log_record_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetLogRecord {
    type Output =
        std::result::Result<crate::output::GetLogRecordOutput, crate::error::GetLogRecordError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_log_record_error(response)
        } else {
            crate::operation_deser::parse_get_log_record_response(response)
        }
    }
}

/// <p>Returns the results from the specified query.</p>
/// <p>Only the fields requested in the query are returned, along with a <code>@ptr</code>
/// field, which is the identifier for the log record. You can use the value of <code>@ptr</code>
/// in a <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_GetLogRecord.html">GetLogRecord</a>
/// operation to get the full log record.</p>
/// <p>
/// <code>GetQueryResults</code>
/// does not start a query execution. To run a query, use <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_StartQuery.html">StartQuery</a>.</p>
/// <p>If the value of the <code>Status</code> field in the output is <code>Running</code>, this operation
/// returns only partial results. If you see a value of <code>Scheduled</code> or <code>Running</code> for the status,
/// you can retry the operation later to see the final results. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetQueryResults {
    _private: (),
}
impl GetQueryResults {
    /// Creates a new builder-style object to manufacture [`GetQueryResultsInput`](crate::input::GetQueryResultsInput)
    pub fn builder() -> crate::input::get_query_results_input::Builder {
        crate::input::get_query_results_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetQueryResults {
    type Output = std::result::Result<
        crate::output::GetQueryResultsOutput,
        crate::error::GetQueryResultsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_query_results_error(response)
        } else {
            crate::operation_deser::parse_get_query_results_response(response)
        }
    }
}

/// <p>Lists the tags for the specified log group.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTagsLogGroup {
    _private: (),
}
impl ListTagsLogGroup {
    /// Creates a new builder-style object to manufacture [`ListTagsLogGroupInput`](crate::input::ListTagsLogGroupInput)
    pub fn builder() -> crate::input::list_tags_log_group_input::Builder {
        crate::input::list_tags_log_group_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTagsLogGroup {
    type Output = std::result::Result<
        crate::output::ListTagsLogGroupOutput,
        crate::error::ListTagsLogGroupError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_tags_log_group_error(response)
        } else {
            crate::operation_deser::parse_list_tags_log_group_response(response)
        }
    }
}

/// <p>Creates or updates a destination. This operation is used only to create destinations for cross-account subscriptions.</p>
/// <p>A destination encapsulates a physical resource (such
/// as an Amazon Kinesis stream) and enables you to subscribe to a real-time stream of log events
/// for a different account, ingested using <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_PutLogEvents.html">PutLogEvents</a>.</p>
/// <p>Through an access policy, a destination controls what is written to it.
/// By default, <code>PutDestination</code> does not set any access policy with the destination,
/// which means a cross-account user cannot call <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_PutSubscriptionFilter.html">PutSubscriptionFilter</a> against
/// this destination. To enable this, the destination owner must call <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_PutDestinationPolicy.html">PutDestinationPolicy</a> after <code>PutDestination</code>.</p>
/// <p>To perform a <code>PutDestination</code> operation, you must also have the
/// <code>iam:PassRole</code> permission.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutDestination {
    _private: (),
}
impl PutDestination {
    /// Creates a new builder-style object to manufacture [`PutDestinationInput`](crate::input::PutDestinationInput)
    pub fn builder() -> crate::input::put_destination_input::Builder {
        crate::input::put_destination_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutDestination {
    type Output =
        std::result::Result<crate::output::PutDestinationOutput, crate::error::PutDestinationError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_destination_error(response)
        } else {
            crate::operation_deser::parse_put_destination_response(response)
        }
    }
}

/// <p>Creates or updates an access policy associated with an existing
/// destination. An access policy is an <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/policies_overview.html">IAM policy document</a> that is used
/// to authorize claims to register a subscription filter against a given destination.</p>
/// <p>If multiple AWS accounts are sending logs to this destination, each sender account must be
/// listed separately in the policy. The policy does not support specifying <code>*</code>
/// as the Principal or the use of the <code>aws:PrincipalOrgId</code> global key.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutDestinationPolicy {
    _private: (),
}
impl PutDestinationPolicy {
    /// Creates a new builder-style object to manufacture [`PutDestinationPolicyInput`](crate::input::PutDestinationPolicyInput)
    pub fn builder() -> crate::input::put_destination_policy_input::Builder {
        crate::input::put_destination_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutDestinationPolicy {
    type Output = std::result::Result<
        crate::output::PutDestinationPolicyOutput,
        crate::error::PutDestinationPolicyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_destination_policy_error(response)
        } else {
            crate::operation_deser::parse_put_destination_policy_response(response)
        }
    }
}

/// <p>Uploads a batch of log events to the specified log stream.</p>
/// <p>You must include the sequence token obtained from the response of the previous call. An
/// upload in a newly created log stream does not require a sequence token. You can also get the
/// sequence token in the <code>expectedSequenceToken</code> field from
/// <code>InvalidSequenceTokenException</code>. If you call <code>PutLogEvents</code> twice
/// within a narrow time period using the same value for <code>sequenceToken</code>, both calls
/// might be successful or one might be rejected.</p>
/// <p>The batch of events must satisfy the following constraints:</p>
/// <ul>
/// <li>
/// <p>The maximum batch size is 1,048,576 bytes. This size is calculated as the sum of
/// all event messages in UTF-8, plus 26 bytes for each log event.</p>
/// </li>
/// <li>
/// <p>None of the log events in the batch can be more than 2 hours in the future.</p>
/// </li>
/// <li>
/// <p>None of the log events in the batch can be older than 14 days or older than the retention
/// period of the log group.</p>
/// </li>
/// <li>
/// <p>The log events in the batch must be in chronological order by their timestamp. The
/// timestamp is the time the event occurred, expressed as the number of milliseconds after
/// Jan 1, 1970 00:00:00 UTC. (In AWS Tools for PowerShell and the AWS SDK for .NET, the
/// timestamp is specified in .NET format: yyyy-mm-ddThh:mm:ss. For example,
/// 2017-09-15T13:45:30.) </p>
/// </li>
/// <li>
/// <p>A batch of log events in a single request cannot span more than 24 hours. Otherwise, the operation fails.</p>
/// </li>
/// <li>
/// <p>The maximum number of log events in a batch is 10,000.</p>
/// </li>
/// <li>
/// <p>There is a quota of 5 requests per second per log stream. Additional requests are throttled. This quota can't be changed.</p>
/// </li>
/// </ul>
/// <p>If a call to <code>PutLogEvents</code> returns "UnrecognizedClientException" the most likely cause is an invalid AWS access key ID or secret key. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutLogEvents {
    _private: (),
}
impl PutLogEvents {
    /// Creates a new builder-style object to manufacture [`PutLogEventsInput`](crate::input::PutLogEventsInput)
    pub fn builder() -> crate::input::put_log_events_input::Builder {
        crate::input::put_log_events_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutLogEvents {
    type Output =
        std::result::Result<crate::output::PutLogEventsOutput, crate::error::PutLogEventsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_log_events_error(response)
        } else {
            crate::operation_deser::parse_put_log_events_response(response)
        }
    }
}

/// <p>Creates or updates a metric filter and associates it with the specified log group.
/// Metric filters allow you to configure rules to extract metric data from log events ingested
/// through <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_PutLogEvents.html">PutLogEvents</a>.</p>
/// <p>The maximum number of metric filters that can be associated with a log group is
/// 100.</p>
/// <p>When you create a metric filter, you can also optionally assign a unit and dimensions
/// to the metric that is created.</p>
/// <important>
/// <p>Metrics extracted from log events are charged as custom metrics.
/// To prevent unexpected high charges, do not specify high-cardinality fields such as
/// <code>IPAddress</code> or <code>requestID</code> as dimensions. Each different value
/// found for
/// a dimension is treated as a separate metric and accrues charges as a separate custom metric.
/// </p>
/// <p>To help prevent accidental high charges, Amazon disables a metric filter
/// if it generates 1000 different name/value pairs for the dimensions that you
/// have specified within a certain amount of time.</p>
/// <p>You can also set up a billing alarm to alert you if your charges are higher than
/// expected. For more information,
/// see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/monitor_estimated_charges_with_cloudwatch.html">
/// Creating a Billing Alarm to Monitor Your Estimated AWS Charges</a>.
/// </p>
/// </important>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutMetricFilter {
    _private: (),
}
impl PutMetricFilter {
    /// Creates a new builder-style object to manufacture [`PutMetricFilterInput`](crate::input::PutMetricFilterInput)
    pub fn builder() -> crate::input::put_metric_filter_input::Builder {
        crate::input::put_metric_filter_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutMetricFilter {
    type Output = std::result::Result<
        crate::output::PutMetricFilterOutput,
        crate::error::PutMetricFilterError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_metric_filter_error(response)
        } else {
            crate::operation_deser::parse_put_metric_filter_response(response)
        }
    }
}

/// <p>Creates or updates a query definition for CloudWatch Logs Insights. For
/// more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/AnalyzingLogData.html">Analyzing Log Data with CloudWatch Logs Insights</a>.</p>
/// <p>To update a query definition, specify its
/// <code>queryDefinitionId</code> in your request. The values of <code>name</code>, <code>queryString</code>,
/// and <code>logGroupNames</code> are changed to the values that you specify in your update
/// operation. No current values are retained from the current query definition. For example, if
/// you update a current query definition that includes log groups, and you don't specify the
/// <code>logGroupNames</code> parameter in your update operation, the query definition changes
/// to contain no log groups.</p>
/// <p>You must have the <code>logs:PutQueryDefinition</code> permission to be able to perform
/// this operation.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutQueryDefinition {
    _private: (),
}
impl PutQueryDefinition {
    /// Creates a new builder-style object to manufacture [`PutQueryDefinitionInput`](crate::input::PutQueryDefinitionInput)
    pub fn builder() -> crate::input::put_query_definition_input::Builder {
        crate::input::put_query_definition_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutQueryDefinition {
    type Output = std::result::Result<
        crate::output::PutQueryDefinitionOutput,
        crate::error::PutQueryDefinitionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_query_definition_error(response)
        } else {
            crate::operation_deser::parse_put_query_definition_response(response)
        }
    }
}

/// <p>Creates or updates a resource policy allowing other AWS services to put log events to
/// this account, such as Amazon Route 53. An account can have up to 10 resource policies per AWS
/// Region.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutResourcePolicy {
    _private: (),
}
impl PutResourcePolicy {
    /// Creates a new builder-style object to manufacture [`PutResourcePolicyInput`](crate::input::PutResourcePolicyInput)
    pub fn builder() -> crate::input::put_resource_policy_input::Builder {
        crate::input::put_resource_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutResourcePolicy {
    type Output = std::result::Result<
        crate::output::PutResourcePolicyOutput,
        crate::error::PutResourcePolicyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_resource_policy_error(response)
        } else {
            crate::operation_deser::parse_put_resource_policy_response(response)
        }
    }
}

/// <p>Sets the retention of the specified log group. A retention policy allows you to
/// configure the number of days for which to retain log events in the specified log
/// group.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutRetentionPolicy {
    _private: (),
}
impl PutRetentionPolicy {
    /// Creates a new builder-style object to manufacture [`PutRetentionPolicyInput`](crate::input::PutRetentionPolicyInput)
    pub fn builder() -> crate::input::put_retention_policy_input::Builder {
        crate::input::put_retention_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutRetentionPolicy {
    type Output = std::result::Result<
        crate::output::PutRetentionPolicyOutput,
        crate::error::PutRetentionPolicyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_retention_policy_error(response)
        } else {
            crate::operation_deser::parse_put_retention_policy_response(response)
        }
    }
}

/// <p>Creates or updates a subscription filter and associates it with the specified log
/// group. Subscription filters allow you to subscribe to a real-time stream of log events
/// ingested through <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_PutLogEvents.html">PutLogEvents</a> and have them delivered to a specific
/// destination. When log events are sent to the
/// receiving service, they are Base64 encoded
/// and compressed with the gzip format.</p>
/// <p>The following destinations are supported for subscription filters:</p>
/// <ul>
/// <li>
/// <p>An Amazon Kinesis stream belonging to the same account as the subscription filter,
/// for same-account delivery.</p>
/// </li>
/// <li>
/// <p>A logical destination that belongs to a different account, for cross-account delivery.</p>
/// </li>
/// <li>
/// <p>An Amazon Kinesis Firehose delivery stream that belongs to the same account as the
/// subscription filter, for same-account delivery.</p>
/// </li>
/// <li>
/// <p>An AWS Lambda function that belongs to the same account as the subscription filter,
/// for same-account delivery.</p>
/// </li>
/// </ul>
/// <p>Each log group can have up to two subscription filters associated with it. If you are
/// updating an existing filter, you must specify the correct name in <code>filterName</code>.
/// </p>
/// <p>To perform a <code>PutSubscriptionFilter</code> operation, you must also have the
/// <code>iam:PassRole</code> permission.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutSubscriptionFilter {
    _private: (),
}
impl PutSubscriptionFilter {
    /// Creates a new builder-style object to manufacture [`PutSubscriptionFilterInput`](crate::input::PutSubscriptionFilterInput)
    pub fn builder() -> crate::input::put_subscription_filter_input::Builder {
        crate::input::put_subscription_filter_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutSubscriptionFilter {
    type Output = std::result::Result<
        crate::output::PutSubscriptionFilterOutput,
        crate::error::PutSubscriptionFilterError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_subscription_filter_error(response)
        } else {
            crate::operation_deser::parse_put_subscription_filter_response(response)
        }
    }
}

/// <p>Schedules a query of a log group using CloudWatch Logs Insights. You specify the log group
/// and time range to query and the query string to use.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CWL_QuerySyntax.html">CloudWatch Logs Insights Query Syntax</a>.</p>
/// <p>Queries time out after 15 minutes of execution. If your queries are timing out, reduce the
/// time range being searched or partition your query into a number of queries.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StartQuery {
    _private: (),
}
impl StartQuery {
    /// Creates a new builder-style object to manufacture [`StartQueryInput`](crate::input::StartQueryInput)
    pub fn builder() -> crate::input::start_query_input::Builder {
        crate::input::start_query_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StartQuery {
    type Output =
        std::result::Result<crate::output::StartQueryOutput, crate::error::StartQueryError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_start_query_error(response)
        } else {
            crate::operation_deser::parse_start_query_response(response)
        }
    }
}

/// <p>Stops a CloudWatch Logs Insights query that is in progress. If the query has already ended, the operation
/// returns an error indicating that the specified query is not running.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StopQuery {
    _private: (),
}
impl StopQuery {
    /// Creates a new builder-style object to manufacture [`StopQueryInput`](crate::input::StopQueryInput)
    pub fn builder() -> crate::input::stop_query_input::Builder {
        crate::input::stop_query_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StopQuery {
    type Output = std::result::Result<crate::output::StopQueryOutput, crate::error::StopQueryError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_stop_query_error(response)
        } else {
            crate::operation_deser::parse_stop_query_response(response)
        }
    }
}

/// <p>Adds or updates the specified tags for the specified log group.</p>
/// <p>To list the tags for a log group, use <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_ListTagsLogGroup.html">ListTagsLogGroup</a>.
/// To remove tags, use <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_UntagLogGroup.html">UntagLogGroup</a>.</p>
/// <p>For more information about tags, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/Working-with-log-groups-and-streams.html#log-group-tagging">Tag Log Groups in Amazon CloudWatch Logs</a>
/// in the <i>Amazon CloudWatch Logs User Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct TagLogGroup {
    _private: (),
}
impl TagLogGroup {
    /// Creates a new builder-style object to manufacture [`TagLogGroupInput`](crate::input::TagLogGroupInput)
    pub fn builder() -> crate::input::tag_log_group_input::Builder {
        crate::input::tag_log_group_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for TagLogGroup {
    type Output =
        std::result::Result<crate::output::TagLogGroupOutput, crate::error::TagLogGroupError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_tag_log_group_error(response)
        } else {
            crate::operation_deser::parse_tag_log_group_response(response)
        }
    }
}

/// <p>Tests the filter pattern of a metric filter against a sample of log event messages. You
/// can use this operation to validate the correctness of a metric filter pattern.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct TestMetricFilter {
    _private: (),
}
impl TestMetricFilter {
    /// Creates a new builder-style object to manufacture [`TestMetricFilterInput`](crate::input::TestMetricFilterInput)
    pub fn builder() -> crate::input::test_metric_filter_input::Builder {
        crate::input::test_metric_filter_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for TestMetricFilter {
    type Output = std::result::Result<
        crate::output::TestMetricFilterOutput,
        crate::error::TestMetricFilterError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_test_metric_filter_error(response)
        } else {
            crate::operation_deser::parse_test_metric_filter_response(response)
        }
    }
}

/// <p>Removes the specified tags from the specified log group.</p>
/// <p>To list the tags for a log group, use <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_ListTagsLogGroup.html">ListTagsLogGroup</a>.
/// To add tags, use <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_TagLogGroup.html">TagLogGroup</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UntagLogGroup {
    _private: (),
}
impl UntagLogGroup {
    /// Creates a new builder-style object to manufacture [`UntagLogGroupInput`](crate::input::UntagLogGroupInput)
    pub fn builder() -> crate::input::untag_log_group_input::Builder {
        crate::input::untag_log_group_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UntagLogGroup {
    type Output =
        std::result::Result<crate::output::UntagLogGroupOutput, crate::error::UntagLogGroupError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_untag_log_group_error(response)
        } else {
            crate::operation_deser::parse_untag_log_group_response(response)
        }
    }
}
