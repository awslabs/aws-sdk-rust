// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>Associates the specified AWS Key Management Service (AWS KMS) customer master key (CMK) with the specified log group.</p>
/// <p>Associating an AWS KMS CMK with a log group overrides any existing associations between the log group and a CMK.
/// After a CMK is associated with a log group, all newly ingested data for the log group is encrypted using the CMK.
/// This association is stored as long as the data encrypted with the CMK is still within Amazon CloudWatch Logs.
/// This enables Amazon CloudWatch Logs to decrypt this data whenever it is requested.</p>
/// <important>
/// <p>CloudWatch Logs supports only symmetric CMKs. Do not use an associate an asymmetric CMK
/// with your log group. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/symmetric-asymmetric.html">Using Symmetric and Asymmetric
/// Keys</a>.</p>
/// </important>
/// <p>It can take up to 5 minutes for this operation to take effect.</p>
/// <p>If you attempt to associate a CMK with a log group but the CMK does not exist or the
/// CMK is disabled, you receive an <code>InvalidParameterException</code> error. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AssociateKmsKey {
    _private: (),
}
impl AssociateKmsKey {
    /// Creates a new builder-style object to manufacture [`AssociateKmsKeyInput`](crate::input::AssociateKmsKeyInput)
    pub fn builder() -> crate::input::associate_kms_key_input::Builder {
        crate::input::associate_kms_key_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> std::result::Result<crate::output::AssociateKmsKeyOutput, crate::error::AssociateKmsKeyError>
    {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::AssociateKmsKeyError::unhandled(generic)),
            };
            return Err(match error_code {
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::AssociateKmsKeyError {
                        kind: crate::error::AssociateKmsKeyErrorKind::InvalidParameterError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::AssociateKmsKeyError::unhandled(e),
                },
                "OperationAbortedException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::AssociateKmsKeyError {
                        kind: crate::error::AssociateKmsKeyErrorKind::OperationAbortedError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::AssociateKmsKeyError::unhandled(e),
                },
                "ResourceNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::AssociateKmsKeyError {
                        kind: crate::error::AssociateKmsKeyErrorKind::ResourceNotFoundError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::AssociateKmsKeyError::unhandled(e),
                },
                "ServiceUnavailableException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::AssociateKmsKeyError {
                        kind: crate::error::AssociateKmsKeyErrorKind::ServiceUnavailableError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::AssociateKmsKeyError::unhandled(e),
                },
                _ => crate::error::AssociateKmsKeyError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::associate_kms_key_output::Builder::default();
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AssociateKmsKey {
    type Output = std::result::Result<
        crate::output::AssociateKmsKeyOutput,
        crate::error::AssociateKmsKeyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Cancels the specified export task.</p>
/// <p>The task must be in the <code>PENDING</code> or <code>RUNNING</code> state.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CancelExportTask {
    _private: (),
}
impl CancelExportTask {
    /// Creates a new builder-style object to manufacture [`CancelExportTaskInput`](crate::input::CancelExportTaskInput)
    pub fn builder() -> crate::input::cancel_export_task_input::Builder {
        crate::input::cancel_export_task_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> std::result::Result<
        crate::output::CancelExportTaskOutput,
        crate::error::CancelExportTaskError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::CancelExportTaskError::unhandled(generic)),
            };
            return Err(match error_code {
                "InvalidOperationException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CancelExportTaskError {
                        kind: crate::error::CancelExportTaskErrorKind::InvalidOperationError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::CancelExportTaskError::unhandled(e),
                },
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CancelExportTaskError {
                        kind: crate::error::CancelExportTaskErrorKind::InvalidParameterError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::CancelExportTaskError::unhandled(e),
                },
                "ResourceNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CancelExportTaskError {
                        kind: crate::error::CancelExportTaskErrorKind::ResourceNotFoundError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::CancelExportTaskError::unhandled(e),
                },
                "ServiceUnavailableException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CancelExportTaskError {
                        kind: crate::error::CancelExportTaskErrorKind::ServiceUnavailableError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::CancelExportTaskError::unhandled(e),
                },
                _ => crate::error::CancelExportTaskError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::cancel_export_task_output::Builder::default();
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CancelExportTask {
    type Output = std::result::Result<
        crate::output::CancelExportTaskOutput,
        crate::error::CancelExportTaskError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Creates an export task, which allows you to efficiently export data from a
/// log group to an Amazon S3 bucket. When you perform a <code>CreateExportTask</code>
/// operation, you must use credentials that have permission to write to the S3 bucket
/// that you specify as the destination.</p>
/// <p>This is an asynchronous call. If all the required information is provided, this
/// operation initiates an export task and responds with the ID of the task. After the task has started,
/// you can use <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_DescribeExportTasks.html">DescribeExportTasks</a> to get the status of the export task. Each account can
/// only have one active (<code>RUNNING</code> or <code>PENDING</code>) export task at a time.
/// To cancel an export task, use <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_CancelExportTask.html">CancelExportTask</a>.</p>
/// <p>You can export logs from multiple log groups or multiple time ranges to the same S3
/// bucket. To separate out log data for each export task, you can specify a prefix to be used as
/// the Amazon S3 key prefix for all exported objects.</p>
/// <p>Exporting to S3 buckets that are encrypted with AES-256 is supported. Exporting to S3 buckets
/// encrypted with SSE-KMS is not supported. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateExportTask {
    _private: (),
}
impl CreateExportTask {
    /// Creates a new builder-style object to manufacture [`CreateExportTaskInput`](crate::input::CreateExportTaskInput)
    pub fn builder() -> crate::input::create_export_task_input::Builder {
        crate::input::create_export_task_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> std::result::Result<
        crate::output::CreateExportTaskOutput,
        crate::error::CreateExportTaskError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::CreateExportTaskError::unhandled(generic)),
            };
            return Err(match error_code {
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateExportTaskError {
                        kind: crate::error::CreateExportTaskErrorKind::InvalidParameterError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::CreateExportTaskError::unhandled(e),
                },
                "LimitExceededException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateExportTaskError {
                        kind: crate::error::CreateExportTaskErrorKind::LimitExceededError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::CreateExportTaskError::unhandled(e),
                },
                "OperationAbortedException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateExportTaskError {
                        kind: crate::error::CreateExportTaskErrorKind::OperationAbortedError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::CreateExportTaskError::unhandled(e),
                },
                "ResourceAlreadyExistsException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateExportTaskError {
                        kind: crate::error::CreateExportTaskErrorKind::ResourceAlreadyExistsError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::CreateExportTaskError::unhandled(e),
                },
                "ResourceNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateExportTaskError {
                        kind: crate::error::CreateExportTaskErrorKind::ResourceNotFoundError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::CreateExportTaskError::unhandled(e),
                },
                "ServiceUnavailableException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateExportTaskError {
                        kind: crate::error::CreateExportTaskErrorKind::ServiceUnavailableError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::CreateExportTaskError::unhandled(e),
                },
                _ => crate::error::CreateExportTaskError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::create_export_task_output::Builder::default();
        builder = crate::json_deser::create_export_task_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::CreateExportTaskError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateExportTask {
    type Output = std::result::Result<
        crate::output::CreateExportTaskOutput,
        crate::error::CreateExportTaskError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Creates a log group with the specified name. You can create up to 20,000 log groups per account.</p>
/// <p>You must use the following guidelines when naming a log group:</p>
/// <ul>
/// <li>
/// <p>Log group names must be unique within a region for an AWS account.</p>
/// </li>
/// <li>
/// <p>Log group names can be between 1 and 512 characters long.</p>
/// </li>
/// <li>
/// <p>Log group names consist of the following characters: a-z, A-Z, 0-9, '_' (underscore), '-' (hyphen),
/// '/' (forward slash), '.' (period), and '#' (number sign)</p>
/// </li>
/// </ul>
/// <p>When you create a log group, by default the log events in the log group never expire. To set
/// a retention policy so that events expire and are deleted after a specified time, use
/// <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_PutRetentionPolicy.html">PutRetentionPolicy</a>.</p>
/// <p>If you associate a AWS Key Management Service (AWS KMS) customer master key (CMK) with the log group, ingested data is encrypted using the CMK.
/// This association is stored as long as the data encrypted with the CMK is still within Amazon CloudWatch Logs.
/// This enables Amazon CloudWatch Logs to decrypt this data whenever it is requested.</p>
/// <p>If you attempt to associate a CMK with the log group but the CMK does not exist or the
/// CMK is disabled, you receive an <code>InvalidParameterException</code> error. </p>
/// <important>
/// <p> CloudWatch Logs supports only symmetric CMKs. Do not associate an asymmetric CMK with
/// your log group. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/symmetric-asymmetric.html">Using Symmetric and Asymmetric
/// Keys</a>.</p>
/// </important>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateLogGroup {
    _private: (),
}
impl CreateLogGroup {
    /// Creates a new builder-style object to manufacture [`CreateLogGroupInput`](crate::input::CreateLogGroupInput)
    pub fn builder() -> crate::input::create_log_group_input::Builder {
        crate::input::create_log_group_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> std::result::Result<crate::output::CreateLogGroupOutput, crate::error::CreateLogGroupError>
    {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::CreateLogGroupError::unhandled(generic)),
            };
            return Err(match error_code {
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateLogGroupError {
                        kind: crate::error::CreateLogGroupErrorKind::InvalidParameterError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::CreateLogGroupError::unhandled(e),
                },
                "LimitExceededException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateLogGroupError {
                        kind: crate::error::CreateLogGroupErrorKind::LimitExceededError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::CreateLogGroupError::unhandled(e),
                },
                "OperationAbortedException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateLogGroupError {
                        kind: crate::error::CreateLogGroupErrorKind::OperationAbortedError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::CreateLogGroupError::unhandled(e),
                },
                "ResourceAlreadyExistsException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateLogGroupError {
                        kind: crate::error::CreateLogGroupErrorKind::ResourceAlreadyExistsError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::CreateLogGroupError::unhandled(e),
                },
                "ServiceUnavailableException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateLogGroupError {
                        kind: crate::error::CreateLogGroupErrorKind::ServiceUnavailableError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::CreateLogGroupError::unhandled(e),
                },
                _ => crate::error::CreateLogGroupError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::create_log_group_output::Builder::default();
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateLogGroup {
    type Output =
        std::result::Result<crate::output::CreateLogGroupOutput, crate::error::CreateLogGroupError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Creates a log stream for the specified log group. A log stream is a sequence of log events
/// that originate from a single source, such as an application instance or a resource that is
/// being monitored.</p>
/// <p>There is no limit on the number of log streams that you can create for a log group. There is a limit
/// of 50 TPS on <code>CreateLogStream</code> operations, after which transactions are throttled.</p>
/// <p>You must use the following guidelines when naming a log stream:</p>
/// <ul>
/// <li>
/// <p>Log stream names must be unique within the log group.</p>
/// </li>
/// <li>
/// <p>Log stream names can be between 1 and 512 characters long.</p>
/// </li>
/// <li>
/// <p>The ':' (colon) and '*' (asterisk) characters are not allowed.</p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateLogStream {
    _private: (),
}
impl CreateLogStream {
    /// Creates a new builder-style object to manufacture [`CreateLogStreamInput`](crate::input::CreateLogStreamInput)
    pub fn builder() -> crate::input::create_log_stream_input::Builder {
        crate::input::create_log_stream_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> std::result::Result<crate::output::CreateLogStreamOutput, crate::error::CreateLogStreamError>
    {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::CreateLogStreamError::unhandled(generic)),
            };
            return Err(match error_code {
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateLogStreamError {
                        kind: crate::error::CreateLogStreamErrorKind::InvalidParameterError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::CreateLogStreamError::unhandled(e),
                },
                "ResourceAlreadyExistsException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateLogStreamError {
                        kind: crate::error::CreateLogStreamErrorKind::ResourceAlreadyExistsError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::CreateLogStreamError::unhandled(e),
                },
                "ResourceNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateLogStreamError {
                        kind: crate::error::CreateLogStreamErrorKind::ResourceNotFoundError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::CreateLogStreamError::unhandled(e),
                },
                "ServiceUnavailableException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::CreateLogStreamError {
                        kind: crate::error::CreateLogStreamErrorKind::ServiceUnavailableError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::CreateLogStreamError::unhandled(e),
                },
                _ => crate::error::CreateLogStreamError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::create_log_stream_output::Builder::default();
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateLogStream {
    type Output = std::result::Result<
        crate::output::CreateLogStreamOutput,
        crate::error::CreateLogStreamError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Deletes the specified destination, and eventually disables all the
/// subscription filters that publish to it. This operation does not delete the
/// physical resource encapsulated by the destination.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteDestination {
    _private: (),
}
impl DeleteDestination {
    /// Creates a new builder-style object to manufacture [`DeleteDestinationInput`](crate::input::DeleteDestinationInput)
    pub fn builder() -> crate::input::delete_destination_input::Builder {
        crate::input::delete_destination_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> std::result::Result<
        crate::output::DeleteDestinationOutput,
        crate::error::DeleteDestinationError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::DeleteDestinationError::unhandled(generic)),
            };
            return Err(match error_code {
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteDestinationError {
                        kind: crate::error::DeleteDestinationErrorKind::InvalidParameterError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeleteDestinationError::unhandled(e),
                },
                "OperationAbortedException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteDestinationError {
                        kind: crate::error::DeleteDestinationErrorKind::OperationAbortedError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeleteDestinationError::unhandled(e),
                },
                "ResourceNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteDestinationError {
                        kind: crate::error::DeleteDestinationErrorKind::ResourceNotFoundError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeleteDestinationError::unhandled(e),
                },
                "ServiceUnavailableException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteDestinationError {
                        kind: crate::error::DeleteDestinationErrorKind::ServiceUnavailableError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeleteDestinationError::unhandled(e),
                },
                _ => crate::error::DeleteDestinationError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::delete_destination_output::Builder::default();
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteDestination {
    type Output = std::result::Result<
        crate::output::DeleteDestinationOutput,
        crate::error::DeleteDestinationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Deletes the specified log group and permanently deletes all the archived
/// log events associated with the log group.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteLogGroup {
    _private: (),
}
impl DeleteLogGroup {
    /// Creates a new builder-style object to manufacture [`DeleteLogGroupInput`](crate::input::DeleteLogGroupInput)
    pub fn builder() -> crate::input::delete_log_group_input::Builder {
        crate::input::delete_log_group_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> std::result::Result<crate::output::DeleteLogGroupOutput, crate::error::DeleteLogGroupError>
    {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::DeleteLogGroupError::unhandled(generic)),
            };
            return Err(match error_code {
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteLogGroupError {
                        kind: crate::error::DeleteLogGroupErrorKind::InvalidParameterError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeleteLogGroupError::unhandled(e),
                },
                "OperationAbortedException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteLogGroupError {
                        kind: crate::error::DeleteLogGroupErrorKind::OperationAbortedError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeleteLogGroupError::unhandled(e),
                },
                "ResourceNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteLogGroupError {
                        kind: crate::error::DeleteLogGroupErrorKind::ResourceNotFoundError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeleteLogGroupError::unhandled(e),
                },
                "ServiceUnavailableException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteLogGroupError {
                        kind: crate::error::DeleteLogGroupErrorKind::ServiceUnavailableError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeleteLogGroupError::unhandled(e),
                },
                _ => crate::error::DeleteLogGroupError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::delete_log_group_output::Builder::default();
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteLogGroup {
    type Output =
        std::result::Result<crate::output::DeleteLogGroupOutput, crate::error::DeleteLogGroupError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Deletes the specified log stream and permanently deletes all the archived log events associated
/// with the log stream.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteLogStream {
    _private: (),
}
impl DeleteLogStream {
    /// Creates a new builder-style object to manufacture [`DeleteLogStreamInput`](crate::input::DeleteLogStreamInput)
    pub fn builder() -> crate::input::delete_log_stream_input::Builder {
        crate::input::delete_log_stream_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> std::result::Result<crate::output::DeleteLogStreamOutput, crate::error::DeleteLogStreamError>
    {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::DeleteLogStreamError::unhandled(generic)),
            };
            return Err(match error_code {
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteLogStreamError {
                        kind: crate::error::DeleteLogStreamErrorKind::InvalidParameterError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeleteLogStreamError::unhandled(e),
                },
                "OperationAbortedException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteLogStreamError {
                        kind: crate::error::DeleteLogStreamErrorKind::OperationAbortedError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeleteLogStreamError::unhandled(e),
                },
                "ResourceNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteLogStreamError {
                        kind: crate::error::DeleteLogStreamErrorKind::ResourceNotFoundError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeleteLogStreamError::unhandled(e),
                },
                "ServiceUnavailableException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteLogStreamError {
                        kind: crate::error::DeleteLogStreamErrorKind::ServiceUnavailableError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeleteLogStreamError::unhandled(e),
                },
                _ => crate::error::DeleteLogStreamError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::delete_log_stream_output::Builder::default();
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteLogStream {
    type Output = std::result::Result<
        crate::output::DeleteLogStreamOutput,
        crate::error::DeleteLogStreamError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Deletes the specified metric filter.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteMetricFilter {
    _private: (),
}
impl DeleteMetricFilter {
    /// Creates a new builder-style object to manufacture [`DeleteMetricFilterInput`](crate::input::DeleteMetricFilterInput)
    pub fn builder() -> crate::input::delete_metric_filter_input::Builder {
        crate::input::delete_metric_filter_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> std::result::Result<
        crate::output::DeleteMetricFilterOutput,
        crate::error::DeleteMetricFilterError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::DeleteMetricFilterError::unhandled(generic)),
            };
            return Err(match error_code {
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteMetricFilterError {
                        kind: crate::error::DeleteMetricFilterErrorKind::InvalidParameterError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeleteMetricFilterError::unhandled(e),
                },
                "OperationAbortedException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteMetricFilterError {
                        kind: crate::error::DeleteMetricFilterErrorKind::OperationAbortedError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeleteMetricFilterError::unhandled(e),
                },
                "ResourceNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteMetricFilterError {
                        kind: crate::error::DeleteMetricFilterErrorKind::ResourceNotFoundError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeleteMetricFilterError::unhandled(e),
                },
                "ServiceUnavailableException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteMetricFilterError {
                        kind: crate::error::DeleteMetricFilterErrorKind::ServiceUnavailableError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeleteMetricFilterError::unhandled(e),
                },
                _ => crate::error::DeleteMetricFilterError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::delete_metric_filter_output::Builder::default();
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteMetricFilter {
    type Output = std::result::Result<
        crate::output::DeleteMetricFilterOutput,
        crate::error::DeleteMetricFilterError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Deletes a saved CloudWatch Logs Insights query definition.
/// A query definition contains details about a saved CloudWatch Logs Insights query.</p>
/// <p>Each <code>DeleteQueryDefinition</code> operation can delete one query definition.</p>
/// <p>You must have the <code>logs:DeleteQueryDefinition</code> permission to be able to perform
/// this operation.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteQueryDefinition {
    _private: (),
}
impl DeleteQueryDefinition {
    /// Creates a new builder-style object to manufacture [`DeleteQueryDefinitionInput`](crate::input::DeleteQueryDefinitionInput)
    pub fn builder() -> crate::input::delete_query_definition_input::Builder {
        crate::input::delete_query_definition_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> std::result::Result<
        crate::output::DeleteQueryDefinitionOutput,
        crate::error::DeleteQueryDefinitionError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::DeleteQueryDefinitionError::unhandled(generic)),
            };
            return Err(match error_code {
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteQueryDefinitionError {
                        kind: crate::error::DeleteQueryDefinitionErrorKind::InvalidParameterError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeleteQueryDefinitionError::unhandled(e),
                },
                "ResourceNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteQueryDefinitionError {
                        kind: crate::error::DeleteQueryDefinitionErrorKind::ResourceNotFoundError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeleteQueryDefinitionError::unhandled(e),
                },
                "ServiceUnavailableException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteQueryDefinitionError {
                        kind: crate::error::DeleteQueryDefinitionErrorKind::ServiceUnavailableError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeleteQueryDefinitionError::unhandled(e),
                },
                _ => crate::error::DeleteQueryDefinitionError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::delete_query_definition_output::Builder::default();
        builder = crate::json_deser::delete_query_definition_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::DeleteQueryDefinitionError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteQueryDefinition {
    type Output = std::result::Result<
        crate::output::DeleteQueryDefinitionOutput,
        crate::error::DeleteQueryDefinitionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Deletes a resource policy from this account. This revokes
/// the access of the identities in that policy to put log events to this account.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteResourcePolicy {
    _private: (),
}
impl DeleteResourcePolicy {
    /// Creates a new builder-style object to manufacture [`DeleteResourcePolicyInput`](crate::input::DeleteResourcePolicyInput)
    pub fn builder() -> crate::input::delete_resource_policy_input::Builder {
        crate::input::delete_resource_policy_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> std::result::Result<
        crate::output::DeleteResourcePolicyOutput,
        crate::error::DeleteResourcePolicyError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::DeleteResourcePolicyError::unhandled(generic)),
            };
            return Err(match error_code {
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteResourcePolicyError {
                        kind: crate::error::DeleteResourcePolicyErrorKind::InvalidParameterError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeleteResourcePolicyError::unhandled(e),
                },
                "ResourceNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteResourcePolicyError {
                        kind: crate::error::DeleteResourcePolicyErrorKind::ResourceNotFoundError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeleteResourcePolicyError::unhandled(e),
                },
                "ServiceUnavailableException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteResourcePolicyError {
                        kind: crate::error::DeleteResourcePolicyErrorKind::ServiceUnavailableError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeleteResourcePolicyError::unhandled(e),
                },
                _ => crate::error::DeleteResourcePolicyError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::delete_resource_policy_output::Builder::default();
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteResourcePolicy {
    type Output = std::result::Result<
        crate::output::DeleteResourcePolicyOutput,
        crate::error::DeleteResourcePolicyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Deletes the specified retention policy.</p>
/// <p>Log events do not expire if they belong to log groups without a retention policy.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteRetentionPolicy {
    _private: (),
}
impl DeleteRetentionPolicy {
    /// Creates a new builder-style object to manufacture [`DeleteRetentionPolicyInput`](crate::input::DeleteRetentionPolicyInput)
    pub fn builder() -> crate::input::delete_retention_policy_input::Builder {
        crate::input::delete_retention_policy_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> std::result::Result<
        crate::output::DeleteRetentionPolicyOutput,
        crate::error::DeleteRetentionPolicyError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::DeleteRetentionPolicyError::unhandled(generic)),
            };
            return Err(match error_code {
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteRetentionPolicyError {
                        kind: crate::error::DeleteRetentionPolicyErrorKind::InvalidParameterError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeleteRetentionPolicyError::unhandled(e),
                },
                "OperationAbortedException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteRetentionPolicyError {
                        kind: crate::error::DeleteRetentionPolicyErrorKind::OperationAbortedError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeleteRetentionPolicyError::unhandled(e),
                },
                "ResourceNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteRetentionPolicyError {
                        kind: crate::error::DeleteRetentionPolicyErrorKind::ResourceNotFoundError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeleteRetentionPolicyError::unhandled(e),
                },
                "ServiceUnavailableException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteRetentionPolicyError {
                        kind: crate::error::DeleteRetentionPolicyErrorKind::ServiceUnavailableError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeleteRetentionPolicyError::unhandled(e),
                },
                _ => crate::error::DeleteRetentionPolicyError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::delete_retention_policy_output::Builder::default();
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteRetentionPolicy {
    type Output = std::result::Result<
        crate::output::DeleteRetentionPolicyOutput,
        crate::error::DeleteRetentionPolicyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Deletes the specified subscription filter.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteSubscriptionFilter {
    _private: (),
}
impl DeleteSubscriptionFilter {
    /// Creates a new builder-style object to manufacture [`DeleteSubscriptionFilterInput`](crate::input::DeleteSubscriptionFilterInput)
    pub fn builder() -> crate::input::delete_subscription_filter_input::Builder {
        crate::input::delete_subscription_filter_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> std::result::Result<
        crate::output::DeleteSubscriptionFilterOutput,
        crate::error::DeleteSubscriptionFilterError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::DeleteSubscriptionFilterError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteSubscriptionFilterError {
                        kind:
                            crate::error::DeleteSubscriptionFilterErrorKind::InvalidParameterError(
                                body,
                            ),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeleteSubscriptionFilterError::unhandled(e),
                },
                "OperationAbortedException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteSubscriptionFilterError {
                        kind:
                            crate::error::DeleteSubscriptionFilterErrorKind::OperationAbortedError(
                                body,
                            ),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeleteSubscriptionFilterError::unhandled(e),
                },
                "ResourceNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteSubscriptionFilterError {
                        kind:
                            crate::error::DeleteSubscriptionFilterErrorKind::ResourceNotFoundError(
                                body,
                            ),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeleteSubscriptionFilterError::unhandled(e),
                },
                "ServiceUnavailableException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DeleteSubscriptionFilterError {
                        kind:
                            crate::error::DeleteSubscriptionFilterErrorKind::ServiceUnavailableError(
                                body,
                            ),
                        meta: generic,
                    },
                    Err(e) => crate::error::DeleteSubscriptionFilterError::unhandled(e),
                },
                _ => crate::error::DeleteSubscriptionFilterError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::delete_subscription_filter_output::Builder::default();
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteSubscriptionFilter {
    type Output = std::result::Result<
        crate::output::DeleteSubscriptionFilterOutput,
        crate::error::DeleteSubscriptionFilterError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Lists all your destinations. The results are ASCII-sorted by destination name.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeDestinations {
    _private: (),
}
impl DescribeDestinations {
    /// Creates a new builder-style object to manufacture [`DescribeDestinationsInput`](crate::input::DescribeDestinationsInput)
    pub fn builder() -> crate::input::describe_destinations_input::Builder {
        crate::input::describe_destinations_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> std::result::Result<
        crate::output::DescribeDestinationsOutput,
        crate::error::DescribeDestinationsError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::DescribeDestinationsError::unhandled(generic)),
            };
            return Err(match error_code {
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeDestinationsError {
                        kind: crate::error::DescribeDestinationsErrorKind::InvalidParameterError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeDestinationsError::unhandled(e),
                },
                "ServiceUnavailableException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeDestinationsError {
                        kind: crate::error::DescribeDestinationsErrorKind::ServiceUnavailableError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeDestinationsError::unhandled(e),
                },
                _ => crate::error::DescribeDestinationsError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::describe_destinations_output::Builder::default();
        builder = crate::json_deser::describe_destinations_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::DescribeDestinationsError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeDestinations {
    type Output = std::result::Result<
        crate::output::DescribeDestinationsOutput,
        crate::error::DescribeDestinationsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Lists the specified export tasks. You can list all your export tasks or filter
/// the results based on task ID or task status.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeExportTasks {
    _private: (),
}
impl DescribeExportTasks {
    /// Creates a new builder-style object to manufacture [`DescribeExportTasksInput`](crate::input::DescribeExportTasksInput)
    pub fn builder() -> crate::input::describe_export_tasks_input::Builder {
        crate::input::describe_export_tasks_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> std::result::Result<
        crate::output::DescribeExportTasksOutput,
        crate::error::DescribeExportTasksError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::DescribeExportTasksError::unhandled(generic)),
            };
            return Err(match error_code {
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeExportTasksError {
                        kind: crate::error::DescribeExportTasksErrorKind::InvalidParameterError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeExportTasksError::unhandled(e),
                },
                "ServiceUnavailableException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeExportTasksError {
                        kind: crate::error::DescribeExportTasksErrorKind::ServiceUnavailableError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeExportTasksError::unhandled(e),
                },
                _ => crate::error::DescribeExportTasksError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::describe_export_tasks_output::Builder::default();
        builder = crate::json_deser::describe_export_tasks_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::DescribeExportTasksError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeExportTasks {
    type Output = std::result::Result<
        crate::output::DescribeExportTasksOutput,
        crate::error::DescribeExportTasksError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Lists the specified log groups. You can list all your log groups or filter the results by prefix.
/// The results are ASCII-sorted by log group name.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeLogGroups {
    _private: (),
}
impl DescribeLogGroups {
    /// Creates a new builder-style object to manufacture [`DescribeLogGroupsInput`](crate::input::DescribeLogGroupsInput)
    pub fn builder() -> crate::input::describe_log_groups_input::Builder {
        crate::input::describe_log_groups_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> std::result::Result<
        crate::output::DescribeLogGroupsOutput,
        crate::error::DescribeLogGroupsError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::DescribeLogGroupsError::unhandled(generic)),
            };
            return Err(match error_code {
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeLogGroupsError {
                        kind: crate::error::DescribeLogGroupsErrorKind::InvalidParameterError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeLogGroupsError::unhandled(e),
                },
                "ServiceUnavailableException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeLogGroupsError {
                        kind: crate::error::DescribeLogGroupsErrorKind::ServiceUnavailableError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeLogGroupsError::unhandled(e),
                },
                _ => crate::error::DescribeLogGroupsError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::describe_log_groups_output::Builder::default();
        builder = crate::json_deser::describe_log_groups_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::DescribeLogGroupsError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeLogGroups {
    type Output = std::result::Result<
        crate::output::DescribeLogGroupsOutput,
        crate::error::DescribeLogGroupsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Lists the log streams for the specified log group.
/// You can list all the log streams or filter the results by prefix.
/// You can also control how the results are ordered.</p>
/// <p>This operation has a limit of five transactions per second, after which transactions are throttled.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeLogStreams {
    _private: (),
}
impl DescribeLogStreams {
    /// Creates a new builder-style object to manufacture [`DescribeLogStreamsInput`](crate::input::DescribeLogStreamsInput)
    pub fn builder() -> crate::input::describe_log_streams_input::Builder {
        crate::input::describe_log_streams_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> std::result::Result<
        crate::output::DescribeLogStreamsOutput,
        crate::error::DescribeLogStreamsError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::DescribeLogStreamsError::unhandled(generic)),
            };
            return Err(match error_code {
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeLogStreamsError {
                        kind: crate::error::DescribeLogStreamsErrorKind::InvalidParameterError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeLogStreamsError::unhandled(e),
                },
                "ResourceNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeLogStreamsError {
                        kind: crate::error::DescribeLogStreamsErrorKind::ResourceNotFoundError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeLogStreamsError::unhandled(e),
                },
                "ServiceUnavailableException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeLogStreamsError {
                        kind: crate::error::DescribeLogStreamsErrorKind::ServiceUnavailableError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeLogStreamsError::unhandled(e),
                },
                _ => crate::error::DescribeLogStreamsError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::describe_log_streams_output::Builder::default();
        builder = crate::json_deser::describe_log_streams_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::DescribeLogStreamsError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeLogStreams {
    type Output = std::result::Result<
        crate::output::DescribeLogStreamsOutput,
        crate::error::DescribeLogStreamsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Lists the specified metric filters. You can list all of the metric filters or filter
/// the results by log name, prefix, metric name, or metric namespace. The results are
/// ASCII-sorted by filter name.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeMetricFilters {
    _private: (),
}
impl DescribeMetricFilters {
    /// Creates a new builder-style object to manufacture [`DescribeMetricFiltersInput`](crate::input::DescribeMetricFiltersInput)
    pub fn builder() -> crate::input::describe_metric_filters_input::Builder {
        crate::input::describe_metric_filters_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> std::result::Result<
        crate::output::DescribeMetricFiltersOutput,
        crate::error::DescribeMetricFiltersError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::DescribeMetricFiltersError::unhandled(generic)),
            };
            return Err(match error_code {
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeMetricFiltersError {
                        kind: crate::error::DescribeMetricFiltersErrorKind::InvalidParameterError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeMetricFiltersError::unhandled(e),
                },
                "ResourceNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeMetricFiltersError {
                        kind: crate::error::DescribeMetricFiltersErrorKind::ResourceNotFoundError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeMetricFiltersError::unhandled(e),
                },
                "ServiceUnavailableException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeMetricFiltersError {
                        kind: crate::error::DescribeMetricFiltersErrorKind::ServiceUnavailableError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeMetricFiltersError::unhandled(e),
                },
                _ => crate::error::DescribeMetricFiltersError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::describe_metric_filters_output::Builder::default();
        builder = crate::json_deser::describe_metric_filters_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::DescribeMetricFiltersError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeMetricFilters {
    type Output = std::result::Result<
        crate::output::DescribeMetricFiltersOutput,
        crate::error::DescribeMetricFiltersError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Returns a list of CloudWatch Logs Insights queries that are scheduled, executing, or have
/// been executed recently in this account. You can request all queries or limit it to queries of
/// a specific log group or queries with a certain status.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeQueries {
    _private: (),
}
impl DescribeQueries {
    /// Creates a new builder-style object to manufacture [`DescribeQueriesInput`](crate::input::DescribeQueriesInput)
    pub fn builder() -> crate::input::describe_queries_input::Builder {
        crate::input::describe_queries_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> std::result::Result<crate::output::DescribeQueriesOutput, crate::error::DescribeQueriesError>
    {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::DescribeQueriesError::unhandled(generic)),
            };
            return Err(match error_code {
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeQueriesError {
                        kind: crate::error::DescribeQueriesErrorKind::InvalidParameterError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeQueriesError::unhandled(e),
                },
                "ResourceNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeQueriesError {
                        kind: crate::error::DescribeQueriesErrorKind::ResourceNotFoundError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeQueriesError::unhandled(e),
                },
                "ServiceUnavailableException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeQueriesError {
                        kind: crate::error::DescribeQueriesErrorKind::ServiceUnavailableError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeQueriesError::unhandled(e),
                },
                _ => crate::error::DescribeQueriesError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::describe_queries_output::Builder::default();
        builder =
            crate::json_deser::describe_queries_deser_operation(response.body().as_ref(), builder)
                .map_err(crate::error::DescribeQueriesError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeQueries {
    type Output = std::result::Result<
        crate::output::DescribeQueriesOutput,
        crate::error::DescribeQueriesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>This operation returns a paginated list of your saved CloudWatch Logs Insights query definitions.</p>
/// <p>You can use the <code>queryDefinitionNamePrefix</code> parameter to limit the results to only the
/// query definitions that have names that start with a certain string.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeQueryDefinitions {
    _private: (),
}
impl DescribeQueryDefinitions {
    /// Creates a new builder-style object to manufacture [`DescribeQueryDefinitionsInput`](crate::input::DescribeQueryDefinitionsInput)
    pub fn builder() -> crate::input::describe_query_definitions_input::Builder {
        crate::input::describe_query_definitions_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> std::result::Result<
        crate::output::DescribeQueryDefinitionsOutput,
        crate::error::DescribeQueryDefinitionsError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::DescribeQueryDefinitionsError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeQueryDefinitionsError {
                        kind:
                            crate::error::DescribeQueryDefinitionsErrorKind::InvalidParameterError(
                                body,
                            ),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeQueryDefinitionsError::unhandled(e),
                },
                "ServiceUnavailableException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeQueryDefinitionsError {
                        kind:
                            crate::error::DescribeQueryDefinitionsErrorKind::ServiceUnavailableError(
                                body,
                            ),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeQueryDefinitionsError::unhandled(e),
                },
                _ => crate::error::DescribeQueryDefinitionsError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::describe_query_definitions_output::Builder::default();
        builder = crate::json_deser::describe_query_definitions_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::DescribeQueryDefinitionsError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeQueryDefinitions {
    type Output = std::result::Result<
        crate::output::DescribeQueryDefinitionsOutput,
        crate::error::DescribeQueryDefinitionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Lists the resource policies in this account.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeResourcePolicies {
    _private: (),
}
impl DescribeResourcePolicies {
    /// Creates a new builder-style object to manufacture [`DescribeResourcePoliciesInput`](crate::input::DescribeResourcePoliciesInput)
    pub fn builder() -> crate::input::describe_resource_policies_input::Builder {
        crate::input::describe_resource_policies_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> std::result::Result<
        crate::output::DescribeResourcePoliciesOutput,
        crate::error::DescribeResourcePoliciesError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::DescribeResourcePoliciesError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeResourcePoliciesError {
                        kind:
                            crate::error::DescribeResourcePoliciesErrorKind::InvalidParameterError(
                                body,
                            ),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeResourcePoliciesError::unhandled(e),
                },
                "ServiceUnavailableException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeResourcePoliciesError {
                        kind:
                            crate::error::DescribeResourcePoliciesErrorKind::ServiceUnavailableError(
                                body,
                            ),
                        meta: generic,
                    },
                    Err(e) => crate::error::DescribeResourcePoliciesError::unhandled(e),
                },
                _ => crate::error::DescribeResourcePoliciesError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::describe_resource_policies_output::Builder::default();
        builder = crate::json_deser::describe_resource_policies_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::DescribeResourcePoliciesError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeResourcePolicies {
    type Output = std::result::Result<
        crate::output::DescribeResourcePoliciesOutput,
        crate::error::DescribeResourcePoliciesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Lists the subscription filters for the specified log group. You can list all the subscription filters or filter the results by prefix.
/// The results are ASCII-sorted by filter name.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeSubscriptionFilters {
    _private: (),
}
impl DescribeSubscriptionFilters {
    /// Creates a new builder-style object to manufacture [`DescribeSubscriptionFiltersInput`](crate::input::DescribeSubscriptionFiltersInput)
    pub fn builder() -> crate::input::describe_subscription_filters_input::Builder {
        crate::input::describe_subscription_filters_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> std::result::Result<
        crate::output::DescribeSubscriptionFiltersOutput,
        crate::error::DescribeSubscriptionFiltersError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => {
                    return Err(crate::error::DescribeSubscriptionFiltersError::unhandled(
                        generic,
                    ))
                }
            };
            return Err(match error_code {
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeSubscriptionFiltersError { kind: crate::error::DescribeSubscriptionFiltersErrorKind::InvalidParameterError(body), meta: generic },
                    Err(e) => crate::error::DescribeSubscriptionFiltersError::unhandled(e)
                }
                "ResourceNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeSubscriptionFiltersError { kind: crate::error::DescribeSubscriptionFiltersErrorKind::ResourceNotFoundError(body), meta: generic },
                    Err(e) => crate::error::DescribeSubscriptionFiltersError::unhandled(e)
                }
                "ServiceUnavailableException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DescribeSubscriptionFiltersError { kind: crate::error::DescribeSubscriptionFiltersErrorKind::ServiceUnavailableError(body), meta: generic },
                    Err(e) => crate::error::DescribeSubscriptionFiltersError::unhandled(e)
                }
                _ => crate::error::DescribeSubscriptionFiltersError::generic(generic)
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::describe_subscription_filters_output::Builder::default();
        builder = crate::json_deser::describe_subscription_filters_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::DescribeSubscriptionFiltersError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeSubscriptionFilters {
    type Output = std::result::Result<
        crate::output::DescribeSubscriptionFiltersOutput,
        crate::error::DescribeSubscriptionFiltersError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Disassociates the associated AWS Key Management Service (AWS KMS) customer master key (CMK) from the specified log group.</p>
/// <p>After the AWS KMS CMK is disassociated from the log group, AWS CloudWatch Logs stops encrypting newly ingested data for the log group.
/// All previously ingested data remains encrypted, and AWS CloudWatch Logs requires permissions for the CMK whenever the encrypted data is requested.</p>
/// <p>Note that it can take up to 5 minutes for this operation to take effect.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DisassociateKmsKey {
    _private: (),
}
impl DisassociateKmsKey {
    /// Creates a new builder-style object to manufacture [`DisassociateKmsKeyInput`](crate::input::DisassociateKmsKeyInput)
    pub fn builder() -> crate::input::disassociate_kms_key_input::Builder {
        crate::input::disassociate_kms_key_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> std::result::Result<
        crate::output::DisassociateKmsKeyOutput,
        crate::error::DisassociateKmsKeyError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::DisassociateKmsKeyError::unhandled(generic)),
            };
            return Err(match error_code {
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DisassociateKmsKeyError {
                        kind: crate::error::DisassociateKmsKeyErrorKind::InvalidParameterError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::DisassociateKmsKeyError::unhandled(e),
                },
                "OperationAbortedException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DisassociateKmsKeyError {
                        kind: crate::error::DisassociateKmsKeyErrorKind::OperationAbortedError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::DisassociateKmsKeyError::unhandled(e),
                },
                "ResourceNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DisassociateKmsKeyError {
                        kind: crate::error::DisassociateKmsKeyErrorKind::ResourceNotFoundError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::DisassociateKmsKeyError::unhandled(e),
                },
                "ServiceUnavailableException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::DisassociateKmsKeyError {
                        kind: crate::error::DisassociateKmsKeyErrorKind::ServiceUnavailableError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::DisassociateKmsKeyError::unhandled(e),
                },
                _ => crate::error::DisassociateKmsKeyError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::disassociate_kms_key_output::Builder::default();
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DisassociateKmsKey {
    type Output = std::result::Result<
        crate::output::DisassociateKmsKeyOutput,
        crate::error::DisassociateKmsKeyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Lists log events from the specified log group. You can list all the log events or filter the results
/// using a filter pattern, a time range, and the name of the log stream.</p>
/// <p>By default, this operation returns as many log events as can fit in 1 MB (up to 10,000
/// log events) or all the events found within the time range that you specify. If the results
/// include a token, then there are more log events available, and you can get additional results
/// by specifying the token in a subsequent call. This operation can return empty results
/// while there are more log events available through the token.</p>
/// <p>The returned log events are sorted by event timestamp, the timestamp when the event was ingested
/// by CloudWatch Logs, and the ID of the <code>PutLogEvents</code> request.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct FilterLogEvents {
    _private: (),
}
impl FilterLogEvents {
    /// Creates a new builder-style object to manufacture [`FilterLogEventsInput`](crate::input::FilterLogEventsInput)
    pub fn builder() -> crate::input::filter_log_events_input::Builder {
        crate::input::filter_log_events_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> std::result::Result<crate::output::FilterLogEventsOutput, crate::error::FilterLogEventsError>
    {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::FilterLogEventsError::unhandled(generic)),
            };
            return Err(match error_code {
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::FilterLogEventsError {
                        kind: crate::error::FilterLogEventsErrorKind::InvalidParameterError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::FilterLogEventsError::unhandled(e),
                },
                "ResourceNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::FilterLogEventsError {
                        kind: crate::error::FilterLogEventsErrorKind::ResourceNotFoundError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::FilterLogEventsError::unhandled(e),
                },
                "ServiceUnavailableException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::FilterLogEventsError {
                        kind: crate::error::FilterLogEventsErrorKind::ServiceUnavailableError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::FilterLogEventsError::unhandled(e),
                },
                _ => crate::error::FilterLogEventsError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::filter_log_events_output::Builder::default();
        builder =
            crate::json_deser::filter_log_events_deser_operation(response.body().as_ref(), builder)
                .map_err(crate::error::FilterLogEventsError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for FilterLogEvents {
    type Output = std::result::Result<
        crate::output::FilterLogEventsOutput,
        crate::error::FilterLogEventsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Lists log events from the specified log stream. You can list all of the log events or
/// filter using a time range.</p>
/// <p>By default, this operation returns as many log events as can fit in a response size of 1MB (up to 10,000 log events).
/// You can get additional log events by specifying one of the tokens in a subsequent call.
/// This operation can return empty results while there are more log events available through the token.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetLogEvents {
    _private: (),
}
impl GetLogEvents {
    /// Creates a new builder-style object to manufacture [`GetLogEventsInput`](crate::input::GetLogEventsInput)
    pub fn builder() -> crate::input::get_log_events_input::Builder {
        crate::input::get_log_events_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> std::result::Result<crate::output::GetLogEventsOutput, crate::error::GetLogEventsError>
    {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::GetLogEventsError::unhandled(generic)),
            };
            return Err(match error_code {
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetLogEventsError {
                        kind: crate::error::GetLogEventsErrorKind::InvalidParameterError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::GetLogEventsError::unhandled(e),
                },
                "ResourceNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetLogEventsError {
                        kind: crate::error::GetLogEventsErrorKind::ResourceNotFoundError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::GetLogEventsError::unhandled(e),
                },
                "ServiceUnavailableException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetLogEventsError {
                        kind: crate::error::GetLogEventsErrorKind::ServiceUnavailableError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::GetLogEventsError::unhandled(e),
                },
                _ => crate::error::GetLogEventsError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::get_log_events_output::Builder::default();
        builder =
            crate::json_deser::get_log_events_deser_operation(response.body().as_ref(), builder)
                .map_err(crate::error::GetLogEventsError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetLogEvents {
    type Output =
        std::result::Result<crate::output::GetLogEventsOutput, crate::error::GetLogEventsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Returns a list of the fields that are included in log events in the specified log group, along with the percentage of log events
/// that contain each field. The search is limited to a time period that you specify.</p>
/// <p>In the results, fields that start with @ are fields generated by CloudWatch Logs. For
/// example, <code>@timestamp</code> is the timestamp of each log event. For more information about the fields that are
/// generated by CloudWatch logs, see
/// <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CWL_AnalyzeLogData-discoverable-fields.html">Supported Logs and Discovered Fields</a>.</p>
/// <p>The response results are sorted by the frequency percentage, starting
/// with the highest percentage.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetLogGroupFields {
    _private: (),
}
impl GetLogGroupFields {
    /// Creates a new builder-style object to manufacture [`GetLogGroupFieldsInput`](crate::input::GetLogGroupFieldsInput)
    pub fn builder() -> crate::input::get_log_group_fields_input::Builder {
        crate::input::get_log_group_fields_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> std::result::Result<
        crate::output::GetLogGroupFieldsOutput,
        crate::error::GetLogGroupFieldsError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::GetLogGroupFieldsError::unhandled(generic)),
            };
            return Err(match error_code {
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetLogGroupFieldsError {
                        kind: crate::error::GetLogGroupFieldsErrorKind::InvalidParameterError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::GetLogGroupFieldsError::unhandled(e),
                },
                "LimitExceededException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetLogGroupFieldsError {
                        kind: crate::error::GetLogGroupFieldsErrorKind::LimitExceededError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::GetLogGroupFieldsError::unhandled(e),
                },
                "ResourceNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetLogGroupFieldsError {
                        kind: crate::error::GetLogGroupFieldsErrorKind::ResourceNotFoundError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::GetLogGroupFieldsError::unhandled(e),
                },
                "ServiceUnavailableException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetLogGroupFieldsError {
                        kind: crate::error::GetLogGroupFieldsErrorKind::ServiceUnavailableError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::GetLogGroupFieldsError::unhandled(e),
                },
                _ => crate::error::GetLogGroupFieldsError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::get_log_group_fields_output::Builder::default();
        builder = crate::json_deser::get_log_group_fields_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::GetLogGroupFieldsError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetLogGroupFields {
    type Output = std::result::Result<
        crate::output::GetLogGroupFieldsOutput,
        crate::error::GetLogGroupFieldsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Retrieves all of the fields and values of a single log event. All fields are retrieved,
/// even if the original query that produced the <code>logRecordPointer</code> retrieved only a
/// subset of fields. Fields are returned as field name/field value pairs.</p>
/// <p>The full unparsed log event is returned within <code>@message</code>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetLogRecord {
    _private: (),
}
impl GetLogRecord {
    /// Creates a new builder-style object to manufacture [`GetLogRecordInput`](crate::input::GetLogRecordInput)
    pub fn builder() -> crate::input::get_log_record_input::Builder {
        crate::input::get_log_record_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> std::result::Result<crate::output::GetLogRecordOutput, crate::error::GetLogRecordError>
    {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::GetLogRecordError::unhandled(generic)),
            };
            return Err(match error_code {
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetLogRecordError {
                        kind: crate::error::GetLogRecordErrorKind::InvalidParameterError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::GetLogRecordError::unhandled(e),
                },
                "LimitExceededException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetLogRecordError {
                        kind: crate::error::GetLogRecordErrorKind::LimitExceededError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::GetLogRecordError::unhandled(e),
                },
                "ResourceNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetLogRecordError {
                        kind: crate::error::GetLogRecordErrorKind::ResourceNotFoundError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::GetLogRecordError::unhandled(e),
                },
                "ServiceUnavailableException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetLogRecordError {
                        kind: crate::error::GetLogRecordErrorKind::ServiceUnavailableError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::GetLogRecordError::unhandled(e),
                },
                _ => crate::error::GetLogRecordError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::get_log_record_output::Builder::default();
        builder =
            crate::json_deser::get_log_record_deser_operation(response.body().as_ref(), builder)
                .map_err(crate::error::GetLogRecordError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetLogRecord {
    type Output =
        std::result::Result<crate::output::GetLogRecordOutput, crate::error::GetLogRecordError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Returns the results from the specified query.</p>
/// <p>Only the fields requested in the query are returned, along with a <code>@ptr</code>
/// field, which is the identifier for the log record. You can use the value of <code>@ptr</code>
/// in a <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_GetLogRecord.html">GetLogRecord</a>
/// operation to get the full log record.</p>
/// <p>
/// <code>GetQueryResults</code>
/// does not start a query execution. To run a query, use <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_StartQuery.html">StartQuery</a>.</p>
/// <p>If the value of the <code>Status</code> field in the output is <code>Running</code>, this operation
/// returns only partial results. If you see a value of <code>Scheduled</code> or <code>Running</code> for the status,
/// you can retry the operation later to see the final results. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetQueryResults {
    _private: (),
}
impl GetQueryResults {
    /// Creates a new builder-style object to manufacture [`GetQueryResultsInput`](crate::input::GetQueryResultsInput)
    pub fn builder() -> crate::input::get_query_results_input::Builder {
        crate::input::get_query_results_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> std::result::Result<crate::output::GetQueryResultsOutput, crate::error::GetQueryResultsError>
    {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::GetQueryResultsError::unhandled(generic)),
            };
            return Err(match error_code {
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetQueryResultsError {
                        kind: crate::error::GetQueryResultsErrorKind::InvalidParameterError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::GetQueryResultsError::unhandled(e),
                },
                "ResourceNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetQueryResultsError {
                        kind: crate::error::GetQueryResultsErrorKind::ResourceNotFoundError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::GetQueryResultsError::unhandled(e),
                },
                "ServiceUnavailableException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::GetQueryResultsError {
                        kind: crate::error::GetQueryResultsErrorKind::ServiceUnavailableError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::GetQueryResultsError::unhandled(e),
                },
                _ => crate::error::GetQueryResultsError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::get_query_results_output::Builder::default();
        builder =
            crate::json_deser::get_query_results_deser_operation(response.body().as_ref(), builder)
                .map_err(crate::error::GetQueryResultsError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetQueryResults {
    type Output = std::result::Result<
        crate::output::GetQueryResultsOutput,
        crate::error::GetQueryResultsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Lists the tags for the specified log group.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTagsLogGroup {
    _private: (),
}
impl ListTagsLogGroup {
    /// Creates a new builder-style object to manufacture [`ListTagsLogGroupInput`](crate::input::ListTagsLogGroupInput)
    pub fn builder() -> crate::input::list_tags_log_group_input::Builder {
        crate::input::list_tags_log_group_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> std::result::Result<
        crate::output::ListTagsLogGroupOutput,
        crate::error::ListTagsLogGroupError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::ListTagsLogGroupError::unhandled(generic)),
            };
            return Err(match error_code {
                "ResourceNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListTagsLogGroupError {
                        kind: crate::error::ListTagsLogGroupErrorKind::ResourceNotFoundError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::ListTagsLogGroupError::unhandled(e),
                },
                "ServiceUnavailableException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::ListTagsLogGroupError {
                        kind: crate::error::ListTagsLogGroupErrorKind::ServiceUnavailableError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::ListTagsLogGroupError::unhandled(e),
                },
                _ => crate::error::ListTagsLogGroupError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::list_tags_log_group_output::Builder::default();
        builder = crate::json_deser::list_tags_log_group_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::ListTagsLogGroupError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTagsLogGroup {
    type Output = std::result::Result<
        crate::output::ListTagsLogGroupOutput,
        crate::error::ListTagsLogGroupError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Creates or updates a destination. This operation is used only to create destinations for cross-account subscriptions.</p>
/// <p>A destination encapsulates a physical resource (such
/// as an Amazon Kinesis stream) and enables you to subscribe to a real-time stream of log events
/// for a different account, ingested using <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_PutLogEvents.html">PutLogEvents</a>.</p>
/// <p>Through an access policy, a destination controls what is written to it.
/// By default, <code>PutDestination</code> does not set any access policy with the destination,
/// which means a cross-account user cannot call <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_PutSubscriptionFilter.html">PutSubscriptionFilter</a> against
/// this destination. To enable this, the destination owner must call <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_PutDestinationPolicy.html">PutDestinationPolicy</a> after <code>PutDestination</code>.</p>
/// <p>To perform a <code>PutDestination</code> operation, you must also have the
/// <code>iam:PassRole</code> permission.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutDestination {
    _private: (),
}
impl PutDestination {
    /// Creates a new builder-style object to manufacture [`PutDestinationInput`](crate::input::PutDestinationInput)
    pub fn builder() -> crate::input::put_destination_input::Builder {
        crate::input::put_destination_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> std::result::Result<crate::output::PutDestinationOutput, crate::error::PutDestinationError>
    {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::PutDestinationError::unhandled(generic)),
            };
            return Err(match error_code {
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutDestinationError {
                        kind: crate::error::PutDestinationErrorKind::InvalidParameterError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::PutDestinationError::unhandled(e),
                },
                "OperationAbortedException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutDestinationError {
                        kind: crate::error::PutDestinationErrorKind::OperationAbortedError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::PutDestinationError::unhandled(e),
                },
                "ServiceUnavailableException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutDestinationError {
                        kind: crate::error::PutDestinationErrorKind::ServiceUnavailableError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::PutDestinationError::unhandled(e),
                },
                _ => crate::error::PutDestinationError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::put_destination_output::Builder::default();
        builder =
            crate::json_deser::put_destination_deser_operation(response.body().as_ref(), builder)
                .map_err(crate::error::PutDestinationError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutDestination {
    type Output =
        std::result::Result<crate::output::PutDestinationOutput, crate::error::PutDestinationError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Creates or updates an access policy associated with an existing
/// destination. An access policy is an <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/policies_overview.html">IAM policy document</a> that is used
/// to authorize claims to register a subscription filter against a given destination.</p>
/// <p>If multiple AWS accounts are sending logs to this destination, each sender account must be
/// listed separately in the policy. The policy does not support specifying <code>*</code>
/// as the Principal or the use of the <code>aws:PrincipalOrgId</code> global key.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutDestinationPolicy {
    _private: (),
}
impl PutDestinationPolicy {
    /// Creates a new builder-style object to manufacture [`PutDestinationPolicyInput`](crate::input::PutDestinationPolicyInput)
    pub fn builder() -> crate::input::put_destination_policy_input::Builder {
        crate::input::put_destination_policy_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> std::result::Result<
        crate::output::PutDestinationPolicyOutput,
        crate::error::PutDestinationPolicyError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::PutDestinationPolicyError::unhandled(generic)),
            };
            return Err(match error_code {
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutDestinationPolicyError {
                        kind: crate::error::PutDestinationPolicyErrorKind::InvalidParameterError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::PutDestinationPolicyError::unhandled(e),
                },
                "OperationAbortedException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutDestinationPolicyError {
                        kind: crate::error::PutDestinationPolicyErrorKind::OperationAbortedError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::PutDestinationPolicyError::unhandled(e),
                },
                "ServiceUnavailableException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutDestinationPolicyError {
                        kind: crate::error::PutDestinationPolicyErrorKind::ServiceUnavailableError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::PutDestinationPolicyError::unhandled(e),
                },
                _ => crate::error::PutDestinationPolicyError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::put_destination_policy_output::Builder::default();
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutDestinationPolicy {
    type Output = std::result::Result<
        crate::output::PutDestinationPolicyOutput,
        crate::error::PutDestinationPolicyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Uploads a batch of log events to the specified log stream.</p>
/// <p>You must include the sequence token obtained from the response of the previous call. An
/// upload in a newly created log stream does not require a sequence token. You can also get the
/// sequence token in the <code>expectedSequenceToken</code> field from
/// <code>InvalidSequenceTokenException</code>. If you call <code>PutLogEvents</code> twice
/// within a narrow time period using the same value for <code>sequenceToken</code>, both calls
/// might be successful or one might be rejected.</p>
/// <p>The batch of events must satisfy the following constraints:</p>
/// <ul>
/// <li>
/// <p>The maximum batch size is 1,048,576 bytes. This size is calculated as the sum of
/// all event messages in UTF-8, plus 26 bytes for each log event.</p>
/// </li>
/// <li>
/// <p>None of the log events in the batch can be more than 2 hours in the future.</p>
/// </li>
/// <li>
/// <p>None of the log events in the batch can be older than 14 days or older than the retention
/// period of the log group.</p>
/// </li>
/// <li>
/// <p>The log events in the batch must be in chronological order by their timestamp. The
/// timestamp is the time the event occurred, expressed as the number of milliseconds after
/// Jan 1, 1970 00:00:00 UTC. (In AWS Tools for PowerShell and the AWS SDK for .NET, the
/// timestamp is specified in .NET format: yyyy-mm-ddThh:mm:ss. For example,
/// 2017-09-15T13:45:30.) </p>
/// </li>
/// <li>
/// <p>A batch of log events in a single request cannot span more than 24 hours. Otherwise, the operation fails.</p>
/// </li>
/// <li>
/// <p>The maximum number of log events in a batch is 10,000.</p>
/// </li>
/// <li>
/// <p>There is a quota of 5 requests per second per log stream. Additional requests are throttled. This quota can't be changed.</p>
/// </li>
/// </ul>
/// <p>If a call to <code>PutLogEvents</code> returns "UnrecognizedClientException" the most likely cause is an invalid AWS access key ID or secret key. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutLogEvents {
    _private: (),
}
impl PutLogEvents {
    /// Creates a new builder-style object to manufacture [`PutLogEventsInput`](crate::input::PutLogEventsInput)
    pub fn builder() -> crate::input::put_log_events_input::Builder {
        crate::input::put_log_events_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> std::result::Result<crate::output::PutLogEventsOutput, crate::error::PutLogEventsError>
    {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::PutLogEventsError::unhandled(generic)),
            };
            return Err(match error_code {
                "DataAlreadyAcceptedException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutLogEventsError {
                        kind: crate::error::PutLogEventsErrorKind::DataAlreadyAcceptedError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::PutLogEventsError::unhandled(e),
                },
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutLogEventsError {
                        kind: crate::error::PutLogEventsErrorKind::InvalidParameterError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::PutLogEventsError::unhandled(e),
                },
                "InvalidSequenceTokenException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutLogEventsError {
                        kind: crate::error::PutLogEventsErrorKind::InvalidSequenceTokenError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::PutLogEventsError::unhandled(e),
                },
                "ResourceNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutLogEventsError {
                        kind: crate::error::PutLogEventsErrorKind::ResourceNotFoundError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::PutLogEventsError::unhandled(e),
                },
                "ServiceUnavailableException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutLogEventsError {
                        kind: crate::error::PutLogEventsErrorKind::ServiceUnavailableError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::PutLogEventsError::unhandled(e),
                },
                "UnrecognizedClientException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutLogEventsError {
                        kind: crate::error::PutLogEventsErrorKind::UnrecognizedClientError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::PutLogEventsError::unhandled(e),
                },
                _ => crate::error::PutLogEventsError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::put_log_events_output::Builder::default();
        builder =
            crate::json_deser::put_log_events_deser_operation(response.body().as_ref(), builder)
                .map_err(crate::error::PutLogEventsError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutLogEvents {
    type Output =
        std::result::Result<crate::output::PutLogEventsOutput, crate::error::PutLogEventsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Creates or updates a metric filter and associates it with the specified log group.
/// Metric filters allow you to configure rules to extract metric data from log events ingested
/// through <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_PutLogEvents.html">PutLogEvents</a>.</p>
/// <p>The maximum number of metric filters that can be associated with a log group is
/// 100.</p>
/// <p>When you create a metric filter, you can also optionally assign a unit and dimensions
/// to the metric that is created.</p>
/// <important>
/// <p>Metrics extracted from log events are charged as custom metrics.
/// To prevent unexpected high charges, do not specify high-cardinality fields such as
/// <code>IPAddress</code> or <code>requestID</code> as dimensions. Each different value
/// found for
/// a dimension is treated as a separate metric and accrues charges as a separate custom metric.
/// </p>
/// <p>To help prevent accidental high charges, Amazon disables a metric filter
/// if it generates 1000 different name/value pairs for the dimensions that you
/// have specified within a certain amount of time.</p>
/// <p>You can also set up a billing alarm to alert you if your charges are higher than
/// expected. For more information,
/// see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/monitor_estimated_charges_with_cloudwatch.html">
/// Creating a Billing Alarm to Monitor Your Estimated AWS Charges</a>.
/// </p>
/// </important>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutMetricFilter {
    _private: (),
}
impl PutMetricFilter {
    /// Creates a new builder-style object to manufacture [`PutMetricFilterInput`](crate::input::PutMetricFilterInput)
    pub fn builder() -> crate::input::put_metric_filter_input::Builder {
        crate::input::put_metric_filter_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> std::result::Result<crate::output::PutMetricFilterOutput, crate::error::PutMetricFilterError>
    {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::PutMetricFilterError::unhandled(generic)),
            };
            return Err(match error_code {
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutMetricFilterError {
                        kind: crate::error::PutMetricFilterErrorKind::InvalidParameterError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::PutMetricFilterError::unhandled(e),
                },
                "LimitExceededException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutMetricFilterError {
                        kind: crate::error::PutMetricFilterErrorKind::LimitExceededError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::PutMetricFilterError::unhandled(e),
                },
                "OperationAbortedException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutMetricFilterError {
                        kind: crate::error::PutMetricFilterErrorKind::OperationAbortedError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::PutMetricFilterError::unhandled(e),
                },
                "ResourceNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutMetricFilterError {
                        kind: crate::error::PutMetricFilterErrorKind::ResourceNotFoundError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::PutMetricFilterError::unhandled(e),
                },
                "ServiceUnavailableException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutMetricFilterError {
                        kind: crate::error::PutMetricFilterErrorKind::ServiceUnavailableError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::PutMetricFilterError::unhandled(e),
                },
                _ => crate::error::PutMetricFilterError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::put_metric_filter_output::Builder::default();
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutMetricFilter {
    type Output = std::result::Result<
        crate::output::PutMetricFilterOutput,
        crate::error::PutMetricFilterError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Creates or updates a query definition for CloudWatch Logs Insights. For
/// more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/AnalyzingLogData.html">Analyzing Log Data with CloudWatch Logs Insights</a>.</p>
/// <p>To update a query definition, specify its
/// <code>queryDefinitionId</code> in your request. The values of <code>name</code>, <code>queryString</code>,
/// and <code>logGroupNames</code> are changed to the values that you specify in your update
/// operation. No current values are retained from the current query definition. For example, if
/// you update a current query definition that includes log groups, and you don't specify the
/// <code>logGroupNames</code> parameter in your update operation, the query definition changes
/// to contain no log groups.</p>
/// <p>You must have the <code>logs:PutQueryDefinition</code> permission to be able to perform
/// this operation.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutQueryDefinition {
    _private: (),
}
impl PutQueryDefinition {
    /// Creates a new builder-style object to manufacture [`PutQueryDefinitionInput`](crate::input::PutQueryDefinitionInput)
    pub fn builder() -> crate::input::put_query_definition_input::Builder {
        crate::input::put_query_definition_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> std::result::Result<
        crate::output::PutQueryDefinitionOutput,
        crate::error::PutQueryDefinitionError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::PutQueryDefinitionError::unhandled(generic)),
            };
            return Err(match error_code {
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutQueryDefinitionError {
                        kind: crate::error::PutQueryDefinitionErrorKind::InvalidParameterError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::PutQueryDefinitionError::unhandled(e),
                },
                "ResourceNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutQueryDefinitionError {
                        kind: crate::error::PutQueryDefinitionErrorKind::ResourceNotFoundError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::PutQueryDefinitionError::unhandled(e),
                },
                "ServiceUnavailableException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutQueryDefinitionError {
                        kind: crate::error::PutQueryDefinitionErrorKind::ServiceUnavailableError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::PutQueryDefinitionError::unhandled(e),
                },
                _ => crate::error::PutQueryDefinitionError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::put_query_definition_output::Builder::default();
        builder = crate::json_deser::put_query_definition_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::PutQueryDefinitionError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutQueryDefinition {
    type Output = std::result::Result<
        crate::output::PutQueryDefinitionOutput,
        crate::error::PutQueryDefinitionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Creates or updates a resource policy allowing other AWS services to put log events to
/// this account, such as Amazon Route 53. An account can have up to 10 resource policies per AWS
/// Region.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutResourcePolicy {
    _private: (),
}
impl PutResourcePolicy {
    /// Creates a new builder-style object to manufacture [`PutResourcePolicyInput`](crate::input::PutResourcePolicyInput)
    pub fn builder() -> crate::input::put_resource_policy_input::Builder {
        crate::input::put_resource_policy_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> std::result::Result<
        crate::output::PutResourcePolicyOutput,
        crate::error::PutResourcePolicyError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::PutResourcePolicyError::unhandled(generic)),
            };
            return Err(match error_code {
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutResourcePolicyError {
                        kind: crate::error::PutResourcePolicyErrorKind::InvalidParameterError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::PutResourcePolicyError::unhandled(e),
                },
                "LimitExceededException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutResourcePolicyError {
                        kind: crate::error::PutResourcePolicyErrorKind::LimitExceededError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::PutResourcePolicyError::unhandled(e),
                },
                "ServiceUnavailableException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutResourcePolicyError {
                        kind: crate::error::PutResourcePolicyErrorKind::ServiceUnavailableError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::PutResourcePolicyError::unhandled(e),
                },
                _ => crate::error::PutResourcePolicyError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::put_resource_policy_output::Builder::default();
        builder = crate::json_deser::put_resource_policy_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::PutResourcePolicyError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutResourcePolicy {
    type Output = std::result::Result<
        crate::output::PutResourcePolicyOutput,
        crate::error::PutResourcePolicyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Sets the retention of the specified log group. A retention policy allows you to
/// configure the number of days for which to retain log events in the specified log
/// group.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutRetentionPolicy {
    _private: (),
}
impl PutRetentionPolicy {
    /// Creates a new builder-style object to manufacture [`PutRetentionPolicyInput`](crate::input::PutRetentionPolicyInput)
    pub fn builder() -> crate::input::put_retention_policy_input::Builder {
        crate::input::put_retention_policy_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> std::result::Result<
        crate::output::PutRetentionPolicyOutput,
        crate::error::PutRetentionPolicyError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::PutRetentionPolicyError::unhandled(generic)),
            };
            return Err(match error_code {
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutRetentionPolicyError {
                        kind: crate::error::PutRetentionPolicyErrorKind::InvalidParameterError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::PutRetentionPolicyError::unhandled(e),
                },
                "OperationAbortedException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutRetentionPolicyError {
                        kind: crate::error::PutRetentionPolicyErrorKind::OperationAbortedError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::PutRetentionPolicyError::unhandled(e),
                },
                "ResourceNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutRetentionPolicyError {
                        kind: crate::error::PutRetentionPolicyErrorKind::ResourceNotFoundError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::PutRetentionPolicyError::unhandled(e),
                },
                "ServiceUnavailableException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutRetentionPolicyError {
                        kind: crate::error::PutRetentionPolicyErrorKind::ServiceUnavailableError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::PutRetentionPolicyError::unhandled(e),
                },
                _ => crate::error::PutRetentionPolicyError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::put_retention_policy_output::Builder::default();
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutRetentionPolicy {
    type Output = std::result::Result<
        crate::output::PutRetentionPolicyOutput,
        crate::error::PutRetentionPolicyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Creates or updates a subscription filter and associates it with the specified log
/// group. Subscription filters allow you to subscribe to a real-time stream of log events
/// ingested through <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_PutLogEvents.html">PutLogEvents</a> and have them delivered to a specific
/// destination. When log events are sent to the
/// receiving service, they are Base64 encoded
/// and compressed with the gzip format.</p>
/// <p>The following destinations are supported for subscription filters:</p>
/// <ul>
/// <li>
/// <p>An Amazon Kinesis stream belonging to the same account as the subscription filter,
/// for same-account delivery.</p>
/// </li>
/// <li>
/// <p>A logical destination that belongs to a different account, for cross-account delivery.</p>
/// </li>
/// <li>
/// <p>An Amazon Kinesis Firehose delivery stream that belongs to the same account as the
/// subscription filter, for same-account delivery.</p>
/// </li>
/// <li>
/// <p>An AWS Lambda function that belongs to the same account as the subscription filter,
/// for same-account delivery.</p>
/// </li>
/// </ul>
/// <p>Each log group can have up to two subscription filters associated with it. If you are
/// updating an existing filter, you must specify the correct name in <code>filterName</code>.
/// </p>
/// <p>To perform a <code>PutSubscriptionFilter</code> operation, you must also have the
/// <code>iam:PassRole</code> permission.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutSubscriptionFilter {
    _private: (),
}
impl PutSubscriptionFilter {
    /// Creates a new builder-style object to manufacture [`PutSubscriptionFilterInput`](crate::input::PutSubscriptionFilterInput)
    pub fn builder() -> crate::input::put_subscription_filter_input::Builder {
        crate::input::put_subscription_filter_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> std::result::Result<
        crate::output::PutSubscriptionFilterOutput,
        crate::error::PutSubscriptionFilterError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::PutSubscriptionFilterError::unhandled(generic)),
            };
            return Err(match error_code {
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutSubscriptionFilterError {
                        kind: crate::error::PutSubscriptionFilterErrorKind::InvalidParameterError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::PutSubscriptionFilterError::unhandled(e),
                },
                "LimitExceededException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutSubscriptionFilterError {
                        kind: crate::error::PutSubscriptionFilterErrorKind::LimitExceededError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::PutSubscriptionFilterError::unhandled(e),
                },
                "OperationAbortedException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutSubscriptionFilterError {
                        kind: crate::error::PutSubscriptionFilterErrorKind::OperationAbortedError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::PutSubscriptionFilterError::unhandled(e),
                },
                "ResourceNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutSubscriptionFilterError {
                        kind: crate::error::PutSubscriptionFilterErrorKind::ResourceNotFoundError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::PutSubscriptionFilterError::unhandled(e),
                },
                "ServiceUnavailableException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::PutSubscriptionFilterError {
                        kind: crate::error::PutSubscriptionFilterErrorKind::ServiceUnavailableError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::PutSubscriptionFilterError::unhandled(e),
                },
                _ => crate::error::PutSubscriptionFilterError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::put_subscription_filter_output::Builder::default();
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutSubscriptionFilter {
    type Output = std::result::Result<
        crate::output::PutSubscriptionFilterOutput,
        crate::error::PutSubscriptionFilterError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Schedules a query of a log group using CloudWatch Logs Insights. You specify the log group
/// and time range to query and the query string to use.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CWL_QuerySyntax.html">CloudWatch Logs Insights Query Syntax</a>.</p>
/// <p>Queries time out after 15 minutes of execution. If your queries are timing out, reduce the
/// time range being searched or partition your query into a number of queries.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StartQuery {
    _private: (),
}
impl StartQuery {
    /// Creates a new builder-style object to manufacture [`StartQueryInput`](crate::input::StartQueryInput)
    pub fn builder() -> crate::input::start_query_input::Builder {
        crate::input::start_query_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> std::result::Result<crate::output::StartQueryOutput, crate::error::StartQueryError> {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::StartQueryError::unhandled(generic)),
            };
            return Err(match error_code {
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::StartQueryError {
                        kind: crate::error::StartQueryErrorKind::InvalidParameterError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::StartQueryError::unhandled(e),
                },
                "LimitExceededException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::StartQueryError {
                        kind: crate::error::StartQueryErrorKind::LimitExceededError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::StartQueryError::unhandled(e),
                },
                "MalformedQueryException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::StartQueryError {
                        kind: crate::error::StartQueryErrorKind::MalformedQueryError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::StartQueryError::unhandled(e),
                },
                "ResourceNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::StartQueryError {
                        kind: crate::error::StartQueryErrorKind::ResourceNotFoundError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::StartQueryError::unhandled(e),
                },
                "ServiceUnavailableException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::StartQueryError {
                        kind: crate::error::StartQueryErrorKind::ServiceUnavailableError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::StartQueryError::unhandled(e),
                },
                _ => crate::error::StartQueryError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::start_query_output::Builder::default();
        builder = crate::json_deser::start_query_deser_operation(response.body().as_ref(), builder)
            .map_err(crate::error::StartQueryError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StartQuery {
    type Output =
        std::result::Result<crate::output::StartQueryOutput, crate::error::StartQueryError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Stops a CloudWatch Logs Insights query that is in progress. If the query has already ended, the operation
/// returns an error indicating that the specified query is not running.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StopQuery {
    _private: (),
}
impl StopQuery {
    /// Creates a new builder-style object to manufacture [`StopQueryInput`](crate::input::StopQueryInput)
    pub fn builder() -> crate::input::stop_query_input::Builder {
        crate::input::stop_query_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> std::result::Result<crate::output::StopQueryOutput, crate::error::StopQueryError> {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::StopQueryError::unhandled(generic)),
            };
            return Err(match error_code {
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::StopQueryError {
                        kind: crate::error::StopQueryErrorKind::InvalidParameterError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::StopQueryError::unhandled(e),
                },
                "ResourceNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::StopQueryError {
                        kind: crate::error::StopQueryErrorKind::ResourceNotFoundError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::StopQueryError::unhandled(e),
                },
                "ServiceUnavailableException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::StopQueryError {
                        kind: crate::error::StopQueryErrorKind::ServiceUnavailableError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::StopQueryError::unhandled(e),
                },
                _ => crate::error::StopQueryError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::stop_query_output::Builder::default();
        builder = crate::json_deser::stop_query_deser_operation(response.body().as_ref(), builder)
            .map_err(crate::error::StopQueryError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StopQuery {
    type Output = std::result::Result<crate::output::StopQueryOutput, crate::error::StopQueryError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Adds or updates the specified tags for the specified log group.</p>
/// <p>To list the tags for a log group, use <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_ListTagsLogGroup.html">ListTagsLogGroup</a>.
/// To remove tags, use <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_UntagLogGroup.html">UntagLogGroup</a>.</p>
/// <p>For more information about tags, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/Working-with-log-groups-and-streams.html#log-group-tagging">Tag Log Groups in Amazon CloudWatch Logs</a>
/// in the <i>Amazon CloudWatch Logs User Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct TagLogGroup {
    _private: (),
}
impl TagLogGroup {
    /// Creates a new builder-style object to manufacture [`TagLogGroupInput`](crate::input::TagLogGroupInput)
    pub fn builder() -> crate::input::tag_log_group_input::Builder {
        crate::input::tag_log_group_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> std::result::Result<crate::output::TagLogGroupOutput, crate::error::TagLogGroupError> {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::TagLogGroupError::unhandled(generic)),
            };
            return Err(match error_code {
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::TagLogGroupError {
                        kind: crate::error::TagLogGroupErrorKind::InvalidParameterError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::TagLogGroupError::unhandled(e),
                },
                "ResourceNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::TagLogGroupError {
                        kind: crate::error::TagLogGroupErrorKind::ResourceNotFoundError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::TagLogGroupError::unhandled(e),
                },
                _ => crate::error::TagLogGroupError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::tag_log_group_output::Builder::default();
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for TagLogGroup {
    type Output =
        std::result::Result<crate::output::TagLogGroupOutput, crate::error::TagLogGroupError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Tests the filter pattern of a metric filter against a sample of log event messages. You
/// can use this operation to validate the correctness of a metric filter pattern.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct TestMetricFilter {
    _private: (),
}
impl TestMetricFilter {
    /// Creates a new builder-style object to manufacture [`TestMetricFilterInput`](crate::input::TestMetricFilterInput)
    pub fn builder() -> crate::input::test_metric_filter_input::Builder {
        crate::input::test_metric_filter_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> std::result::Result<
        crate::output::TestMetricFilterOutput,
        crate::error::TestMetricFilterError,
    > {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::TestMetricFilterError::unhandled(generic)),
            };
            return Err(match error_code {
                "InvalidParameterException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::TestMetricFilterError {
                        kind: crate::error::TestMetricFilterErrorKind::InvalidParameterError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::TestMetricFilterError::unhandled(e),
                },
                "ServiceUnavailableException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::TestMetricFilterError {
                        kind: crate::error::TestMetricFilterErrorKind::ServiceUnavailableError(
                            body,
                        ),
                        meta: generic,
                    },
                    Err(e) => crate::error::TestMetricFilterError::unhandled(e),
                },
                _ => crate::error::TestMetricFilterError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::test_metric_filter_output::Builder::default();
        builder = crate::json_deser::test_metric_filter_deser_operation(
            response.body().as_ref(),
            builder,
        )
        .map_err(crate::error::TestMetricFilterError::unhandled)?;
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for TestMetricFilter {
    type Output = std::result::Result<
        crate::output::TestMetricFilterOutput,
        crate::error::TestMetricFilterError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}

/// <p>Removes the specified tags from the specified log group.</p>
/// <p>To list the tags for a log group, use <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_ListTagsLogGroup.html">ListTagsLogGroup</a>.
/// To add tags, use <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_TagLogGroup.html">TagLogGroup</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UntagLogGroup {
    _private: (),
}
impl UntagLogGroup {
    /// Creates a new builder-style object to manufacture [`UntagLogGroupInput`](crate::input::UntagLogGroupInput)
    pub fn builder() -> crate::input::untag_log_group_input::Builder {
        crate::input::untag_log_group_input::Builder::default()
    }
    #[allow(clippy::unnecessary_wraps)]
    #[allow(dead_code)]
    fn parse_response(
        &self,
        response: &http::response::Response<bytes::Bytes>,
    ) -> std::result::Result<crate::output::UntagLogGroupOutput, crate::error::UntagLogGroupError>
    {
        if crate::aws_json_errors::is_error(&response) {
            let body = serde_json::from_slice(response.body().as_ref())
                .unwrap_or_else(|_| serde_json::json!({}));
            let generic = crate::aws_json_errors::parse_generic_error(&response, &body);
            let error_code = match generic.code() {
                Some(code) => code,
                None => return Err(crate::error::UntagLogGroupError::unhandled(generic)),
            };
            return Err(match error_code {
                "ResourceNotFoundException" => match serde_json::from_value(body) {
                    Ok(body) => crate::error::UntagLogGroupError {
                        kind: crate::error::UntagLogGroupErrorKind::ResourceNotFoundError(body),
                        meta: generic,
                    },
                    Err(e) => crate::error::UntagLogGroupError::unhandled(e),
                },
                _ => crate::error::UntagLogGroupError::generic(generic),
            });
        }
        #[allow(unused_mut)]
        let mut builder = crate::output::untag_log_group_output::Builder::default();
        Ok(builder.build())
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UntagLogGroup {
    type Output =
        std::result::Result<crate::output::UntagLogGroupOutput, crate::error::UntagLogGroupError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        self.parse_response(response)
    }
}
