// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AssociateKmsKeyError {
    pub kind: AssociateKmsKeyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AssociateKmsKeyErrorKind {
    InvalidParameterError(crate::error::InvalidParameterError),
    OperationAbortedError(crate::error::OperationAbortedError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceUnavailableError(crate::error::ServiceUnavailableError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AssociateKmsKeyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AssociateKmsKeyErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            AssociateKmsKeyErrorKind::OperationAbortedError(_inner) => _inner.fmt(f),
            AssociateKmsKeyErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            AssociateKmsKeyErrorKind::ServiceUnavailableError(_inner) => _inner.fmt(f),
            AssociateKmsKeyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AssociateKmsKeyError {
    fn code(&self) -> Option<&str> {
        AssociateKmsKeyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AssociateKmsKeyError {
    pub fn new(kind: AssociateKmsKeyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AssociateKmsKeyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AssociateKmsKeyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            AssociateKmsKeyErrorKind::InvalidParameterError(_)
        )
    }
    pub fn is_operation_aborted_error(&self) -> bool {
        matches!(
            &self.kind,
            AssociateKmsKeyErrorKind::OperationAbortedError(_)
        )
    }
    pub fn is_resource_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            AssociateKmsKeyErrorKind::ResourceNotFoundError(_)
        )
    }
    pub fn is_service_unavailable_error(&self) -> bool {
        matches!(
            &self.kind,
            AssociateKmsKeyErrorKind::ServiceUnavailableError(_)
        )
    }
}
impl std::error::Error for AssociateKmsKeyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AssociateKmsKeyErrorKind::InvalidParameterError(_inner) => Some(_inner),
            AssociateKmsKeyErrorKind::OperationAbortedError(_inner) => Some(_inner),
            AssociateKmsKeyErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            AssociateKmsKeyErrorKind::ServiceUnavailableError(_inner) => Some(_inner),
            AssociateKmsKeyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CancelExportTaskError {
    pub kind: CancelExportTaskErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CancelExportTaskErrorKind {
    InvalidOperationError(crate::error::InvalidOperationError),
    InvalidParameterError(crate::error::InvalidParameterError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceUnavailableError(crate::error::ServiceUnavailableError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CancelExportTaskError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CancelExportTaskErrorKind::InvalidOperationError(_inner) => _inner.fmt(f),
            CancelExportTaskErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            CancelExportTaskErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            CancelExportTaskErrorKind::ServiceUnavailableError(_inner) => _inner.fmt(f),
            CancelExportTaskErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CancelExportTaskError {
    fn code(&self) -> Option<&str> {
        CancelExportTaskError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CancelExportTaskError {
    pub fn new(kind: CancelExportTaskErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CancelExportTaskErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CancelExportTaskErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_operation_error(&self) -> bool {
        matches!(
            &self.kind,
            CancelExportTaskErrorKind::InvalidOperationError(_)
        )
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            CancelExportTaskErrorKind::InvalidParameterError(_)
        )
    }
    pub fn is_resource_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            CancelExportTaskErrorKind::ResourceNotFoundError(_)
        )
    }
    pub fn is_service_unavailable_error(&self) -> bool {
        matches!(
            &self.kind,
            CancelExportTaskErrorKind::ServiceUnavailableError(_)
        )
    }
}
impl std::error::Error for CancelExportTaskError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CancelExportTaskErrorKind::InvalidOperationError(_inner) => Some(_inner),
            CancelExportTaskErrorKind::InvalidParameterError(_inner) => Some(_inner),
            CancelExportTaskErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            CancelExportTaskErrorKind::ServiceUnavailableError(_inner) => Some(_inner),
            CancelExportTaskErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateExportTaskError {
    pub kind: CreateExportTaskErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateExportTaskErrorKind {
    InvalidParameterError(crate::error::InvalidParameterError),
    LimitExceededError(crate::error::LimitExceededError),
    OperationAbortedError(crate::error::OperationAbortedError),
    ResourceAlreadyExistsError(crate::error::ResourceAlreadyExistsError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceUnavailableError(crate::error::ServiceUnavailableError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateExportTaskError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateExportTaskErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            CreateExportTaskErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            CreateExportTaskErrorKind::OperationAbortedError(_inner) => _inner.fmt(f),
            CreateExportTaskErrorKind::ResourceAlreadyExistsError(_inner) => _inner.fmt(f),
            CreateExportTaskErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            CreateExportTaskErrorKind::ServiceUnavailableError(_inner) => _inner.fmt(f),
            CreateExportTaskErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateExportTaskError {
    fn code(&self) -> Option<&str> {
        CreateExportTaskError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateExportTaskError {
    pub fn new(kind: CreateExportTaskErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateExportTaskErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateExportTaskErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateExportTaskErrorKind::InvalidParameterError(_)
        )
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(&self.kind, CreateExportTaskErrorKind::LimitExceededError(_))
    }
    pub fn is_operation_aborted_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateExportTaskErrorKind::OperationAbortedError(_)
        )
    }
    pub fn is_resource_already_exists_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateExportTaskErrorKind::ResourceAlreadyExistsError(_)
        )
    }
    pub fn is_resource_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateExportTaskErrorKind::ResourceNotFoundError(_)
        )
    }
    pub fn is_service_unavailable_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateExportTaskErrorKind::ServiceUnavailableError(_)
        )
    }
}
impl std::error::Error for CreateExportTaskError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateExportTaskErrorKind::InvalidParameterError(_inner) => Some(_inner),
            CreateExportTaskErrorKind::LimitExceededError(_inner) => Some(_inner),
            CreateExportTaskErrorKind::OperationAbortedError(_inner) => Some(_inner),
            CreateExportTaskErrorKind::ResourceAlreadyExistsError(_inner) => Some(_inner),
            CreateExportTaskErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            CreateExportTaskErrorKind::ServiceUnavailableError(_inner) => Some(_inner),
            CreateExportTaskErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateLogGroupError {
    pub kind: CreateLogGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateLogGroupErrorKind {
    InvalidParameterError(crate::error::InvalidParameterError),
    LimitExceededError(crate::error::LimitExceededError),
    OperationAbortedError(crate::error::OperationAbortedError),
    ResourceAlreadyExistsError(crate::error::ResourceAlreadyExistsError),
    ServiceUnavailableError(crate::error::ServiceUnavailableError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateLogGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateLogGroupErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            CreateLogGroupErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            CreateLogGroupErrorKind::OperationAbortedError(_inner) => _inner.fmt(f),
            CreateLogGroupErrorKind::ResourceAlreadyExistsError(_inner) => _inner.fmt(f),
            CreateLogGroupErrorKind::ServiceUnavailableError(_inner) => _inner.fmt(f),
            CreateLogGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateLogGroupError {
    fn code(&self) -> Option<&str> {
        CreateLogGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateLogGroupError {
    pub fn new(kind: CreateLogGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateLogGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateLogGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateLogGroupErrorKind::InvalidParameterError(_)
        )
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(&self.kind, CreateLogGroupErrorKind::LimitExceededError(_))
    }
    pub fn is_operation_aborted_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateLogGroupErrorKind::OperationAbortedError(_)
        )
    }
    pub fn is_resource_already_exists_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateLogGroupErrorKind::ResourceAlreadyExistsError(_)
        )
    }
    pub fn is_service_unavailable_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateLogGroupErrorKind::ServiceUnavailableError(_)
        )
    }
}
impl std::error::Error for CreateLogGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateLogGroupErrorKind::InvalidParameterError(_inner) => Some(_inner),
            CreateLogGroupErrorKind::LimitExceededError(_inner) => Some(_inner),
            CreateLogGroupErrorKind::OperationAbortedError(_inner) => Some(_inner),
            CreateLogGroupErrorKind::ResourceAlreadyExistsError(_inner) => Some(_inner),
            CreateLogGroupErrorKind::ServiceUnavailableError(_inner) => Some(_inner),
            CreateLogGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateLogStreamError {
    pub kind: CreateLogStreamErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateLogStreamErrorKind {
    InvalidParameterError(crate::error::InvalidParameterError),
    ResourceAlreadyExistsError(crate::error::ResourceAlreadyExistsError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceUnavailableError(crate::error::ServiceUnavailableError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateLogStreamError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateLogStreamErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            CreateLogStreamErrorKind::ResourceAlreadyExistsError(_inner) => _inner.fmt(f),
            CreateLogStreamErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            CreateLogStreamErrorKind::ServiceUnavailableError(_inner) => _inner.fmt(f),
            CreateLogStreamErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateLogStreamError {
    fn code(&self) -> Option<&str> {
        CreateLogStreamError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateLogStreamError {
    pub fn new(kind: CreateLogStreamErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateLogStreamErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateLogStreamErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateLogStreamErrorKind::InvalidParameterError(_)
        )
    }
    pub fn is_resource_already_exists_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateLogStreamErrorKind::ResourceAlreadyExistsError(_)
        )
    }
    pub fn is_resource_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateLogStreamErrorKind::ResourceNotFoundError(_)
        )
    }
    pub fn is_service_unavailable_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateLogStreamErrorKind::ServiceUnavailableError(_)
        )
    }
}
impl std::error::Error for CreateLogStreamError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateLogStreamErrorKind::InvalidParameterError(_inner) => Some(_inner),
            CreateLogStreamErrorKind::ResourceAlreadyExistsError(_inner) => Some(_inner),
            CreateLogStreamErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            CreateLogStreamErrorKind::ServiceUnavailableError(_inner) => Some(_inner),
            CreateLogStreamErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteDestinationError {
    pub kind: DeleteDestinationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDestinationErrorKind {
    InvalidParameterError(crate::error::InvalidParameterError),
    OperationAbortedError(crate::error::OperationAbortedError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceUnavailableError(crate::error::ServiceUnavailableError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteDestinationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteDestinationErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            DeleteDestinationErrorKind::OperationAbortedError(_inner) => _inner.fmt(f),
            DeleteDestinationErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            DeleteDestinationErrorKind::ServiceUnavailableError(_inner) => _inner.fmt(f),
            DeleteDestinationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteDestinationError {
    fn code(&self) -> Option<&str> {
        DeleteDestinationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteDestinationError {
    pub fn new(kind: DeleteDestinationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteDestinationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteDestinationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDestinationErrorKind::InvalidParameterError(_)
        )
    }
    pub fn is_operation_aborted_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDestinationErrorKind::OperationAbortedError(_)
        )
    }
    pub fn is_resource_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDestinationErrorKind::ResourceNotFoundError(_)
        )
    }
    pub fn is_service_unavailable_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDestinationErrorKind::ServiceUnavailableError(_)
        )
    }
}
impl std::error::Error for DeleteDestinationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteDestinationErrorKind::InvalidParameterError(_inner) => Some(_inner),
            DeleteDestinationErrorKind::OperationAbortedError(_inner) => Some(_inner),
            DeleteDestinationErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            DeleteDestinationErrorKind::ServiceUnavailableError(_inner) => Some(_inner),
            DeleteDestinationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteLogGroupError {
    pub kind: DeleteLogGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteLogGroupErrorKind {
    InvalidParameterError(crate::error::InvalidParameterError),
    OperationAbortedError(crate::error::OperationAbortedError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceUnavailableError(crate::error::ServiceUnavailableError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteLogGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteLogGroupErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            DeleteLogGroupErrorKind::OperationAbortedError(_inner) => _inner.fmt(f),
            DeleteLogGroupErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            DeleteLogGroupErrorKind::ServiceUnavailableError(_inner) => _inner.fmt(f),
            DeleteLogGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteLogGroupError {
    fn code(&self) -> Option<&str> {
        DeleteLogGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteLogGroupError {
    pub fn new(kind: DeleteLogGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteLogGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteLogGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteLogGroupErrorKind::InvalidParameterError(_)
        )
    }
    pub fn is_operation_aborted_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteLogGroupErrorKind::OperationAbortedError(_)
        )
    }
    pub fn is_resource_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteLogGroupErrorKind::ResourceNotFoundError(_)
        )
    }
    pub fn is_service_unavailable_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteLogGroupErrorKind::ServiceUnavailableError(_)
        )
    }
}
impl std::error::Error for DeleteLogGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteLogGroupErrorKind::InvalidParameterError(_inner) => Some(_inner),
            DeleteLogGroupErrorKind::OperationAbortedError(_inner) => Some(_inner),
            DeleteLogGroupErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            DeleteLogGroupErrorKind::ServiceUnavailableError(_inner) => Some(_inner),
            DeleteLogGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteLogStreamError {
    pub kind: DeleteLogStreamErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteLogStreamErrorKind {
    InvalidParameterError(crate::error::InvalidParameterError),
    OperationAbortedError(crate::error::OperationAbortedError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceUnavailableError(crate::error::ServiceUnavailableError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteLogStreamError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteLogStreamErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            DeleteLogStreamErrorKind::OperationAbortedError(_inner) => _inner.fmt(f),
            DeleteLogStreamErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            DeleteLogStreamErrorKind::ServiceUnavailableError(_inner) => _inner.fmt(f),
            DeleteLogStreamErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteLogStreamError {
    fn code(&self) -> Option<&str> {
        DeleteLogStreamError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteLogStreamError {
    pub fn new(kind: DeleteLogStreamErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteLogStreamErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteLogStreamErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteLogStreamErrorKind::InvalidParameterError(_)
        )
    }
    pub fn is_operation_aborted_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteLogStreamErrorKind::OperationAbortedError(_)
        )
    }
    pub fn is_resource_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteLogStreamErrorKind::ResourceNotFoundError(_)
        )
    }
    pub fn is_service_unavailable_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteLogStreamErrorKind::ServiceUnavailableError(_)
        )
    }
}
impl std::error::Error for DeleteLogStreamError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteLogStreamErrorKind::InvalidParameterError(_inner) => Some(_inner),
            DeleteLogStreamErrorKind::OperationAbortedError(_inner) => Some(_inner),
            DeleteLogStreamErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            DeleteLogStreamErrorKind::ServiceUnavailableError(_inner) => Some(_inner),
            DeleteLogStreamErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteMetricFilterError {
    pub kind: DeleteMetricFilterErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteMetricFilterErrorKind {
    InvalidParameterError(crate::error::InvalidParameterError),
    OperationAbortedError(crate::error::OperationAbortedError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceUnavailableError(crate::error::ServiceUnavailableError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteMetricFilterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteMetricFilterErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            DeleteMetricFilterErrorKind::OperationAbortedError(_inner) => _inner.fmt(f),
            DeleteMetricFilterErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            DeleteMetricFilterErrorKind::ServiceUnavailableError(_inner) => _inner.fmt(f),
            DeleteMetricFilterErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteMetricFilterError {
    fn code(&self) -> Option<&str> {
        DeleteMetricFilterError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteMetricFilterError {
    pub fn new(kind: DeleteMetricFilterErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteMetricFilterErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteMetricFilterErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMetricFilterErrorKind::InvalidParameterError(_)
        )
    }
    pub fn is_operation_aborted_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMetricFilterErrorKind::OperationAbortedError(_)
        )
    }
    pub fn is_resource_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMetricFilterErrorKind::ResourceNotFoundError(_)
        )
    }
    pub fn is_service_unavailable_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMetricFilterErrorKind::ServiceUnavailableError(_)
        )
    }
}
impl std::error::Error for DeleteMetricFilterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteMetricFilterErrorKind::InvalidParameterError(_inner) => Some(_inner),
            DeleteMetricFilterErrorKind::OperationAbortedError(_inner) => Some(_inner),
            DeleteMetricFilterErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            DeleteMetricFilterErrorKind::ServiceUnavailableError(_inner) => Some(_inner),
            DeleteMetricFilterErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteQueryDefinitionError {
    pub kind: DeleteQueryDefinitionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteQueryDefinitionErrorKind {
    InvalidParameterError(crate::error::InvalidParameterError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceUnavailableError(crate::error::ServiceUnavailableError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteQueryDefinitionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteQueryDefinitionErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            DeleteQueryDefinitionErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            DeleteQueryDefinitionErrorKind::ServiceUnavailableError(_inner) => _inner.fmt(f),
            DeleteQueryDefinitionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteQueryDefinitionError {
    fn code(&self) -> Option<&str> {
        DeleteQueryDefinitionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteQueryDefinitionError {
    pub fn new(kind: DeleteQueryDefinitionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteQueryDefinitionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteQueryDefinitionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteQueryDefinitionErrorKind::InvalidParameterError(_)
        )
    }
    pub fn is_resource_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteQueryDefinitionErrorKind::ResourceNotFoundError(_)
        )
    }
    pub fn is_service_unavailable_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteQueryDefinitionErrorKind::ServiceUnavailableError(_)
        )
    }
}
impl std::error::Error for DeleteQueryDefinitionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteQueryDefinitionErrorKind::InvalidParameterError(_inner) => Some(_inner),
            DeleteQueryDefinitionErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            DeleteQueryDefinitionErrorKind::ServiceUnavailableError(_inner) => Some(_inner),
            DeleteQueryDefinitionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteResourcePolicyError {
    pub kind: DeleteResourcePolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteResourcePolicyErrorKind {
    InvalidParameterError(crate::error::InvalidParameterError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceUnavailableError(crate::error::ServiceUnavailableError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteResourcePolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteResourcePolicyErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            DeleteResourcePolicyErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            DeleteResourcePolicyErrorKind::ServiceUnavailableError(_inner) => _inner.fmt(f),
            DeleteResourcePolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteResourcePolicyError {
    fn code(&self) -> Option<&str> {
        DeleteResourcePolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteResourcePolicyError {
    pub fn new(kind: DeleteResourcePolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteResourcePolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteResourcePolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteResourcePolicyErrorKind::InvalidParameterError(_)
        )
    }
    pub fn is_resource_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteResourcePolicyErrorKind::ResourceNotFoundError(_)
        )
    }
    pub fn is_service_unavailable_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteResourcePolicyErrorKind::ServiceUnavailableError(_)
        )
    }
}
impl std::error::Error for DeleteResourcePolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteResourcePolicyErrorKind::InvalidParameterError(_inner) => Some(_inner),
            DeleteResourcePolicyErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            DeleteResourcePolicyErrorKind::ServiceUnavailableError(_inner) => Some(_inner),
            DeleteResourcePolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteRetentionPolicyError {
    pub kind: DeleteRetentionPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteRetentionPolicyErrorKind {
    InvalidParameterError(crate::error::InvalidParameterError),
    OperationAbortedError(crate::error::OperationAbortedError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceUnavailableError(crate::error::ServiceUnavailableError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteRetentionPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteRetentionPolicyErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            DeleteRetentionPolicyErrorKind::OperationAbortedError(_inner) => _inner.fmt(f),
            DeleteRetentionPolicyErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            DeleteRetentionPolicyErrorKind::ServiceUnavailableError(_inner) => _inner.fmt(f),
            DeleteRetentionPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteRetentionPolicyError {
    fn code(&self) -> Option<&str> {
        DeleteRetentionPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteRetentionPolicyError {
    pub fn new(kind: DeleteRetentionPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteRetentionPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteRetentionPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRetentionPolicyErrorKind::InvalidParameterError(_)
        )
    }
    pub fn is_operation_aborted_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRetentionPolicyErrorKind::OperationAbortedError(_)
        )
    }
    pub fn is_resource_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRetentionPolicyErrorKind::ResourceNotFoundError(_)
        )
    }
    pub fn is_service_unavailable_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRetentionPolicyErrorKind::ServiceUnavailableError(_)
        )
    }
}
impl std::error::Error for DeleteRetentionPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteRetentionPolicyErrorKind::InvalidParameterError(_inner) => Some(_inner),
            DeleteRetentionPolicyErrorKind::OperationAbortedError(_inner) => Some(_inner),
            DeleteRetentionPolicyErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            DeleteRetentionPolicyErrorKind::ServiceUnavailableError(_inner) => Some(_inner),
            DeleteRetentionPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteSubscriptionFilterError {
    pub kind: DeleteSubscriptionFilterErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteSubscriptionFilterErrorKind {
    InvalidParameterError(crate::error::InvalidParameterError),
    OperationAbortedError(crate::error::OperationAbortedError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceUnavailableError(crate::error::ServiceUnavailableError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteSubscriptionFilterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteSubscriptionFilterErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            DeleteSubscriptionFilterErrorKind::OperationAbortedError(_inner) => _inner.fmt(f),
            DeleteSubscriptionFilterErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            DeleteSubscriptionFilterErrorKind::ServiceUnavailableError(_inner) => _inner.fmt(f),
            DeleteSubscriptionFilterErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteSubscriptionFilterError {
    fn code(&self) -> Option<&str> {
        DeleteSubscriptionFilterError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteSubscriptionFilterError {
    pub fn new(kind: DeleteSubscriptionFilterErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteSubscriptionFilterErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteSubscriptionFilterErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSubscriptionFilterErrorKind::InvalidParameterError(_)
        )
    }
    pub fn is_operation_aborted_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSubscriptionFilterErrorKind::OperationAbortedError(_)
        )
    }
    pub fn is_resource_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSubscriptionFilterErrorKind::ResourceNotFoundError(_)
        )
    }
    pub fn is_service_unavailable_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSubscriptionFilterErrorKind::ServiceUnavailableError(_)
        )
    }
}
impl std::error::Error for DeleteSubscriptionFilterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteSubscriptionFilterErrorKind::InvalidParameterError(_inner) => Some(_inner),
            DeleteSubscriptionFilterErrorKind::OperationAbortedError(_inner) => Some(_inner),
            DeleteSubscriptionFilterErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            DeleteSubscriptionFilterErrorKind::ServiceUnavailableError(_inner) => Some(_inner),
            DeleteSubscriptionFilterErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeDestinationsError {
    pub kind: DescribeDestinationsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDestinationsErrorKind {
    InvalidParameterError(crate::error::InvalidParameterError),
    ServiceUnavailableError(crate::error::ServiceUnavailableError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeDestinationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeDestinationsErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            DescribeDestinationsErrorKind::ServiceUnavailableError(_inner) => _inner.fmt(f),
            DescribeDestinationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeDestinationsError {
    fn code(&self) -> Option<&str> {
        DescribeDestinationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDestinationsError {
    pub fn new(kind: DescribeDestinationsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeDestinationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeDestinationsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDestinationsErrorKind::InvalidParameterError(_)
        )
    }
    pub fn is_service_unavailable_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDestinationsErrorKind::ServiceUnavailableError(_)
        )
    }
}
impl std::error::Error for DescribeDestinationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeDestinationsErrorKind::InvalidParameterError(_inner) => Some(_inner),
            DescribeDestinationsErrorKind::ServiceUnavailableError(_inner) => Some(_inner),
            DescribeDestinationsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeExportTasksError {
    pub kind: DescribeExportTasksErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeExportTasksErrorKind {
    InvalidParameterError(crate::error::InvalidParameterError),
    ServiceUnavailableError(crate::error::ServiceUnavailableError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeExportTasksError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeExportTasksErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            DescribeExportTasksErrorKind::ServiceUnavailableError(_inner) => _inner.fmt(f),
            DescribeExportTasksErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeExportTasksError {
    fn code(&self) -> Option<&str> {
        DescribeExportTasksError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeExportTasksError {
    pub fn new(kind: DescribeExportTasksErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeExportTasksErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeExportTasksErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeExportTasksErrorKind::InvalidParameterError(_)
        )
    }
    pub fn is_service_unavailable_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeExportTasksErrorKind::ServiceUnavailableError(_)
        )
    }
}
impl std::error::Error for DescribeExportTasksError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeExportTasksErrorKind::InvalidParameterError(_inner) => Some(_inner),
            DescribeExportTasksErrorKind::ServiceUnavailableError(_inner) => Some(_inner),
            DescribeExportTasksErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeLogGroupsError {
    pub kind: DescribeLogGroupsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeLogGroupsErrorKind {
    InvalidParameterError(crate::error::InvalidParameterError),
    ServiceUnavailableError(crate::error::ServiceUnavailableError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeLogGroupsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeLogGroupsErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            DescribeLogGroupsErrorKind::ServiceUnavailableError(_inner) => _inner.fmt(f),
            DescribeLogGroupsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeLogGroupsError {
    fn code(&self) -> Option<&str> {
        DescribeLogGroupsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeLogGroupsError {
    pub fn new(kind: DescribeLogGroupsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeLogGroupsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeLogGroupsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeLogGroupsErrorKind::InvalidParameterError(_)
        )
    }
    pub fn is_service_unavailable_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeLogGroupsErrorKind::ServiceUnavailableError(_)
        )
    }
}
impl std::error::Error for DescribeLogGroupsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeLogGroupsErrorKind::InvalidParameterError(_inner) => Some(_inner),
            DescribeLogGroupsErrorKind::ServiceUnavailableError(_inner) => Some(_inner),
            DescribeLogGroupsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeLogStreamsError {
    pub kind: DescribeLogStreamsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeLogStreamsErrorKind {
    InvalidParameterError(crate::error::InvalidParameterError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceUnavailableError(crate::error::ServiceUnavailableError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeLogStreamsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeLogStreamsErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            DescribeLogStreamsErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            DescribeLogStreamsErrorKind::ServiceUnavailableError(_inner) => _inner.fmt(f),
            DescribeLogStreamsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeLogStreamsError {
    fn code(&self) -> Option<&str> {
        DescribeLogStreamsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeLogStreamsError {
    pub fn new(kind: DescribeLogStreamsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeLogStreamsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeLogStreamsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeLogStreamsErrorKind::InvalidParameterError(_)
        )
    }
    pub fn is_resource_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeLogStreamsErrorKind::ResourceNotFoundError(_)
        )
    }
    pub fn is_service_unavailable_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeLogStreamsErrorKind::ServiceUnavailableError(_)
        )
    }
}
impl std::error::Error for DescribeLogStreamsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeLogStreamsErrorKind::InvalidParameterError(_inner) => Some(_inner),
            DescribeLogStreamsErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            DescribeLogStreamsErrorKind::ServiceUnavailableError(_inner) => Some(_inner),
            DescribeLogStreamsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeMetricFiltersError {
    pub kind: DescribeMetricFiltersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeMetricFiltersErrorKind {
    InvalidParameterError(crate::error::InvalidParameterError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceUnavailableError(crate::error::ServiceUnavailableError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeMetricFiltersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeMetricFiltersErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            DescribeMetricFiltersErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            DescribeMetricFiltersErrorKind::ServiceUnavailableError(_inner) => _inner.fmt(f),
            DescribeMetricFiltersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeMetricFiltersError {
    fn code(&self) -> Option<&str> {
        DescribeMetricFiltersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeMetricFiltersError {
    pub fn new(kind: DescribeMetricFiltersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeMetricFiltersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeMetricFiltersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMetricFiltersErrorKind::InvalidParameterError(_)
        )
    }
    pub fn is_resource_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMetricFiltersErrorKind::ResourceNotFoundError(_)
        )
    }
    pub fn is_service_unavailable_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMetricFiltersErrorKind::ServiceUnavailableError(_)
        )
    }
}
impl std::error::Error for DescribeMetricFiltersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeMetricFiltersErrorKind::InvalidParameterError(_inner) => Some(_inner),
            DescribeMetricFiltersErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            DescribeMetricFiltersErrorKind::ServiceUnavailableError(_inner) => Some(_inner),
            DescribeMetricFiltersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeQueriesError {
    pub kind: DescribeQueriesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeQueriesErrorKind {
    InvalidParameterError(crate::error::InvalidParameterError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceUnavailableError(crate::error::ServiceUnavailableError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeQueriesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeQueriesErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            DescribeQueriesErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            DescribeQueriesErrorKind::ServiceUnavailableError(_inner) => _inner.fmt(f),
            DescribeQueriesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeQueriesError {
    fn code(&self) -> Option<&str> {
        DescribeQueriesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeQueriesError {
    pub fn new(kind: DescribeQueriesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeQueriesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeQueriesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeQueriesErrorKind::InvalidParameterError(_)
        )
    }
    pub fn is_resource_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeQueriesErrorKind::ResourceNotFoundError(_)
        )
    }
    pub fn is_service_unavailable_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeQueriesErrorKind::ServiceUnavailableError(_)
        )
    }
}
impl std::error::Error for DescribeQueriesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeQueriesErrorKind::InvalidParameterError(_inner) => Some(_inner),
            DescribeQueriesErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            DescribeQueriesErrorKind::ServiceUnavailableError(_inner) => Some(_inner),
            DescribeQueriesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeQueryDefinitionsError {
    pub kind: DescribeQueryDefinitionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeQueryDefinitionsErrorKind {
    InvalidParameterError(crate::error::InvalidParameterError),
    ServiceUnavailableError(crate::error::ServiceUnavailableError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeQueryDefinitionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeQueryDefinitionsErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            DescribeQueryDefinitionsErrorKind::ServiceUnavailableError(_inner) => _inner.fmt(f),
            DescribeQueryDefinitionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeQueryDefinitionsError {
    fn code(&self) -> Option<&str> {
        DescribeQueryDefinitionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeQueryDefinitionsError {
    pub fn new(kind: DescribeQueryDefinitionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeQueryDefinitionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeQueryDefinitionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeQueryDefinitionsErrorKind::InvalidParameterError(_)
        )
    }
    pub fn is_service_unavailable_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeQueryDefinitionsErrorKind::ServiceUnavailableError(_)
        )
    }
}
impl std::error::Error for DescribeQueryDefinitionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeQueryDefinitionsErrorKind::InvalidParameterError(_inner) => Some(_inner),
            DescribeQueryDefinitionsErrorKind::ServiceUnavailableError(_inner) => Some(_inner),
            DescribeQueryDefinitionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeResourcePoliciesError {
    pub kind: DescribeResourcePoliciesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeResourcePoliciesErrorKind {
    InvalidParameterError(crate::error::InvalidParameterError),
    ServiceUnavailableError(crate::error::ServiceUnavailableError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeResourcePoliciesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeResourcePoliciesErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            DescribeResourcePoliciesErrorKind::ServiceUnavailableError(_inner) => _inner.fmt(f),
            DescribeResourcePoliciesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeResourcePoliciesError {
    fn code(&self) -> Option<&str> {
        DescribeResourcePoliciesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeResourcePoliciesError {
    pub fn new(kind: DescribeResourcePoliciesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeResourcePoliciesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeResourcePoliciesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeResourcePoliciesErrorKind::InvalidParameterError(_)
        )
    }
    pub fn is_service_unavailable_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeResourcePoliciesErrorKind::ServiceUnavailableError(_)
        )
    }
}
impl std::error::Error for DescribeResourcePoliciesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeResourcePoliciesErrorKind::InvalidParameterError(_inner) => Some(_inner),
            DescribeResourcePoliciesErrorKind::ServiceUnavailableError(_inner) => Some(_inner),
            DescribeResourcePoliciesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeSubscriptionFiltersError {
    pub kind: DescribeSubscriptionFiltersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeSubscriptionFiltersErrorKind {
    InvalidParameterError(crate::error::InvalidParameterError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceUnavailableError(crate::error::ServiceUnavailableError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeSubscriptionFiltersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeSubscriptionFiltersErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            DescribeSubscriptionFiltersErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            DescribeSubscriptionFiltersErrorKind::ServiceUnavailableError(_inner) => _inner.fmt(f),
            DescribeSubscriptionFiltersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeSubscriptionFiltersError {
    fn code(&self) -> Option<&str> {
        DescribeSubscriptionFiltersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeSubscriptionFiltersError {
    pub fn new(kind: DescribeSubscriptionFiltersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeSubscriptionFiltersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeSubscriptionFiltersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeSubscriptionFiltersErrorKind::InvalidParameterError(_)
        )
    }
    pub fn is_resource_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeSubscriptionFiltersErrorKind::ResourceNotFoundError(_)
        )
    }
    pub fn is_service_unavailable_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeSubscriptionFiltersErrorKind::ServiceUnavailableError(_)
        )
    }
}
impl std::error::Error for DescribeSubscriptionFiltersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeSubscriptionFiltersErrorKind::InvalidParameterError(_inner) => Some(_inner),
            DescribeSubscriptionFiltersErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            DescribeSubscriptionFiltersErrorKind::ServiceUnavailableError(_inner) => Some(_inner),
            DescribeSubscriptionFiltersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DisassociateKmsKeyError {
    pub kind: DisassociateKmsKeyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DisassociateKmsKeyErrorKind {
    InvalidParameterError(crate::error::InvalidParameterError),
    OperationAbortedError(crate::error::OperationAbortedError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceUnavailableError(crate::error::ServiceUnavailableError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DisassociateKmsKeyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DisassociateKmsKeyErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            DisassociateKmsKeyErrorKind::OperationAbortedError(_inner) => _inner.fmt(f),
            DisassociateKmsKeyErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            DisassociateKmsKeyErrorKind::ServiceUnavailableError(_inner) => _inner.fmt(f),
            DisassociateKmsKeyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DisassociateKmsKeyError {
    fn code(&self) -> Option<&str> {
        DisassociateKmsKeyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DisassociateKmsKeyError {
    pub fn new(kind: DisassociateKmsKeyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DisassociateKmsKeyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DisassociateKmsKeyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateKmsKeyErrorKind::InvalidParameterError(_)
        )
    }
    pub fn is_operation_aborted_error(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateKmsKeyErrorKind::OperationAbortedError(_)
        )
    }
    pub fn is_resource_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateKmsKeyErrorKind::ResourceNotFoundError(_)
        )
    }
    pub fn is_service_unavailable_error(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateKmsKeyErrorKind::ServiceUnavailableError(_)
        )
    }
}
impl std::error::Error for DisassociateKmsKeyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DisassociateKmsKeyErrorKind::InvalidParameterError(_inner) => Some(_inner),
            DisassociateKmsKeyErrorKind::OperationAbortedError(_inner) => Some(_inner),
            DisassociateKmsKeyErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            DisassociateKmsKeyErrorKind::ServiceUnavailableError(_inner) => Some(_inner),
            DisassociateKmsKeyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct FilterLogEventsError {
    pub kind: FilterLogEventsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum FilterLogEventsErrorKind {
    InvalidParameterError(crate::error::InvalidParameterError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceUnavailableError(crate::error::ServiceUnavailableError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for FilterLogEventsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            FilterLogEventsErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            FilterLogEventsErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            FilterLogEventsErrorKind::ServiceUnavailableError(_inner) => _inner.fmt(f),
            FilterLogEventsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for FilterLogEventsError {
    fn code(&self) -> Option<&str> {
        FilterLogEventsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl FilterLogEventsError {
    pub fn new(kind: FilterLogEventsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: FilterLogEventsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: FilterLogEventsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            FilterLogEventsErrorKind::InvalidParameterError(_)
        )
    }
    pub fn is_resource_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            FilterLogEventsErrorKind::ResourceNotFoundError(_)
        )
    }
    pub fn is_service_unavailable_error(&self) -> bool {
        matches!(
            &self.kind,
            FilterLogEventsErrorKind::ServiceUnavailableError(_)
        )
    }
}
impl std::error::Error for FilterLogEventsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            FilterLogEventsErrorKind::InvalidParameterError(_inner) => Some(_inner),
            FilterLogEventsErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            FilterLogEventsErrorKind::ServiceUnavailableError(_inner) => Some(_inner),
            FilterLogEventsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetLogEventsError {
    pub kind: GetLogEventsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetLogEventsErrorKind {
    InvalidParameterError(crate::error::InvalidParameterError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceUnavailableError(crate::error::ServiceUnavailableError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetLogEventsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetLogEventsErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            GetLogEventsErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            GetLogEventsErrorKind::ServiceUnavailableError(_inner) => _inner.fmt(f),
            GetLogEventsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetLogEventsError {
    fn code(&self) -> Option<&str> {
        GetLogEventsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetLogEventsError {
    pub fn new(kind: GetLogEventsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetLogEventsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetLogEventsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(&self.kind, GetLogEventsErrorKind::InvalidParameterError(_))
    }
    pub fn is_resource_not_found_error(&self) -> bool {
        matches!(&self.kind, GetLogEventsErrorKind::ResourceNotFoundError(_))
    }
    pub fn is_service_unavailable_error(&self) -> bool {
        matches!(
            &self.kind,
            GetLogEventsErrorKind::ServiceUnavailableError(_)
        )
    }
}
impl std::error::Error for GetLogEventsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetLogEventsErrorKind::InvalidParameterError(_inner) => Some(_inner),
            GetLogEventsErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            GetLogEventsErrorKind::ServiceUnavailableError(_inner) => Some(_inner),
            GetLogEventsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetLogGroupFieldsError {
    pub kind: GetLogGroupFieldsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetLogGroupFieldsErrorKind {
    InvalidParameterError(crate::error::InvalidParameterError),
    LimitExceededError(crate::error::LimitExceededError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceUnavailableError(crate::error::ServiceUnavailableError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetLogGroupFieldsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetLogGroupFieldsErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            GetLogGroupFieldsErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            GetLogGroupFieldsErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            GetLogGroupFieldsErrorKind::ServiceUnavailableError(_inner) => _inner.fmt(f),
            GetLogGroupFieldsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetLogGroupFieldsError {
    fn code(&self) -> Option<&str> {
        GetLogGroupFieldsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetLogGroupFieldsError {
    pub fn new(kind: GetLogGroupFieldsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetLogGroupFieldsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetLogGroupFieldsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            GetLogGroupFieldsErrorKind::InvalidParameterError(_)
        )
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            GetLogGroupFieldsErrorKind::LimitExceededError(_)
        )
    }
    pub fn is_resource_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            GetLogGroupFieldsErrorKind::ResourceNotFoundError(_)
        )
    }
    pub fn is_service_unavailable_error(&self) -> bool {
        matches!(
            &self.kind,
            GetLogGroupFieldsErrorKind::ServiceUnavailableError(_)
        )
    }
}
impl std::error::Error for GetLogGroupFieldsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetLogGroupFieldsErrorKind::InvalidParameterError(_inner) => Some(_inner),
            GetLogGroupFieldsErrorKind::LimitExceededError(_inner) => Some(_inner),
            GetLogGroupFieldsErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            GetLogGroupFieldsErrorKind::ServiceUnavailableError(_inner) => Some(_inner),
            GetLogGroupFieldsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetLogRecordError {
    pub kind: GetLogRecordErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetLogRecordErrorKind {
    InvalidParameterError(crate::error::InvalidParameterError),
    LimitExceededError(crate::error::LimitExceededError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceUnavailableError(crate::error::ServiceUnavailableError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetLogRecordError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetLogRecordErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            GetLogRecordErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            GetLogRecordErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            GetLogRecordErrorKind::ServiceUnavailableError(_inner) => _inner.fmt(f),
            GetLogRecordErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetLogRecordError {
    fn code(&self) -> Option<&str> {
        GetLogRecordError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetLogRecordError {
    pub fn new(kind: GetLogRecordErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetLogRecordErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetLogRecordErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(&self.kind, GetLogRecordErrorKind::InvalidParameterError(_))
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(&self.kind, GetLogRecordErrorKind::LimitExceededError(_))
    }
    pub fn is_resource_not_found_error(&self) -> bool {
        matches!(&self.kind, GetLogRecordErrorKind::ResourceNotFoundError(_))
    }
    pub fn is_service_unavailable_error(&self) -> bool {
        matches!(
            &self.kind,
            GetLogRecordErrorKind::ServiceUnavailableError(_)
        )
    }
}
impl std::error::Error for GetLogRecordError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetLogRecordErrorKind::InvalidParameterError(_inner) => Some(_inner),
            GetLogRecordErrorKind::LimitExceededError(_inner) => Some(_inner),
            GetLogRecordErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            GetLogRecordErrorKind::ServiceUnavailableError(_inner) => Some(_inner),
            GetLogRecordErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetQueryResultsError {
    pub kind: GetQueryResultsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetQueryResultsErrorKind {
    InvalidParameterError(crate::error::InvalidParameterError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceUnavailableError(crate::error::ServiceUnavailableError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetQueryResultsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetQueryResultsErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            GetQueryResultsErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            GetQueryResultsErrorKind::ServiceUnavailableError(_inner) => _inner.fmt(f),
            GetQueryResultsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetQueryResultsError {
    fn code(&self) -> Option<&str> {
        GetQueryResultsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetQueryResultsError {
    pub fn new(kind: GetQueryResultsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetQueryResultsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetQueryResultsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            GetQueryResultsErrorKind::InvalidParameterError(_)
        )
    }
    pub fn is_resource_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            GetQueryResultsErrorKind::ResourceNotFoundError(_)
        )
    }
    pub fn is_service_unavailable_error(&self) -> bool {
        matches!(
            &self.kind,
            GetQueryResultsErrorKind::ServiceUnavailableError(_)
        )
    }
}
impl std::error::Error for GetQueryResultsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetQueryResultsErrorKind::InvalidParameterError(_inner) => Some(_inner),
            GetQueryResultsErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            GetQueryResultsErrorKind::ServiceUnavailableError(_inner) => Some(_inner),
            GetQueryResultsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTagsLogGroupError {
    pub kind: ListTagsLogGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTagsLogGroupErrorKind {
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceUnavailableError(crate::error::ServiceUnavailableError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTagsLogGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTagsLogGroupErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            ListTagsLogGroupErrorKind::ServiceUnavailableError(_inner) => _inner.fmt(f),
            ListTagsLogGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTagsLogGroupError {
    fn code(&self) -> Option<&str> {
        ListTagsLogGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTagsLogGroupError {
    pub fn new(kind: ListTagsLogGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTagsLogGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTagsLogGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_resource_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsLogGroupErrorKind::ResourceNotFoundError(_)
        )
    }
    pub fn is_service_unavailable_error(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsLogGroupErrorKind::ServiceUnavailableError(_)
        )
    }
}
impl std::error::Error for ListTagsLogGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTagsLogGroupErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            ListTagsLogGroupErrorKind::ServiceUnavailableError(_inner) => Some(_inner),
            ListTagsLogGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutDestinationError {
    pub kind: PutDestinationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutDestinationErrorKind {
    InvalidParameterError(crate::error::InvalidParameterError),
    OperationAbortedError(crate::error::OperationAbortedError),
    ServiceUnavailableError(crate::error::ServiceUnavailableError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutDestinationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutDestinationErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            PutDestinationErrorKind::OperationAbortedError(_inner) => _inner.fmt(f),
            PutDestinationErrorKind::ServiceUnavailableError(_inner) => _inner.fmt(f),
            PutDestinationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutDestinationError {
    fn code(&self) -> Option<&str> {
        PutDestinationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutDestinationError {
    pub fn new(kind: PutDestinationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutDestinationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutDestinationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            PutDestinationErrorKind::InvalidParameterError(_)
        )
    }
    pub fn is_operation_aborted_error(&self) -> bool {
        matches!(
            &self.kind,
            PutDestinationErrorKind::OperationAbortedError(_)
        )
    }
    pub fn is_service_unavailable_error(&self) -> bool {
        matches!(
            &self.kind,
            PutDestinationErrorKind::ServiceUnavailableError(_)
        )
    }
}
impl std::error::Error for PutDestinationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutDestinationErrorKind::InvalidParameterError(_inner) => Some(_inner),
            PutDestinationErrorKind::OperationAbortedError(_inner) => Some(_inner),
            PutDestinationErrorKind::ServiceUnavailableError(_inner) => Some(_inner),
            PutDestinationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutDestinationPolicyError {
    pub kind: PutDestinationPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutDestinationPolicyErrorKind {
    InvalidParameterError(crate::error::InvalidParameterError),
    OperationAbortedError(crate::error::OperationAbortedError),
    ServiceUnavailableError(crate::error::ServiceUnavailableError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutDestinationPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutDestinationPolicyErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            PutDestinationPolicyErrorKind::OperationAbortedError(_inner) => _inner.fmt(f),
            PutDestinationPolicyErrorKind::ServiceUnavailableError(_inner) => _inner.fmt(f),
            PutDestinationPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutDestinationPolicyError {
    fn code(&self) -> Option<&str> {
        PutDestinationPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutDestinationPolicyError {
    pub fn new(kind: PutDestinationPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutDestinationPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutDestinationPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            PutDestinationPolicyErrorKind::InvalidParameterError(_)
        )
    }
    pub fn is_operation_aborted_error(&self) -> bool {
        matches!(
            &self.kind,
            PutDestinationPolicyErrorKind::OperationAbortedError(_)
        )
    }
    pub fn is_service_unavailable_error(&self) -> bool {
        matches!(
            &self.kind,
            PutDestinationPolicyErrorKind::ServiceUnavailableError(_)
        )
    }
}
impl std::error::Error for PutDestinationPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutDestinationPolicyErrorKind::InvalidParameterError(_inner) => Some(_inner),
            PutDestinationPolicyErrorKind::OperationAbortedError(_inner) => Some(_inner),
            PutDestinationPolicyErrorKind::ServiceUnavailableError(_inner) => Some(_inner),
            PutDestinationPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutLogEventsError {
    pub kind: PutLogEventsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutLogEventsErrorKind {
    DataAlreadyAcceptedError(crate::error::DataAlreadyAcceptedError),
    InvalidParameterError(crate::error::InvalidParameterError),
    InvalidSequenceTokenError(crate::error::InvalidSequenceTokenError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceUnavailableError(crate::error::ServiceUnavailableError),
    UnrecognizedClientError(crate::error::UnrecognizedClientError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutLogEventsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutLogEventsErrorKind::DataAlreadyAcceptedError(_inner) => _inner.fmt(f),
            PutLogEventsErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            PutLogEventsErrorKind::InvalidSequenceTokenError(_inner) => _inner.fmt(f),
            PutLogEventsErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            PutLogEventsErrorKind::ServiceUnavailableError(_inner) => _inner.fmt(f),
            PutLogEventsErrorKind::UnrecognizedClientError(_inner) => _inner.fmt(f),
            PutLogEventsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutLogEventsError {
    fn code(&self) -> Option<&str> {
        PutLogEventsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutLogEventsError {
    pub fn new(kind: PutLogEventsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutLogEventsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutLogEventsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_data_already_accepted_error(&self) -> bool {
        matches!(
            &self.kind,
            PutLogEventsErrorKind::DataAlreadyAcceptedError(_)
        )
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(&self.kind, PutLogEventsErrorKind::InvalidParameterError(_))
    }
    pub fn is_invalid_sequence_token_error(&self) -> bool {
        matches!(
            &self.kind,
            PutLogEventsErrorKind::InvalidSequenceTokenError(_)
        )
    }
    pub fn is_resource_not_found_error(&self) -> bool {
        matches!(&self.kind, PutLogEventsErrorKind::ResourceNotFoundError(_))
    }
    pub fn is_service_unavailable_error(&self) -> bool {
        matches!(
            &self.kind,
            PutLogEventsErrorKind::ServiceUnavailableError(_)
        )
    }
    pub fn is_unrecognized_client_error(&self) -> bool {
        matches!(
            &self.kind,
            PutLogEventsErrorKind::UnrecognizedClientError(_)
        )
    }
}
impl std::error::Error for PutLogEventsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutLogEventsErrorKind::DataAlreadyAcceptedError(_inner) => Some(_inner),
            PutLogEventsErrorKind::InvalidParameterError(_inner) => Some(_inner),
            PutLogEventsErrorKind::InvalidSequenceTokenError(_inner) => Some(_inner),
            PutLogEventsErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            PutLogEventsErrorKind::ServiceUnavailableError(_inner) => Some(_inner),
            PutLogEventsErrorKind::UnrecognizedClientError(_inner) => Some(_inner),
            PutLogEventsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutMetricFilterError {
    pub kind: PutMetricFilterErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutMetricFilterErrorKind {
    InvalidParameterError(crate::error::InvalidParameterError),
    LimitExceededError(crate::error::LimitExceededError),
    OperationAbortedError(crate::error::OperationAbortedError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceUnavailableError(crate::error::ServiceUnavailableError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutMetricFilterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutMetricFilterErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            PutMetricFilterErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            PutMetricFilterErrorKind::OperationAbortedError(_inner) => _inner.fmt(f),
            PutMetricFilterErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            PutMetricFilterErrorKind::ServiceUnavailableError(_inner) => _inner.fmt(f),
            PutMetricFilterErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutMetricFilterError {
    fn code(&self) -> Option<&str> {
        PutMetricFilterError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutMetricFilterError {
    pub fn new(kind: PutMetricFilterErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutMetricFilterErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutMetricFilterErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            PutMetricFilterErrorKind::InvalidParameterError(_)
        )
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(&self.kind, PutMetricFilterErrorKind::LimitExceededError(_))
    }
    pub fn is_operation_aborted_error(&self) -> bool {
        matches!(
            &self.kind,
            PutMetricFilterErrorKind::OperationAbortedError(_)
        )
    }
    pub fn is_resource_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            PutMetricFilterErrorKind::ResourceNotFoundError(_)
        )
    }
    pub fn is_service_unavailable_error(&self) -> bool {
        matches!(
            &self.kind,
            PutMetricFilterErrorKind::ServiceUnavailableError(_)
        )
    }
}
impl std::error::Error for PutMetricFilterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutMetricFilterErrorKind::InvalidParameterError(_inner) => Some(_inner),
            PutMetricFilterErrorKind::LimitExceededError(_inner) => Some(_inner),
            PutMetricFilterErrorKind::OperationAbortedError(_inner) => Some(_inner),
            PutMetricFilterErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            PutMetricFilterErrorKind::ServiceUnavailableError(_inner) => Some(_inner),
            PutMetricFilterErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutQueryDefinitionError {
    pub kind: PutQueryDefinitionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutQueryDefinitionErrorKind {
    InvalidParameterError(crate::error::InvalidParameterError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceUnavailableError(crate::error::ServiceUnavailableError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutQueryDefinitionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutQueryDefinitionErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            PutQueryDefinitionErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            PutQueryDefinitionErrorKind::ServiceUnavailableError(_inner) => _inner.fmt(f),
            PutQueryDefinitionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutQueryDefinitionError {
    fn code(&self) -> Option<&str> {
        PutQueryDefinitionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutQueryDefinitionError {
    pub fn new(kind: PutQueryDefinitionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutQueryDefinitionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutQueryDefinitionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            PutQueryDefinitionErrorKind::InvalidParameterError(_)
        )
    }
    pub fn is_resource_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            PutQueryDefinitionErrorKind::ResourceNotFoundError(_)
        )
    }
    pub fn is_service_unavailable_error(&self) -> bool {
        matches!(
            &self.kind,
            PutQueryDefinitionErrorKind::ServiceUnavailableError(_)
        )
    }
}
impl std::error::Error for PutQueryDefinitionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutQueryDefinitionErrorKind::InvalidParameterError(_inner) => Some(_inner),
            PutQueryDefinitionErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            PutQueryDefinitionErrorKind::ServiceUnavailableError(_inner) => Some(_inner),
            PutQueryDefinitionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutResourcePolicyError {
    pub kind: PutResourcePolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutResourcePolicyErrorKind {
    InvalidParameterError(crate::error::InvalidParameterError),
    LimitExceededError(crate::error::LimitExceededError),
    ServiceUnavailableError(crate::error::ServiceUnavailableError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutResourcePolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutResourcePolicyErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            PutResourcePolicyErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            PutResourcePolicyErrorKind::ServiceUnavailableError(_inner) => _inner.fmt(f),
            PutResourcePolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutResourcePolicyError {
    fn code(&self) -> Option<&str> {
        PutResourcePolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutResourcePolicyError {
    pub fn new(kind: PutResourcePolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutResourcePolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutResourcePolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            PutResourcePolicyErrorKind::InvalidParameterError(_)
        )
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            PutResourcePolicyErrorKind::LimitExceededError(_)
        )
    }
    pub fn is_service_unavailable_error(&self) -> bool {
        matches!(
            &self.kind,
            PutResourcePolicyErrorKind::ServiceUnavailableError(_)
        )
    }
}
impl std::error::Error for PutResourcePolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutResourcePolicyErrorKind::InvalidParameterError(_inner) => Some(_inner),
            PutResourcePolicyErrorKind::LimitExceededError(_inner) => Some(_inner),
            PutResourcePolicyErrorKind::ServiceUnavailableError(_inner) => Some(_inner),
            PutResourcePolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutRetentionPolicyError {
    pub kind: PutRetentionPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutRetentionPolicyErrorKind {
    InvalidParameterError(crate::error::InvalidParameterError),
    OperationAbortedError(crate::error::OperationAbortedError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceUnavailableError(crate::error::ServiceUnavailableError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutRetentionPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutRetentionPolicyErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            PutRetentionPolicyErrorKind::OperationAbortedError(_inner) => _inner.fmt(f),
            PutRetentionPolicyErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            PutRetentionPolicyErrorKind::ServiceUnavailableError(_inner) => _inner.fmt(f),
            PutRetentionPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutRetentionPolicyError {
    fn code(&self) -> Option<&str> {
        PutRetentionPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutRetentionPolicyError {
    pub fn new(kind: PutRetentionPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutRetentionPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutRetentionPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            PutRetentionPolicyErrorKind::InvalidParameterError(_)
        )
    }
    pub fn is_operation_aborted_error(&self) -> bool {
        matches!(
            &self.kind,
            PutRetentionPolicyErrorKind::OperationAbortedError(_)
        )
    }
    pub fn is_resource_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            PutRetentionPolicyErrorKind::ResourceNotFoundError(_)
        )
    }
    pub fn is_service_unavailable_error(&self) -> bool {
        matches!(
            &self.kind,
            PutRetentionPolicyErrorKind::ServiceUnavailableError(_)
        )
    }
}
impl std::error::Error for PutRetentionPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutRetentionPolicyErrorKind::InvalidParameterError(_inner) => Some(_inner),
            PutRetentionPolicyErrorKind::OperationAbortedError(_inner) => Some(_inner),
            PutRetentionPolicyErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            PutRetentionPolicyErrorKind::ServiceUnavailableError(_inner) => Some(_inner),
            PutRetentionPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutSubscriptionFilterError {
    pub kind: PutSubscriptionFilterErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutSubscriptionFilterErrorKind {
    InvalidParameterError(crate::error::InvalidParameterError),
    LimitExceededError(crate::error::LimitExceededError),
    OperationAbortedError(crate::error::OperationAbortedError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceUnavailableError(crate::error::ServiceUnavailableError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutSubscriptionFilterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutSubscriptionFilterErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            PutSubscriptionFilterErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            PutSubscriptionFilterErrorKind::OperationAbortedError(_inner) => _inner.fmt(f),
            PutSubscriptionFilterErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            PutSubscriptionFilterErrorKind::ServiceUnavailableError(_inner) => _inner.fmt(f),
            PutSubscriptionFilterErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutSubscriptionFilterError {
    fn code(&self) -> Option<&str> {
        PutSubscriptionFilterError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutSubscriptionFilterError {
    pub fn new(kind: PutSubscriptionFilterErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutSubscriptionFilterErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutSubscriptionFilterErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            PutSubscriptionFilterErrorKind::InvalidParameterError(_)
        )
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            PutSubscriptionFilterErrorKind::LimitExceededError(_)
        )
    }
    pub fn is_operation_aborted_error(&self) -> bool {
        matches!(
            &self.kind,
            PutSubscriptionFilterErrorKind::OperationAbortedError(_)
        )
    }
    pub fn is_resource_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            PutSubscriptionFilterErrorKind::ResourceNotFoundError(_)
        )
    }
    pub fn is_service_unavailable_error(&self) -> bool {
        matches!(
            &self.kind,
            PutSubscriptionFilterErrorKind::ServiceUnavailableError(_)
        )
    }
}
impl std::error::Error for PutSubscriptionFilterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutSubscriptionFilterErrorKind::InvalidParameterError(_inner) => Some(_inner),
            PutSubscriptionFilterErrorKind::LimitExceededError(_inner) => Some(_inner),
            PutSubscriptionFilterErrorKind::OperationAbortedError(_inner) => Some(_inner),
            PutSubscriptionFilterErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            PutSubscriptionFilterErrorKind::ServiceUnavailableError(_inner) => Some(_inner),
            PutSubscriptionFilterErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartQueryError {
    pub kind: StartQueryErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartQueryErrorKind {
    InvalidParameterError(crate::error::InvalidParameterError),
    LimitExceededError(crate::error::LimitExceededError),
    MalformedQueryError(crate::error::MalformedQueryError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceUnavailableError(crate::error::ServiceUnavailableError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartQueryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartQueryErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            StartQueryErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            StartQueryErrorKind::MalformedQueryError(_inner) => _inner.fmt(f),
            StartQueryErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            StartQueryErrorKind::ServiceUnavailableError(_inner) => _inner.fmt(f),
            StartQueryErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartQueryError {
    fn code(&self) -> Option<&str> {
        StartQueryError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartQueryError {
    pub fn new(kind: StartQueryErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartQueryErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartQueryErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(&self.kind, StartQueryErrorKind::InvalidParameterError(_))
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(&self.kind, StartQueryErrorKind::LimitExceededError(_))
    }
    pub fn is_malformed_query_error(&self) -> bool {
        matches!(&self.kind, StartQueryErrorKind::MalformedQueryError(_))
    }
    pub fn is_resource_not_found_error(&self) -> bool {
        matches!(&self.kind, StartQueryErrorKind::ResourceNotFoundError(_))
    }
    pub fn is_service_unavailable_error(&self) -> bool {
        matches!(&self.kind, StartQueryErrorKind::ServiceUnavailableError(_))
    }
}
impl std::error::Error for StartQueryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartQueryErrorKind::InvalidParameterError(_inner) => Some(_inner),
            StartQueryErrorKind::LimitExceededError(_inner) => Some(_inner),
            StartQueryErrorKind::MalformedQueryError(_inner) => Some(_inner),
            StartQueryErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            StartQueryErrorKind::ServiceUnavailableError(_inner) => Some(_inner),
            StartQueryErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StopQueryError {
    pub kind: StopQueryErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StopQueryErrorKind {
    InvalidParameterError(crate::error::InvalidParameterError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    ServiceUnavailableError(crate::error::ServiceUnavailableError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StopQueryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StopQueryErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            StopQueryErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            StopQueryErrorKind::ServiceUnavailableError(_inner) => _inner.fmt(f),
            StopQueryErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StopQueryError {
    fn code(&self) -> Option<&str> {
        StopQueryError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StopQueryError {
    pub fn new(kind: StopQueryErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StopQueryErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StopQueryErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(&self.kind, StopQueryErrorKind::InvalidParameterError(_))
    }
    pub fn is_resource_not_found_error(&self) -> bool {
        matches!(&self.kind, StopQueryErrorKind::ResourceNotFoundError(_))
    }
    pub fn is_service_unavailable_error(&self) -> bool {
        matches!(&self.kind, StopQueryErrorKind::ServiceUnavailableError(_))
    }
}
impl std::error::Error for StopQueryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StopQueryErrorKind::InvalidParameterError(_inner) => Some(_inner),
            StopQueryErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            StopQueryErrorKind::ServiceUnavailableError(_inner) => Some(_inner),
            StopQueryErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagLogGroupError {
    pub kind: TagLogGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagLogGroupErrorKind {
    InvalidParameterError(crate::error::InvalidParameterError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TagLogGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagLogGroupErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            TagLogGroupErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            TagLogGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TagLogGroupError {
    fn code(&self) -> Option<&str> {
        TagLogGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagLogGroupError {
    pub fn new(kind: TagLogGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TagLogGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TagLogGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(&self.kind, TagLogGroupErrorKind::InvalidParameterError(_))
    }
    pub fn is_resource_not_found_error(&self) -> bool {
        matches!(&self.kind, TagLogGroupErrorKind::ResourceNotFoundError(_))
    }
}
impl std::error::Error for TagLogGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagLogGroupErrorKind::InvalidParameterError(_inner) => Some(_inner),
            TagLogGroupErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            TagLogGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TestMetricFilterError {
    pub kind: TestMetricFilterErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TestMetricFilterErrorKind {
    InvalidParameterError(crate::error::InvalidParameterError),
    ServiceUnavailableError(crate::error::ServiceUnavailableError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TestMetricFilterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TestMetricFilterErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            TestMetricFilterErrorKind::ServiceUnavailableError(_inner) => _inner.fmt(f),
            TestMetricFilterErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TestMetricFilterError {
    fn code(&self) -> Option<&str> {
        TestMetricFilterError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TestMetricFilterError {
    pub fn new(kind: TestMetricFilterErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TestMetricFilterErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TestMetricFilterErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            TestMetricFilterErrorKind::InvalidParameterError(_)
        )
    }
    pub fn is_service_unavailable_error(&self) -> bool {
        matches!(
            &self.kind,
            TestMetricFilterErrorKind::ServiceUnavailableError(_)
        )
    }
}
impl std::error::Error for TestMetricFilterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TestMetricFilterErrorKind::InvalidParameterError(_inner) => Some(_inner),
            TestMetricFilterErrorKind::ServiceUnavailableError(_inner) => Some(_inner),
            TestMetricFilterErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagLogGroupError {
    pub kind: UntagLogGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagLogGroupErrorKind {
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UntagLogGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagLogGroupErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            UntagLogGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UntagLogGroupError {
    fn code(&self) -> Option<&str> {
        UntagLogGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagLogGroupError {
    pub fn new(kind: UntagLogGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UntagLogGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UntagLogGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_resource_not_found_error(&self) -> bool {
        matches!(&self.kind, UntagLogGroupErrorKind::ResourceNotFoundError(_))
    }
}
impl std::error::Error for UntagLogGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagLogGroupErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            UntagLogGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// <p>The specified resource does not exist.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceNotFoundError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceNotFoundError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ResourceNotFoundError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceNotFoundError [ResourceNotFoundException]")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceNotFoundError {}
/// See [`ResourceNotFoundError`](crate::error::ResourceNotFoundError)
pub mod resource_not_found_error {
    /// A builder for [`ResourceNotFoundError`](crate::error::ResourceNotFoundError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceNotFoundError`](crate::error::ResourceNotFoundError)
        pub fn build(self) -> crate::error::ResourceNotFoundError {
            crate::error::ResourceNotFoundError {
                message: self.message,
            }
        }
    }
}
impl ResourceNotFoundError {
    /// Creates a new builder-style object to manufacture [`ResourceNotFoundError`](crate::error::ResourceNotFoundError)
    pub fn builder() -> crate::error::resource_not_found_error::Builder {
        crate::error::resource_not_found_error::Builder::default()
    }
}

/// <p>The service cannot complete the request.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ServiceUnavailableError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ServiceUnavailableError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ServiceUnavailableError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ServiceUnavailableError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ServiceUnavailableError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ServiceUnavailableError [ServiceUnavailableException]")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for ServiceUnavailableError {}
/// See [`ServiceUnavailableError`](crate::error::ServiceUnavailableError)
pub mod service_unavailable_error {
    /// A builder for [`ServiceUnavailableError`](crate::error::ServiceUnavailableError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ServiceUnavailableError`](crate::error::ServiceUnavailableError)
        pub fn build(self) -> crate::error::ServiceUnavailableError {
            crate::error::ServiceUnavailableError {
                message: self.message,
            }
        }
    }
}
impl ServiceUnavailableError {
    /// Creates a new builder-style object to manufacture [`ServiceUnavailableError`](crate::error::ServiceUnavailableError)
    pub fn builder() -> crate::error::service_unavailable_error::Builder {
        crate::error::service_unavailable_error::Builder::default()
    }
}

/// <p>A parameter is specified incorrectly.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidParameterError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidParameterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidParameterError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidParameterError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidParameterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidParameterError [InvalidParameterException]")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidParameterError {}
/// See [`InvalidParameterError`](crate::error::InvalidParameterError)
pub mod invalid_parameter_error {
    /// A builder for [`InvalidParameterError`](crate::error::InvalidParameterError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidParameterError`](crate::error::InvalidParameterError)
        pub fn build(self) -> crate::error::InvalidParameterError {
            crate::error::InvalidParameterError {
                message: self.message,
            }
        }
    }
}
impl InvalidParameterError {
    /// Creates a new builder-style object to manufacture [`InvalidParameterError`](crate::error::InvalidParameterError)
    pub fn builder() -> crate::error::invalid_parameter_error::Builder {
        crate::error::invalid_parameter_error::Builder::default()
    }
}

/// <p>The query string is not valid. Details about this error are displayed in a
/// <code>QueryCompileError</code> object. For more information, see
/// <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_QueryCompileError.html">QueryCompileError</a>.</p>
/// <p>For more information about valid query syntax, see
/// <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CWL_QuerySyntax.html">CloudWatch Logs Insights Query Syntax</a>.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct MalformedQueryError {
    /// <p>Reserved.</p>
    #[serde(rename = "queryCompileError")]
    #[serde(default)]
    pub query_compile_error: std::option::Option<crate::model::QueryCompileError>,
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MalformedQueryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MalformedQueryError");
        formatter.field("query_compile_error", &self.query_compile_error);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl MalformedQueryError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MalformedQueryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MalformedQueryError [MalformedQueryException]")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for MalformedQueryError {}
/// See [`MalformedQueryError`](crate::error::MalformedQueryError)
pub mod malformed_query_error {
    /// A builder for [`MalformedQueryError`](crate::error::MalformedQueryError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) query_compile_error: std::option::Option<crate::model::QueryCompileError>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Reserved.</p>
        pub fn query_compile_error(mut self, input: crate::model::QueryCompileError) -> Self {
            self.query_compile_error = Some(input);
            self
        }
        pub fn set_query_compile_error(
            mut self,
            input: std::option::Option<crate::model::QueryCompileError>,
        ) -> Self {
            self.query_compile_error = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`MalformedQueryError`](crate::error::MalformedQueryError)
        pub fn build(self) -> crate::error::MalformedQueryError {
            crate::error::MalformedQueryError {
                query_compile_error: self.query_compile_error,
                message: self.message,
            }
        }
    }
}
impl MalformedQueryError {
    /// Creates a new builder-style object to manufacture [`MalformedQueryError`](crate::error::MalformedQueryError)
    pub fn builder() -> crate::error::malformed_query_error::Builder {
        crate::error::malformed_query_error::Builder::default()
    }
}

/// <p>You have reached the maximum number of resources that can be created.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct LimitExceededError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LimitExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LimitExceededError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl LimitExceededError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for LimitExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "LimitExceededError [LimitExceededException]")?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for LimitExceededError {}
/// See [`LimitExceededError`](crate::error::LimitExceededError)
pub mod limit_exceeded_error {
    /// A builder for [`LimitExceededError`](crate::error::LimitExceededError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`LimitExceededError`](crate::error::LimitExceededError)
        pub fn build(self) -> crate::error::LimitExceededError {
            crate::error::LimitExceededError {
                message: self.message,
            }
        }
    }
}
impl LimitExceededError {
    /// Creates a new builder-style object to manufacture [`LimitExceededError`](crate::error::LimitExceededError)
    pub fn builder() -> crate::error::limit_exceeded_error::Builder {
        crate::error::limit_exceeded_error::Builder::default()
    }
}

/// <p>Multiple requests to update the same resource were in conflict.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct OperationAbortedError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for OperationAbortedError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OperationAbortedError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl OperationAbortedError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for OperationAbortedError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "OperationAbortedError [OperationAbortedException]")?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl std::error::Error for OperationAbortedError {}
/// See [`OperationAbortedError`](crate::error::OperationAbortedError)
pub mod operation_aborted_error {
    /// A builder for [`OperationAbortedError`](crate::error::OperationAbortedError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`OperationAbortedError`](crate::error::OperationAbortedError)
        pub fn build(self) -> crate::error::OperationAbortedError {
            crate::error::OperationAbortedError {
                message: self.message,
            }
        }
    }
}
impl OperationAbortedError {
    /// Creates a new builder-style object to manufacture [`OperationAbortedError`](crate::error::OperationAbortedError)
    pub fn builder() -> crate::error::operation_aborted_error::Builder {
        crate::error::operation_aborted_error::Builder::default()
    }
}

/// <p>The most likely cause is an invalid AWS access key ID or secret key.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct UnrecognizedClientError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UnrecognizedClientError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UnrecognizedClientError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl UnrecognizedClientError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UnrecognizedClientError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UnrecognizedClientError [UnrecognizedClientException]")?;
        if let Some(inner_7) = &self.message {
            write!(f, ": {}", inner_7)?;
        }
        Ok(())
    }
}
impl std::error::Error for UnrecognizedClientError {}
/// See [`UnrecognizedClientError`](crate::error::UnrecognizedClientError)
pub mod unrecognized_client_error {
    /// A builder for [`UnrecognizedClientError`](crate::error::UnrecognizedClientError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`UnrecognizedClientError`](crate::error::UnrecognizedClientError)
        pub fn build(self) -> crate::error::UnrecognizedClientError {
            crate::error::UnrecognizedClientError {
                message: self.message,
            }
        }
    }
}
impl UnrecognizedClientError {
    /// Creates a new builder-style object to manufacture [`UnrecognizedClientError`](crate::error::UnrecognizedClientError)
    pub fn builder() -> crate::error::unrecognized_client_error::Builder {
        crate::error::unrecognized_client_error::Builder::default()
    }
}

/// <p>The sequence token is not valid. You can get the correct sequence token in
/// the <code>expectedSequenceToken</code> field in the <code>InvalidSequenceTokenException</code>
/// message. </p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidSequenceTokenError {
    #[serde(rename = "expectedSequenceToken")]
    #[serde(default)]
    pub expected_sequence_token: std::option::Option<std::string::String>,
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidSequenceTokenError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidSequenceTokenError");
        formatter.field("expected_sequence_token", &self.expected_sequence_token);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidSequenceTokenError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidSequenceTokenError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "InvalidSequenceTokenError [InvalidSequenceTokenException]"
        )?;
        if let Some(inner_8) = &self.message {
            write!(f, ": {}", inner_8)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidSequenceTokenError {}
/// See [`InvalidSequenceTokenError`](crate::error::InvalidSequenceTokenError)
pub mod invalid_sequence_token_error {
    /// A builder for [`InvalidSequenceTokenError`](crate::error::InvalidSequenceTokenError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) expected_sequence_token: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn expected_sequence_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_sequence_token = Some(input.into());
            self
        }
        pub fn set_expected_sequence_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_sequence_token = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidSequenceTokenError`](crate::error::InvalidSequenceTokenError)
        pub fn build(self) -> crate::error::InvalidSequenceTokenError {
            crate::error::InvalidSequenceTokenError {
                expected_sequence_token: self.expected_sequence_token,
                message: self.message,
            }
        }
    }
}
impl InvalidSequenceTokenError {
    /// Creates a new builder-style object to manufacture [`InvalidSequenceTokenError`](crate::error::InvalidSequenceTokenError)
    pub fn builder() -> crate::error::invalid_sequence_token_error::Builder {
        crate::error::invalid_sequence_token_error::Builder::default()
    }
}

/// <p>The event was already logged.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DataAlreadyAcceptedError {
    #[serde(rename = "expectedSequenceToken")]
    #[serde(default)]
    pub expected_sequence_token: std::option::Option<std::string::String>,
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DataAlreadyAcceptedError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DataAlreadyAcceptedError");
        formatter.field("expected_sequence_token", &self.expected_sequence_token);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DataAlreadyAcceptedError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DataAlreadyAcceptedError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DataAlreadyAcceptedError [DataAlreadyAcceptedException]")?;
        if let Some(inner_9) = &self.message {
            write!(f, ": {}", inner_9)?;
        }
        Ok(())
    }
}
impl std::error::Error for DataAlreadyAcceptedError {}
/// See [`DataAlreadyAcceptedError`](crate::error::DataAlreadyAcceptedError)
pub mod data_already_accepted_error {
    /// A builder for [`DataAlreadyAcceptedError`](crate::error::DataAlreadyAcceptedError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) expected_sequence_token: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn expected_sequence_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_sequence_token = Some(input.into());
            self
        }
        pub fn set_expected_sequence_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_sequence_token = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DataAlreadyAcceptedError`](crate::error::DataAlreadyAcceptedError)
        pub fn build(self) -> crate::error::DataAlreadyAcceptedError {
            crate::error::DataAlreadyAcceptedError {
                expected_sequence_token: self.expected_sequence_token,
                message: self.message,
            }
        }
    }
}
impl DataAlreadyAcceptedError {
    /// Creates a new builder-style object to manufacture [`DataAlreadyAcceptedError`](crate::error::DataAlreadyAcceptedError)
    pub fn builder() -> crate::error::data_already_accepted_error::Builder {
        crate::error::data_already_accepted_error::Builder::default()
    }
}

/// <p>The specified resource already exists.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceAlreadyExistsError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceAlreadyExistsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceAlreadyExistsError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ResourceAlreadyExistsError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceAlreadyExistsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "ResourceAlreadyExistsError [ResourceAlreadyExistsException]"
        )?;
        if let Some(inner_10) = &self.message {
            write!(f, ": {}", inner_10)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceAlreadyExistsError {}
/// See [`ResourceAlreadyExistsError`](crate::error::ResourceAlreadyExistsError)
pub mod resource_already_exists_error {
    /// A builder for [`ResourceAlreadyExistsError`](crate::error::ResourceAlreadyExistsError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceAlreadyExistsError`](crate::error::ResourceAlreadyExistsError)
        pub fn build(self) -> crate::error::ResourceAlreadyExistsError {
            crate::error::ResourceAlreadyExistsError {
                message: self.message,
            }
        }
    }
}
impl ResourceAlreadyExistsError {
    /// Creates a new builder-style object to manufacture [`ResourceAlreadyExistsError`](crate::error::ResourceAlreadyExistsError)
    pub fn builder() -> crate::error::resource_already_exists_error::Builder {
        crate::error::resource_already_exists_error::Builder::default()
    }
}

/// <p>The operation is not valid on the specified resource.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidOperationError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidOperationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidOperationError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidOperationError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidOperationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidOperationError [InvalidOperationException]")?;
        if let Some(inner_11) = &self.message {
            write!(f, ": {}", inner_11)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidOperationError {}
/// See [`InvalidOperationError`](crate::error::InvalidOperationError)
pub mod invalid_operation_error {
    /// A builder for [`InvalidOperationError`](crate::error::InvalidOperationError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidOperationError`](crate::error::InvalidOperationError)
        pub fn build(self) -> crate::error::InvalidOperationError {
            crate::error::InvalidOperationError {
                message: self.message,
            }
        }
    }
}
impl InvalidOperationError {
    /// Creates a new builder-style object to manufacture [`InvalidOperationError`](crate::error::InvalidOperationError)
    pub fn builder() -> crate::error::invalid_operation_error::Builder {
        crate::error::invalid_operation_error::Builder::default()
    }
}
