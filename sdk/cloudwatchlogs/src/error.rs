// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AssociateKmsKeyError {
    pub kind: AssociateKmsKeyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AssociateKmsKeyErrorKind {
    InvalidParameterException(crate::error::InvalidParameterException),
    OperationAbortedException(crate::error::OperationAbortedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AssociateKmsKeyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AssociateKmsKeyErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            AssociateKmsKeyErrorKind::OperationAbortedException(_inner) => _inner.fmt(f),
            AssociateKmsKeyErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            AssociateKmsKeyErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            AssociateKmsKeyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AssociateKmsKeyError {
    fn code(&self) -> Option<&str> {
        AssociateKmsKeyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AssociateKmsKeyError {
    pub fn new(kind: AssociateKmsKeyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AssociateKmsKeyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AssociateKmsKeyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateKmsKeyErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_operation_aborted_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateKmsKeyErrorKind::OperationAbortedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateKmsKeyErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateKmsKeyErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for AssociateKmsKeyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AssociateKmsKeyErrorKind::InvalidParameterException(_inner) => Some(_inner),
            AssociateKmsKeyErrorKind::OperationAbortedException(_inner) => Some(_inner),
            AssociateKmsKeyErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            AssociateKmsKeyErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            AssociateKmsKeyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CancelExportTaskError {
    pub kind: CancelExportTaskErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CancelExportTaskErrorKind {
    InvalidOperationException(crate::error::InvalidOperationException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CancelExportTaskError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CancelExportTaskErrorKind::InvalidOperationException(_inner) => _inner.fmt(f),
            CancelExportTaskErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            CancelExportTaskErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CancelExportTaskErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CancelExportTaskErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CancelExportTaskError {
    fn code(&self) -> Option<&str> {
        CancelExportTaskError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CancelExportTaskError {
    pub fn new(kind: CancelExportTaskErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CancelExportTaskErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CancelExportTaskErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_operation_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelExportTaskErrorKind::InvalidOperationException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelExportTaskErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelExportTaskErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelExportTaskErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for CancelExportTaskError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CancelExportTaskErrorKind::InvalidOperationException(_inner) => Some(_inner),
            CancelExportTaskErrorKind::InvalidParameterException(_inner) => Some(_inner),
            CancelExportTaskErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CancelExportTaskErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CancelExportTaskErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateExportTaskError {
    pub kind: CreateExportTaskErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateExportTaskErrorKind {
    InvalidParameterException(crate::error::InvalidParameterException),
    LimitExceededException(crate::error::LimitExceededException),
    OperationAbortedException(crate::error::OperationAbortedException),
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateExportTaskError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateExportTaskErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            CreateExportTaskErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateExportTaskErrorKind::OperationAbortedException(_inner) => _inner.fmt(f),
            CreateExportTaskErrorKind::ResourceAlreadyExistsException(_inner) => _inner.fmt(f),
            CreateExportTaskErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateExportTaskErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateExportTaskErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateExportTaskError {
    fn code(&self) -> Option<&str> {
        CreateExportTaskError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateExportTaskError {
    pub fn new(kind: CreateExportTaskErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateExportTaskErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateExportTaskErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateExportTaskErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateExportTaskErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_operation_aborted_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateExportTaskErrorKind::OperationAbortedException(_)
        )
    }
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateExportTaskErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateExportTaskErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateExportTaskErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for CreateExportTaskError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateExportTaskErrorKind::InvalidParameterException(_inner) => Some(_inner),
            CreateExportTaskErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateExportTaskErrorKind::OperationAbortedException(_inner) => Some(_inner),
            CreateExportTaskErrorKind::ResourceAlreadyExistsException(_inner) => Some(_inner),
            CreateExportTaskErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateExportTaskErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateExportTaskErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateLogGroupError {
    pub kind: CreateLogGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateLogGroupErrorKind {
    InvalidParameterException(crate::error::InvalidParameterException),
    LimitExceededException(crate::error::LimitExceededException),
    OperationAbortedException(crate::error::OperationAbortedException),
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateLogGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateLogGroupErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            CreateLogGroupErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateLogGroupErrorKind::OperationAbortedException(_inner) => _inner.fmt(f),
            CreateLogGroupErrorKind::ResourceAlreadyExistsException(_inner) => _inner.fmt(f),
            CreateLogGroupErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateLogGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateLogGroupError {
    fn code(&self) -> Option<&str> {
        CreateLogGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateLogGroupError {
    pub fn new(kind: CreateLogGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateLogGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateLogGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateLogGroupErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateLogGroupErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_operation_aborted_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateLogGroupErrorKind::OperationAbortedException(_)
        )
    }
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateLogGroupErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateLogGroupErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for CreateLogGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateLogGroupErrorKind::InvalidParameterException(_inner) => Some(_inner),
            CreateLogGroupErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateLogGroupErrorKind::OperationAbortedException(_inner) => Some(_inner),
            CreateLogGroupErrorKind::ResourceAlreadyExistsException(_inner) => Some(_inner),
            CreateLogGroupErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateLogGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateLogStreamError {
    pub kind: CreateLogStreamErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateLogStreamErrorKind {
    InvalidParameterException(crate::error::InvalidParameterException),
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateLogStreamError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateLogStreamErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            CreateLogStreamErrorKind::ResourceAlreadyExistsException(_inner) => _inner.fmt(f),
            CreateLogStreamErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateLogStreamErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateLogStreamErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateLogStreamError {
    fn code(&self) -> Option<&str> {
        CreateLogStreamError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateLogStreamError {
    pub fn new(kind: CreateLogStreamErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateLogStreamErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateLogStreamErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateLogStreamErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateLogStreamErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateLogStreamErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateLogStreamErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for CreateLogStreamError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateLogStreamErrorKind::InvalidParameterException(_inner) => Some(_inner),
            CreateLogStreamErrorKind::ResourceAlreadyExistsException(_inner) => Some(_inner),
            CreateLogStreamErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateLogStreamErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateLogStreamErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteDestinationError {
    pub kind: DeleteDestinationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDestinationErrorKind {
    InvalidParameterException(crate::error::InvalidParameterException),
    OperationAbortedException(crate::error::OperationAbortedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteDestinationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteDestinationErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DeleteDestinationErrorKind::OperationAbortedException(_inner) => _inner.fmt(f),
            DeleteDestinationErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteDestinationErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteDestinationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteDestinationError {
    fn code(&self) -> Option<&str> {
        DeleteDestinationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteDestinationError {
    pub fn new(kind: DeleteDestinationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteDestinationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteDestinationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDestinationErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_operation_aborted_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDestinationErrorKind::OperationAbortedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDestinationErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDestinationErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for DeleteDestinationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteDestinationErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DeleteDestinationErrorKind::OperationAbortedException(_inner) => Some(_inner),
            DeleteDestinationErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteDestinationErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteDestinationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteLogGroupError {
    pub kind: DeleteLogGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteLogGroupErrorKind {
    InvalidParameterException(crate::error::InvalidParameterException),
    OperationAbortedException(crate::error::OperationAbortedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteLogGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteLogGroupErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DeleteLogGroupErrorKind::OperationAbortedException(_inner) => _inner.fmt(f),
            DeleteLogGroupErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteLogGroupErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteLogGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteLogGroupError {
    fn code(&self) -> Option<&str> {
        DeleteLogGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteLogGroupError {
    pub fn new(kind: DeleteLogGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteLogGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteLogGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteLogGroupErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_operation_aborted_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteLogGroupErrorKind::OperationAbortedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteLogGroupErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteLogGroupErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for DeleteLogGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteLogGroupErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DeleteLogGroupErrorKind::OperationAbortedException(_inner) => Some(_inner),
            DeleteLogGroupErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteLogGroupErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteLogGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteLogStreamError {
    pub kind: DeleteLogStreamErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteLogStreamErrorKind {
    InvalidParameterException(crate::error::InvalidParameterException),
    OperationAbortedException(crate::error::OperationAbortedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteLogStreamError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteLogStreamErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DeleteLogStreamErrorKind::OperationAbortedException(_inner) => _inner.fmt(f),
            DeleteLogStreamErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteLogStreamErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteLogStreamErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteLogStreamError {
    fn code(&self) -> Option<&str> {
        DeleteLogStreamError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteLogStreamError {
    pub fn new(kind: DeleteLogStreamErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteLogStreamErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteLogStreamErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteLogStreamErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_operation_aborted_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteLogStreamErrorKind::OperationAbortedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteLogStreamErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteLogStreamErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for DeleteLogStreamError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteLogStreamErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DeleteLogStreamErrorKind::OperationAbortedException(_inner) => Some(_inner),
            DeleteLogStreamErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteLogStreamErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteLogStreamErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteMetricFilterError {
    pub kind: DeleteMetricFilterErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteMetricFilterErrorKind {
    InvalidParameterException(crate::error::InvalidParameterException),
    OperationAbortedException(crate::error::OperationAbortedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteMetricFilterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteMetricFilterErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DeleteMetricFilterErrorKind::OperationAbortedException(_inner) => _inner.fmt(f),
            DeleteMetricFilterErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteMetricFilterErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteMetricFilterErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteMetricFilterError {
    fn code(&self) -> Option<&str> {
        DeleteMetricFilterError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteMetricFilterError {
    pub fn new(kind: DeleteMetricFilterErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteMetricFilterErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteMetricFilterErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMetricFilterErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_operation_aborted_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMetricFilterErrorKind::OperationAbortedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMetricFilterErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMetricFilterErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for DeleteMetricFilterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteMetricFilterErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DeleteMetricFilterErrorKind::OperationAbortedException(_inner) => Some(_inner),
            DeleteMetricFilterErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteMetricFilterErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteMetricFilterErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteQueryDefinitionError {
    pub kind: DeleteQueryDefinitionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteQueryDefinitionErrorKind {
    InvalidParameterException(crate::error::InvalidParameterException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteQueryDefinitionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteQueryDefinitionErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DeleteQueryDefinitionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteQueryDefinitionErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteQueryDefinitionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteQueryDefinitionError {
    fn code(&self) -> Option<&str> {
        DeleteQueryDefinitionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteQueryDefinitionError {
    pub fn new(kind: DeleteQueryDefinitionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteQueryDefinitionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteQueryDefinitionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteQueryDefinitionErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteQueryDefinitionErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteQueryDefinitionErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for DeleteQueryDefinitionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteQueryDefinitionErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DeleteQueryDefinitionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteQueryDefinitionErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteQueryDefinitionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteResourcePolicyError {
    pub kind: DeleteResourcePolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteResourcePolicyErrorKind {
    InvalidParameterException(crate::error::InvalidParameterException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteResourcePolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteResourcePolicyErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DeleteResourcePolicyErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteResourcePolicyErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteResourcePolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteResourcePolicyError {
    fn code(&self) -> Option<&str> {
        DeleteResourcePolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteResourcePolicyError {
    pub fn new(kind: DeleteResourcePolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteResourcePolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteResourcePolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteResourcePolicyErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteResourcePolicyErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteResourcePolicyErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for DeleteResourcePolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteResourcePolicyErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DeleteResourcePolicyErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteResourcePolicyErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteResourcePolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteRetentionPolicyError {
    pub kind: DeleteRetentionPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteRetentionPolicyErrorKind {
    InvalidParameterException(crate::error::InvalidParameterException),
    OperationAbortedException(crate::error::OperationAbortedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteRetentionPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteRetentionPolicyErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DeleteRetentionPolicyErrorKind::OperationAbortedException(_inner) => _inner.fmt(f),
            DeleteRetentionPolicyErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteRetentionPolicyErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteRetentionPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteRetentionPolicyError {
    fn code(&self) -> Option<&str> {
        DeleteRetentionPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteRetentionPolicyError {
    pub fn new(kind: DeleteRetentionPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteRetentionPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteRetentionPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRetentionPolicyErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_operation_aborted_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRetentionPolicyErrorKind::OperationAbortedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRetentionPolicyErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRetentionPolicyErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for DeleteRetentionPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteRetentionPolicyErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DeleteRetentionPolicyErrorKind::OperationAbortedException(_inner) => Some(_inner),
            DeleteRetentionPolicyErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteRetentionPolicyErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteRetentionPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteSubscriptionFilterError {
    pub kind: DeleteSubscriptionFilterErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteSubscriptionFilterErrorKind {
    InvalidParameterException(crate::error::InvalidParameterException),
    OperationAbortedException(crate::error::OperationAbortedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteSubscriptionFilterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteSubscriptionFilterErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DeleteSubscriptionFilterErrorKind::OperationAbortedException(_inner) => _inner.fmt(f),
            DeleteSubscriptionFilterErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteSubscriptionFilterErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteSubscriptionFilterErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteSubscriptionFilterError {
    fn code(&self) -> Option<&str> {
        DeleteSubscriptionFilterError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteSubscriptionFilterError {
    pub fn new(kind: DeleteSubscriptionFilterErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteSubscriptionFilterErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteSubscriptionFilterErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSubscriptionFilterErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_operation_aborted_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSubscriptionFilterErrorKind::OperationAbortedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSubscriptionFilterErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSubscriptionFilterErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for DeleteSubscriptionFilterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteSubscriptionFilterErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DeleteSubscriptionFilterErrorKind::OperationAbortedException(_inner) => Some(_inner),
            DeleteSubscriptionFilterErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteSubscriptionFilterErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteSubscriptionFilterErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeDestinationsError {
    pub kind: DescribeDestinationsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDestinationsErrorKind {
    InvalidParameterException(crate::error::InvalidParameterException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeDestinationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeDestinationsErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DescribeDestinationsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DescribeDestinationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeDestinationsError {
    fn code(&self) -> Option<&str> {
        DescribeDestinationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDestinationsError {
    pub fn new(kind: DescribeDestinationsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeDestinationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeDestinationsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDestinationsErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDestinationsErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for DescribeDestinationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeDestinationsErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DescribeDestinationsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DescribeDestinationsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeExportTasksError {
    pub kind: DescribeExportTasksErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeExportTasksErrorKind {
    InvalidParameterException(crate::error::InvalidParameterException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeExportTasksError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeExportTasksErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DescribeExportTasksErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DescribeExportTasksErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeExportTasksError {
    fn code(&self) -> Option<&str> {
        DescribeExportTasksError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeExportTasksError {
    pub fn new(kind: DescribeExportTasksErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeExportTasksErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeExportTasksErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeExportTasksErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeExportTasksErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for DescribeExportTasksError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeExportTasksErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DescribeExportTasksErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DescribeExportTasksErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeLogGroupsError {
    pub kind: DescribeLogGroupsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeLogGroupsErrorKind {
    InvalidParameterException(crate::error::InvalidParameterException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeLogGroupsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeLogGroupsErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DescribeLogGroupsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DescribeLogGroupsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeLogGroupsError {
    fn code(&self) -> Option<&str> {
        DescribeLogGroupsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeLogGroupsError {
    pub fn new(kind: DescribeLogGroupsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeLogGroupsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeLogGroupsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeLogGroupsErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeLogGroupsErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for DescribeLogGroupsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeLogGroupsErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DescribeLogGroupsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DescribeLogGroupsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeLogStreamsError {
    pub kind: DescribeLogStreamsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeLogStreamsErrorKind {
    InvalidParameterException(crate::error::InvalidParameterException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeLogStreamsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeLogStreamsErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DescribeLogStreamsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeLogStreamsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DescribeLogStreamsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeLogStreamsError {
    fn code(&self) -> Option<&str> {
        DescribeLogStreamsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeLogStreamsError {
    pub fn new(kind: DescribeLogStreamsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeLogStreamsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeLogStreamsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeLogStreamsErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeLogStreamsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeLogStreamsErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for DescribeLogStreamsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeLogStreamsErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DescribeLogStreamsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeLogStreamsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DescribeLogStreamsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeMetricFiltersError {
    pub kind: DescribeMetricFiltersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeMetricFiltersErrorKind {
    InvalidParameterException(crate::error::InvalidParameterException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeMetricFiltersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeMetricFiltersErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DescribeMetricFiltersErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeMetricFiltersErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DescribeMetricFiltersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeMetricFiltersError {
    fn code(&self) -> Option<&str> {
        DescribeMetricFiltersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeMetricFiltersError {
    pub fn new(kind: DescribeMetricFiltersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeMetricFiltersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeMetricFiltersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMetricFiltersErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMetricFiltersErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMetricFiltersErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for DescribeMetricFiltersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeMetricFiltersErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DescribeMetricFiltersErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeMetricFiltersErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DescribeMetricFiltersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeQueriesError {
    pub kind: DescribeQueriesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeQueriesErrorKind {
    InvalidParameterException(crate::error::InvalidParameterException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeQueriesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeQueriesErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DescribeQueriesErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeQueriesErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DescribeQueriesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeQueriesError {
    fn code(&self) -> Option<&str> {
        DescribeQueriesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeQueriesError {
    pub fn new(kind: DescribeQueriesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeQueriesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeQueriesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeQueriesErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeQueriesErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeQueriesErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for DescribeQueriesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeQueriesErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DescribeQueriesErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeQueriesErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DescribeQueriesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeQueryDefinitionsError {
    pub kind: DescribeQueryDefinitionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeQueryDefinitionsErrorKind {
    InvalidParameterException(crate::error::InvalidParameterException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeQueryDefinitionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeQueryDefinitionsErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DescribeQueryDefinitionsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DescribeQueryDefinitionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeQueryDefinitionsError {
    fn code(&self) -> Option<&str> {
        DescribeQueryDefinitionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeQueryDefinitionsError {
    pub fn new(kind: DescribeQueryDefinitionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeQueryDefinitionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeQueryDefinitionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeQueryDefinitionsErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeQueryDefinitionsErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for DescribeQueryDefinitionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeQueryDefinitionsErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DescribeQueryDefinitionsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DescribeQueryDefinitionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeResourcePoliciesError {
    pub kind: DescribeResourcePoliciesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeResourcePoliciesErrorKind {
    InvalidParameterException(crate::error::InvalidParameterException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeResourcePoliciesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeResourcePoliciesErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DescribeResourcePoliciesErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DescribeResourcePoliciesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeResourcePoliciesError {
    fn code(&self) -> Option<&str> {
        DescribeResourcePoliciesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeResourcePoliciesError {
    pub fn new(kind: DescribeResourcePoliciesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeResourcePoliciesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeResourcePoliciesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeResourcePoliciesErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeResourcePoliciesErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for DescribeResourcePoliciesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeResourcePoliciesErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DescribeResourcePoliciesErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DescribeResourcePoliciesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeSubscriptionFiltersError {
    pub kind: DescribeSubscriptionFiltersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeSubscriptionFiltersErrorKind {
    InvalidParameterException(crate::error::InvalidParameterException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeSubscriptionFiltersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeSubscriptionFiltersErrorKind::InvalidParameterException(_inner) => {
                _inner.fmt(f)
            }
            DescribeSubscriptionFiltersErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DescribeSubscriptionFiltersErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            DescribeSubscriptionFiltersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeSubscriptionFiltersError {
    fn code(&self) -> Option<&str> {
        DescribeSubscriptionFiltersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeSubscriptionFiltersError {
    pub fn new(kind: DescribeSubscriptionFiltersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeSubscriptionFiltersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeSubscriptionFiltersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeSubscriptionFiltersErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeSubscriptionFiltersErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeSubscriptionFiltersErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for DescribeSubscriptionFiltersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeSubscriptionFiltersErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DescribeSubscriptionFiltersErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeSubscriptionFiltersErrorKind::ServiceUnavailableException(_inner) => {
                Some(_inner)
            }
            DescribeSubscriptionFiltersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DisassociateKmsKeyError {
    pub kind: DisassociateKmsKeyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DisassociateKmsKeyErrorKind {
    InvalidParameterException(crate::error::InvalidParameterException),
    OperationAbortedException(crate::error::OperationAbortedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DisassociateKmsKeyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DisassociateKmsKeyErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DisassociateKmsKeyErrorKind::OperationAbortedException(_inner) => _inner.fmt(f),
            DisassociateKmsKeyErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DisassociateKmsKeyErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DisassociateKmsKeyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DisassociateKmsKeyError {
    fn code(&self) -> Option<&str> {
        DisassociateKmsKeyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DisassociateKmsKeyError {
    pub fn new(kind: DisassociateKmsKeyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DisassociateKmsKeyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DisassociateKmsKeyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateKmsKeyErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_operation_aborted_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateKmsKeyErrorKind::OperationAbortedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateKmsKeyErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateKmsKeyErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for DisassociateKmsKeyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DisassociateKmsKeyErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DisassociateKmsKeyErrorKind::OperationAbortedException(_inner) => Some(_inner),
            DisassociateKmsKeyErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DisassociateKmsKeyErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DisassociateKmsKeyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct FilterLogEventsError {
    pub kind: FilterLogEventsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum FilterLogEventsErrorKind {
    InvalidParameterException(crate::error::InvalidParameterException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for FilterLogEventsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            FilterLogEventsErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            FilterLogEventsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            FilterLogEventsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            FilterLogEventsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for FilterLogEventsError {
    fn code(&self) -> Option<&str> {
        FilterLogEventsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl FilterLogEventsError {
    pub fn new(kind: FilterLogEventsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: FilterLogEventsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: FilterLogEventsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            FilterLogEventsErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            FilterLogEventsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            FilterLogEventsErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for FilterLogEventsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            FilterLogEventsErrorKind::InvalidParameterException(_inner) => Some(_inner),
            FilterLogEventsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            FilterLogEventsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            FilterLogEventsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetLogEventsError {
    pub kind: GetLogEventsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetLogEventsErrorKind {
    InvalidParameterException(crate::error::InvalidParameterException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetLogEventsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetLogEventsErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            GetLogEventsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetLogEventsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            GetLogEventsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetLogEventsError {
    fn code(&self) -> Option<&str> {
        GetLogEventsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetLogEventsError {
    pub fn new(kind: GetLogEventsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetLogEventsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetLogEventsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLogEventsErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLogEventsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLogEventsErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for GetLogEventsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetLogEventsErrorKind::InvalidParameterException(_inner) => Some(_inner),
            GetLogEventsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetLogEventsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            GetLogEventsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetLogGroupFieldsError {
    pub kind: GetLogGroupFieldsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetLogGroupFieldsErrorKind {
    InvalidParameterException(crate::error::InvalidParameterException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetLogGroupFieldsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetLogGroupFieldsErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            GetLogGroupFieldsErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            GetLogGroupFieldsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetLogGroupFieldsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            GetLogGroupFieldsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetLogGroupFieldsError {
    fn code(&self) -> Option<&str> {
        GetLogGroupFieldsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetLogGroupFieldsError {
    pub fn new(kind: GetLogGroupFieldsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetLogGroupFieldsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetLogGroupFieldsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLogGroupFieldsErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLogGroupFieldsErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLogGroupFieldsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLogGroupFieldsErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for GetLogGroupFieldsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetLogGroupFieldsErrorKind::InvalidParameterException(_inner) => Some(_inner),
            GetLogGroupFieldsErrorKind::LimitExceededException(_inner) => Some(_inner),
            GetLogGroupFieldsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetLogGroupFieldsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            GetLogGroupFieldsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetLogRecordError {
    pub kind: GetLogRecordErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetLogRecordErrorKind {
    InvalidParameterException(crate::error::InvalidParameterException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetLogRecordError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetLogRecordErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            GetLogRecordErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            GetLogRecordErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetLogRecordErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            GetLogRecordErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetLogRecordError {
    fn code(&self) -> Option<&str> {
        GetLogRecordError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetLogRecordError {
    pub fn new(kind: GetLogRecordErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetLogRecordErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetLogRecordErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLogRecordErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, GetLogRecordErrorKind::LimitExceededException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLogRecordErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLogRecordErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for GetLogRecordError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetLogRecordErrorKind::InvalidParameterException(_inner) => Some(_inner),
            GetLogRecordErrorKind::LimitExceededException(_inner) => Some(_inner),
            GetLogRecordErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetLogRecordErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            GetLogRecordErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetQueryResultsError {
    pub kind: GetQueryResultsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetQueryResultsErrorKind {
    InvalidParameterException(crate::error::InvalidParameterException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetQueryResultsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetQueryResultsErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            GetQueryResultsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetQueryResultsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            GetQueryResultsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetQueryResultsError {
    fn code(&self) -> Option<&str> {
        GetQueryResultsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetQueryResultsError {
    pub fn new(kind: GetQueryResultsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetQueryResultsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetQueryResultsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetQueryResultsErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetQueryResultsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetQueryResultsErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for GetQueryResultsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetQueryResultsErrorKind::InvalidParameterException(_inner) => Some(_inner),
            GetQueryResultsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetQueryResultsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            GetQueryResultsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTagsLogGroupError {
    pub kind: ListTagsLogGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTagsLogGroupErrorKind {
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTagsLogGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTagsLogGroupErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListTagsLogGroupErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListTagsLogGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTagsLogGroupError {
    fn code(&self) -> Option<&str> {
        ListTagsLogGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTagsLogGroupError {
    pub fn new(kind: ListTagsLogGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTagsLogGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTagsLogGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsLogGroupErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsLogGroupErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for ListTagsLogGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTagsLogGroupErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListTagsLogGroupErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListTagsLogGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutDestinationError {
    pub kind: PutDestinationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutDestinationErrorKind {
    InvalidParameterException(crate::error::InvalidParameterException),
    OperationAbortedException(crate::error::OperationAbortedException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutDestinationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutDestinationErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            PutDestinationErrorKind::OperationAbortedException(_inner) => _inner.fmt(f),
            PutDestinationErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            PutDestinationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutDestinationError {
    fn code(&self) -> Option<&str> {
        PutDestinationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutDestinationError {
    pub fn new(kind: PutDestinationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutDestinationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutDestinationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutDestinationErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_operation_aborted_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutDestinationErrorKind::OperationAbortedException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutDestinationErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for PutDestinationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutDestinationErrorKind::InvalidParameterException(_inner) => Some(_inner),
            PutDestinationErrorKind::OperationAbortedException(_inner) => Some(_inner),
            PutDestinationErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            PutDestinationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutDestinationPolicyError {
    pub kind: PutDestinationPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutDestinationPolicyErrorKind {
    InvalidParameterException(crate::error::InvalidParameterException),
    OperationAbortedException(crate::error::OperationAbortedException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutDestinationPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutDestinationPolicyErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            PutDestinationPolicyErrorKind::OperationAbortedException(_inner) => _inner.fmt(f),
            PutDestinationPolicyErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            PutDestinationPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutDestinationPolicyError {
    fn code(&self) -> Option<&str> {
        PutDestinationPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutDestinationPolicyError {
    pub fn new(kind: PutDestinationPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutDestinationPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutDestinationPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutDestinationPolicyErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_operation_aborted_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutDestinationPolicyErrorKind::OperationAbortedException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutDestinationPolicyErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for PutDestinationPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutDestinationPolicyErrorKind::InvalidParameterException(_inner) => Some(_inner),
            PutDestinationPolicyErrorKind::OperationAbortedException(_inner) => Some(_inner),
            PutDestinationPolicyErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            PutDestinationPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutLogEventsError {
    pub kind: PutLogEventsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutLogEventsErrorKind {
    DataAlreadyAcceptedException(crate::error::DataAlreadyAcceptedException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidSequenceTokenException(crate::error::InvalidSequenceTokenException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    UnrecognizedClientException(crate::error::UnrecognizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutLogEventsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutLogEventsErrorKind::DataAlreadyAcceptedException(_inner) => _inner.fmt(f),
            PutLogEventsErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            PutLogEventsErrorKind::InvalidSequenceTokenException(_inner) => _inner.fmt(f),
            PutLogEventsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            PutLogEventsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            PutLogEventsErrorKind::UnrecognizedClientException(_inner) => _inner.fmt(f),
            PutLogEventsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutLogEventsError {
    fn code(&self) -> Option<&str> {
        PutLogEventsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutLogEventsError {
    pub fn new(kind: PutLogEventsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutLogEventsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutLogEventsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_data_already_accepted_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutLogEventsErrorKind::DataAlreadyAcceptedException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutLogEventsErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_sequence_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutLogEventsErrorKind::InvalidSequenceTokenException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutLogEventsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutLogEventsErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_unrecognized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutLogEventsErrorKind::UnrecognizedClientException(_)
        )
    }
}
impl std::error::Error for PutLogEventsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutLogEventsErrorKind::DataAlreadyAcceptedException(_inner) => Some(_inner),
            PutLogEventsErrorKind::InvalidParameterException(_inner) => Some(_inner),
            PutLogEventsErrorKind::InvalidSequenceTokenException(_inner) => Some(_inner),
            PutLogEventsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            PutLogEventsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            PutLogEventsErrorKind::UnrecognizedClientException(_inner) => Some(_inner),
            PutLogEventsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutMetricFilterError {
    pub kind: PutMetricFilterErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutMetricFilterErrorKind {
    InvalidParameterException(crate::error::InvalidParameterException),
    LimitExceededException(crate::error::LimitExceededException),
    OperationAbortedException(crate::error::OperationAbortedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutMetricFilterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutMetricFilterErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            PutMetricFilterErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            PutMetricFilterErrorKind::OperationAbortedException(_inner) => _inner.fmt(f),
            PutMetricFilterErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            PutMetricFilterErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            PutMetricFilterErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutMetricFilterError {
    fn code(&self) -> Option<&str> {
        PutMetricFilterError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutMetricFilterError {
    pub fn new(kind: PutMetricFilterErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutMetricFilterErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutMetricFilterErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutMetricFilterErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutMetricFilterErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_operation_aborted_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutMetricFilterErrorKind::OperationAbortedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutMetricFilterErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutMetricFilterErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for PutMetricFilterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutMetricFilterErrorKind::InvalidParameterException(_inner) => Some(_inner),
            PutMetricFilterErrorKind::LimitExceededException(_inner) => Some(_inner),
            PutMetricFilterErrorKind::OperationAbortedException(_inner) => Some(_inner),
            PutMetricFilterErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            PutMetricFilterErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            PutMetricFilterErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutQueryDefinitionError {
    pub kind: PutQueryDefinitionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutQueryDefinitionErrorKind {
    InvalidParameterException(crate::error::InvalidParameterException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutQueryDefinitionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutQueryDefinitionErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            PutQueryDefinitionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            PutQueryDefinitionErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            PutQueryDefinitionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutQueryDefinitionError {
    fn code(&self) -> Option<&str> {
        PutQueryDefinitionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutQueryDefinitionError {
    pub fn new(kind: PutQueryDefinitionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutQueryDefinitionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutQueryDefinitionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutQueryDefinitionErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutQueryDefinitionErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutQueryDefinitionErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for PutQueryDefinitionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutQueryDefinitionErrorKind::InvalidParameterException(_inner) => Some(_inner),
            PutQueryDefinitionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            PutQueryDefinitionErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            PutQueryDefinitionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutResourcePolicyError {
    pub kind: PutResourcePolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutResourcePolicyErrorKind {
    InvalidParameterException(crate::error::InvalidParameterException),
    LimitExceededException(crate::error::LimitExceededException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutResourcePolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutResourcePolicyErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            PutResourcePolicyErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            PutResourcePolicyErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            PutResourcePolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutResourcePolicyError {
    fn code(&self) -> Option<&str> {
        PutResourcePolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutResourcePolicyError {
    pub fn new(kind: PutResourcePolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutResourcePolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutResourcePolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutResourcePolicyErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutResourcePolicyErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutResourcePolicyErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for PutResourcePolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutResourcePolicyErrorKind::InvalidParameterException(_inner) => Some(_inner),
            PutResourcePolicyErrorKind::LimitExceededException(_inner) => Some(_inner),
            PutResourcePolicyErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            PutResourcePolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutRetentionPolicyError {
    pub kind: PutRetentionPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutRetentionPolicyErrorKind {
    InvalidParameterException(crate::error::InvalidParameterException),
    OperationAbortedException(crate::error::OperationAbortedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutRetentionPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutRetentionPolicyErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            PutRetentionPolicyErrorKind::OperationAbortedException(_inner) => _inner.fmt(f),
            PutRetentionPolicyErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            PutRetentionPolicyErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            PutRetentionPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutRetentionPolicyError {
    fn code(&self) -> Option<&str> {
        PutRetentionPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutRetentionPolicyError {
    pub fn new(kind: PutRetentionPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutRetentionPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutRetentionPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutRetentionPolicyErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_operation_aborted_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutRetentionPolicyErrorKind::OperationAbortedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutRetentionPolicyErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutRetentionPolicyErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for PutRetentionPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutRetentionPolicyErrorKind::InvalidParameterException(_inner) => Some(_inner),
            PutRetentionPolicyErrorKind::OperationAbortedException(_inner) => Some(_inner),
            PutRetentionPolicyErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            PutRetentionPolicyErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            PutRetentionPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutSubscriptionFilterError {
    pub kind: PutSubscriptionFilterErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutSubscriptionFilterErrorKind {
    InvalidParameterException(crate::error::InvalidParameterException),
    LimitExceededException(crate::error::LimitExceededException),
    OperationAbortedException(crate::error::OperationAbortedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutSubscriptionFilterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutSubscriptionFilterErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            PutSubscriptionFilterErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            PutSubscriptionFilterErrorKind::OperationAbortedException(_inner) => _inner.fmt(f),
            PutSubscriptionFilterErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            PutSubscriptionFilterErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            PutSubscriptionFilterErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutSubscriptionFilterError {
    fn code(&self) -> Option<&str> {
        PutSubscriptionFilterError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutSubscriptionFilterError {
    pub fn new(kind: PutSubscriptionFilterErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutSubscriptionFilterErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutSubscriptionFilterErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutSubscriptionFilterErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutSubscriptionFilterErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_operation_aborted_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutSubscriptionFilterErrorKind::OperationAbortedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutSubscriptionFilterErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutSubscriptionFilterErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for PutSubscriptionFilterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutSubscriptionFilterErrorKind::InvalidParameterException(_inner) => Some(_inner),
            PutSubscriptionFilterErrorKind::LimitExceededException(_inner) => Some(_inner),
            PutSubscriptionFilterErrorKind::OperationAbortedException(_inner) => Some(_inner),
            PutSubscriptionFilterErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            PutSubscriptionFilterErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            PutSubscriptionFilterErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartQueryError {
    pub kind: StartQueryErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartQueryErrorKind {
    InvalidParameterException(crate::error::InvalidParameterException),
    LimitExceededException(crate::error::LimitExceededException),
    MalformedQueryException(crate::error::MalformedQueryException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartQueryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartQueryErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            StartQueryErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            StartQueryErrorKind::MalformedQueryException(_inner) => _inner.fmt(f),
            StartQueryErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            StartQueryErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            StartQueryErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartQueryError {
    fn code(&self) -> Option<&str> {
        StartQueryError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartQueryError {
    pub fn new(kind: StartQueryErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartQueryErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartQueryErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartQueryErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, StartQueryErrorKind::LimitExceededException(_))
    }
    pub fn is_malformed_query_exception(&self) -> bool {
        matches!(&self.kind, StartQueryErrorKind::MalformedQueryException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartQueryErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartQueryErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for StartQueryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartQueryErrorKind::InvalidParameterException(_inner) => Some(_inner),
            StartQueryErrorKind::LimitExceededException(_inner) => Some(_inner),
            StartQueryErrorKind::MalformedQueryException(_inner) => Some(_inner),
            StartQueryErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            StartQueryErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            StartQueryErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StopQueryError {
    pub kind: StopQueryErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StopQueryErrorKind {
    InvalidParameterException(crate::error::InvalidParameterException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StopQueryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StopQueryErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            StopQueryErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            StopQueryErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            StopQueryErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StopQueryError {
    fn code(&self) -> Option<&str> {
        StopQueryError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StopQueryError {
    pub fn new(kind: StopQueryErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StopQueryErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StopQueryErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(&self.kind, StopQueryErrorKind::InvalidParameterException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, StopQueryErrorKind::ResourceNotFoundException(_))
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopQueryErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for StopQueryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StopQueryErrorKind::InvalidParameterException(_inner) => Some(_inner),
            StopQueryErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            StopQueryErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            StopQueryErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagLogGroupError {
    pub kind: TagLogGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagLogGroupErrorKind {
    InvalidParameterException(crate::error::InvalidParameterException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TagLogGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagLogGroupErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            TagLogGroupErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            TagLogGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TagLogGroupError {
    fn code(&self) -> Option<&str> {
        TagLogGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagLogGroupError {
    pub fn new(kind: TagLogGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TagLogGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TagLogGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagLogGroupErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagLogGroupErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for TagLogGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagLogGroupErrorKind::InvalidParameterException(_inner) => Some(_inner),
            TagLogGroupErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            TagLogGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TestMetricFilterError {
    pub kind: TestMetricFilterErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TestMetricFilterErrorKind {
    InvalidParameterException(crate::error::InvalidParameterException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TestMetricFilterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TestMetricFilterErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            TestMetricFilterErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            TestMetricFilterErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TestMetricFilterError {
    fn code(&self) -> Option<&str> {
        TestMetricFilterError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TestMetricFilterError {
    pub fn new(kind: TestMetricFilterErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TestMetricFilterErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TestMetricFilterErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestMetricFilterErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestMetricFilterErrorKind::ServiceUnavailableException(_)
        )
    }
}
impl std::error::Error for TestMetricFilterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TestMetricFilterErrorKind::InvalidParameterException(_inner) => Some(_inner),
            TestMetricFilterErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            TestMetricFilterErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagLogGroupError {
    pub kind: UntagLogGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagLogGroupErrorKind {
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UntagLogGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagLogGroupErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UntagLogGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UntagLogGroupError {
    fn code(&self) -> Option<&str> {
        UntagLogGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagLogGroupError {
    pub fn new(kind: UntagLogGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UntagLogGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UntagLogGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagLogGroupErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for UntagLogGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagLogGroupErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UntagLogGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// <p>The specified resource does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceNotFoundException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceNotFoundException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ResourceNotFoundException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceNotFoundException")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceNotFoundException {}
/// See [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
pub mod resource_not_found_exception {
    /// A builder for [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
        pub fn build(self) -> crate::error::ResourceNotFoundException {
            crate::error::ResourceNotFoundException {
                message: self.message,
            }
        }
    }
}
impl ResourceNotFoundException {
    /// Creates a new builder-style object to manufacture [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
    pub fn builder() -> crate::error::resource_not_found_exception::Builder {
        crate::error::resource_not_found_exception::Builder::default()
    }
}

/// <p>The service cannot complete the request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ServiceUnavailableException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ServiceUnavailableException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ServiceUnavailableException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ServiceUnavailableException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ServiceUnavailableException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ServiceUnavailableException")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for ServiceUnavailableException {}
/// See [`ServiceUnavailableException`](crate::error::ServiceUnavailableException)
pub mod service_unavailable_exception {
    /// A builder for [`ServiceUnavailableException`](crate::error::ServiceUnavailableException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ServiceUnavailableException`](crate::error::ServiceUnavailableException)
        pub fn build(self) -> crate::error::ServiceUnavailableException {
            crate::error::ServiceUnavailableException {
                message: self.message,
            }
        }
    }
}
impl ServiceUnavailableException {
    /// Creates a new builder-style object to manufacture [`ServiceUnavailableException`](crate::error::ServiceUnavailableException)
    pub fn builder() -> crate::error::service_unavailable_exception::Builder {
        crate::error::service_unavailable_exception::Builder::default()
    }
}

/// <p>A parameter is specified incorrectly.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidParameterException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidParameterException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidParameterException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidParameterException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidParameterException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidParameterException")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidParameterException {}
/// See [`InvalidParameterException`](crate::error::InvalidParameterException)
pub mod invalid_parameter_exception {
    /// A builder for [`InvalidParameterException`](crate::error::InvalidParameterException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidParameterException`](crate::error::InvalidParameterException)
        pub fn build(self) -> crate::error::InvalidParameterException {
            crate::error::InvalidParameterException {
                message: self.message,
            }
        }
    }
}
impl InvalidParameterException {
    /// Creates a new builder-style object to manufacture [`InvalidParameterException`](crate::error::InvalidParameterException)
    pub fn builder() -> crate::error::invalid_parameter_exception::Builder {
        crate::error::invalid_parameter_exception::Builder::default()
    }
}

/// <p>The query string is not valid. Details about this error are displayed in a
/// <code>QueryCompileError</code> object. For more information, see
/// <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_QueryCompileError.html">QueryCompileError</a>.</p>
/// <p>For more information about valid query syntax, see
/// <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CWL_QuerySyntax.html">CloudWatch Logs Insights Query Syntax</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MalformedQueryException {
    /// <p>Reserved.</p>
    pub query_compile_error: std::option::Option<crate::model::QueryCompileError>,
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MalformedQueryException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MalformedQueryException");
        formatter.field("query_compile_error", &self.query_compile_error);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl MalformedQueryException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MalformedQueryException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MalformedQueryException")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for MalformedQueryException {}
/// See [`MalformedQueryException`](crate::error::MalformedQueryException)
pub mod malformed_query_exception {
    /// A builder for [`MalformedQueryException`](crate::error::MalformedQueryException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) query_compile_error: std::option::Option<crate::model::QueryCompileError>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Reserved.</p>
        pub fn query_compile_error(mut self, input: crate::model::QueryCompileError) -> Self {
            self.query_compile_error = Some(input);
            self
        }
        pub fn set_query_compile_error(
            mut self,
            input: std::option::Option<crate::model::QueryCompileError>,
        ) -> Self {
            self.query_compile_error = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`MalformedQueryException`](crate::error::MalformedQueryException)
        pub fn build(self) -> crate::error::MalformedQueryException {
            crate::error::MalformedQueryException {
                query_compile_error: self.query_compile_error,
                message: self.message,
            }
        }
    }
}
impl MalformedQueryException {
    /// Creates a new builder-style object to manufacture [`MalformedQueryException`](crate::error::MalformedQueryException)
    pub fn builder() -> crate::error::malformed_query_exception::Builder {
        crate::error::malformed_query_exception::Builder::default()
    }
}

/// <p>You have reached the maximum number of resources that can be created.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LimitExceededException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LimitExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl LimitExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for LimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "LimitExceededException")?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for LimitExceededException {}
/// See [`LimitExceededException`](crate::error::LimitExceededException)
pub mod limit_exceeded_exception {
    /// A builder for [`LimitExceededException`](crate::error::LimitExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`LimitExceededException`](crate::error::LimitExceededException)
        pub fn build(self) -> crate::error::LimitExceededException {
            crate::error::LimitExceededException {
                message: self.message,
            }
        }
    }
}
impl LimitExceededException {
    /// Creates a new builder-style object to manufacture [`LimitExceededException`](crate::error::LimitExceededException)
    pub fn builder() -> crate::error::limit_exceeded_exception::Builder {
        crate::error::limit_exceeded_exception::Builder::default()
    }
}

/// <p>Multiple requests to update the same resource were in conflict.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct OperationAbortedException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for OperationAbortedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OperationAbortedException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl OperationAbortedException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for OperationAbortedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "OperationAbortedException")?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl std::error::Error for OperationAbortedException {}
/// See [`OperationAbortedException`](crate::error::OperationAbortedException)
pub mod operation_aborted_exception {
    /// A builder for [`OperationAbortedException`](crate::error::OperationAbortedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`OperationAbortedException`](crate::error::OperationAbortedException)
        pub fn build(self) -> crate::error::OperationAbortedException {
            crate::error::OperationAbortedException {
                message: self.message,
            }
        }
    }
}
impl OperationAbortedException {
    /// Creates a new builder-style object to manufacture [`OperationAbortedException`](crate::error::OperationAbortedException)
    pub fn builder() -> crate::error::operation_aborted_exception::Builder {
        crate::error::operation_aborted_exception::Builder::default()
    }
}

/// <p>The most likely cause is an invalid Amazon Web Services access key ID or secret key.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UnrecognizedClientException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UnrecognizedClientException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UnrecognizedClientException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl UnrecognizedClientException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UnrecognizedClientException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UnrecognizedClientException")?;
        if let Some(inner_7) = &self.message {
            write!(f, ": {}", inner_7)?;
        }
        Ok(())
    }
}
impl std::error::Error for UnrecognizedClientException {}
/// See [`UnrecognizedClientException`](crate::error::UnrecognizedClientException)
pub mod unrecognized_client_exception {
    /// A builder for [`UnrecognizedClientException`](crate::error::UnrecognizedClientException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`UnrecognizedClientException`](crate::error::UnrecognizedClientException)
        pub fn build(self) -> crate::error::UnrecognizedClientException {
            crate::error::UnrecognizedClientException {
                message: self.message,
            }
        }
    }
}
impl UnrecognizedClientException {
    /// Creates a new builder-style object to manufacture [`UnrecognizedClientException`](crate::error::UnrecognizedClientException)
    pub fn builder() -> crate::error::unrecognized_client_exception::Builder {
        crate::error::unrecognized_client_exception::Builder::default()
    }
}

/// <p>The sequence token is not valid. You can get the correct sequence token in
/// the <code>expectedSequenceToken</code> field in the <code>InvalidSequenceTokenException</code>
/// message. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidSequenceTokenException {
    pub expected_sequence_token: std::option::Option<std::string::String>,
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidSequenceTokenException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidSequenceTokenException");
        formatter.field("expected_sequence_token", &self.expected_sequence_token);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidSequenceTokenException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidSequenceTokenException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidSequenceTokenException")?;
        if let Some(inner_8) = &self.message {
            write!(f, ": {}", inner_8)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidSequenceTokenException {}
/// See [`InvalidSequenceTokenException`](crate::error::InvalidSequenceTokenException)
pub mod invalid_sequence_token_exception {
    /// A builder for [`InvalidSequenceTokenException`](crate::error::InvalidSequenceTokenException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) expected_sequence_token: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn expected_sequence_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_sequence_token = Some(input.into());
            self
        }
        pub fn set_expected_sequence_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_sequence_token = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidSequenceTokenException`](crate::error::InvalidSequenceTokenException)
        pub fn build(self) -> crate::error::InvalidSequenceTokenException {
            crate::error::InvalidSequenceTokenException {
                expected_sequence_token: self.expected_sequence_token,
                message: self.message,
            }
        }
    }
}
impl InvalidSequenceTokenException {
    /// Creates a new builder-style object to manufacture [`InvalidSequenceTokenException`](crate::error::InvalidSequenceTokenException)
    pub fn builder() -> crate::error::invalid_sequence_token_exception::Builder {
        crate::error::invalid_sequence_token_exception::Builder::default()
    }
}

/// <p>The event was already logged.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DataAlreadyAcceptedException {
    pub expected_sequence_token: std::option::Option<std::string::String>,
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DataAlreadyAcceptedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DataAlreadyAcceptedException");
        formatter.field("expected_sequence_token", &self.expected_sequence_token);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DataAlreadyAcceptedException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DataAlreadyAcceptedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DataAlreadyAcceptedException")?;
        if let Some(inner_9) = &self.message {
            write!(f, ": {}", inner_9)?;
        }
        Ok(())
    }
}
impl std::error::Error for DataAlreadyAcceptedException {}
/// See [`DataAlreadyAcceptedException`](crate::error::DataAlreadyAcceptedException)
pub mod data_already_accepted_exception {
    /// A builder for [`DataAlreadyAcceptedException`](crate::error::DataAlreadyAcceptedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) expected_sequence_token: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn expected_sequence_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.expected_sequence_token = Some(input.into());
            self
        }
        pub fn set_expected_sequence_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expected_sequence_token = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DataAlreadyAcceptedException`](crate::error::DataAlreadyAcceptedException)
        pub fn build(self) -> crate::error::DataAlreadyAcceptedException {
            crate::error::DataAlreadyAcceptedException {
                expected_sequence_token: self.expected_sequence_token,
                message: self.message,
            }
        }
    }
}
impl DataAlreadyAcceptedException {
    /// Creates a new builder-style object to manufacture [`DataAlreadyAcceptedException`](crate::error::DataAlreadyAcceptedException)
    pub fn builder() -> crate::error::data_already_accepted_exception::Builder {
        crate::error::data_already_accepted_exception::Builder::default()
    }
}

/// <p>The specified resource already exists.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceAlreadyExistsException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceAlreadyExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceAlreadyExistsException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ResourceAlreadyExistsException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceAlreadyExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceAlreadyExistsException")?;
        if let Some(inner_10) = &self.message {
            write!(f, ": {}", inner_10)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceAlreadyExistsException {}
/// See [`ResourceAlreadyExistsException`](crate::error::ResourceAlreadyExistsException)
pub mod resource_already_exists_exception {
    /// A builder for [`ResourceAlreadyExistsException`](crate::error::ResourceAlreadyExistsException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceAlreadyExistsException`](crate::error::ResourceAlreadyExistsException)
        pub fn build(self) -> crate::error::ResourceAlreadyExistsException {
            crate::error::ResourceAlreadyExistsException {
                message: self.message,
            }
        }
    }
}
impl ResourceAlreadyExistsException {
    /// Creates a new builder-style object to manufacture [`ResourceAlreadyExistsException`](crate::error::ResourceAlreadyExistsException)
    pub fn builder() -> crate::error::resource_already_exists_exception::Builder {
        crate::error::resource_already_exists_exception::Builder::default()
    }
}

/// <p>The operation is not valid on the specified resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidOperationException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidOperationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidOperationException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidOperationException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidOperationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidOperationException")?;
        if let Some(inner_11) = &self.message {
            write!(f, ": {}", inner_11)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidOperationException {}
/// See [`InvalidOperationException`](crate::error::InvalidOperationException)
pub mod invalid_operation_exception {
    /// A builder for [`InvalidOperationException`](crate::error::InvalidOperationException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidOperationException`](crate::error::InvalidOperationException)
        pub fn build(self) -> crate::error::InvalidOperationException {
            crate::error::InvalidOperationException {
                message: self.message,
            }
        }
    }
}
impl InvalidOperationException {
    /// Creates a new builder-style object to manufacture [`InvalidOperationException`](crate::error::InvalidOperationException)
    pub fn builder() -> crate::error::invalid_operation_exception::Builder {
        crate::error::invalid_operation_exception::Builder::default()
    }
}
