// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use std::fmt::Write;
/// See [`AssociateKmsKeyInput`](crate::input::AssociateKmsKeyInput)
pub mod associate_kms_key_input {
    /// A builder for [`AssociateKmsKeyInput`](crate::input::AssociateKmsKeyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) log_group_name: std::option::Option<std::string::String>,
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the log group.</p>
        pub fn log_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.log_group_name = Some(input.into());
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.log_group_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the CMK to use when encrypting log data. This must be a symmetric CMK.
        /// For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-kms">Amazon Resource Names - Key Management Service</a> and <a href="https://docs.aws.amazon.com/kms/latest/developerguide/symmetric-asymmetric.html">Using Symmetric and Asymmetric Keys</a>.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// Consumes the builder and constructs a [`AssociateKmsKeyInput`](crate::input::AssociateKmsKeyInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::AssociateKmsKeyInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::AssociateKmsKeyInput {
                log_group_name: self.log_group_name,
                kms_key_id: self.kms_key_id,
            })
        }
    }
}
#[doc(hidden)]
pub type AssociateKmsKeyInputOperationOutputAlias = crate::operation::AssociateKmsKey;
#[doc(hidden)]
pub type AssociateKmsKeyInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl AssociateKmsKeyInput {
    /// Consumes the builder and constructs an Operation<[`AssociateKmsKey`](crate::operation::AssociateKmsKey)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::AssociateKmsKey,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_crate_operation_associate_kms_key(&self)
                    .map_err(|err| {
                        smithy_http::operation::BuildError::SerializationError(err.into())
                    })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::AssociateKmsKey::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "AssociateKmsKey",
                "cloudwatchlogs",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("content-type"),
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("x-amz-target"),
            "Logs_20140328.AssociateKmsKey",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`AssociateKmsKeyInput`](crate::input::AssociateKmsKeyInput)
    pub fn builder() -> crate::input::associate_kms_key_input::Builder {
        crate::input::associate_kms_key_input::Builder::default()
    }
}

/// See [`CancelExportTaskInput`](crate::input::CancelExportTaskInput)
pub mod cancel_export_task_input {
    /// A builder for [`CancelExportTaskInput`](crate::input::CancelExportTaskInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) task_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the export task.</p>
        pub fn task_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.task_id = Some(input.into());
            self
        }
        pub fn set_task_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.task_id = input;
            self
        }
        /// Consumes the builder and constructs a [`CancelExportTaskInput`](crate::input::CancelExportTaskInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CancelExportTaskInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CancelExportTaskInput {
                task_id: self.task_id,
            })
        }
    }
}
#[doc(hidden)]
pub type CancelExportTaskInputOperationOutputAlias = crate::operation::CancelExportTask;
#[doc(hidden)]
pub type CancelExportTaskInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CancelExportTaskInput {
    /// Consumes the builder and constructs an Operation<[`CancelExportTask`](crate::operation::CancelExportTask)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::CancelExportTask,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_crate_operation_cancel_export_task(&self)
                    .map_err(|err| {
                        smithy_http::operation::BuildError::SerializationError(err.into())
                    })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::CancelExportTask::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "CancelExportTask",
                "cloudwatchlogs",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("content-type"),
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("x-amz-target"),
            "Logs_20140328.CancelExportTask",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CancelExportTaskInput`](crate::input::CancelExportTaskInput)
    pub fn builder() -> crate::input::cancel_export_task_input::Builder {
        crate::input::cancel_export_task_input::Builder::default()
    }
}

/// See [`CreateExportTaskInput`](crate::input::CreateExportTaskInput)
pub mod create_export_task_input {
    /// A builder for [`CreateExportTaskInput`](crate::input::CreateExportTaskInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) task_name: std::option::Option<std::string::String>,
        pub(crate) log_group_name: std::option::Option<std::string::String>,
        pub(crate) log_stream_name_prefix: std::option::Option<std::string::String>,
        pub(crate) from: std::option::Option<i64>,
        pub(crate) to: std::option::Option<i64>,
        pub(crate) destination: std::option::Option<std::string::String>,
        pub(crate) destination_prefix: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the export task.</p>
        pub fn task_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.task_name = Some(input.into());
            self
        }
        pub fn set_task_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.task_name = input;
            self
        }
        /// <p>The name of the log group.</p>
        pub fn log_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.log_group_name = Some(input.into());
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.log_group_name = input;
            self
        }
        /// <p>Export only log streams that match the provided prefix. If you don't
        /// specify a value, no prefix filter is applied.</p>
        pub fn log_stream_name_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.log_stream_name_prefix = Some(input.into());
            self
        }
        pub fn set_log_stream_name_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.log_stream_name_prefix = input;
            self
        }
        /// <p>The start time of the range for the request, expressed as the number of milliseconds
        /// after Jan 1, 1970 00:00:00 UTC. Events with a timestamp earlier than this time are not
        /// exported.</p>
        pub fn from(mut self, input: i64) -> Self {
            self.from = Some(input);
            self
        }
        pub fn set_from(mut self, input: std::option::Option<i64>) -> Self {
            self.from = input;
            self
        }
        /// <p>The end time of the range for the request, expreswatchlogsdocused as the number of milliseconds
        /// after Jan 1, 1970 00:00:00 UTC. Events with a timestamp later than this time are not
        /// exported.</p>
        pub fn to(mut self, input: i64) -> Self {
            self.to = Some(input);
            self
        }
        pub fn set_to(mut self, input: std::option::Option<i64>) -> Self {
            self.to = input;
            self
        }
        /// <p>The name of S3 bucket for the exported log data. The bucket must be in the same Amazon Web Services region.</p>
        pub fn destination(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination = Some(input.into());
            self
        }
        pub fn set_destination(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.destination = input;
            self
        }
        /// <p>The prefix used as the start of the key for every object exported. If you don't
        /// specify a value, the default is <code>exportedlogs</code>.</p>
        pub fn destination_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination_prefix = Some(input.into());
            self
        }
        pub fn set_destination_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.destination_prefix = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateExportTaskInput`](crate::input::CreateExportTaskInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateExportTaskInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateExportTaskInput {
                task_name: self.task_name,
                log_group_name: self.log_group_name,
                log_stream_name_prefix: self.log_stream_name_prefix,
                from: self.from,
                to: self.to,
                destination: self.destination,
                destination_prefix: self.destination_prefix,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateExportTaskInputOperationOutputAlias = crate::operation::CreateExportTask;
#[doc(hidden)]
pub type CreateExportTaskInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateExportTaskInput {
    /// Consumes the builder and constructs an Operation<[`CreateExportTask`](crate::operation::CreateExportTask)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::CreateExportTask,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_crate_operation_create_export_task(&self)
                    .map_err(|err| {
                        smithy_http::operation::BuildError::SerializationError(err.into())
                    })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::CreateExportTask::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "CreateExportTask",
                "cloudwatchlogs",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("content-type"),
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("x-amz-target"),
            "Logs_20140328.CreateExportTask",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateExportTaskInput`](crate::input::CreateExportTaskInput)
    pub fn builder() -> crate::input::create_export_task_input::Builder {
        crate::input::create_export_task_input::Builder::default()
    }
}

/// See [`CreateLogGroupInput`](crate::input::CreateLogGroupInput)
pub mod create_log_group_input {
    /// A builder for [`CreateLogGroupInput`](crate::input::CreateLogGroupInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) log_group_name: std::option::Option<std::string::String>,
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The name of the log group.</p>
        pub fn log_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.log_group_name = Some(input.into());
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.log_group_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the CMK to use when encrypting log data.
        /// For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-kms">Amazon Resource Names - Key Management Service</a>.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateLogGroupInput`](crate::input::CreateLogGroupInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateLogGroupInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateLogGroupInput {
                log_group_name: self.log_group_name,
                kms_key_id: self.kms_key_id,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateLogGroupInputOperationOutputAlias = crate::operation::CreateLogGroup;
#[doc(hidden)]
pub type CreateLogGroupInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateLogGroupInput {
    /// Consumes the builder and constructs an Operation<[`CreateLogGroup`](crate::operation::CreateLogGroup)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::CreateLogGroup,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_crate_operation_create_log_group(&self)
                    .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::CreateLogGroup::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "CreateLogGroup",
                "cloudwatchlogs",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("content-type"),
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("x-amz-target"),
            "Logs_20140328.CreateLogGroup",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateLogGroupInput`](crate::input::CreateLogGroupInput)
    pub fn builder() -> crate::input::create_log_group_input::Builder {
        crate::input::create_log_group_input::Builder::default()
    }
}

/// See [`CreateLogStreamInput`](crate::input::CreateLogStreamInput)
pub mod create_log_stream_input {
    /// A builder for [`CreateLogStreamInput`](crate::input::CreateLogStreamInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) log_group_name: std::option::Option<std::string::String>,
        pub(crate) log_stream_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the log group.</p>
        pub fn log_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.log_group_name = Some(input.into());
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.log_group_name = input;
            self
        }
        /// <p>The name of the log stream.</p>
        pub fn log_stream_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.log_stream_name = Some(input.into());
            self
        }
        pub fn set_log_stream_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.log_stream_name = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateLogStreamInput`](crate::input::CreateLogStreamInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateLogStreamInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateLogStreamInput {
                log_group_name: self.log_group_name,
                log_stream_name: self.log_stream_name,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateLogStreamInputOperationOutputAlias = crate::operation::CreateLogStream;
#[doc(hidden)]
pub type CreateLogStreamInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl CreateLogStreamInput {
    /// Consumes the builder and constructs an Operation<[`CreateLogStream`](crate::operation::CreateLogStream)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::CreateLogStream,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_crate_operation_create_log_stream(&self)
                    .map_err(|err| {
                        smithy_http::operation::BuildError::SerializationError(err.into())
                    })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::CreateLogStream::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "CreateLogStream",
                "cloudwatchlogs",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("content-type"),
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("x-amz-target"),
            "Logs_20140328.CreateLogStream",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateLogStreamInput`](crate::input::CreateLogStreamInput)
    pub fn builder() -> crate::input::create_log_stream_input::Builder {
        crate::input::create_log_stream_input::Builder::default()
    }
}

/// See [`DeleteDestinationInput`](crate::input::DeleteDestinationInput)
pub mod delete_destination_input {
    /// A builder for [`DeleteDestinationInput`](crate::input::DeleteDestinationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) destination_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the destination.</p>
        pub fn destination_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination_name = Some(input.into());
            self
        }
        pub fn set_destination_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.destination_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteDestinationInput`](crate::input::DeleteDestinationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteDestinationInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteDestinationInput {
                destination_name: self.destination_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteDestinationInputOperationOutputAlias = crate::operation::DeleteDestination;
#[doc(hidden)]
pub type DeleteDestinationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteDestinationInput {
    /// Consumes the builder and constructs an Operation<[`DeleteDestination`](crate::operation::DeleteDestination)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteDestination,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_crate_operation_delete_destination(&self)
                    .map_err(|err| {
                        smithy_http::operation::BuildError::SerializationError(err.into())
                    })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeleteDestination::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DeleteDestination",
                "cloudwatchlogs",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("content-type"),
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("x-amz-target"),
            "Logs_20140328.DeleteDestination",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteDestinationInput`](crate::input::DeleteDestinationInput)
    pub fn builder() -> crate::input::delete_destination_input::Builder {
        crate::input::delete_destination_input::Builder::default()
    }
}

/// See [`DeleteLogGroupInput`](crate::input::DeleteLogGroupInput)
pub mod delete_log_group_input {
    /// A builder for [`DeleteLogGroupInput`](crate::input::DeleteLogGroupInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) log_group_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the log group.</p>
        pub fn log_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.log_group_name = Some(input.into());
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.log_group_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteLogGroupInput`](crate::input::DeleteLogGroupInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteLogGroupInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteLogGroupInput {
                log_group_name: self.log_group_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteLogGroupInputOperationOutputAlias = crate::operation::DeleteLogGroup;
#[doc(hidden)]
pub type DeleteLogGroupInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteLogGroupInput {
    /// Consumes the builder and constructs an Operation<[`DeleteLogGroup`](crate::operation::DeleteLogGroup)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteLogGroup,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_crate_operation_delete_log_group(&self)
                    .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeleteLogGroup::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DeleteLogGroup",
                "cloudwatchlogs",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("content-type"),
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("x-amz-target"),
            "Logs_20140328.DeleteLogGroup",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteLogGroupInput`](crate::input::DeleteLogGroupInput)
    pub fn builder() -> crate::input::delete_log_group_input::Builder {
        crate::input::delete_log_group_input::Builder::default()
    }
}

/// See [`DeleteLogStreamInput`](crate::input::DeleteLogStreamInput)
pub mod delete_log_stream_input {
    /// A builder for [`DeleteLogStreamInput`](crate::input::DeleteLogStreamInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) log_group_name: std::option::Option<std::string::String>,
        pub(crate) log_stream_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the log group.</p>
        pub fn log_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.log_group_name = Some(input.into());
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.log_group_name = input;
            self
        }
        /// <p>The name of the log stream.</p>
        pub fn log_stream_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.log_stream_name = Some(input.into());
            self
        }
        pub fn set_log_stream_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.log_stream_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteLogStreamInput`](crate::input::DeleteLogStreamInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteLogStreamInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteLogStreamInput {
                log_group_name: self.log_group_name,
                log_stream_name: self.log_stream_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteLogStreamInputOperationOutputAlias = crate::operation::DeleteLogStream;
#[doc(hidden)]
pub type DeleteLogStreamInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteLogStreamInput {
    /// Consumes the builder and constructs an Operation<[`DeleteLogStream`](crate::operation::DeleteLogStream)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteLogStream,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_crate_operation_delete_log_stream(&self)
                    .map_err(|err| {
                        smithy_http::operation::BuildError::SerializationError(err.into())
                    })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeleteLogStream::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DeleteLogStream",
                "cloudwatchlogs",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("content-type"),
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("x-amz-target"),
            "Logs_20140328.DeleteLogStream",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteLogStreamInput`](crate::input::DeleteLogStreamInput)
    pub fn builder() -> crate::input::delete_log_stream_input::Builder {
        crate::input::delete_log_stream_input::Builder::default()
    }
}

/// See [`DeleteMetricFilterInput`](crate::input::DeleteMetricFilterInput)
pub mod delete_metric_filter_input {
    /// A builder for [`DeleteMetricFilterInput`](crate::input::DeleteMetricFilterInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) log_group_name: std::option::Option<std::string::String>,
        pub(crate) filter_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the log group.</p>
        pub fn log_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.log_group_name = Some(input.into());
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.log_group_name = input;
            self
        }
        /// <p>The name of the metric filter.</p>
        pub fn filter_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.filter_name = Some(input.into());
            self
        }
        pub fn set_filter_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.filter_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteMetricFilterInput`](crate::input::DeleteMetricFilterInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteMetricFilterInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteMetricFilterInput {
                log_group_name: self.log_group_name,
                filter_name: self.filter_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteMetricFilterInputOperationOutputAlias = crate::operation::DeleteMetricFilter;
#[doc(hidden)]
pub type DeleteMetricFilterInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteMetricFilterInput {
    /// Consumes the builder and constructs an Operation<[`DeleteMetricFilter`](crate::operation::DeleteMetricFilter)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteMetricFilter,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_crate_operation_delete_metric_filter(
                    &self,
                )
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeleteMetricFilter::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DeleteMetricFilter",
                "cloudwatchlogs",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("content-type"),
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("x-amz-target"),
            "Logs_20140328.DeleteMetricFilter",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteMetricFilterInput`](crate::input::DeleteMetricFilterInput)
    pub fn builder() -> crate::input::delete_metric_filter_input::Builder {
        crate::input::delete_metric_filter_input::Builder::default()
    }
}

/// See [`DeleteQueryDefinitionInput`](crate::input::DeleteQueryDefinitionInput)
pub mod delete_query_definition_input {
    /// A builder for [`DeleteQueryDefinitionInput`](crate::input::DeleteQueryDefinitionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) query_definition_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the query definition that you want to delete. You can use <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_DescribeQueryDefinitions.html">DescribeQueryDefinitions</a> to retrieve the
        /// IDs of your saved query definitions.</p>
        pub fn query_definition_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.query_definition_id = Some(input.into());
            self
        }
        pub fn set_query_definition_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.query_definition_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteQueryDefinitionInput`](crate::input::DeleteQueryDefinitionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteQueryDefinitionInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteQueryDefinitionInput {
                query_definition_id: self.query_definition_id,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteQueryDefinitionInputOperationOutputAlias = crate::operation::DeleteQueryDefinition;
#[doc(hidden)]
pub type DeleteQueryDefinitionInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteQueryDefinitionInput {
    /// Consumes the builder and constructs an Operation<[`DeleteQueryDefinition`](crate::operation::DeleteQueryDefinition)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteQueryDefinition,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_crate_operation_delete_query_definition(
                    &self,
                )
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeleteQueryDefinition::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DeleteQueryDefinition",
                "cloudwatchlogs",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("content-type"),
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("x-amz-target"),
            "Logs_20140328.DeleteQueryDefinition",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteQueryDefinitionInput`](crate::input::DeleteQueryDefinitionInput)
    pub fn builder() -> crate::input::delete_query_definition_input::Builder {
        crate::input::delete_query_definition_input::Builder::default()
    }
}

/// See [`DeleteResourcePolicyInput`](crate::input::DeleteResourcePolicyInput)
pub mod delete_resource_policy_input {
    /// A builder for [`DeleteResourcePolicyInput`](crate::input::DeleteResourcePolicyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) policy_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the policy to be revoked. This parameter is required.</p>
        pub fn policy_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_name = Some(input.into());
            self
        }
        pub fn set_policy_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.policy_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteResourcePolicyInput`](crate::input::DeleteResourcePolicyInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteResourcePolicyInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteResourcePolicyInput {
                policy_name: self.policy_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteResourcePolicyInputOperationOutputAlias = crate::operation::DeleteResourcePolicy;
#[doc(hidden)]
pub type DeleteResourcePolicyInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteResourcePolicyInput {
    /// Consumes the builder and constructs an Operation<[`DeleteResourcePolicy`](crate::operation::DeleteResourcePolicy)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteResourcePolicy,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_crate_operation_delete_resource_policy(
                    &self,
                )
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeleteResourcePolicy::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DeleteResourcePolicy",
                "cloudwatchlogs",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("content-type"),
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("x-amz-target"),
            "Logs_20140328.DeleteResourcePolicy",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteResourcePolicyInput`](crate::input::DeleteResourcePolicyInput)
    pub fn builder() -> crate::input::delete_resource_policy_input::Builder {
        crate::input::delete_resource_policy_input::Builder::default()
    }
}

/// See [`DeleteRetentionPolicyInput`](crate::input::DeleteRetentionPolicyInput)
pub mod delete_retention_policy_input {
    /// A builder for [`DeleteRetentionPolicyInput`](crate::input::DeleteRetentionPolicyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) log_group_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the log group.</p>
        pub fn log_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.log_group_name = Some(input.into());
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.log_group_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteRetentionPolicyInput`](crate::input::DeleteRetentionPolicyInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteRetentionPolicyInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteRetentionPolicyInput {
                log_group_name: self.log_group_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteRetentionPolicyInputOperationOutputAlias = crate::operation::DeleteRetentionPolicy;
#[doc(hidden)]
pub type DeleteRetentionPolicyInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteRetentionPolicyInput {
    /// Consumes the builder and constructs an Operation<[`DeleteRetentionPolicy`](crate::operation::DeleteRetentionPolicy)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteRetentionPolicy,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_crate_operation_delete_retention_policy(
                    &self,
                )
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeleteRetentionPolicy::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DeleteRetentionPolicy",
                "cloudwatchlogs",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("content-type"),
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("x-amz-target"),
            "Logs_20140328.DeleteRetentionPolicy",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteRetentionPolicyInput`](crate::input::DeleteRetentionPolicyInput)
    pub fn builder() -> crate::input::delete_retention_policy_input::Builder {
        crate::input::delete_retention_policy_input::Builder::default()
    }
}

/// See [`DeleteSubscriptionFilterInput`](crate::input::DeleteSubscriptionFilterInput)
pub mod delete_subscription_filter_input {
    /// A builder for [`DeleteSubscriptionFilterInput`](crate::input::DeleteSubscriptionFilterInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) log_group_name: std::option::Option<std::string::String>,
        pub(crate) filter_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the log group.</p>
        pub fn log_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.log_group_name = Some(input.into());
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.log_group_name = input;
            self
        }
        /// <p>The name of the subscription filter.</p>
        pub fn filter_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.filter_name = Some(input.into());
            self
        }
        pub fn set_filter_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.filter_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteSubscriptionFilterInput`](crate::input::DeleteSubscriptionFilterInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteSubscriptionFilterInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteSubscriptionFilterInput {
                log_group_name: self.log_group_name,
                filter_name: self.filter_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteSubscriptionFilterInputOperationOutputAlias =
    crate::operation::DeleteSubscriptionFilter;
#[doc(hidden)]
pub type DeleteSubscriptionFilterInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DeleteSubscriptionFilterInput {
    /// Consumes the builder and constructs an Operation<[`DeleteSubscriptionFilter`](crate::operation::DeleteSubscriptionFilter)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteSubscriptionFilter,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_crate_operation_delete_subscription_filter(&self).map_err(|err|smithy_http::operation::BuildError::SerializationError(err.into()))?
            ;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeleteSubscriptionFilter::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DeleteSubscriptionFilter",
                "cloudwatchlogs",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("content-type"),
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("x-amz-target"),
            "Logs_20140328.DeleteSubscriptionFilter",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteSubscriptionFilterInput`](crate::input::DeleteSubscriptionFilterInput)
    pub fn builder() -> crate::input::delete_subscription_filter_input::Builder {
        crate::input::delete_subscription_filter_input::Builder::default()
    }
}

/// See [`DescribeDestinationsInput`](crate::input::DescribeDestinationsInput)
pub mod describe_destinations_input {
    /// A builder for [`DescribeDestinationsInput`](crate::input::DescribeDestinationsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) destination_name_prefix: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) limit: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The prefix to match. If you don't specify a value, no prefix filter is applied.</p>
        pub fn destination_name_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination_name_prefix = Some(input.into());
            self
        }
        pub fn set_destination_name_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.destination_name_prefix = input;
            self
        }
        /// <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of items returned. If you don't specify a value, the default is up to 50 items.</p>
        pub fn limit(mut self, input: i32) -> Self {
            self.limit = Some(input);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.limit = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeDestinationsInput`](crate::input::DescribeDestinationsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeDestinationsInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeDestinationsInput {
                destination_name_prefix: self.destination_name_prefix,
                next_token: self.next_token,
                limit: self.limit,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeDestinationsInputOperationOutputAlias = crate::operation::DescribeDestinations;
#[doc(hidden)]
pub type DescribeDestinationsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DescribeDestinationsInput {
    /// Consumes the builder and constructs an Operation<[`DescribeDestinations`](crate::operation::DescribeDestinations)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DescribeDestinations,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_crate_operation_describe_destinations(
                    &self,
                )
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DescribeDestinations::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DescribeDestinations",
                "cloudwatchlogs",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("content-type"),
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("x-amz-target"),
            "Logs_20140328.DescribeDestinations",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DescribeDestinationsInput`](crate::input::DescribeDestinationsInput)
    pub fn builder() -> crate::input::describe_destinations_input::Builder {
        crate::input::describe_destinations_input::Builder::default()
    }
}

/// See [`DescribeExportTasksInput`](crate::input::DescribeExportTasksInput)
pub mod describe_export_tasks_input {
    /// A builder for [`DescribeExportTasksInput`](crate::input::DescribeExportTasksInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) task_id: std::option::Option<std::string::String>,
        pub(crate) status_code: std::option::Option<crate::model::ExportTaskStatusCode>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) limit: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The ID of the export task. Specifying a task ID filters the results to zero or one export tasks.</p>
        pub fn task_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.task_id = Some(input.into());
            self
        }
        pub fn set_task_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.task_id = input;
            self
        }
        /// <p>The status code of the export task. Specifying a status code filters the results to zero or more export tasks.</p>
        pub fn status_code(mut self, input: crate::model::ExportTaskStatusCode) -> Self {
            self.status_code = Some(input);
            self
        }
        pub fn set_status_code(
            mut self,
            input: std::option::Option<crate::model::ExportTaskStatusCode>,
        ) -> Self {
            self.status_code = input;
            self
        }
        /// <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of items returned. If you don't specify a value, the default is up to 50 items.</p>
        pub fn limit(mut self, input: i32) -> Self {
            self.limit = Some(input);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.limit = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeExportTasksInput`](crate::input::DescribeExportTasksInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeExportTasksInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeExportTasksInput {
                task_id: self.task_id,
                status_code: self.status_code,
                next_token: self.next_token,
                limit: self.limit,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeExportTasksInputOperationOutputAlias = crate::operation::DescribeExportTasks;
#[doc(hidden)]
pub type DescribeExportTasksInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DescribeExportTasksInput {
    /// Consumes the builder and constructs an Operation<[`DescribeExportTasks`](crate::operation::DescribeExportTasks)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DescribeExportTasks,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_crate_operation_describe_export_tasks(
                    &self,
                )
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DescribeExportTasks::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DescribeExportTasks",
                "cloudwatchlogs",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("content-type"),
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("x-amz-target"),
            "Logs_20140328.DescribeExportTasks",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DescribeExportTasksInput`](crate::input::DescribeExportTasksInput)
    pub fn builder() -> crate::input::describe_export_tasks_input::Builder {
        crate::input::describe_export_tasks_input::Builder::default()
    }
}

/// See [`DescribeLogGroupsInput`](crate::input::DescribeLogGroupsInput)
pub mod describe_log_groups_input {
    /// A builder for [`DescribeLogGroupsInput`](crate::input::DescribeLogGroupsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) log_group_name_prefix: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) limit: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The prefix to match.</p>
        pub fn log_group_name_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.log_group_name_prefix = Some(input.into());
            self
        }
        pub fn set_log_group_name_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.log_group_name_prefix = input;
            self
        }
        /// <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of items returned. If you don't specify a value, the default is up to 50 items.</p>
        pub fn limit(mut self, input: i32) -> Self {
            self.limit = Some(input);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.limit = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeLogGroupsInput`](crate::input::DescribeLogGroupsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeLogGroupsInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeLogGroupsInput {
                log_group_name_prefix: self.log_group_name_prefix,
                next_token: self.next_token,
                limit: self.limit,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeLogGroupsInputOperationOutputAlias = crate::operation::DescribeLogGroups;
#[doc(hidden)]
pub type DescribeLogGroupsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DescribeLogGroupsInput {
    /// Consumes the builder and constructs an Operation<[`DescribeLogGroups`](crate::operation::DescribeLogGroups)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DescribeLogGroups,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_crate_operation_describe_log_groups(
                    &self,
                )
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DescribeLogGroups::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DescribeLogGroups",
                "cloudwatchlogs",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("content-type"),
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("x-amz-target"),
            "Logs_20140328.DescribeLogGroups",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DescribeLogGroupsInput`](crate::input::DescribeLogGroupsInput)
    pub fn builder() -> crate::input::describe_log_groups_input::Builder {
        crate::input::describe_log_groups_input::Builder::default()
    }
}

/// See [`DescribeLogStreamsInput`](crate::input::DescribeLogStreamsInput)
pub mod describe_log_streams_input {
    /// A builder for [`DescribeLogStreamsInput`](crate::input::DescribeLogStreamsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) log_group_name: std::option::Option<std::string::String>,
        pub(crate) log_stream_name_prefix: std::option::Option<std::string::String>,
        pub(crate) order_by: std::option::Option<crate::model::OrderBy>,
        pub(crate) descending: std::option::Option<bool>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) limit: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The name of the log group.</p>
        pub fn log_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.log_group_name = Some(input.into());
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.log_group_name = input;
            self
        }
        /// <p>The prefix to match.</p>
        /// <p>If <code>orderBy</code> is <code>LastEventTime</code>, you cannot specify this
        /// parameter.</p>
        pub fn log_stream_name_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.log_stream_name_prefix = Some(input.into());
            self
        }
        pub fn set_log_stream_name_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.log_stream_name_prefix = input;
            self
        }
        /// <p>If the value is <code>LogStreamName</code>, the results are ordered by log stream name.
        /// If the value is <code>LastEventTime</code>, the results are ordered by the event time.
        /// The default value is <code>LogStreamName</code>.</p>
        /// <p>If you order the results by event time, you cannot specify the <code>logStreamNamePrefix</code> parameter.</p>
        /// <p>
        /// <code>lastEventTimestamp</code> represents the time of the most recent log event in the
        /// log stream in CloudWatch Logs. This number is expressed as the number of milliseconds after
        /// Jan 1, 1970 00:00:00 UTC. <code>lastEventTimestamp</code> updates on an eventual consistency
        /// basis. It typically updates in less than an hour from ingestion, but in rare situations might
        /// take longer.</p>
        pub fn order_by(mut self, input: crate::model::OrderBy) -> Self {
            self.order_by = Some(input);
            self
        }
        pub fn set_order_by(mut self, input: std::option::Option<crate::model::OrderBy>) -> Self {
            self.order_by = input;
            self
        }
        /// <p>If the value is true, results are returned in descending order.
        /// If the value is to false, results are returned in ascending order.
        /// The default value is false.</p>
        pub fn descending(mut self, input: bool) -> Self {
            self.descending = Some(input);
            self
        }
        pub fn set_descending(mut self, input: std::option::Option<bool>) -> Self {
            self.descending = input;
            self
        }
        /// <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of items returned. If you don't specify a value, the default is up to 50 items.</p>
        pub fn limit(mut self, input: i32) -> Self {
            self.limit = Some(input);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.limit = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeLogStreamsInput`](crate::input::DescribeLogStreamsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeLogStreamsInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeLogStreamsInput {
                log_group_name: self.log_group_name,
                log_stream_name_prefix: self.log_stream_name_prefix,
                order_by: self.order_by,
                descending: self.descending,
                next_token: self.next_token,
                limit: self.limit,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeLogStreamsInputOperationOutputAlias = crate::operation::DescribeLogStreams;
#[doc(hidden)]
pub type DescribeLogStreamsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DescribeLogStreamsInput {
    /// Consumes the builder and constructs an Operation<[`DescribeLogStreams`](crate::operation::DescribeLogStreams)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DescribeLogStreams,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_crate_operation_describe_log_streams(
                    &self,
                )
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DescribeLogStreams::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DescribeLogStreams",
                "cloudwatchlogs",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("content-type"),
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("x-amz-target"),
            "Logs_20140328.DescribeLogStreams",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DescribeLogStreamsInput`](crate::input::DescribeLogStreamsInput)
    pub fn builder() -> crate::input::describe_log_streams_input::Builder {
        crate::input::describe_log_streams_input::Builder::default()
    }
}

/// See [`DescribeMetricFiltersInput`](crate::input::DescribeMetricFiltersInput)
pub mod describe_metric_filters_input {
    /// A builder for [`DescribeMetricFiltersInput`](crate::input::DescribeMetricFiltersInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) log_group_name: std::option::Option<std::string::String>,
        pub(crate) filter_name_prefix: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) limit: std::option::Option<i32>,
        pub(crate) metric_name: std::option::Option<std::string::String>,
        pub(crate) metric_namespace: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the log group.</p>
        pub fn log_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.log_group_name = Some(input.into());
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.log_group_name = input;
            self
        }
        /// <p>The prefix to match. CloudWatch Logs uses the value you set here
        /// only if you also include the <code>logGroupName</code> parameter in your request.</p>
        pub fn filter_name_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.filter_name_prefix = Some(input.into());
            self
        }
        pub fn set_filter_name_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.filter_name_prefix = input;
            self
        }
        /// <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of items returned. If you don't specify a value, the default is up to 50 items.</p>
        pub fn limit(mut self, input: i32) -> Self {
            self.limit = Some(input);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.limit = input;
            self
        }
        /// <p>Filters results to include only those with the specified metric name. If you include this parameter in your request, you
        /// must also include the <code>metricNamespace</code> parameter.</p>
        pub fn metric_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.metric_name = Some(input.into());
            self
        }
        pub fn set_metric_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.metric_name = input;
            self
        }
        /// <p>Filters results to include only those in the specified namespace. If you include this parameter in your request, you
        /// must also include the <code>metricName</code> parameter.</p>
        pub fn metric_namespace(mut self, input: impl Into<std::string::String>) -> Self {
            self.metric_namespace = Some(input.into());
            self
        }
        pub fn set_metric_namespace(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.metric_namespace = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeMetricFiltersInput`](crate::input::DescribeMetricFiltersInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeMetricFiltersInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeMetricFiltersInput {
                log_group_name: self.log_group_name,
                filter_name_prefix: self.filter_name_prefix,
                next_token: self.next_token,
                limit: self.limit,
                metric_name: self.metric_name,
                metric_namespace: self.metric_namespace,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeMetricFiltersInputOperationOutputAlias = crate::operation::DescribeMetricFilters;
#[doc(hidden)]
pub type DescribeMetricFiltersInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DescribeMetricFiltersInput {
    /// Consumes the builder and constructs an Operation<[`DescribeMetricFilters`](crate::operation::DescribeMetricFilters)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DescribeMetricFilters,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_crate_operation_describe_metric_filters(
                    &self,
                )
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DescribeMetricFilters::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DescribeMetricFilters",
                "cloudwatchlogs",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("content-type"),
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("x-amz-target"),
            "Logs_20140328.DescribeMetricFilters",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DescribeMetricFiltersInput`](crate::input::DescribeMetricFiltersInput)
    pub fn builder() -> crate::input::describe_metric_filters_input::Builder {
        crate::input::describe_metric_filters_input::Builder::default()
    }
}

/// See [`DescribeQueriesInput`](crate::input::DescribeQueriesInput)
pub mod describe_queries_input {
    /// A builder for [`DescribeQueriesInput`](crate::input::DescribeQueriesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) log_group_name: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::QueryStatus>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Limits the returned queries to only those for the specified log group.</p>
        pub fn log_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.log_group_name = Some(input.into());
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.log_group_name = input;
            self
        }
        /// <p>Limits the returned queries to only those that have the specified status. Valid values are <code>Cancelled</code>,
        /// <code>Complete</code>, <code>Failed</code>, <code>Running</code>, and <code>Scheduled</code>.</p>
        pub fn status(mut self, input: crate::model::QueryStatus) -> Self {
            self.status = Some(input);
            self
        }
        pub fn set_status(mut self, input: std::option::Option<crate::model::QueryStatus>) -> Self {
            self.status = input;
            self
        }
        /// <p>Limits the number of returned queries to the specified number.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token for the next set of items to return. The token expires after 24 hours.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeQueriesInput`](crate::input::DescribeQueriesInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeQueriesInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeQueriesInput {
                log_group_name: self.log_group_name,
                status: self.status,
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeQueriesInputOperationOutputAlias = crate::operation::DescribeQueries;
#[doc(hidden)]
pub type DescribeQueriesInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DescribeQueriesInput {
    /// Consumes the builder and constructs an Operation<[`DescribeQueries`](crate::operation::DescribeQueries)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DescribeQueries,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_crate_operation_describe_queries(&self)
                    .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DescribeQueries::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DescribeQueries",
                "cloudwatchlogs",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("content-type"),
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("x-amz-target"),
            "Logs_20140328.DescribeQueries",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DescribeQueriesInput`](crate::input::DescribeQueriesInput)
    pub fn builder() -> crate::input::describe_queries_input::Builder {
        crate::input::describe_queries_input::Builder::default()
    }
}

/// See [`DescribeQueryDefinitionsInput`](crate::input::DescribeQueryDefinitionsInput)
pub mod describe_query_definitions_input {
    /// A builder for [`DescribeQueryDefinitionsInput`](crate::input::DescribeQueryDefinitionsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) query_definition_name_prefix: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Use this parameter to filter your results to only the query definitions that have names that start with the prefix you specify.</p>
        pub fn query_definition_name_prefix(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.query_definition_name_prefix = Some(input.into());
            self
        }
        pub fn set_query_definition_name_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.query_definition_name_prefix = input;
            self
        }
        /// <p>Limits the number of returned query definitions to the specified number.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token for the next set of items to return. The token expires after 24 hours.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeQueryDefinitionsInput`](crate::input::DescribeQueryDefinitionsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeQueryDefinitionsInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeQueryDefinitionsInput {
                query_definition_name_prefix: self.query_definition_name_prefix,
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeQueryDefinitionsInputOperationOutputAlias =
    crate::operation::DescribeQueryDefinitions;
#[doc(hidden)]
pub type DescribeQueryDefinitionsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DescribeQueryDefinitionsInput {
    /// Consumes the builder and constructs an Operation<[`DescribeQueryDefinitions`](crate::operation::DescribeQueryDefinitions)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DescribeQueryDefinitions,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_crate_operation_describe_query_definitions(&self).map_err(|err|smithy_http::operation::BuildError::SerializationError(err.into()))?
            ;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DescribeQueryDefinitions::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DescribeQueryDefinitions",
                "cloudwatchlogs",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("content-type"),
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("x-amz-target"),
            "Logs_20140328.DescribeQueryDefinitions",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DescribeQueryDefinitionsInput`](crate::input::DescribeQueryDefinitionsInput)
    pub fn builder() -> crate::input::describe_query_definitions_input::Builder {
        crate::input::describe_query_definitions_input::Builder::default()
    }
}

/// See [`DescribeResourcePoliciesInput`](crate::input::DescribeResourcePoliciesInput)
pub mod describe_resource_policies_input {
    /// A builder for [`DescribeResourcePoliciesInput`](crate::input::DescribeResourcePoliciesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) limit: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The token for the next set of items to return. The token expires after 24 hours.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of resource policies to be displayed with one call of this API.</p>
        pub fn limit(mut self, input: i32) -> Self {
            self.limit = Some(input);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.limit = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeResourcePoliciesInput`](crate::input::DescribeResourcePoliciesInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeResourcePoliciesInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeResourcePoliciesInput {
                next_token: self.next_token,
                limit: self.limit,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeResourcePoliciesInputOperationOutputAlias =
    crate::operation::DescribeResourcePolicies;
#[doc(hidden)]
pub type DescribeResourcePoliciesInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DescribeResourcePoliciesInput {
    /// Consumes the builder and constructs an Operation<[`DescribeResourcePolicies`](crate::operation::DescribeResourcePolicies)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DescribeResourcePolicies,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_crate_operation_describe_resource_policies(&self).map_err(|err|smithy_http::operation::BuildError::SerializationError(err.into()))?
            ;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DescribeResourcePolicies::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DescribeResourcePolicies",
                "cloudwatchlogs",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("content-type"),
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("x-amz-target"),
            "Logs_20140328.DescribeResourcePolicies",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DescribeResourcePoliciesInput`](crate::input::DescribeResourcePoliciesInput)
    pub fn builder() -> crate::input::describe_resource_policies_input::Builder {
        crate::input::describe_resource_policies_input::Builder::default()
    }
}

/// See [`DescribeSubscriptionFiltersInput`](crate::input::DescribeSubscriptionFiltersInput)
pub mod describe_subscription_filters_input {
    /// A builder for [`DescribeSubscriptionFiltersInput`](crate::input::DescribeSubscriptionFiltersInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) log_group_name: std::option::Option<std::string::String>,
        pub(crate) filter_name_prefix: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) limit: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The name of the log group.</p>
        pub fn log_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.log_group_name = Some(input.into());
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.log_group_name = input;
            self
        }
        /// <p>The prefix to match. If you don't specify a value, no prefix filter is applied.</p>
        pub fn filter_name_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.filter_name_prefix = Some(input.into());
            self
        }
        pub fn set_filter_name_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.filter_name_prefix = input;
            self
        }
        /// <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of items returned. If you don't specify a value, the default is up to 50 items.</p>
        pub fn limit(mut self, input: i32) -> Self {
            self.limit = Some(input);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.limit = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeSubscriptionFiltersInput`](crate::input::DescribeSubscriptionFiltersInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeSubscriptionFiltersInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeSubscriptionFiltersInput {
                log_group_name: self.log_group_name,
                filter_name_prefix: self.filter_name_prefix,
                next_token: self.next_token,
                limit: self.limit,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeSubscriptionFiltersInputOperationOutputAlias =
    crate::operation::DescribeSubscriptionFilters;
#[doc(hidden)]
pub type DescribeSubscriptionFiltersInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DescribeSubscriptionFiltersInput {
    /// Consumes the builder and constructs an Operation<[`DescribeSubscriptionFilters`](crate::operation::DescribeSubscriptionFilters)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DescribeSubscriptionFilters,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_crate_operation_describe_subscription_filters(&self).map_err(|err|smithy_http::operation::BuildError::SerializationError(err.into()))?
            ;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DescribeSubscriptionFilters::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DescribeSubscriptionFilters",
                "cloudwatchlogs",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("content-type"),
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("x-amz-target"),
            "Logs_20140328.DescribeSubscriptionFilters",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DescribeSubscriptionFiltersInput`](crate::input::DescribeSubscriptionFiltersInput)
    pub fn builder() -> crate::input::describe_subscription_filters_input::Builder {
        crate::input::describe_subscription_filters_input::Builder::default()
    }
}

/// See [`DisassociateKmsKeyInput`](crate::input::DisassociateKmsKeyInput)
pub mod disassociate_kms_key_input {
    /// A builder for [`DisassociateKmsKeyInput`](crate::input::DisassociateKmsKeyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) log_group_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the log group.</p>
        pub fn log_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.log_group_name = Some(input.into());
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.log_group_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DisassociateKmsKeyInput`](crate::input::DisassociateKmsKeyInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DisassociateKmsKeyInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DisassociateKmsKeyInput {
                log_group_name: self.log_group_name,
            })
        }
    }
}
#[doc(hidden)]
pub type DisassociateKmsKeyInputOperationOutputAlias = crate::operation::DisassociateKmsKey;
#[doc(hidden)]
pub type DisassociateKmsKeyInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DisassociateKmsKeyInput {
    /// Consumes the builder and constructs an Operation<[`DisassociateKmsKey`](crate::operation::DisassociateKmsKey)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DisassociateKmsKey,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_crate_operation_disassociate_kms_key(
                    &self,
                )
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DisassociateKmsKey::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DisassociateKmsKey",
                "cloudwatchlogs",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("content-type"),
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("x-amz-target"),
            "Logs_20140328.DisassociateKmsKey",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DisassociateKmsKeyInput`](crate::input::DisassociateKmsKeyInput)
    pub fn builder() -> crate::input::disassociate_kms_key_input::Builder {
        crate::input::disassociate_kms_key_input::Builder::default()
    }
}

/// See [`FilterLogEventsInput`](crate::input::FilterLogEventsInput)
pub mod filter_log_events_input {
    /// A builder for [`FilterLogEventsInput`](crate::input::FilterLogEventsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) log_group_name: std::option::Option<std::string::String>,
        pub(crate) log_stream_names: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) log_stream_name_prefix: std::option::Option<std::string::String>,
        pub(crate) start_time: std::option::Option<i64>,
        pub(crate) end_time: std::option::Option<i64>,
        pub(crate) filter_pattern: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) limit: std::option::Option<i32>,
        pub(crate) interleaved: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The name of the log group to search.</p>
        pub fn log_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.log_group_name = Some(input.into());
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.log_group_name = input;
            self
        }
        pub fn log_stream_names(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.log_stream_names.unwrap_or_default();
            v.push(input.into());
            self.log_stream_names = Some(v);
            self
        }
        pub fn set_log_stream_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.log_stream_names = input;
            self
        }
        /// <p>Filters the results to include only events from log streams that have names starting with this prefix.</p>
        /// <p>If you specify a value for both <code>logStreamNamePrefix</code> and <code>logStreamNames</code>, but the value for
        /// <code>logStreamNamePrefix</code> does not match any log stream names specified in <code>logStreamNames</code>, the action
        /// returns an <code>InvalidParameterException</code> error.</p>
        pub fn log_stream_name_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.log_stream_name_prefix = Some(input.into());
            self
        }
        pub fn set_log_stream_name_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.log_stream_name_prefix = input;
            self
        }
        /// <p>The start of the time range, expressed as the number of milliseconds after Jan 1, 1970
        /// 00:00:00 UTC. Events with a timestamp before this time are not returned.</p>
        pub fn start_time(mut self, input: i64) -> Self {
            self.start_time = Some(input);
            self
        }
        pub fn set_start_time(mut self, input: std::option::Option<i64>) -> Self {
            self.start_time = input;
            self
        }
        /// <p>The end of the time range, expressed as the number of milliseconds after Jan 1, 1970
        /// 00:00:00 UTC. Events with a timestamp later than this time are not returned.</p>
        pub fn end_time(mut self, input: i64) -> Self {
            self.end_time = Some(input);
            self
        }
        pub fn set_end_time(mut self, input: std::option::Option<i64>) -> Self {
            self.end_time = input;
            self
        }
        /// <p>The filter pattern to use. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/FilterAndPatternSyntax.html">Filter and Pattern Syntax</a>.</p>
        /// <p>If not provided, all the events are matched.</p>
        pub fn filter_pattern(mut self, input: impl Into<std::string::String>) -> Self {
            self.filter_pattern = Some(input.into());
            self
        }
        pub fn set_filter_pattern(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.filter_pattern = input;
            self
        }
        /// <p>The token for the next set of events to return. (You received this token from a previous call.)</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of events to return. The default is 10,000 events.</p>
        pub fn limit(mut self, input: i32) -> Self {
            self.limit = Some(input);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.limit = input;
            self
        }
        /// <p>If the value is true, the operation makes a best effort to provide responses that
        /// contain events from multiple log streams within the log group, interleaved in a single
        /// response. If the value is false, all the matched log events in the first log stream are
        /// searched first, then those in the next log stream, and so on. The default is false.</p>
        /// <p>
        /// <b>Important:</b> Starting on June 17, 2019, this parameter
        /// is ignored and the value is assumed to be true. The response from this operation always
        /// interleaves events from multiple log streams within a log group.</p>
        pub fn interleaved(mut self, input: bool) -> Self {
            self.interleaved = Some(input);
            self
        }
        pub fn set_interleaved(mut self, input: std::option::Option<bool>) -> Self {
            self.interleaved = input;
            self
        }
        /// Consumes the builder and constructs a [`FilterLogEventsInput`](crate::input::FilterLogEventsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::FilterLogEventsInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::FilterLogEventsInput {
                log_group_name: self.log_group_name,
                log_stream_names: self.log_stream_names,
                log_stream_name_prefix: self.log_stream_name_prefix,
                start_time: self.start_time,
                end_time: self.end_time,
                filter_pattern: self.filter_pattern,
                next_token: self.next_token,
                limit: self.limit,
                interleaved: self.interleaved,
            })
        }
    }
}
#[doc(hidden)]
pub type FilterLogEventsInputOperationOutputAlias = crate::operation::FilterLogEvents;
#[doc(hidden)]
pub type FilterLogEventsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl FilterLogEventsInput {
    /// Consumes the builder and constructs an Operation<[`FilterLogEvents`](crate::operation::FilterLogEvents)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::FilterLogEvents,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_crate_operation_filter_log_events(&self)
                    .map_err(|err| {
                        smithy_http::operation::BuildError::SerializationError(err.into())
                    })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::FilterLogEvents::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "FilterLogEvents",
                "cloudwatchlogs",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("content-type"),
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("x-amz-target"),
            "Logs_20140328.FilterLogEvents",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`FilterLogEventsInput`](crate::input::FilterLogEventsInput)
    pub fn builder() -> crate::input::filter_log_events_input::Builder {
        crate::input::filter_log_events_input::Builder::default()
    }
}

/// See [`GetLogEventsInput`](crate::input::GetLogEventsInput)
pub mod get_log_events_input {
    /// A builder for [`GetLogEventsInput`](crate::input::GetLogEventsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) log_group_name: std::option::Option<std::string::String>,
        pub(crate) log_stream_name: std::option::Option<std::string::String>,
        pub(crate) start_time: std::option::Option<i64>,
        pub(crate) end_time: std::option::Option<i64>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) limit: std::option::Option<i32>,
        pub(crate) start_from_head: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The name of the log group.</p>
        pub fn log_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.log_group_name = Some(input.into());
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.log_group_name = input;
            self
        }
        /// <p>The name of the log stream.</p>
        pub fn log_stream_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.log_stream_name = Some(input.into());
            self
        }
        pub fn set_log_stream_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.log_stream_name = input;
            self
        }
        /// <p>The start of the time range, expressed as the number of milliseconds after Jan 1, 1970
        /// 00:00:00 UTC. Events with a timestamp equal to this time or later than this time are included.
        /// Events with a timestamp earlier than this time are not included.</p>
        pub fn start_time(mut self, input: i64) -> Self {
            self.start_time = Some(input);
            self
        }
        pub fn set_start_time(mut self, input: std::option::Option<i64>) -> Self {
            self.start_time = input;
            self
        }
        /// <p>The end of the time range, expressed as the number of milliseconds after Jan 1, 1970
        /// 00:00:00 UTC. Events with a timestamp equal to or later than this time are not
        /// included.</p>
        pub fn end_time(mut self, input: i64) -> Self {
            self.end_time = Some(input);
            self
        }
        pub fn set_end_time(mut self, input: std::option::Option<i64>) -> Self {
            self.end_time = input;
            self
        }
        /// <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The maximum number of log events returned. If you don't specify a value, the maximum is
        /// as many log events as can fit in a response size of 1 MB, up to 10,000 log events.</p>
        pub fn limit(mut self, input: i32) -> Self {
            self.limit = Some(input);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.limit = input;
            self
        }
        /// <p>If the value is true, the earliest log events are returned first.
        /// If the value is false, the latest log events are returned first.
        /// The default value is false.</p>
        /// <p>If you are using a previous <code>nextForwardToken</code> value as the <code>nextToken</code> in this operation,
        /// you must specify <code>true</code> for <code>startFromHead</code>.</p>
        pub fn start_from_head(mut self, input: bool) -> Self {
            self.start_from_head = Some(input);
            self
        }
        pub fn set_start_from_head(mut self, input: std::option::Option<bool>) -> Self {
            self.start_from_head = input;
            self
        }
        /// Consumes the builder and constructs a [`GetLogEventsInput`](crate::input::GetLogEventsInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::GetLogEventsInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::GetLogEventsInput {
                log_group_name: self.log_group_name,
                log_stream_name: self.log_stream_name,
                start_time: self.start_time,
                end_time: self.end_time,
                next_token: self.next_token,
                limit: self.limit,
                start_from_head: self.start_from_head,
            })
        }
    }
}
#[doc(hidden)]
pub type GetLogEventsInputOperationOutputAlias = crate::operation::GetLogEvents;
#[doc(hidden)]
pub type GetLogEventsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetLogEventsInput {
    /// Consumes the builder and constructs an Operation<[`GetLogEvents`](crate::operation::GetLogEvents)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetLogEvents,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_crate_operation_get_log_events(&self)
                    .map_err(|err| {
                        smithy_http::operation::BuildError::SerializationError(err.into())
                    })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetLogEvents::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetLogEvents",
                "cloudwatchlogs",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("content-type"),
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("x-amz-target"),
            "Logs_20140328.GetLogEvents",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetLogEventsInput`](crate::input::GetLogEventsInput)
    pub fn builder() -> crate::input::get_log_events_input::Builder {
        crate::input::get_log_events_input::Builder::default()
    }
}

/// See [`GetLogGroupFieldsInput`](crate::input::GetLogGroupFieldsInput)
pub mod get_log_group_fields_input {
    /// A builder for [`GetLogGroupFieldsInput`](crate::input::GetLogGroupFieldsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) log_group_name: std::option::Option<std::string::String>,
        pub(crate) time: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The name of the log group to search.</p>
        pub fn log_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.log_group_name = Some(input.into());
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.log_group_name = input;
            self
        }
        /// <p>The time to set as the center of the query. If you specify <code>time</code>, the 15 minutes
        /// before this time are queries. If you omit <code>time</code> the 8
        /// minutes before and 8 minutes after this time are searched.</p>
        /// <p>The <code>time</code> value is specified as epoch time, the number of seconds since
        /// January 1, 1970, 00:00:00 UTC.</p>
        pub fn time(mut self, input: i64) -> Self {
            self.time = Some(input);
            self
        }
        pub fn set_time(mut self, input: std::option::Option<i64>) -> Self {
            self.time = input;
            self
        }
        /// Consumes the builder and constructs a [`GetLogGroupFieldsInput`](crate::input::GetLogGroupFieldsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetLogGroupFieldsInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetLogGroupFieldsInput {
                log_group_name: self.log_group_name,
                time: self.time,
            })
        }
    }
}
#[doc(hidden)]
pub type GetLogGroupFieldsInputOperationOutputAlias = crate::operation::GetLogGroupFields;
#[doc(hidden)]
pub type GetLogGroupFieldsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetLogGroupFieldsInput {
    /// Consumes the builder and constructs an Operation<[`GetLogGroupFields`](crate::operation::GetLogGroupFields)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetLogGroupFields,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_crate_operation_get_log_group_fields(
                    &self,
                )
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetLogGroupFields::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetLogGroupFields",
                "cloudwatchlogs",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("content-type"),
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("x-amz-target"),
            "Logs_20140328.GetLogGroupFields",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetLogGroupFieldsInput`](crate::input::GetLogGroupFieldsInput)
    pub fn builder() -> crate::input::get_log_group_fields_input::Builder {
        crate::input::get_log_group_fields_input::Builder::default()
    }
}

/// See [`GetLogRecordInput`](crate::input::GetLogRecordInput)
pub mod get_log_record_input {
    /// A builder for [`GetLogRecordInput`](crate::input::GetLogRecordInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) log_record_pointer: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The pointer corresponding to the log event record you want to retrieve. You get this from
        /// the response of a <code>GetQueryResults</code> operation. In that response, the value of the
        /// <code>@ptr</code> field for a log event is the value to use as <code>logRecordPointer</code>
        /// to retrieve that complete log event record.</p>
        pub fn log_record_pointer(mut self, input: impl Into<std::string::String>) -> Self {
            self.log_record_pointer = Some(input.into());
            self
        }
        pub fn set_log_record_pointer(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.log_record_pointer = input;
            self
        }
        /// Consumes the builder and constructs a [`GetLogRecordInput`](crate::input::GetLogRecordInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::GetLogRecordInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::GetLogRecordInput {
                log_record_pointer: self.log_record_pointer,
            })
        }
    }
}
#[doc(hidden)]
pub type GetLogRecordInputOperationOutputAlias = crate::operation::GetLogRecord;
#[doc(hidden)]
pub type GetLogRecordInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetLogRecordInput {
    /// Consumes the builder and constructs an Operation<[`GetLogRecord`](crate::operation::GetLogRecord)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetLogRecord,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_crate_operation_get_log_record(&self)
                    .map_err(|err| {
                        smithy_http::operation::BuildError::SerializationError(err.into())
                    })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetLogRecord::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetLogRecord",
                "cloudwatchlogs",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("content-type"),
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("x-amz-target"),
            "Logs_20140328.GetLogRecord",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetLogRecordInput`](crate::input::GetLogRecordInput)
    pub fn builder() -> crate::input::get_log_record_input::Builder {
        crate::input::get_log_record_input::Builder::default()
    }
}

/// See [`GetQueryResultsInput`](crate::input::GetQueryResultsInput)
pub mod get_query_results_input {
    /// A builder for [`GetQueryResultsInput`](crate::input::GetQueryResultsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) query_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID number of the query.</p>
        pub fn query_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.query_id = Some(input.into());
            self
        }
        pub fn set_query_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.query_id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetQueryResultsInput`](crate::input::GetQueryResultsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetQueryResultsInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetQueryResultsInput {
                query_id: self.query_id,
            })
        }
    }
}
#[doc(hidden)]
pub type GetQueryResultsInputOperationOutputAlias = crate::operation::GetQueryResults;
#[doc(hidden)]
pub type GetQueryResultsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetQueryResultsInput {
    /// Consumes the builder and constructs an Operation<[`GetQueryResults`](crate::operation::GetQueryResults)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetQueryResults,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_crate_operation_get_query_results(&self)
                    .map_err(|err| {
                        smithy_http::operation::BuildError::SerializationError(err.into())
                    })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetQueryResults::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetQueryResults",
                "cloudwatchlogs",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("content-type"),
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("x-amz-target"),
            "Logs_20140328.GetQueryResults",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetQueryResultsInput`](crate::input::GetQueryResultsInput)
    pub fn builder() -> crate::input::get_query_results_input::Builder {
        crate::input::get_query_results_input::Builder::default()
    }
}

/// See [`ListTagsLogGroupInput`](crate::input::ListTagsLogGroupInput)
pub mod list_tags_log_group_input {
    /// A builder for [`ListTagsLogGroupInput`](crate::input::ListTagsLogGroupInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) log_group_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the log group.</p>
        pub fn log_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.log_group_name = Some(input.into());
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.log_group_name = input;
            self
        }
        /// Consumes the builder and constructs a [`ListTagsLogGroupInput`](crate::input::ListTagsLogGroupInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListTagsLogGroupInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListTagsLogGroupInput {
                log_group_name: self.log_group_name,
            })
        }
    }
}
#[doc(hidden)]
pub type ListTagsLogGroupInputOperationOutputAlias = crate::operation::ListTagsLogGroup;
#[doc(hidden)]
pub type ListTagsLogGroupInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl ListTagsLogGroupInput {
    /// Consumes the builder and constructs an Operation<[`ListTagsLogGroup`](crate::operation::ListTagsLogGroup)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::ListTagsLogGroup,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_crate_operation_list_tags_log_group(
                    &self,
                )
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListTagsLogGroup::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ListTagsLogGroup",
                "cloudwatchlogs",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("content-type"),
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("x-amz-target"),
            "Logs_20140328.ListTagsLogGroup",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListTagsLogGroupInput`](crate::input::ListTagsLogGroupInput)
    pub fn builder() -> crate::input::list_tags_log_group_input::Builder {
        crate::input::list_tags_log_group_input::Builder::default()
    }
}

/// See [`PutDestinationInput`](crate::input::PutDestinationInput)
pub mod put_destination_input {
    /// A builder for [`PutDestinationInput`](crate::input::PutDestinationInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) destination_name: std::option::Option<std::string::String>,
        pub(crate) target_arn: std::option::Option<std::string::String>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A name for the destination.</p>
        pub fn destination_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination_name = Some(input.into());
            self
        }
        pub fn set_destination_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.destination_name = input;
            self
        }
        /// <p>The ARN of an Amazon Kinesis stream to which to deliver matching log events.</p>
        pub fn target_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.target_arn = Some(input.into());
            self
        }
        pub fn set_target_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.target_arn = input;
            self
        }
        /// <p>The ARN of an IAM role that grants CloudWatch Logs permissions to call the Amazon
        /// Kinesis <code>PutRecord</code> operation on the destination stream.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`PutDestinationInput`](crate::input::PutDestinationInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutDestinationInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutDestinationInput {
                destination_name: self.destination_name,
                target_arn: self.target_arn,
                role_arn: self.role_arn,
            })
        }
    }
}
#[doc(hidden)]
pub type PutDestinationInputOperationOutputAlias = crate::operation::PutDestination;
#[doc(hidden)]
pub type PutDestinationInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutDestinationInput {
    /// Consumes the builder and constructs an Operation<[`PutDestination`](crate::operation::PutDestination)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::PutDestination,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_crate_operation_put_destination(&self)
                    .map_err(|err| {
                        smithy_http::operation::BuildError::SerializationError(err.into())
                    })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::PutDestination::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "PutDestination",
                "cloudwatchlogs",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("content-type"),
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("x-amz-target"),
            "Logs_20140328.PutDestination",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutDestinationInput`](crate::input::PutDestinationInput)
    pub fn builder() -> crate::input::put_destination_input::Builder {
        crate::input::put_destination_input::Builder::default()
    }
}

/// See [`PutDestinationPolicyInput`](crate::input::PutDestinationPolicyInput)
pub mod put_destination_policy_input {
    /// A builder for [`PutDestinationPolicyInput`](crate::input::PutDestinationPolicyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) destination_name: std::option::Option<std::string::String>,
        pub(crate) access_policy: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A name for an existing destination.</p>
        pub fn destination_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination_name = Some(input.into());
            self
        }
        pub fn set_destination_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.destination_name = input;
            self
        }
        /// <p>An IAM policy document that authorizes cross-account users to deliver their log events
        /// to the associated destination. This can be up to 5120 bytes.</p>
        pub fn access_policy(mut self, input: impl Into<std::string::String>) -> Self {
            self.access_policy = Some(input.into());
            self
        }
        pub fn set_access_policy(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.access_policy = input;
            self
        }
        /// Consumes the builder and constructs a [`PutDestinationPolicyInput`](crate::input::PutDestinationPolicyInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutDestinationPolicyInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutDestinationPolicyInput {
                destination_name: self.destination_name,
                access_policy: self.access_policy,
            })
        }
    }
}
#[doc(hidden)]
pub type PutDestinationPolicyInputOperationOutputAlias = crate::operation::PutDestinationPolicy;
#[doc(hidden)]
pub type PutDestinationPolicyInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutDestinationPolicyInput {
    /// Consumes the builder and constructs an Operation<[`PutDestinationPolicy`](crate::operation::PutDestinationPolicy)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::PutDestinationPolicy,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_crate_operation_put_destination_policy(
                    &self,
                )
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::PutDestinationPolicy::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "PutDestinationPolicy",
                "cloudwatchlogs",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("content-type"),
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("x-amz-target"),
            "Logs_20140328.PutDestinationPolicy",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutDestinationPolicyInput`](crate::input::PutDestinationPolicyInput)
    pub fn builder() -> crate::input::put_destination_policy_input::Builder {
        crate::input::put_destination_policy_input::Builder::default()
    }
}

/// See [`PutLogEventsInput`](crate::input::PutLogEventsInput)
pub mod put_log_events_input {
    /// A builder for [`PutLogEventsInput`](crate::input::PutLogEventsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) log_group_name: std::option::Option<std::string::String>,
        pub(crate) log_stream_name: std::option::Option<std::string::String>,
        pub(crate) log_events: std::option::Option<std::vec::Vec<crate::model::InputLogEvent>>,
        pub(crate) sequence_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the log group.</p>
        pub fn log_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.log_group_name = Some(input.into());
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.log_group_name = input;
            self
        }
        /// <p>The name of the log stream.</p>
        pub fn log_stream_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.log_stream_name = Some(input.into());
            self
        }
        pub fn set_log_stream_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.log_stream_name = input;
            self
        }
        pub fn log_events(mut self, input: impl Into<crate::model::InputLogEvent>) -> Self {
            let mut v = self.log_events.unwrap_or_default();
            v.push(input.into());
            self.log_events = Some(v);
            self
        }
        pub fn set_log_events(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::InputLogEvent>>,
        ) -> Self {
            self.log_events = input;
            self
        }
        /// <p>The sequence token obtained from the response of the previous <code>PutLogEvents</code>
        /// call. An upload in a newly created log stream does not require a sequence token. You can also
        /// get the sequence token using <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_DescribeLogStreams.html">DescribeLogStreams</a>. If you call <code>PutLogEvents</code> twice within a narrow
        /// time period using the same value for <code>sequenceToken</code>, both calls might be
        /// successful or one might be rejected.</p>
        pub fn sequence_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.sequence_token = Some(input.into());
            self
        }
        pub fn set_sequence_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sequence_token = input;
            self
        }
        /// Consumes the builder and constructs a [`PutLogEventsInput`](crate::input::PutLogEventsInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::PutLogEventsInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::PutLogEventsInput {
                log_group_name: self.log_group_name,
                log_stream_name: self.log_stream_name,
                log_events: self.log_events,
                sequence_token: self.sequence_token,
            })
        }
    }
}
#[doc(hidden)]
pub type PutLogEventsInputOperationOutputAlias = crate::operation::PutLogEvents;
#[doc(hidden)]
pub type PutLogEventsInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutLogEventsInput {
    /// Consumes the builder and constructs an Operation<[`PutLogEvents`](crate::operation::PutLogEvents)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::PutLogEvents,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_crate_operation_put_log_events(&self)
                    .map_err(|err| {
                        smithy_http::operation::BuildError::SerializationError(err.into())
                    })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::PutLogEvents::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "PutLogEvents",
                "cloudwatchlogs",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("content-type"),
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("x-amz-target"),
            "Logs_20140328.PutLogEvents",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutLogEventsInput`](crate::input::PutLogEventsInput)
    pub fn builder() -> crate::input::put_log_events_input::Builder {
        crate::input::put_log_events_input::Builder::default()
    }
}

/// See [`PutMetricFilterInput`](crate::input::PutMetricFilterInput)
pub mod put_metric_filter_input {
    /// A builder for [`PutMetricFilterInput`](crate::input::PutMetricFilterInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) log_group_name: std::option::Option<std::string::String>,
        pub(crate) filter_name: std::option::Option<std::string::String>,
        pub(crate) filter_pattern: std::option::Option<std::string::String>,
        pub(crate) metric_transformations:
            std::option::Option<std::vec::Vec<crate::model::MetricTransformation>>,
    }
    impl Builder {
        /// <p>The name of the log group.</p>
        pub fn log_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.log_group_name = Some(input.into());
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.log_group_name = input;
            self
        }
        /// <p>A name for the metric filter.</p>
        pub fn filter_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.filter_name = Some(input.into());
            self
        }
        pub fn set_filter_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.filter_name = input;
            self
        }
        /// <p>A filter pattern for extracting metric data out of ingested log events.</p>
        pub fn filter_pattern(mut self, input: impl Into<std::string::String>) -> Self {
            self.filter_pattern = Some(input.into());
            self
        }
        pub fn set_filter_pattern(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.filter_pattern = input;
            self
        }
        pub fn metric_transformations(
            mut self,
            input: impl Into<crate::model::MetricTransformation>,
        ) -> Self {
            let mut v = self.metric_transformations.unwrap_or_default();
            v.push(input.into());
            self.metric_transformations = Some(v);
            self
        }
        pub fn set_metric_transformations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MetricTransformation>>,
        ) -> Self {
            self.metric_transformations = input;
            self
        }
        /// Consumes the builder and constructs a [`PutMetricFilterInput`](crate::input::PutMetricFilterInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutMetricFilterInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutMetricFilterInput {
                log_group_name: self.log_group_name,
                filter_name: self.filter_name,
                filter_pattern: self.filter_pattern,
                metric_transformations: self.metric_transformations,
            })
        }
    }
}
#[doc(hidden)]
pub type PutMetricFilterInputOperationOutputAlias = crate::operation::PutMetricFilter;
#[doc(hidden)]
pub type PutMetricFilterInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutMetricFilterInput {
    /// Consumes the builder and constructs an Operation<[`PutMetricFilter`](crate::operation::PutMetricFilter)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::PutMetricFilter,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_crate_operation_put_metric_filter(&self)
                    .map_err(|err| {
                        smithy_http::operation::BuildError::SerializationError(err.into())
                    })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::PutMetricFilter::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "PutMetricFilter",
                "cloudwatchlogs",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("content-type"),
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("x-amz-target"),
            "Logs_20140328.PutMetricFilter",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutMetricFilterInput`](crate::input::PutMetricFilterInput)
    pub fn builder() -> crate::input::put_metric_filter_input::Builder {
        crate::input::put_metric_filter_input::Builder::default()
    }
}

/// See [`PutQueryDefinitionInput`](crate::input::PutQueryDefinitionInput)
pub mod put_query_definition_input {
    /// A builder for [`PutQueryDefinitionInput`](crate::input::PutQueryDefinitionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) query_definition_id: std::option::Option<std::string::String>,
        pub(crate) log_group_names: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) query_string: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A name for the query definition. If you are saving a lot of query definitions, we
        /// recommend that you name them so that you can easily find the ones you want by using the first
        /// part of the name as a filter in the <code>queryDefinitionNamePrefix</code> parameter of <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_DescribeQueryDefinitions.html">DescribeQueryDefinitions</a>.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>If you are updating a query definition, use this parameter to specify the ID of the query
        /// definition that you want to update. You can use <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_DescribeQueryDefinitions.html">DescribeQueryDefinitions</a> to retrieve the IDs of your saved query
        /// definitions.</p>
        /// <p>If you are creating a query definition, do not specify this parameter. CloudWatch
        /// generates a unique ID for the new query definition and include it in the response to this
        /// operation.</p>
        pub fn query_definition_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.query_definition_id = Some(input.into());
            self
        }
        pub fn set_query_definition_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.query_definition_id = input;
            self
        }
        pub fn log_group_names(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.log_group_names.unwrap_or_default();
            v.push(input.into());
            self.log_group_names = Some(v);
            self
        }
        pub fn set_log_group_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.log_group_names = input;
            self
        }
        /// <p>The query string to use for this definition.
        /// For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CWL_QuerySyntax.html">CloudWatch Logs Insights Query Syntax</a>.</p>
        pub fn query_string(mut self, input: impl Into<std::string::String>) -> Self {
            self.query_string = Some(input.into());
            self
        }
        pub fn set_query_string(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.query_string = input;
            self
        }
        /// Consumes the builder and constructs a [`PutQueryDefinitionInput`](crate::input::PutQueryDefinitionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutQueryDefinitionInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutQueryDefinitionInput {
                name: self.name,
                query_definition_id: self.query_definition_id,
                log_group_names: self.log_group_names,
                query_string: self.query_string,
            })
        }
    }
}
#[doc(hidden)]
pub type PutQueryDefinitionInputOperationOutputAlias = crate::operation::PutQueryDefinition;
#[doc(hidden)]
pub type PutQueryDefinitionInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutQueryDefinitionInput {
    /// Consumes the builder and constructs an Operation<[`PutQueryDefinition`](crate::operation::PutQueryDefinition)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::PutQueryDefinition,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_crate_operation_put_query_definition(
                    &self,
                )
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::PutQueryDefinition::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "PutQueryDefinition",
                "cloudwatchlogs",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("content-type"),
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("x-amz-target"),
            "Logs_20140328.PutQueryDefinition",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutQueryDefinitionInput`](crate::input::PutQueryDefinitionInput)
    pub fn builder() -> crate::input::put_query_definition_input::Builder {
        crate::input::put_query_definition_input::Builder::default()
    }
}

/// See [`PutResourcePolicyInput`](crate::input::PutResourcePolicyInput)
pub mod put_resource_policy_input {
    /// A builder for [`PutResourcePolicyInput`](crate::input::PutResourcePolicyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) policy_name: std::option::Option<std::string::String>,
        pub(crate) policy_document: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Name of the new policy. This parameter is required.</p>
        pub fn policy_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_name = Some(input.into());
            self
        }
        pub fn set_policy_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.policy_name = input;
            self
        }
        /// <p>Details of the new policy, including the identity of the principal that is enabled to put logs to this account. This is formatted as a JSON string.
        /// This parameter is required.</p>
        /// <p>The following example creates a resource policy enabling the Route 53 service to put
        /// DNS query logs in to the specified log group. Replace <code>"logArn"</code> with the ARN of
        /// your CloudWatch Logs resource, such as a log group or log stream.</p>
        /// <p>CloudWatch Logs also supports <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_condition-keys.html#condition-keys-sourcearn">aws:SourceArn</a>
        /// and <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_condition-keys.html#condition-keys-sourceaccount">aws:SourceAccount</a>
        /// condition context keys.</p>
        /// <p>In the example resource policy, you would replace the value of <code>SourceArn</code> with the resource making the
        /// call from Route 53 to CloudWatch Logs and replace the value of <code>SourceAccount</code> with
        /// the Amazon Web Services account ID making that call.</p>
        /// <p></p>
        /// <p>
        /// <code>{
        /// "Version": "2012-10-17",
        /// "Statement": [
        /// {
        /// "Sid": "Route53LogsToCloudWatchLogs",
        /// "Effect": "Allow",
        /// "Principal": {
        /// "Service": [
        /// "route53.amazonaws.com"
        /// ]
        /// },
        /// "Action": "logs:PutLogEvents",
        /// "Resource": "logArn",
        /// "Condition": {
        /// "ArnLike": {
        /// "aws:SourceArn": "myRoute53ResourceArn"
        /// },
        /// "StringEquals": {
        /// "aws:SourceAccount": "myAwsAccountId"
        /// }
        /// }
        /// }
        /// ]
        /// }</code>
        /// </p>
        pub fn policy_document(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_document = Some(input.into());
            self
        }
        pub fn set_policy_document(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.policy_document = input;
            self
        }
        /// Consumes the builder and constructs a [`PutResourcePolicyInput`](crate::input::PutResourcePolicyInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutResourcePolicyInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutResourcePolicyInput {
                policy_name: self.policy_name,
                policy_document: self.policy_document,
            })
        }
    }
}
#[doc(hidden)]
pub type PutResourcePolicyInputOperationOutputAlias = crate::operation::PutResourcePolicy;
#[doc(hidden)]
pub type PutResourcePolicyInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutResourcePolicyInput {
    /// Consumes the builder and constructs an Operation<[`PutResourcePolicy`](crate::operation::PutResourcePolicy)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::PutResourcePolicy,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_crate_operation_put_resource_policy(
                    &self,
                )
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::PutResourcePolicy::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "PutResourcePolicy",
                "cloudwatchlogs",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("content-type"),
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("x-amz-target"),
            "Logs_20140328.PutResourcePolicy",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutResourcePolicyInput`](crate::input::PutResourcePolicyInput)
    pub fn builder() -> crate::input::put_resource_policy_input::Builder {
        crate::input::put_resource_policy_input::Builder::default()
    }
}

/// See [`PutRetentionPolicyInput`](crate::input::PutRetentionPolicyInput)
pub mod put_retention_policy_input {
    /// A builder for [`PutRetentionPolicyInput`](crate::input::PutRetentionPolicyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) log_group_name: std::option::Option<std::string::String>,
        pub(crate) retention_in_days: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The name of the log group.</p>
        pub fn log_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.log_group_name = Some(input.into());
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.log_group_name = input;
            self
        }
        /// <p>The number of days to retain the log events in the specified log group.
        /// Possible values are: 1, 3, 5, 7, 14, 30, 60, 90, 120, 150, 180, 365, 400, 545, 731, 1827, and 3653.</p>
        /// <p>To set a log group to never have log events expire, use
        /// <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_DeleteRetentionPolicy.html">DeleteRetentionPolicy</a>.
        /// </p>
        pub fn retention_in_days(mut self, input: i32) -> Self {
            self.retention_in_days = Some(input);
            self
        }
        pub fn set_retention_in_days(mut self, input: std::option::Option<i32>) -> Self {
            self.retention_in_days = input;
            self
        }
        /// Consumes the builder and constructs a [`PutRetentionPolicyInput`](crate::input::PutRetentionPolicyInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutRetentionPolicyInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutRetentionPolicyInput {
                log_group_name: self.log_group_name,
                retention_in_days: self.retention_in_days,
            })
        }
    }
}
#[doc(hidden)]
pub type PutRetentionPolicyInputOperationOutputAlias = crate::operation::PutRetentionPolicy;
#[doc(hidden)]
pub type PutRetentionPolicyInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutRetentionPolicyInput {
    /// Consumes the builder and constructs an Operation<[`PutRetentionPolicy`](crate::operation::PutRetentionPolicy)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::PutRetentionPolicy,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_crate_operation_put_retention_policy(
                    &self,
                )
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::PutRetentionPolicy::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "PutRetentionPolicy",
                "cloudwatchlogs",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("content-type"),
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("x-amz-target"),
            "Logs_20140328.PutRetentionPolicy",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutRetentionPolicyInput`](crate::input::PutRetentionPolicyInput)
    pub fn builder() -> crate::input::put_retention_policy_input::Builder {
        crate::input::put_retention_policy_input::Builder::default()
    }
}

/// See [`PutSubscriptionFilterInput`](crate::input::PutSubscriptionFilterInput)
pub mod put_subscription_filter_input {
    /// A builder for [`PutSubscriptionFilterInput`](crate::input::PutSubscriptionFilterInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) log_group_name: std::option::Option<std::string::String>,
        pub(crate) filter_name: std::option::Option<std::string::String>,
        pub(crate) filter_pattern: std::option::Option<std::string::String>,
        pub(crate) destination_arn: std::option::Option<std::string::String>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
        pub(crate) distribution: std::option::Option<crate::model::Distribution>,
    }
    impl Builder {
        /// <p>The name of the log group.</p>
        pub fn log_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.log_group_name = Some(input.into());
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.log_group_name = input;
            self
        }
        /// <p>A name for the subscription filter. If you are updating an existing filter, you must
        /// specify the correct name in <code>filterName</code>. To find the name of the filter currently
        /// associated with a log group, use <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_DescribeSubscriptionFilters.html">DescribeSubscriptionFilters</a>.</p>
        pub fn filter_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.filter_name = Some(input.into());
            self
        }
        pub fn set_filter_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.filter_name = input;
            self
        }
        /// <p>A filter pattern for subscribing to a filtered stream of log events.</p>
        pub fn filter_pattern(mut self, input: impl Into<std::string::String>) -> Self {
            self.filter_pattern = Some(input.into());
            self
        }
        pub fn set_filter_pattern(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.filter_pattern = input;
            self
        }
        /// <p>The ARN of the destination to deliver matching log events to. Currently, the supported
        /// destinations are:</p>
        /// <ul>
        /// <li>
        /// <p>An Amazon Kinesis stream belonging to the same account as the subscription filter,
        /// for same-account delivery.</p>
        /// </li>
        /// <li>
        /// <p>A logical destination (specified using an ARN) belonging to a different account,
        /// for cross-account delivery.</p>
        /// <p>If you are setting up a cross-account subscription, the destination must have an
        /// IAM policy associated with it that allows the sender to send logs to the destination.
        /// For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_PutDestinationPolicy.html">PutDestinationPolicy</a>.</p>
        /// </li>
        /// <li>
        /// <p>An Amazon Kinesis Firehose delivery stream belonging to the same account as the
        /// subscription filter, for same-account delivery.</p>
        /// </li>
        /// <li>
        /// <p>A Lambda function belonging to the same account as the subscription filter,
        /// for same-account delivery.</p>
        /// </li>
        /// </ul>
        pub fn destination_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination_arn = Some(input.into());
            self
        }
        pub fn set_destination_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.destination_arn = input;
            self
        }
        /// <p>The ARN of an IAM role that grants CloudWatch Logs permissions to deliver ingested log
        /// events to the destination stream. You don't need to provide the ARN when you are working with
        /// a logical destination for cross-account delivery.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// <p>The method used to distribute log data to the destination. By default, log data is
        /// grouped by log stream, but the grouping can be set to random for a more even distribution.
        /// This property is only applicable when the destination is an Amazon Kinesis stream. </p>
        pub fn distribution(mut self, input: crate::model::Distribution) -> Self {
            self.distribution = Some(input);
            self
        }
        pub fn set_distribution(
            mut self,
            input: std::option::Option<crate::model::Distribution>,
        ) -> Self {
            self.distribution = input;
            self
        }
        /// Consumes the builder and constructs a [`PutSubscriptionFilterInput`](crate::input::PutSubscriptionFilterInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutSubscriptionFilterInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutSubscriptionFilterInput {
                log_group_name: self.log_group_name,
                filter_name: self.filter_name,
                filter_pattern: self.filter_pattern,
                destination_arn: self.destination_arn,
                role_arn: self.role_arn,
                distribution: self.distribution,
            })
        }
    }
}
#[doc(hidden)]
pub type PutSubscriptionFilterInputOperationOutputAlias = crate::operation::PutSubscriptionFilter;
#[doc(hidden)]
pub type PutSubscriptionFilterInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl PutSubscriptionFilterInput {
    /// Consumes the builder and constructs an Operation<[`PutSubscriptionFilter`](crate::operation::PutSubscriptionFilter)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::PutSubscriptionFilter,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_crate_operation_put_subscription_filter(
                    &self,
                )
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::PutSubscriptionFilter::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "PutSubscriptionFilter",
                "cloudwatchlogs",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("content-type"),
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("x-amz-target"),
            "Logs_20140328.PutSubscriptionFilter",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutSubscriptionFilterInput`](crate::input::PutSubscriptionFilterInput)
    pub fn builder() -> crate::input::put_subscription_filter_input::Builder {
        crate::input::put_subscription_filter_input::Builder::default()
    }
}

/// See [`StartQueryInput`](crate::input::StartQueryInput)
pub mod start_query_input {
    /// A builder for [`StartQueryInput`](crate::input::StartQueryInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) log_group_name: std::option::Option<std::string::String>,
        pub(crate) log_group_names: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) start_time: std::option::Option<i64>,
        pub(crate) end_time: std::option::Option<i64>,
        pub(crate) query_string: std::option::Option<std::string::String>,
        pub(crate) limit: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The log group on which to perform the query.</p>
        /// <p>A <code>StartQuery</code> operation must include a <code>logGroupNames</code> or a <code>logGroupName</code> parameter, but
        /// not both.</p>
        pub fn log_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.log_group_name = Some(input.into());
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.log_group_name = input;
            self
        }
        pub fn log_group_names(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.log_group_names.unwrap_or_default();
            v.push(input.into());
            self.log_group_names = Some(v);
            self
        }
        pub fn set_log_group_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.log_group_names = input;
            self
        }
        /// <p>The beginning of the time range to query. The range is inclusive, so the specified
        /// start time is included in the query. Specified as epoch time, the
        /// number of seconds since January 1, 1970, 00:00:00 UTC.</p>
        pub fn start_time(mut self, input: i64) -> Self {
            self.start_time = Some(input);
            self
        }
        pub fn set_start_time(mut self, input: std::option::Option<i64>) -> Self {
            self.start_time = input;
            self
        }
        /// <p>The end of the time range to query. The range is inclusive, so the specified
        /// end time is included in the query. Specified as epoch
        /// time, the number of seconds since January 1, 1970, 00:00:00 UTC.</p>
        pub fn end_time(mut self, input: i64) -> Self {
            self.end_time = Some(input);
            self
        }
        pub fn set_end_time(mut self, input: std::option::Option<i64>) -> Self {
            self.end_time = input;
            self
        }
        /// <p>The query string to use.
        /// For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CWL_QuerySyntax.html">CloudWatch Logs Insights Query Syntax</a>.</p>
        pub fn query_string(mut self, input: impl Into<std::string::String>) -> Self {
            self.query_string = Some(input.into());
            self
        }
        pub fn set_query_string(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.query_string = input;
            self
        }
        /// <p>The maximum number of log events to return in the query. If the query string uses the <code>fields</code> command,
        /// only the specified fields and their values are returned. The default is 1000.</p>
        pub fn limit(mut self, input: i32) -> Self {
            self.limit = Some(input);
            self
        }
        pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.limit = input;
            self
        }
        /// Consumes the builder and constructs a [`StartQueryInput`](crate::input::StartQueryInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::StartQueryInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::StartQueryInput {
                log_group_name: self.log_group_name,
                log_group_names: self.log_group_names,
                start_time: self.start_time,
                end_time: self.end_time,
                query_string: self.query_string,
                limit: self.limit,
            })
        }
    }
}
#[doc(hidden)]
pub type StartQueryInputOperationOutputAlias = crate::operation::StartQuery;
#[doc(hidden)]
pub type StartQueryInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl StartQueryInput {
    /// Consumes the builder and constructs an Operation<[`StartQuery`](crate::operation::StartQuery)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::StartQuery,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_crate_operation_start_query(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::StartQuery::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "StartQuery",
                "cloudwatchlogs",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("content-type"),
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("x-amz-target"),
            "Logs_20140328.StartQuery",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`StartQueryInput`](crate::input::StartQueryInput)
    pub fn builder() -> crate::input::start_query_input::Builder {
        crate::input::start_query_input::Builder::default()
    }
}

/// See [`StopQueryInput`](crate::input::StopQueryInput)
pub mod stop_query_input {
    /// A builder for [`StopQueryInput`](crate::input::StopQueryInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) query_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID number of the query to stop. To find this ID number, use
        /// <code>DescribeQueries</code>.</p>
        pub fn query_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.query_id = Some(input.into());
            self
        }
        pub fn set_query_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.query_id = input;
            self
        }
        /// Consumes the builder and constructs a [`StopQueryInput`](crate::input::StopQueryInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::StopQueryInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::StopQueryInput {
                query_id: self.query_id,
            })
        }
    }
}
#[doc(hidden)]
pub type StopQueryInputOperationOutputAlias = crate::operation::StopQuery;
#[doc(hidden)]
pub type StopQueryInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl StopQueryInput {
    /// Consumes the builder and constructs an Operation<[`StopQuery`](crate::operation::StopQuery)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::StopQuery,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_crate_operation_stop_query(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op =
                smithy_http::operation::Operation::new(request, crate::operation::StopQuery::new())
                    .with_metadata(smithy_http::operation::Metadata::new(
                        "StopQuery",
                        "cloudwatchlogs",
                    ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("content-type"),
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("x-amz-target"),
            "Logs_20140328.StopQuery",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`StopQueryInput`](crate::input::StopQueryInput)
    pub fn builder() -> crate::input::stop_query_input::Builder {
        crate::input::stop_query_input::Builder::default()
    }
}

/// See [`TagLogGroupInput`](crate::input::TagLogGroupInput)
pub mod tag_log_group_input {
    /// A builder for [`TagLogGroupInput`](crate::input::TagLogGroupInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) log_group_name: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The name of the log group.</p>
        pub fn log_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.log_group_name = Some(input.into());
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.log_group_name = input;
            self
        }
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`TagLogGroupInput`](crate::input::TagLogGroupInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::TagLogGroupInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::TagLogGroupInput {
                log_group_name: self.log_group_name,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type TagLogGroupInputOperationOutputAlias = crate::operation::TagLogGroup;
#[doc(hidden)]
pub type TagLogGroupInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl TagLogGroupInput {
    /// Consumes the builder and constructs an Operation<[`TagLogGroup`](crate::operation::TagLogGroup)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::TagLogGroup,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_crate_operation_tag_log_group(&self)
                    .map_err(|err| {
                        smithy_http::operation::BuildError::SerializationError(err.into())
                    })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::TagLogGroup::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "TagLogGroup",
                "cloudwatchlogs",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("content-type"),
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("x-amz-target"),
            "Logs_20140328.TagLogGroup",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`TagLogGroupInput`](crate::input::TagLogGroupInput)
    pub fn builder() -> crate::input::tag_log_group_input::Builder {
        crate::input::tag_log_group_input::Builder::default()
    }
}

/// See [`TestMetricFilterInput`](crate::input::TestMetricFilterInput)
pub mod test_metric_filter_input {
    /// A builder for [`TestMetricFilterInput`](crate::input::TestMetricFilterInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) filter_pattern: std::option::Option<std::string::String>,
        pub(crate) log_event_messages: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>A symbolic description of how CloudWatch Logs should interpret the data in each log
        /// event. For example, a log event can contain timestamps, IP addresses, strings, and so on. You
        /// use the filter pattern to specify what to look for in the log event message.</p>
        pub fn filter_pattern(mut self, input: impl Into<std::string::String>) -> Self {
            self.filter_pattern = Some(input.into());
            self
        }
        pub fn set_filter_pattern(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.filter_pattern = input;
            self
        }
        pub fn log_event_messages(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.log_event_messages.unwrap_or_default();
            v.push(input.into());
            self.log_event_messages = Some(v);
            self
        }
        pub fn set_log_event_messages(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.log_event_messages = input;
            self
        }
        /// Consumes the builder and constructs a [`TestMetricFilterInput`](crate::input::TestMetricFilterInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::TestMetricFilterInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::TestMetricFilterInput {
                filter_pattern: self.filter_pattern,
                log_event_messages: self.log_event_messages,
            })
        }
    }
}
#[doc(hidden)]
pub type TestMetricFilterInputOperationOutputAlias = crate::operation::TestMetricFilter;
#[doc(hidden)]
pub type TestMetricFilterInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl TestMetricFilterInput {
    /// Consumes the builder and constructs an Operation<[`TestMetricFilter`](crate::operation::TestMetricFilter)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::TestMetricFilter,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_crate_operation_test_metric_filter(&self)
                    .map_err(|err| {
                        smithy_http::operation::BuildError::SerializationError(err.into())
                    })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::TestMetricFilter::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "TestMetricFilter",
                "cloudwatchlogs",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("content-type"),
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("x-amz-target"),
            "Logs_20140328.TestMetricFilter",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`TestMetricFilterInput`](crate::input::TestMetricFilterInput)
    pub fn builder() -> crate::input::test_metric_filter_input::Builder {
        crate::input::test_metric_filter_input::Builder::default()
    }
}

/// See [`UntagLogGroupInput`](crate::input::UntagLogGroupInput)
pub mod untag_log_group_input {
    /// A builder for [`UntagLogGroupInput`](crate::input::UntagLogGroupInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) log_group_name: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The name of the log group.</p>
        pub fn log_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.log_group_name = Some(input.into());
            self
        }
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.log_group_name = input;
            self
        }
        pub fn tags(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`UntagLogGroupInput`](crate::input::UntagLogGroupInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::UntagLogGroupInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::UntagLogGroupInput {
                log_group_name: self.log_group_name,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type UntagLogGroupInputOperationOutputAlias = crate::operation::UntagLogGroup;
#[doc(hidden)]
pub type UntagLogGroupInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl UntagLogGroupInput {
    /// Consumes the builder and constructs an Operation<[`UntagLogGroup`](crate::operation::UntagLogGroup)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::UntagLogGroup,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let properties = smithy_http::property_bag::SharedPropertyBag::new();
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_crate_operation_untag_log_group(&self)
                    .map_err(|err| {
                        smithy_http::operation::BuildError::SerializationError(err.into())
                    })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request = smithy_http::operation::Request::from_parts(
                request.map(smithy_http::body::SdkBody::from),
                properties,
            );
            request.properties_mut().insert(
                aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ),
            );
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.properties_mut().insert(signing_config);
            request
                .properties_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.properties_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.properties_mut().insert(region.clone());
            }
            aws_auth::set_provider(
                &mut request.properties_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::UntagLogGroup::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "UntagLogGroup",
                "cloudwatchlogs",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("content-type"),
            "application/x-amz-json-1.1",
        );
        builder = smithy_http::header::set_header_if_absent(
            builder,
            http::header::HeaderName::from_static("x-amz-target"),
            "Logs_20140328.UntagLogGroup",
        );
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UntagLogGroupInput`](crate::input::UntagLogGroupInput)
    pub fn builder() -> crate::input::untag_log_group_input::Builder {
        crate::input::untag_log_group_input::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UntagLogGroupInput {
    /// <p>The name of the log group.</p>
    pub log_group_name: std::option::Option<std::string::String>,
    /// <p>The tag keys. The corresponding tags are removed from the log group.</p>
    pub tags: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for UntagLogGroupInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UntagLogGroupInput");
        formatter.field("log_group_name", &self.log_group_name);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TestMetricFilterInput {
    /// <p>A symbolic description of how CloudWatch Logs should interpret the data in each log
    /// event. For example, a log event can contain timestamps, IP addresses, strings, and so on. You
    /// use the filter pattern to specify what to look for in the log event message.</p>
    pub filter_pattern: std::option::Option<std::string::String>,
    /// <p>The log event messages to test.</p>
    pub log_event_messages: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for TestMetricFilterInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TestMetricFilterInput");
        formatter.field("filter_pattern", &self.filter_pattern);
        formatter.field("log_event_messages", &self.log_event_messages);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TagLogGroupInput {
    /// <p>The name of the log group.</p>
    pub log_group_name: std::option::Option<std::string::String>,
    /// <p>The key-value pairs to use for the tags.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl std::fmt::Debug for TagLogGroupInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TagLogGroupInput");
        formatter.field("log_group_name", &self.log_group_name);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StopQueryInput {
    /// <p>The ID number of the query to stop. To find this ID number, use
    /// <code>DescribeQueries</code>.</p>
    pub query_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for StopQueryInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StopQueryInput");
        formatter.field("query_id", &self.query_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StartQueryInput {
    /// <p>The log group on which to perform the query.</p>
    /// <p>A <code>StartQuery</code> operation must include a <code>logGroupNames</code> or a <code>logGroupName</code> parameter, but
    /// not both.</p>
    pub log_group_name: std::option::Option<std::string::String>,
    /// <p>The list of log groups to be queried. You can include up to 20 log groups.</p>
    /// <p>A <code>StartQuery</code> operation must include a <code>logGroupNames</code> or a <code>logGroupName</code> parameter, but
    /// not both.</p>
    pub log_group_names: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The beginning of the time range to query. The range is inclusive, so the specified
    /// start time is included in the query. Specified as epoch time, the
    /// number of seconds since January 1, 1970, 00:00:00 UTC.</p>
    pub start_time: std::option::Option<i64>,
    /// <p>The end of the time range to query. The range is inclusive, so the specified
    /// end time is included in the query. Specified as epoch
    /// time, the number of seconds since January 1, 1970, 00:00:00 UTC.</p>
    pub end_time: std::option::Option<i64>,
    /// <p>The query string to use.
    /// For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CWL_QuerySyntax.html">CloudWatch Logs Insights Query Syntax</a>.</p>
    pub query_string: std::option::Option<std::string::String>,
    /// <p>The maximum number of log events to return in the query. If the query string uses the <code>fields</code> command,
    /// only the specified fields and their values are returned. The default is 1000.</p>
    pub limit: std::option::Option<i32>,
}
impl std::fmt::Debug for StartQueryInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartQueryInput");
        formatter.field("log_group_name", &self.log_group_name);
        formatter.field("log_group_names", &self.log_group_names);
        formatter.field("start_time", &self.start_time);
        formatter.field("end_time", &self.end_time);
        formatter.field("query_string", &self.query_string);
        formatter.field("limit", &self.limit);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutSubscriptionFilterInput {
    /// <p>The name of the log group.</p>
    pub log_group_name: std::option::Option<std::string::String>,
    /// <p>A name for the subscription filter. If you are updating an existing filter, you must
    /// specify the correct name in <code>filterName</code>. To find the name of the filter currently
    /// associated with a log group, use <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_DescribeSubscriptionFilters.html">DescribeSubscriptionFilters</a>.</p>
    pub filter_name: std::option::Option<std::string::String>,
    /// <p>A filter pattern for subscribing to a filtered stream of log events.</p>
    pub filter_pattern: std::option::Option<std::string::String>,
    /// <p>The ARN of the destination to deliver matching log events to. Currently, the supported
    /// destinations are:</p>
    /// <ul>
    /// <li>
    /// <p>An Amazon Kinesis stream belonging to the same account as the subscription filter,
    /// for same-account delivery.</p>
    /// </li>
    /// <li>
    /// <p>A logical destination (specified using an ARN) belonging to a different account,
    /// for cross-account delivery.</p>
    /// <p>If you are setting up a cross-account subscription, the destination must have an
    /// IAM policy associated with it that allows the sender to send logs to the destination.
    /// For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_PutDestinationPolicy.html">PutDestinationPolicy</a>.</p>
    /// </li>
    /// <li>
    /// <p>An Amazon Kinesis Firehose delivery stream belonging to the same account as the
    /// subscription filter, for same-account delivery.</p>
    /// </li>
    /// <li>
    /// <p>A Lambda function belonging to the same account as the subscription filter,
    /// for same-account delivery.</p>
    /// </li>
    /// </ul>
    pub destination_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of an IAM role that grants CloudWatch Logs permissions to deliver ingested log
    /// events to the destination stream. You don't need to provide the ARN when you are working with
    /// a logical destination for cross-account delivery.</p>
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>The method used to distribute log data to the destination. By default, log data is
    /// grouped by log stream, but the grouping can be set to random for a more even distribution.
    /// This property is only applicable when the destination is an Amazon Kinesis stream. </p>
    pub distribution: std::option::Option<crate::model::Distribution>,
}
impl std::fmt::Debug for PutSubscriptionFilterInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutSubscriptionFilterInput");
        formatter.field("log_group_name", &self.log_group_name);
        formatter.field("filter_name", &self.filter_name);
        formatter.field("filter_pattern", &self.filter_pattern);
        formatter.field("destination_arn", &self.destination_arn);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("distribution", &self.distribution);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutRetentionPolicyInput {
    /// <p>The name of the log group.</p>
    pub log_group_name: std::option::Option<std::string::String>,
    /// <p>The number of days to retain the log events in the specified log group.
    /// Possible values are: 1, 3, 5, 7, 14, 30, 60, 90, 120, 150, 180, 365, 400, 545, 731, 1827, and 3653.</p>
    /// <p>To set a log group to never have log events expire, use
    /// <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_DeleteRetentionPolicy.html">DeleteRetentionPolicy</a>.
    /// </p>
    pub retention_in_days: std::option::Option<i32>,
}
impl std::fmt::Debug for PutRetentionPolicyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutRetentionPolicyInput");
        formatter.field("log_group_name", &self.log_group_name);
        formatter.field("retention_in_days", &self.retention_in_days);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutResourcePolicyInput {
    /// <p>Name of the new policy. This parameter is required.</p>
    pub policy_name: std::option::Option<std::string::String>,
    /// <p>Details of the new policy, including the identity of the principal that is enabled to put logs to this account. This is formatted as a JSON string.
    /// This parameter is required.</p>
    /// <p>The following example creates a resource policy enabling the Route 53 service to put
    /// DNS query logs in to the specified log group. Replace <code>"logArn"</code> with the ARN of
    /// your CloudWatch Logs resource, such as a log group or log stream.</p>
    /// <p>CloudWatch Logs also supports <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_condition-keys.html#condition-keys-sourcearn">aws:SourceArn</a>
    /// and <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_condition-keys.html#condition-keys-sourceaccount">aws:SourceAccount</a>
    /// condition context keys.</p>
    /// <p>In the example resource policy, you would replace the value of <code>SourceArn</code> with the resource making the
    /// call from Route 53 to CloudWatch Logs and replace the value of <code>SourceAccount</code> with
    /// the Amazon Web Services account ID making that call.</p>
    /// <p></p>
    /// <p>
    /// <code>{
    /// "Version": "2012-10-17",
    /// "Statement": [
    /// {
    /// "Sid": "Route53LogsToCloudWatchLogs",
    /// "Effect": "Allow",
    /// "Principal": {
    /// "Service": [
    /// "route53.amazonaws.com"
    /// ]
    /// },
    /// "Action": "logs:PutLogEvents",
    /// "Resource": "logArn",
    /// "Condition": {
    /// "ArnLike": {
    /// "aws:SourceArn": "myRoute53ResourceArn"
    /// },
    /// "StringEquals": {
    /// "aws:SourceAccount": "myAwsAccountId"
    /// }
    /// }
    /// }
    /// ]
    /// }</code>
    /// </p>
    pub policy_document: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PutResourcePolicyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutResourcePolicyInput");
        formatter.field("policy_name", &self.policy_name);
        formatter.field("policy_document", &self.policy_document);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutQueryDefinitionInput {
    /// <p>A name for the query definition. If you are saving a lot of query definitions, we
    /// recommend that you name them so that you can easily find the ones you want by using the first
    /// part of the name as a filter in the <code>queryDefinitionNamePrefix</code> parameter of <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_DescribeQueryDefinitions.html">DescribeQueryDefinitions</a>.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>If you are updating a query definition, use this parameter to specify the ID of the query
    /// definition that you want to update. You can use <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_DescribeQueryDefinitions.html">DescribeQueryDefinitions</a> to retrieve the IDs of your saved query
    /// definitions.</p>
    /// <p>If you are creating a query definition, do not specify this parameter. CloudWatch
    /// generates a unique ID for the new query definition and include it in the response to this
    /// operation.</p>
    pub query_definition_id: std::option::Option<std::string::String>,
    /// <p>Use this parameter to include specific log groups as part of your query definition.</p>
    /// <p>If you are updating a query definition and you omit this parameter, then the updated
    /// definition will contain no log groups.</p>
    pub log_group_names: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The query string to use for this definition.
    /// For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CWL_QuerySyntax.html">CloudWatch Logs Insights Query Syntax</a>.</p>
    pub query_string: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PutQueryDefinitionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutQueryDefinitionInput");
        formatter.field("name", &self.name);
        formatter.field("query_definition_id", &self.query_definition_id);
        formatter.field("log_group_names", &self.log_group_names);
        formatter.field("query_string", &self.query_string);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutMetricFilterInput {
    /// <p>The name of the log group.</p>
    pub log_group_name: std::option::Option<std::string::String>,
    /// <p>A name for the metric filter.</p>
    pub filter_name: std::option::Option<std::string::String>,
    /// <p>A filter pattern for extracting metric data out of ingested log events.</p>
    pub filter_pattern: std::option::Option<std::string::String>,
    /// <p>A collection of information that defines how metric data gets emitted.</p>
    pub metric_transformations:
        std::option::Option<std::vec::Vec<crate::model::MetricTransformation>>,
}
impl std::fmt::Debug for PutMetricFilterInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutMetricFilterInput");
        formatter.field("log_group_name", &self.log_group_name);
        formatter.field("filter_name", &self.filter_name);
        formatter.field("filter_pattern", &self.filter_pattern);
        formatter.field("metric_transformations", &self.metric_transformations);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutLogEventsInput {
    /// <p>The name of the log group.</p>
    pub log_group_name: std::option::Option<std::string::String>,
    /// <p>The name of the log stream.</p>
    pub log_stream_name: std::option::Option<std::string::String>,
    /// <p>The log events.</p>
    pub log_events: std::option::Option<std::vec::Vec<crate::model::InputLogEvent>>,
    /// <p>The sequence token obtained from the response of the previous <code>PutLogEvents</code>
    /// call. An upload in a newly created log stream does not require a sequence token. You can also
    /// get the sequence token using <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_DescribeLogStreams.html">DescribeLogStreams</a>. If you call <code>PutLogEvents</code> twice within a narrow
    /// time period using the same value for <code>sequenceToken</code>, both calls might be
    /// successful or one might be rejected.</p>
    pub sequence_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PutLogEventsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutLogEventsInput");
        formatter.field("log_group_name", &self.log_group_name);
        formatter.field("log_stream_name", &self.log_stream_name);
        formatter.field("log_events", &self.log_events);
        formatter.field("sequence_token", &self.sequence_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutDestinationPolicyInput {
    /// <p>A name for an existing destination.</p>
    pub destination_name: std::option::Option<std::string::String>,
    /// <p>An IAM policy document that authorizes cross-account users to deliver their log events
    /// to the associated destination. This can be up to 5120 bytes.</p>
    pub access_policy: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PutDestinationPolicyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutDestinationPolicyInput");
        formatter.field("destination_name", &self.destination_name);
        formatter.field("access_policy", &self.access_policy);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutDestinationInput {
    /// <p>A name for the destination.</p>
    pub destination_name: std::option::Option<std::string::String>,
    /// <p>The ARN of an Amazon Kinesis stream to which to deliver matching log events.</p>
    pub target_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of an IAM role that grants CloudWatch Logs permissions to call the Amazon
    /// Kinesis <code>PutRecord</code> operation on the destination stream.</p>
    pub role_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PutDestinationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutDestinationInput");
        formatter.field("destination_name", &self.destination_name);
        formatter.field("target_arn", &self.target_arn);
        formatter.field("role_arn", &self.role_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListTagsLogGroupInput {
    /// <p>The name of the log group.</p>
    pub log_group_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListTagsLogGroupInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListTagsLogGroupInput");
        formatter.field("log_group_name", &self.log_group_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetQueryResultsInput {
    /// <p>The ID number of the query.</p>
    pub query_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetQueryResultsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetQueryResultsInput");
        formatter.field("query_id", &self.query_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetLogRecordInput {
    /// <p>The pointer corresponding to the log event record you want to retrieve. You get this from
    /// the response of a <code>GetQueryResults</code> operation. In that response, the value of the
    /// <code>@ptr</code> field for a log event is the value to use as <code>logRecordPointer</code>
    /// to retrieve that complete log event record.</p>
    pub log_record_pointer: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetLogRecordInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetLogRecordInput");
        formatter.field("log_record_pointer", &self.log_record_pointer);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetLogGroupFieldsInput {
    /// <p>The name of the log group to search.</p>
    pub log_group_name: std::option::Option<std::string::String>,
    /// <p>The time to set as the center of the query. If you specify <code>time</code>, the 15 minutes
    /// before this time are queries. If you omit <code>time</code> the 8
    /// minutes before and 8 minutes after this time are searched.</p>
    /// <p>The <code>time</code> value is specified as epoch time, the number of seconds since
    /// January 1, 1970, 00:00:00 UTC.</p>
    pub time: std::option::Option<i64>,
}
impl std::fmt::Debug for GetLogGroupFieldsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetLogGroupFieldsInput");
        formatter.field("log_group_name", &self.log_group_name);
        formatter.field("time", &self.time);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetLogEventsInput {
    /// <p>The name of the log group.</p>
    pub log_group_name: std::option::Option<std::string::String>,
    /// <p>The name of the log stream.</p>
    pub log_stream_name: std::option::Option<std::string::String>,
    /// <p>The start of the time range, expressed as the number of milliseconds after Jan 1, 1970
    /// 00:00:00 UTC. Events with a timestamp equal to this time or later than this time are included.
    /// Events with a timestamp earlier than this time are not included.</p>
    pub start_time: std::option::Option<i64>,
    /// <p>The end of the time range, expressed as the number of milliseconds after Jan 1, 1970
    /// 00:00:00 UTC. Events with a timestamp equal to or later than this time are not
    /// included.</p>
    pub end_time: std::option::Option<i64>,
    /// <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of log events returned. If you don't specify a value, the maximum is
    /// as many log events as can fit in a response size of 1 MB, up to 10,000 log events.</p>
    pub limit: std::option::Option<i32>,
    /// <p>If the value is true, the earliest log events are returned first.
    /// If the value is false, the latest log events are returned first.
    /// The default value is false.</p>
    /// <p>If you are using a previous <code>nextForwardToken</code> value as the <code>nextToken</code> in this operation,
    /// you must specify <code>true</code> for <code>startFromHead</code>.</p>
    pub start_from_head: std::option::Option<bool>,
}
impl std::fmt::Debug for GetLogEventsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetLogEventsInput");
        formatter.field("log_group_name", &self.log_group_name);
        formatter.field("log_stream_name", &self.log_stream_name);
        formatter.field("start_time", &self.start_time);
        formatter.field("end_time", &self.end_time);
        formatter.field("next_token", &self.next_token);
        formatter.field("limit", &self.limit);
        formatter.field("start_from_head", &self.start_from_head);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FilterLogEventsInput {
    /// <p>The name of the log group to search.</p>
    pub log_group_name: std::option::Option<std::string::String>,
    /// <p>Filters the results to only logs from the log streams in this list.</p>
    /// <p>If you specify a value for both <code>logStreamNamePrefix</code> and <code>logStreamNames</code>, the action
    /// returns an <code>InvalidParameterException</code> error.</p>
    pub log_stream_names: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Filters the results to include only events from log streams that have names starting with this prefix.</p>
    /// <p>If you specify a value for both <code>logStreamNamePrefix</code> and <code>logStreamNames</code>, but the value for
    /// <code>logStreamNamePrefix</code> does not match any log stream names specified in <code>logStreamNames</code>, the action
    /// returns an <code>InvalidParameterException</code> error.</p>
    pub log_stream_name_prefix: std::option::Option<std::string::String>,
    /// <p>The start of the time range, expressed as the number of milliseconds after Jan 1, 1970
    /// 00:00:00 UTC. Events with a timestamp before this time are not returned.</p>
    pub start_time: std::option::Option<i64>,
    /// <p>The end of the time range, expressed as the number of milliseconds after Jan 1, 1970
    /// 00:00:00 UTC. Events with a timestamp later than this time are not returned.</p>
    pub end_time: std::option::Option<i64>,
    /// <p>The filter pattern to use. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/FilterAndPatternSyntax.html">Filter and Pattern Syntax</a>.</p>
    /// <p>If not provided, all the events are matched.</p>
    pub filter_pattern: std::option::Option<std::string::String>,
    /// <p>The token for the next set of events to return. (You received this token from a previous call.)</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of events to return. The default is 10,000 events.</p>
    pub limit: std::option::Option<i32>,
    /// <p>If the value is true, the operation makes a best effort to provide responses that
    /// contain events from multiple log streams within the log group, interleaved in a single
    /// response. If the value is false, all the matched log events in the first log stream are
    /// searched first, then those in the next log stream, and so on. The default is false.</p>
    /// <p>
    /// <b>Important:</b> Starting on June 17, 2019, this parameter
    /// is ignored and the value is assumed to be true. The response from this operation always
    /// interleaves events from multiple log streams within a log group.</p>
    pub interleaved: std::option::Option<bool>,
}
impl std::fmt::Debug for FilterLogEventsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FilterLogEventsInput");
        formatter.field("log_group_name", &self.log_group_name);
        formatter.field("log_stream_names", &self.log_stream_names);
        formatter.field("log_stream_name_prefix", &self.log_stream_name_prefix);
        formatter.field("start_time", &self.start_time);
        formatter.field("end_time", &self.end_time);
        formatter.field("filter_pattern", &self.filter_pattern);
        formatter.field("next_token", &self.next_token);
        formatter.field("limit", &self.limit);
        formatter.field("interleaved", &self.interleaved);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DisassociateKmsKeyInput {
    /// <p>The name of the log group.</p>
    pub log_group_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DisassociateKmsKeyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DisassociateKmsKeyInput");
        formatter.field("log_group_name", &self.log_group_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeSubscriptionFiltersInput {
    /// <p>The name of the log group.</p>
    pub log_group_name: std::option::Option<std::string::String>,
    /// <p>The prefix to match. If you don't specify a value, no prefix filter is applied.</p>
    pub filter_name_prefix: std::option::Option<std::string::String>,
    /// <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of items returned. If you don't specify a value, the default is up to 50 items.</p>
    pub limit: std::option::Option<i32>,
}
impl std::fmt::Debug for DescribeSubscriptionFiltersInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeSubscriptionFiltersInput");
        formatter.field("log_group_name", &self.log_group_name);
        formatter.field("filter_name_prefix", &self.filter_name_prefix);
        formatter.field("next_token", &self.next_token);
        formatter.field("limit", &self.limit);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeResourcePoliciesInput {
    /// <p>The token for the next set of items to return. The token expires after 24 hours.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of resource policies to be displayed with one call of this API.</p>
    pub limit: std::option::Option<i32>,
}
impl std::fmt::Debug for DescribeResourcePoliciesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeResourcePoliciesInput");
        formatter.field("next_token", &self.next_token);
        formatter.field("limit", &self.limit);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeQueryDefinitionsInput {
    /// <p>Use this parameter to filter your results to only the query definitions that have names that start with the prefix you specify.</p>
    pub query_definition_name_prefix: std::option::Option<std::string::String>,
    /// <p>Limits the number of returned query definitions to the specified number.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>The token for the next set of items to return. The token expires after 24 hours.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeQueryDefinitionsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeQueryDefinitionsInput");
        formatter.field(
            "query_definition_name_prefix",
            &self.query_definition_name_prefix,
        );
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeQueriesInput {
    /// <p>Limits the returned queries to only those for the specified log group.</p>
    pub log_group_name: std::option::Option<std::string::String>,
    /// <p>Limits the returned queries to only those that have the specified status. Valid values are <code>Cancelled</code>,
    /// <code>Complete</code>, <code>Failed</code>, <code>Running</code>, and <code>Scheduled</code>.</p>
    pub status: std::option::Option<crate::model::QueryStatus>,
    /// <p>Limits the number of returned queries to the specified number.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>The token for the next set of items to return. The token expires after 24 hours.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeQueriesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeQueriesInput");
        formatter.field("log_group_name", &self.log_group_name);
        formatter.field("status", &self.status);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeMetricFiltersInput {
    /// <p>The name of the log group.</p>
    pub log_group_name: std::option::Option<std::string::String>,
    /// <p>The prefix to match. CloudWatch Logs uses the value you set here
    /// only if you also include the <code>logGroupName</code> parameter in your request.</p>
    pub filter_name_prefix: std::option::Option<std::string::String>,
    /// <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of items returned. If you don't specify a value, the default is up to 50 items.</p>
    pub limit: std::option::Option<i32>,
    /// <p>Filters results to include only those with the specified metric name. If you include this parameter in your request, you
    /// must also include the <code>metricNamespace</code> parameter.</p>
    pub metric_name: std::option::Option<std::string::String>,
    /// <p>Filters results to include only those in the specified namespace. If you include this parameter in your request, you
    /// must also include the <code>metricName</code> parameter.</p>
    pub metric_namespace: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeMetricFiltersInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeMetricFiltersInput");
        formatter.field("log_group_name", &self.log_group_name);
        formatter.field("filter_name_prefix", &self.filter_name_prefix);
        formatter.field("next_token", &self.next_token);
        formatter.field("limit", &self.limit);
        formatter.field("metric_name", &self.metric_name);
        formatter.field("metric_namespace", &self.metric_namespace);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeLogStreamsInput {
    /// <p>The name of the log group.</p>
    pub log_group_name: std::option::Option<std::string::String>,
    /// <p>The prefix to match.</p>
    /// <p>If <code>orderBy</code> is <code>LastEventTime</code>, you cannot specify this
    /// parameter.</p>
    pub log_stream_name_prefix: std::option::Option<std::string::String>,
    /// <p>If the value is <code>LogStreamName</code>, the results are ordered by log stream name.
    /// If the value is <code>LastEventTime</code>, the results are ordered by the event time.
    /// The default value is <code>LogStreamName</code>.</p>
    /// <p>If you order the results by event time, you cannot specify the <code>logStreamNamePrefix</code> parameter.</p>
    /// <p>
    /// <code>lastEventTimestamp</code> represents the time of the most recent log event in the
    /// log stream in CloudWatch Logs. This number is expressed as the number of milliseconds after
    /// Jan 1, 1970 00:00:00 UTC. <code>lastEventTimestamp</code> updates on an eventual consistency
    /// basis. It typically updates in less than an hour from ingestion, but in rare situations might
    /// take longer.</p>
    pub order_by: std::option::Option<crate::model::OrderBy>,
    /// <p>If the value is true, results are returned in descending order.
    /// If the value is to false, results are returned in ascending order.
    /// The default value is false.</p>
    pub descending: std::option::Option<bool>,
    /// <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of items returned. If you don't specify a value, the default is up to 50 items.</p>
    pub limit: std::option::Option<i32>,
}
impl std::fmt::Debug for DescribeLogStreamsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeLogStreamsInput");
        formatter.field("log_group_name", &self.log_group_name);
        formatter.field("log_stream_name_prefix", &self.log_stream_name_prefix);
        formatter.field("order_by", &self.order_by);
        formatter.field("descending", &self.descending);
        formatter.field("next_token", &self.next_token);
        formatter.field("limit", &self.limit);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeLogGroupsInput {
    /// <p>The prefix to match.</p>
    pub log_group_name_prefix: std::option::Option<std::string::String>,
    /// <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of items returned. If you don't specify a value, the default is up to 50 items.</p>
    pub limit: std::option::Option<i32>,
}
impl std::fmt::Debug for DescribeLogGroupsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeLogGroupsInput");
        formatter.field("log_group_name_prefix", &self.log_group_name_prefix);
        formatter.field("next_token", &self.next_token);
        formatter.field("limit", &self.limit);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeExportTasksInput {
    /// <p>The ID of the export task. Specifying a task ID filters the results to zero or one export tasks.</p>
    pub task_id: std::option::Option<std::string::String>,
    /// <p>The status code of the export task. Specifying a status code filters the results to zero or more export tasks.</p>
    pub status_code: std::option::Option<crate::model::ExportTaskStatusCode>,
    /// <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of items returned. If you don't specify a value, the default is up to 50 items.</p>
    pub limit: std::option::Option<i32>,
}
impl std::fmt::Debug for DescribeExportTasksInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeExportTasksInput");
        formatter.field("task_id", &self.task_id);
        formatter.field("status_code", &self.status_code);
        formatter.field("next_token", &self.next_token);
        formatter.field("limit", &self.limit);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeDestinationsInput {
    /// <p>The prefix to match. If you don't specify a value, no prefix filter is applied.</p>
    pub destination_name_prefix: std::option::Option<std::string::String>,
    /// <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of items returned. If you don't specify a value, the default is up to 50 items.</p>
    pub limit: std::option::Option<i32>,
}
impl std::fmt::Debug for DescribeDestinationsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeDestinationsInput");
        formatter.field("destination_name_prefix", &self.destination_name_prefix);
        formatter.field("next_token", &self.next_token);
        formatter.field("limit", &self.limit);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteSubscriptionFilterInput {
    /// <p>The name of the log group.</p>
    pub log_group_name: std::option::Option<std::string::String>,
    /// <p>The name of the subscription filter.</p>
    pub filter_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteSubscriptionFilterInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteSubscriptionFilterInput");
        formatter.field("log_group_name", &self.log_group_name);
        formatter.field("filter_name", &self.filter_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteRetentionPolicyInput {
    /// <p>The name of the log group.</p>
    pub log_group_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteRetentionPolicyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteRetentionPolicyInput");
        formatter.field("log_group_name", &self.log_group_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteResourcePolicyInput {
    /// <p>The name of the policy to be revoked. This parameter is required.</p>
    pub policy_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteResourcePolicyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteResourcePolicyInput");
        formatter.field("policy_name", &self.policy_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteQueryDefinitionInput {
    /// <p>The ID of the query definition that you want to delete. You can use <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_DescribeQueryDefinitions.html">DescribeQueryDefinitions</a> to retrieve the
    /// IDs of your saved query definitions.</p>
    pub query_definition_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteQueryDefinitionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteQueryDefinitionInput");
        formatter.field("query_definition_id", &self.query_definition_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteMetricFilterInput {
    /// <p>The name of the log group.</p>
    pub log_group_name: std::option::Option<std::string::String>,
    /// <p>The name of the metric filter.</p>
    pub filter_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteMetricFilterInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteMetricFilterInput");
        formatter.field("log_group_name", &self.log_group_name);
        formatter.field("filter_name", &self.filter_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteLogStreamInput {
    /// <p>The name of the log group.</p>
    pub log_group_name: std::option::Option<std::string::String>,
    /// <p>The name of the log stream.</p>
    pub log_stream_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteLogStreamInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteLogStreamInput");
        formatter.field("log_group_name", &self.log_group_name);
        formatter.field("log_stream_name", &self.log_stream_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteLogGroupInput {
    /// <p>The name of the log group.</p>
    pub log_group_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteLogGroupInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteLogGroupInput");
        formatter.field("log_group_name", &self.log_group_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteDestinationInput {
    /// <p>The name of the destination.</p>
    pub destination_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteDestinationInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteDestinationInput");
        formatter.field("destination_name", &self.destination_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateLogStreamInput {
    /// <p>The name of the log group.</p>
    pub log_group_name: std::option::Option<std::string::String>,
    /// <p>The name of the log stream.</p>
    pub log_stream_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateLogStreamInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateLogStreamInput");
        formatter.field("log_group_name", &self.log_group_name);
        formatter.field("log_stream_name", &self.log_stream_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateLogGroupInput {
    /// <p>The name of the log group.</p>
    pub log_group_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the CMK to use when encrypting log data.
    /// For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-kms">Amazon Resource Names - Key Management Service</a>.</p>
    pub kms_key_id: std::option::Option<std::string::String>,
    /// <p>The key-value pairs to use for the tags.</p>
    /// <p>CloudWatch Logs doesn’t support IAM policies that prevent users from assigning specified tags to
    /// log groups using the <code>aws:Resource/<i>key-name</i>
    /// </code> or <code>aws:TagKeys</code> condition keys.
    /// For more information about using tags to control access, see
    /// <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_tags.html">Controlling access to Amazon Web Services resources using tags</a>.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl std::fmt::Debug for CreateLogGroupInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateLogGroupInput");
        formatter.field("log_group_name", &self.log_group_name);
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateExportTaskInput {
    /// <p>The name of the export task.</p>
    pub task_name: std::option::Option<std::string::String>,
    /// <p>The name of the log group.</p>
    pub log_group_name: std::option::Option<std::string::String>,
    /// <p>Export only log streams that match the provided prefix. If you don't
    /// specify a value, no prefix filter is applied.</p>
    pub log_stream_name_prefix: std::option::Option<std::string::String>,
    /// <p>The start time of the range for the request, expressed as the number of milliseconds
    /// after Jan 1, 1970 00:00:00 UTC. Events with a timestamp earlier than this time are not
    /// exported.</p>
    pub from: std::option::Option<i64>,
    /// <p>The end time of the range for the request, expreswatchlogsdocused as the number of milliseconds
    /// after Jan 1, 1970 00:00:00 UTC. Events with a timestamp later than this time are not
    /// exported.</p>
    pub to: std::option::Option<i64>,
    /// <p>The name of S3 bucket for the exported log data. The bucket must be in the same Amazon Web Services region.</p>
    pub destination: std::option::Option<std::string::String>,
    /// <p>The prefix used as the start of the key for every object exported. If you don't
    /// specify a value, the default is <code>exportedlogs</code>.</p>
    pub destination_prefix: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateExportTaskInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateExportTaskInput");
        formatter.field("task_name", &self.task_name);
        formatter.field("log_group_name", &self.log_group_name);
        formatter.field("log_stream_name_prefix", &self.log_stream_name_prefix);
        formatter.field("from", &self.from);
        formatter.field("to", &self.to);
        formatter.field("destination", &self.destination);
        formatter.field("destination_prefix", &self.destination_prefix);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CancelExportTaskInput {
    /// <p>The ID of the export task.</p>
    pub task_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CancelExportTaskInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CancelExportTaskInput");
        formatter.field("task_id", &self.task_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AssociateKmsKeyInput {
    /// <p>The name of the log group.</p>
    pub log_group_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the CMK to use when encrypting log data. This must be a symmetric CMK.
    /// For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-kms">Amazon Resource Names - Key Management Service</a> and <a href="https://docs.aws.amazon.com/kms/latest/developerguide/symmetric-asymmetric.html">Using Symmetric and Asymmetric Keys</a>.</p>
    pub kms_key_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AssociateKmsKeyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AssociateKmsKeyInput");
        formatter.field("log_group_name", &self.log_group_name);
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.finish()
    }
}
