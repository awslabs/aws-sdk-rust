// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PutDataProtectionPolicyInput  {
    /// <p>Specify either the log group name or log group ARN.</p>
    #[doc(hidden)]
    pub log_group_identifier: std::option::Option<std::string::String>,
    /// <p>Specify the data protection policy, in JSON.</p> 
    /// <p>This policy must include two JSON blocks:</p> 
    /// <ul> 
    /// <li> <p>The first block must include both a <code>DataIdentifer</code> array and an <code>Operation</code> property with an <code>Audit</code> action. The <code>DataIdentifer</code> array lists the types of sensitive data that you want to mask. For more information about the available options, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/mask-sensitive-log-data-types.html">Types of data that you can mask</a>.</p> <p>The <code>Operation</code> property with an <code>Audit</code> action is required to find the sensitive data terms. This <code>Audit</code> action must contain a <code>FindingsDestination</code> object. You can optionally use that <code>FindingsDestination</code> object to list one or more destinations to send audit findings to. If you specify destinations such as log groups, Kinesis Data Firehose streams, and S3 buckets, they must already exist.</p> </li> 
    /// <li> <p>The second block must include both a <code>DataIdentifer</code> array and an <code>Operation</code> property with an <code>Deidentify</code> action. The <code>DataIdentifer</code> array must exactly match the <code>DataIdentifer</code> array in the first block of the policy.</p> <p>The <code>Operation</code> property with the <code>Deidentify</code> action is what actually masks the data, and it must contain the <code> "MaskConfig": {}</code> object. The <code> "MaskConfig": {}</code> object must be empty.</p> </li> 
    /// </ul> 
    /// <p>For an example data protection policy, see the <b>Examples</b> section on this page.</p> <important> 
    /// <p>The contents of two <code>DataIdentifer</code> arrays must match exactly.</p> 
    /// </important>
    #[doc(hidden)]
    pub policy_document: std::option::Option<std::string::String>,
}
impl PutDataProtectionPolicyInput {
    /// <p>Specify either the log group name or log group ARN.</p>
    pub fn log_group_identifier(&self) -> std::option::Option<& str> {
        self.log_group_identifier.as_deref()
    }
    /// <p>Specify the data protection policy, in JSON.</p> 
    /// <p>This policy must include two JSON blocks:</p> 
    /// <ul> 
    /// <li> <p>The first block must include both a <code>DataIdentifer</code> array and an <code>Operation</code> property with an <code>Audit</code> action. The <code>DataIdentifer</code> array lists the types of sensitive data that you want to mask. For more information about the available options, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/mask-sensitive-log-data-types.html">Types of data that you can mask</a>.</p> <p>The <code>Operation</code> property with an <code>Audit</code> action is required to find the sensitive data terms. This <code>Audit</code> action must contain a <code>FindingsDestination</code> object. You can optionally use that <code>FindingsDestination</code> object to list one or more destinations to send audit findings to. If you specify destinations such as log groups, Kinesis Data Firehose streams, and S3 buckets, they must already exist.</p> </li> 
    /// <li> <p>The second block must include both a <code>DataIdentifer</code> array and an <code>Operation</code> property with an <code>Deidentify</code> action. The <code>DataIdentifer</code> array must exactly match the <code>DataIdentifer</code> array in the first block of the policy.</p> <p>The <code>Operation</code> property with the <code>Deidentify</code> action is what actually masks the data, and it must contain the <code> "MaskConfig": {}</code> object. The <code> "MaskConfig": {}</code> object must be empty.</p> </li> 
    /// </ul> 
    /// <p>For an example data protection policy, see the <b>Examples</b> section on this page.</p> <important> 
    /// <p>The contents of two <code>DataIdentifer</code> arrays must match exactly.</p> 
    /// </important>
    pub fn policy_document(&self) -> std::option::Option<& str> {
        self.policy_document.as_deref()
    }
}
impl PutDataProtectionPolicyInput {
    /// Creates a new builder-style object to manufacture [`PutDataProtectionPolicyInput`](crate::operation::put_data_protection_policy::PutDataProtectionPolicyInput).
    pub fn builder() -> crate::operation::put_data_protection_policy::builders::PutDataProtectionPolicyInputBuilder {
        crate::operation::put_data_protection_policy::builders::PutDataProtectionPolicyInputBuilder::default()
    }
}

/// A builder for [`PutDataProtectionPolicyInput`](crate::operation::put_data_protection_policy::PutDataProtectionPolicyInput).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct PutDataProtectionPolicyInputBuilder {
    pub(crate) log_group_identifier: std::option::Option<std::string::String>,
    pub(crate) policy_document: std::option::Option<std::string::String>,
}
impl PutDataProtectionPolicyInputBuilder {
    /// <p>Specify either the log group name or log group ARN.</p>
    pub fn log_group_identifier(mut self, input: impl Into<std::string::String>) -> Self {
        self.log_group_identifier = Some(input.into());
        self
    }
    /// <p>Specify either the log group name or log group ARN.</p>
    pub fn set_log_group_identifier(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.log_group_identifier = input; self
    }
    /// <p>Specify the data protection policy, in JSON.</p> 
    /// <p>This policy must include two JSON blocks:</p> 
    /// <ul> 
    /// <li> <p>The first block must include both a <code>DataIdentifer</code> array and an <code>Operation</code> property with an <code>Audit</code> action. The <code>DataIdentifer</code> array lists the types of sensitive data that you want to mask. For more information about the available options, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/mask-sensitive-log-data-types.html">Types of data that you can mask</a>.</p> <p>The <code>Operation</code> property with an <code>Audit</code> action is required to find the sensitive data terms. This <code>Audit</code> action must contain a <code>FindingsDestination</code> object. You can optionally use that <code>FindingsDestination</code> object to list one or more destinations to send audit findings to. If you specify destinations such as log groups, Kinesis Data Firehose streams, and S3 buckets, they must already exist.</p> </li> 
    /// <li> <p>The second block must include both a <code>DataIdentifer</code> array and an <code>Operation</code> property with an <code>Deidentify</code> action. The <code>DataIdentifer</code> array must exactly match the <code>DataIdentifer</code> array in the first block of the policy.</p> <p>The <code>Operation</code> property with the <code>Deidentify</code> action is what actually masks the data, and it must contain the <code> "MaskConfig": {}</code> object. The <code> "MaskConfig": {}</code> object must be empty.</p> </li> 
    /// </ul> 
    /// <p>For an example data protection policy, see the <b>Examples</b> section on this page.</p> <important> 
    /// <p>The contents of two <code>DataIdentifer</code> arrays must match exactly.</p> 
    /// </important>
    pub fn policy_document(mut self, input: impl Into<std::string::String>) -> Self {
        self.policy_document = Some(input.into());
        self
    }
    /// <p>Specify the data protection policy, in JSON.</p> 
    /// <p>This policy must include two JSON blocks:</p> 
    /// <ul> 
    /// <li> <p>The first block must include both a <code>DataIdentifer</code> array and an <code>Operation</code> property with an <code>Audit</code> action. The <code>DataIdentifer</code> array lists the types of sensitive data that you want to mask. For more information about the available options, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/mask-sensitive-log-data-types.html">Types of data that you can mask</a>.</p> <p>The <code>Operation</code> property with an <code>Audit</code> action is required to find the sensitive data terms. This <code>Audit</code> action must contain a <code>FindingsDestination</code> object. You can optionally use that <code>FindingsDestination</code> object to list one or more destinations to send audit findings to. If you specify destinations such as log groups, Kinesis Data Firehose streams, and S3 buckets, they must already exist.</p> </li> 
    /// <li> <p>The second block must include both a <code>DataIdentifer</code> array and an <code>Operation</code> property with an <code>Deidentify</code> action. The <code>DataIdentifer</code> array must exactly match the <code>DataIdentifer</code> array in the first block of the policy.</p> <p>The <code>Operation</code> property with the <code>Deidentify</code> action is what actually masks the data, and it must contain the <code> "MaskConfig": {}</code> object. The <code> "MaskConfig": {}</code> object must be empty.</p> </li> 
    /// </ul> 
    /// <p>For an example data protection policy, see the <b>Examples</b> section on this page.</p> <important> 
    /// <p>The contents of two <code>DataIdentifer</code> arrays must match exactly.</p> 
    /// </important>
    pub fn set_policy_document(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.policy_document = input; self
    }
    /// Consumes the builder and constructs a [`PutDataProtectionPolicyInput`](crate::operation::put_data_protection_policy::PutDataProtectionPolicyInput).
    pub fn build(self) -> Result<crate::operation::put_data_protection_policy::PutDataProtectionPolicyInput, aws_smithy_http::operation::error::BuildError> {
        Ok(
            crate::operation::put_data_protection_policy::PutDataProtectionPolicyInput {
                log_group_identifier: self.log_group_identifier
                ,
                policy_document: self.policy_document
                ,
            }
        )
    }
}

