// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FilterLogEventsInput {
    /// <p>The name of the log group to search.</p> <note>
    /// <p> You must include either <code>logGroupIdentifier</code> or <code>logGroupName</code>, but not both. </p>
    /// </note>
    #[doc(hidden)]
    pub log_group_name: std::option::Option<std::string::String>,
    /// <p>Specify either the name or ARN of the log group to view log events from. If the log group is in a source account and you are using a monitoring account, you must use the log group ARN.</p> <note>
    /// <p> You must include either <code>logGroupIdentifier</code> or <code>logGroupName</code>, but not both. </p>
    /// </note>
    #[doc(hidden)]
    pub log_group_identifier: std::option::Option<std::string::String>,
    /// <p>Filters the results to only logs from the log streams in this list.</p>
    /// <p>If you specify a value for both <code>logStreamNamePrefix</code> and <code>logStreamNames</code>, the action returns an <code>InvalidParameterException</code> error.</p>
    #[doc(hidden)]
    pub log_stream_names: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Filters the results to include only events from log streams that have names starting with this prefix.</p>
    /// <p>If you specify a value for both <code>logStreamNamePrefix</code> and <code>logStreamNames</code>, but the value for <code>logStreamNamePrefix</code> does not match any log stream names specified in <code>logStreamNames</code>, the action returns an <code>InvalidParameterException</code> error.</p>
    #[doc(hidden)]
    pub log_stream_name_prefix: std::option::Option<std::string::String>,
    /// <p>The start of the time range, expressed as the number of milliseconds after <code>Jan 1, 1970 00:00:00 UTC</code>. Events with a timestamp before this time are not returned.</p>
    #[doc(hidden)]
    pub start_time: std::option::Option<i64>,
    /// <p>The end of the time range, expressed as the number of milliseconds after <code>Jan 1, 1970 00:00:00 UTC</code>. Events with a timestamp later than this time are not returned.</p>
    #[doc(hidden)]
    pub end_time: std::option::Option<i64>,
    /// <p>The filter pattern to use. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/FilterAndPatternSyntax.html">Filter and Pattern Syntax</a>.</p>
    /// <p>If not provided, all the events are matched.</p>
    #[doc(hidden)]
    pub filter_pattern: std::option::Option<std::string::String>,
    /// <p>The token for the next set of events to return. (You received this token from a previous call.)</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The maximum number of events to return. The default is 10,000 events.</p>
    #[doc(hidden)]
    pub limit: std::option::Option<i32>,
    /// <p>If the value is true, the operation attempts to provide responses that contain events from multiple log streams within the log group, interleaved in a single response. If the value is false, all the matched log events in the first log stream are searched first, then those in the next log stream, and so on.</p>
    /// <p> <b>Important</b> As of June 17, 2019, this parameter is ignored and the value is assumed to be true. The response from this operation always interleaves events from multiple log streams within a log group.</p>
    #[deprecated(
        note = "Starting on June 17, 2019, this parameter will be ignored and the value will be assumed to be true. The response from this operation will always interleave events from multiple log streams within a log group."
    )]
    #[doc(hidden)]
    pub interleaved: std::option::Option<bool>,
    /// <p>Specify <code>true</code> to display the log event fields with all sensitive data unmasked and visible. The default is <code>false</code>.</p>
    /// <p>To use this operation with this parameter, you must be signed into an account with the <code>logs:Unmask</code> permission.</p>
    #[doc(hidden)]
    pub unmask: bool,
}
impl FilterLogEventsInput {
    /// <p>The name of the log group to search.</p> <note>
    /// <p> You must include either <code>logGroupIdentifier</code> or <code>logGroupName</code>, but not both. </p>
    /// </note>
    pub fn log_group_name(&self) -> std::option::Option<&str> {
        self.log_group_name.as_deref()
    }
    /// <p>Specify either the name or ARN of the log group to view log events from. If the log group is in a source account and you are using a monitoring account, you must use the log group ARN.</p> <note>
    /// <p> You must include either <code>logGroupIdentifier</code> or <code>logGroupName</code>, but not both. </p>
    /// </note>
    pub fn log_group_identifier(&self) -> std::option::Option<&str> {
        self.log_group_identifier.as_deref()
    }
    /// <p>Filters the results to only logs from the log streams in this list.</p>
    /// <p>If you specify a value for both <code>logStreamNamePrefix</code> and <code>logStreamNames</code>, the action returns an <code>InvalidParameterException</code> error.</p>
    pub fn log_stream_names(&self) -> std::option::Option<&[std::string::String]> {
        self.log_stream_names.as_deref()
    }
    /// <p>Filters the results to include only events from log streams that have names starting with this prefix.</p>
    /// <p>If you specify a value for both <code>logStreamNamePrefix</code> and <code>logStreamNames</code>, but the value for <code>logStreamNamePrefix</code> does not match any log stream names specified in <code>logStreamNames</code>, the action returns an <code>InvalidParameterException</code> error.</p>
    pub fn log_stream_name_prefix(&self) -> std::option::Option<&str> {
        self.log_stream_name_prefix.as_deref()
    }
    /// <p>The start of the time range, expressed as the number of milliseconds after <code>Jan 1, 1970 00:00:00 UTC</code>. Events with a timestamp before this time are not returned.</p>
    pub fn start_time(&self) -> std::option::Option<i64> {
        self.start_time
    }
    /// <p>The end of the time range, expressed as the number of milliseconds after <code>Jan 1, 1970 00:00:00 UTC</code>. Events with a timestamp later than this time are not returned.</p>
    pub fn end_time(&self) -> std::option::Option<i64> {
        self.end_time
    }
    /// <p>The filter pattern to use. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/FilterAndPatternSyntax.html">Filter and Pattern Syntax</a>.</p>
    /// <p>If not provided, all the events are matched.</p>
    pub fn filter_pattern(&self) -> std::option::Option<&str> {
        self.filter_pattern.as_deref()
    }
    /// <p>The token for the next set of events to return. (You received this token from a previous call.)</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The maximum number of events to return. The default is 10,000 events.</p>
    pub fn limit(&self) -> std::option::Option<i32> {
        self.limit
    }
    /// <p>If the value is true, the operation attempts to provide responses that contain events from multiple log streams within the log group, interleaved in a single response. If the value is false, all the matched log events in the first log stream are searched first, then those in the next log stream, and so on.</p>
    /// <p> <b>Important</b> As of June 17, 2019, this parameter is ignored and the value is assumed to be true. The response from this operation always interleaves events from multiple log streams within a log group.</p>
    #[deprecated(
        note = "Starting on June 17, 2019, this parameter will be ignored and the value will be assumed to be true. The response from this operation will always interleave events from multiple log streams within a log group."
    )]
    pub fn interleaved(&self) -> std::option::Option<bool> {
        self.interleaved
    }
    /// <p>Specify <code>true</code> to display the log event fields with all sensitive data unmasked and visible. The default is <code>false</code>.</p>
    /// <p>To use this operation with this parameter, you must be signed into an account with the <code>logs:Unmask</code> permission.</p>
    pub fn unmask(&self) -> bool {
        self.unmask
    }
}
impl FilterLogEventsInput {
    /// Creates a new builder-style object to manufacture [`FilterLogEventsInput`](crate::operation::filter_log_events::FilterLogEventsInput).
    pub fn builder() -> crate::operation::filter_log_events::builders::FilterLogEventsInputBuilder {
        crate::operation::filter_log_events::builders::FilterLogEventsInputBuilder::default()
    }
}

/// A builder for [`FilterLogEventsInput`](crate::operation::filter_log_events::FilterLogEventsInput).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct FilterLogEventsInputBuilder {
    pub(crate) log_group_name: std::option::Option<std::string::String>,
    pub(crate) log_group_identifier: std::option::Option<std::string::String>,
    pub(crate) log_stream_names: std::option::Option<std::vec::Vec<std::string::String>>,
    pub(crate) log_stream_name_prefix: std::option::Option<std::string::String>,
    pub(crate) start_time: std::option::Option<i64>,
    pub(crate) end_time: std::option::Option<i64>,
    pub(crate) filter_pattern: std::option::Option<std::string::String>,
    pub(crate) next_token: std::option::Option<std::string::String>,
    pub(crate) limit: std::option::Option<i32>,
    pub(crate) interleaved: std::option::Option<bool>,
    pub(crate) unmask: std::option::Option<bool>,
}
impl FilterLogEventsInputBuilder {
    /// <p>The name of the log group to search.</p> <note>
    /// <p> You must include either <code>logGroupIdentifier</code> or <code>logGroupName</code>, but not both. </p>
    /// </note>
    pub fn log_group_name(mut self, input: impl Into<std::string::String>) -> Self {
        self.log_group_name = Some(input.into());
        self
    }
    /// <p>The name of the log group to search.</p> <note>
    /// <p> You must include either <code>logGroupIdentifier</code> or <code>logGroupName</code>, but not both. </p>
    /// </note>
    pub fn set_log_group_name(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.log_group_name = input;
        self
    }
    /// <p>Specify either the name or ARN of the log group to view log events from. If the log group is in a source account and you are using a monitoring account, you must use the log group ARN.</p> <note>
    /// <p> You must include either <code>logGroupIdentifier</code> or <code>logGroupName</code>, but not both. </p>
    /// </note>
    pub fn log_group_identifier(mut self, input: impl Into<std::string::String>) -> Self {
        self.log_group_identifier = Some(input.into());
        self
    }
    /// <p>Specify either the name or ARN of the log group to view log events from. If the log group is in a source account and you are using a monitoring account, you must use the log group ARN.</p> <note>
    /// <p> You must include either <code>logGroupIdentifier</code> or <code>logGroupName</code>, but not both. </p>
    /// </note>
    pub fn set_log_group_identifier(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.log_group_identifier = input;
        self
    }
    /// Appends an item to `log_stream_names`.
    ///
    /// To override the contents of this collection use [`set_log_stream_names`](Self::set_log_stream_names).
    ///
    /// <p>Filters the results to only logs from the log streams in this list.</p>
    /// <p>If you specify a value for both <code>logStreamNamePrefix</code> and <code>logStreamNames</code>, the action returns an <code>InvalidParameterException</code> error.</p>
    pub fn log_stream_names(mut self, input: impl Into<std::string::String>) -> Self {
        let mut v = self.log_stream_names.unwrap_or_default();
        v.push(input.into());
        self.log_stream_names = Some(v);
        self
    }
    /// <p>Filters the results to only logs from the log streams in this list.</p>
    /// <p>If you specify a value for both <code>logStreamNamePrefix</code> and <code>logStreamNames</code>, the action returns an <code>InvalidParameterException</code> error.</p>
    pub fn set_log_stream_names(
        mut self,
        input: std::option::Option<std::vec::Vec<std::string::String>>,
    ) -> Self {
        self.log_stream_names = input;
        self
    }
    /// <p>Filters the results to include only events from log streams that have names starting with this prefix.</p>
    /// <p>If you specify a value for both <code>logStreamNamePrefix</code> and <code>logStreamNames</code>, but the value for <code>logStreamNamePrefix</code> does not match any log stream names specified in <code>logStreamNames</code>, the action returns an <code>InvalidParameterException</code> error.</p>
    pub fn log_stream_name_prefix(mut self, input: impl Into<std::string::String>) -> Self {
        self.log_stream_name_prefix = Some(input.into());
        self
    }
    /// <p>Filters the results to include only events from log streams that have names starting with this prefix.</p>
    /// <p>If you specify a value for both <code>logStreamNamePrefix</code> and <code>logStreamNames</code>, but the value for <code>logStreamNamePrefix</code> does not match any log stream names specified in <code>logStreamNames</code>, the action returns an <code>InvalidParameterException</code> error.</p>
    pub fn set_log_stream_name_prefix(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.log_stream_name_prefix = input;
        self
    }
    /// <p>The start of the time range, expressed as the number of milliseconds after <code>Jan 1, 1970 00:00:00 UTC</code>. Events with a timestamp before this time are not returned.</p>
    pub fn start_time(mut self, input: i64) -> Self {
        self.start_time = Some(input);
        self
    }
    /// <p>The start of the time range, expressed as the number of milliseconds after <code>Jan 1, 1970 00:00:00 UTC</code>. Events with a timestamp before this time are not returned.</p>
    pub fn set_start_time(mut self, input: std::option::Option<i64>) -> Self {
        self.start_time = input;
        self
    }
    /// <p>The end of the time range, expressed as the number of milliseconds after <code>Jan 1, 1970 00:00:00 UTC</code>. Events with a timestamp later than this time are not returned.</p>
    pub fn end_time(mut self, input: i64) -> Self {
        self.end_time = Some(input);
        self
    }
    /// <p>The end of the time range, expressed as the number of milliseconds after <code>Jan 1, 1970 00:00:00 UTC</code>. Events with a timestamp later than this time are not returned.</p>
    pub fn set_end_time(mut self, input: std::option::Option<i64>) -> Self {
        self.end_time = input;
        self
    }
    /// <p>The filter pattern to use. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/FilterAndPatternSyntax.html">Filter and Pattern Syntax</a>.</p>
    /// <p>If not provided, all the events are matched.</p>
    pub fn filter_pattern(mut self, input: impl Into<std::string::String>) -> Self {
        self.filter_pattern = Some(input.into());
        self
    }
    /// <p>The filter pattern to use. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/FilterAndPatternSyntax.html">Filter and Pattern Syntax</a>.</p>
    /// <p>If not provided, all the events are matched.</p>
    pub fn set_filter_pattern(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.filter_pattern = input;
        self
    }
    /// <p>The token for the next set of events to return. (You received this token from a previous call.)</p>
    pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
        self.next_token = Some(input.into());
        self
    }
    /// <p>The token for the next set of events to return. (You received this token from a previous call.)</p>
    pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.next_token = input;
        self
    }
    /// <p>The maximum number of events to return. The default is 10,000 events.</p>
    pub fn limit(mut self, input: i32) -> Self {
        self.limit = Some(input);
        self
    }
    /// <p>The maximum number of events to return. The default is 10,000 events.</p>
    pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
        self.limit = input;
        self
    }
    /// <p>If the value is true, the operation attempts to provide responses that contain events from multiple log streams within the log group, interleaved in a single response. If the value is false, all the matched log events in the first log stream are searched first, then those in the next log stream, and so on.</p>
    /// <p> <b>Important</b> As of June 17, 2019, this parameter is ignored and the value is assumed to be true. The response from this operation always interleaves events from multiple log streams within a log group.</p>
    #[deprecated(
        note = "Starting on June 17, 2019, this parameter will be ignored and the value will be assumed to be true. The response from this operation will always interleave events from multiple log streams within a log group."
    )]
    pub fn interleaved(mut self, input: bool) -> Self {
        self.interleaved = Some(input);
        self
    }
    /// <p>If the value is true, the operation attempts to provide responses that contain events from multiple log streams within the log group, interleaved in a single response. If the value is false, all the matched log events in the first log stream are searched first, then those in the next log stream, and so on.</p>
    /// <p> <b>Important</b> As of June 17, 2019, this parameter is ignored and the value is assumed to be true. The response from this operation always interleaves events from multiple log streams within a log group.</p>
    #[deprecated(
        note = "Starting on June 17, 2019, this parameter will be ignored and the value will be assumed to be true. The response from this operation will always interleave events from multiple log streams within a log group."
    )]
    pub fn set_interleaved(mut self, input: std::option::Option<bool>) -> Self {
        self.interleaved = input;
        self
    }
    /// <p>Specify <code>true</code> to display the log event fields with all sensitive data unmasked and visible. The default is <code>false</code>.</p>
    /// <p>To use this operation with this parameter, you must be signed into an account with the <code>logs:Unmask</code> permission.</p>
    pub fn unmask(mut self, input: bool) -> Self {
        self.unmask = Some(input);
        self
    }
    /// <p>Specify <code>true</code> to display the log event fields with all sensitive data unmasked and visible. The default is <code>false</code>.</p>
    /// <p>To use this operation with this parameter, you must be signed into an account with the <code>logs:Unmask</code> permission.</p>
    pub fn set_unmask(mut self, input: std::option::Option<bool>) -> Self {
        self.unmask = input;
        self
    }
    /// Consumes the builder and constructs a [`FilterLogEventsInput`](crate::operation::filter_log_events::FilterLogEventsInput).
    pub fn build(
        self,
    ) -> Result<
        crate::operation::filter_log_events::FilterLogEventsInput,
        aws_smithy_http::operation::error::BuildError,
    > {
        Ok(crate::operation::filter_log_events::FilterLogEventsInput {
            log_group_name: self.log_group_name,
            log_group_identifier: self.log_group_identifier,
            log_stream_names: self.log_stream_names,
            log_stream_name_prefix: self.log_stream_name_prefix,
            start_time: self.start_time,
            end_time: self.end_time,
            filter_pattern: self.filter_pattern,
            next_token: self.next_token,
            limit: self.limit,
            interleaved: self.interleaved,
            unmask: self.unmask.unwrap_or_default(),
        })
    }
}
