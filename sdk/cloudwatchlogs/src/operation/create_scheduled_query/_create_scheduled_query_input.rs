// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct CreateScheduledQueryInput {
    /// <p>A unique name for the scheduled query within the region for an AWS account. The name can contain letters, numbers, underscores, hyphens, forward slashes, periods, and hash symbols.</p>
    pub name: ::std::option::Option<::std::string::String>,
    /// <p>An optional description for the scheduled query to help identify its purpose.</p>
    pub description: ::std::option::Option<::std::string::String>,
    /// <p>The query language to use for the scheduled query. Valid values are LogsQL (CloudWatch Logs Insights query language), PPL (OpenSearch Service Piped Processing Language), and SQL (OpenSearch Service Structured Query Language).</p>
    pub query_language: ::std::option::Option<crate::types::QueryLanguage>,
    /// <p>The CloudWatch Logs Insights query string to execute. This is the actual query that will be run against your log data on the specified schedule.</p>
    pub query_string: ::std::option::Option<::std::string::String>,
    /// <p>The log group identifiers to query. You can specify log group names or log group ARNs. If querying log groups in a source account from a monitoring account, you must specify the ARN of the log group.</p>
    pub log_group_identifiers: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    /// <p>A cron expression that defines when the scheduled query runs. The format is cron(fields) where fields consist of six space-separated values: minutes, hours, day_of_month, month, day_of_week, year.</p>
    pub schedule_expression: ::std::option::Option<::std::string::String>,
    /// <p>The timezone in which the schedule expression is evaluated. If not provided, defaults to UTC.</p>
    pub timezone: ::std::option::Option<::std::string::String>,
    /// <p>Time offset in seconds from the execution time for the start of the query time range. This defines the lookback period for the query (for example, 3600 for the last hour).</p>
    pub start_time_offset: ::std::option::Option<i64>,
    /// <p>Configuration for destinations where the query results will be delivered after successful execution. You can configure delivery to S3 buckets or EventBridge event buses.</p>
    pub destination_configuration: ::std::option::Option<crate::types::DestinationConfiguration>,
    /// <p>The start time for the query schedule in Unix epoch time (seconds since January 1, 1970, 00:00:00 UTC). If not specified, the schedule starts immediately.</p>
    pub schedule_start_time: ::std::option::Option<i64>,
    /// <p>The end time for the query schedule in Unix epoch time (seconds since January 1, 1970, 00:00:00 UTC). If not specified, the schedule runs indefinitely.</p>
    pub schedule_end_time: ::std::option::Option<i64>,
    /// <p>The Amazon Resource Name (ARN) of the IAM role that CloudWatch Logs will assume to execute the scheduled query and deliver results to the specified destinations.</p>
    pub execution_role_arn: ::std::option::Option<::std::string::String>,
    /// <p>The initial state of the scheduled query. Valid values are ENABLED (the query will run according to its schedule) and DISABLED (the query is paused and will not run). If not provided, defaults to ENABLED.</p>
    pub state: ::std::option::Option<crate::types::ScheduledQueryState>,
    /// <p>An optional list of key-value pairs to associate with the resource.</p>
    /// <p>For more information about tagging, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging Amazon Web Services resources</a></p>
    pub tags: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
}
impl CreateScheduledQueryInput {
    /// <p>A unique name for the scheduled query within the region for an AWS account. The name can contain letters, numbers, underscores, hyphens, forward slashes, periods, and hash symbols.</p>
    pub fn name(&self) -> ::std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>An optional description for the scheduled query to help identify its purpose.</p>
    pub fn description(&self) -> ::std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The query language to use for the scheduled query. Valid values are LogsQL (CloudWatch Logs Insights query language), PPL (OpenSearch Service Piped Processing Language), and SQL (OpenSearch Service Structured Query Language).</p>
    pub fn query_language(&self) -> ::std::option::Option<&crate::types::QueryLanguage> {
        self.query_language.as_ref()
    }
    /// <p>The CloudWatch Logs Insights query string to execute. This is the actual query that will be run against your log data on the specified schedule.</p>
    pub fn query_string(&self) -> ::std::option::Option<&str> {
        self.query_string.as_deref()
    }
    /// <p>The log group identifiers to query. You can specify log group names or log group ARNs. If querying log groups in a source account from a monitoring account, you must specify the ARN of the log group.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.log_group_identifiers.is_none()`.
    pub fn log_group_identifiers(&self) -> &[::std::string::String] {
        self.log_group_identifiers.as_deref().unwrap_or_default()
    }
    /// <p>A cron expression that defines when the scheduled query runs. The format is cron(fields) where fields consist of six space-separated values: minutes, hours, day_of_month, month, day_of_week, year.</p>
    pub fn schedule_expression(&self) -> ::std::option::Option<&str> {
        self.schedule_expression.as_deref()
    }
    /// <p>The timezone in which the schedule expression is evaluated. If not provided, defaults to UTC.</p>
    pub fn timezone(&self) -> ::std::option::Option<&str> {
        self.timezone.as_deref()
    }
    /// <p>Time offset in seconds from the execution time for the start of the query time range. This defines the lookback period for the query (for example, 3600 for the last hour).</p>
    pub fn start_time_offset(&self) -> ::std::option::Option<i64> {
        self.start_time_offset
    }
    /// <p>Configuration for destinations where the query results will be delivered after successful execution. You can configure delivery to S3 buckets or EventBridge event buses.</p>
    pub fn destination_configuration(&self) -> ::std::option::Option<&crate::types::DestinationConfiguration> {
        self.destination_configuration.as_ref()
    }
    /// <p>The start time for the query schedule in Unix epoch time (seconds since January 1, 1970, 00:00:00 UTC). If not specified, the schedule starts immediately.</p>
    pub fn schedule_start_time(&self) -> ::std::option::Option<i64> {
        self.schedule_start_time
    }
    /// <p>The end time for the query schedule in Unix epoch time (seconds since January 1, 1970, 00:00:00 UTC). If not specified, the schedule runs indefinitely.</p>
    pub fn schedule_end_time(&self) -> ::std::option::Option<i64> {
        self.schedule_end_time
    }
    /// <p>The Amazon Resource Name (ARN) of the IAM role that CloudWatch Logs will assume to execute the scheduled query and deliver results to the specified destinations.</p>
    pub fn execution_role_arn(&self) -> ::std::option::Option<&str> {
        self.execution_role_arn.as_deref()
    }
    /// <p>The initial state of the scheduled query. Valid values are ENABLED (the query will run according to its schedule) and DISABLED (the query is paused and will not run). If not provided, defaults to ENABLED.</p>
    pub fn state(&self) -> ::std::option::Option<&crate::types::ScheduledQueryState> {
        self.state.as_ref()
    }
    /// <p>An optional list of key-value pairs to associate with the resource.</p>
    /// <p>For more information about tagging, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging Amazon Web Services resources</a></p>
    pub fn tags(&self) -> ::std::option::Option<&::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        self.tags.as_ref()
    }
}
impl CreateScheduledQueryInput {
    /// Creates a new builder-style object to manufacture [`CreateScheduledQueryInput`](crate::operation::create_scheduled_query::CreateScheduledQueryInput).
    pub fn builder() -> crate::operation::create_scheduled_query::builders::CreateScheduledQueryInputBuilder {
        crate::operation::create_scheduled_query::builders::CreateScheduledQueryInputBuilder::default()
    }
}

/// A builder for [`CreateScheduledQueryInput`](crate::operation::create_scheduled_query::CreateScheduledQueryInput).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct CreateScheduledQueryInputBuilder {
    pub(crate) name: ::std::option::Option<::std::string::String>,
    pub(crate) description: ::std::option::Option<::std::string::String>,
    pub(crate) query_language: ::std::option::Option<crate::types::QueryLanguage>,
    pub(crate) query_string: ::std::option::Option<::std::string::String>,
    pub(crate) log_group_identifiers: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub(crate) schedule_expression: ::std::option::Option<::std::string::String>,
    pub(crate) timezone: ::std::option::Option<::std::string::String>,
    pub(crate) start_time_offset: ::std::option::Option<i64>,
    pub(crate) destination_configuration: ::std::option::Option<crate::types::DestinationConfiguration>,
    pub(crate) schedule_start_time: ::std::option::Option<i64>,
    pub(crate) schedule_end_time: ::std::option::Option<i64>,
    pub(crate) execution_role_arn: ::std::option::Option<::std::string::String>,
    pub(crate) state: ::std::option::Option<crate::types::ScheduledQueryState>,
    pub(crate) tags: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
}
impl CreateScheduledQueryInputBuilder {
    /// <p>A unique name for the scheduled query within the region for an AWS account. The name can contain letters, numbers, underscores, hyphens, forward slashes, periods, and hash symbols.</p>
    /// This field is required.
    pub fn name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>A unique name for the scheduled query within the region for an AWS account. The name can contain letters, numbers, underscores, hyphens, forward slashes, periods, and hash symbols.</p>
    pub fn set_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.name = input;
        self
    }
    /// <p>A unique name for the scheduled query within the region for an AWS account. The name can contain letters, numbers, underscores, hyphens, forward slashes, periods, and hash symbols.</p>
    pub fn get_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.name
    }
    /// <p>An optional description for the scheduled query to help identify its purpose.</p>
    pub fn description(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.description = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>An optional description for the scheduled query to help identify its purpose.</p>
    pub fn set_description(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.description = input;
        self
    }
    /// <p>An optional description for the scheduled query to help identify its purpose.</p>
    pub fn get_description(&self) -> &::std::option::Option<::std::string::String> {
        &self.description
    }
    /// <p>The query language to use for the scheduled query. Valid values are LogsQL (CloudWatch Logs Insights query language), PPL (OpenSearch Service Piped Processing Language), and SQL (OpenSearch Service Structured Query Language).</p>
    /// This field is required.
    pub fn query_language(mut self, input: crate::types::QueryLanguage) -> Self {
        self.query_language = ::std::option::Option::Some(input);
        self
    }
    /// <p>The query language to use for the scheduled query. Valid values are LogsQL (CloudWatch Logs Insights query language), PPL (OpenSearch Service Piped Processing Language), and SQL (OpenSearch Service Structured Query Language).</p>
    pub fn set_query_language(mut self, input: ::std::option::Option<crate::types::QueryLanguage>) -> Self {
        self.query_language = input;
        self
    }
    /// <p>The query language to use for the scheduled query. Valid values are LogsQL (CloudWatch Logs Insights query language), PPL (OpenSearch Service Piped Processing Language), and SQL (OpenSearch Service Structured Query Language).</p>
    pub fn get_query_language(&self) -> &::std::option::Option<crate::types::QueryLanguage> {
        &self.query_language
    }
    /// <p>The CloudWatch Logs Insights query string to execute. This is the actual query that will be run against your log data on the specified schedule.</p>
    /// This field is required.
    pub fn query_string(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.query_string = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The CloudWatch Logs Insights query string to execute. This is the actual query that will be run against your log data on the specified schedule.</p>
    pub fn set_query_string(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.query_string = input;
        self
    }
    /// <p>The CloudWatch Logs Insights query string to execute. This is the actual query that will be run against your log data on the specified schedule.</p>
    pub fn get_query_string(&self) -> &::std::option::Option<::std::string::String> {
        &self.query_string
    }
    /// Appends an item to `log_group_identifiers`.
    ///
    /// To override the contents of this collection use [`set_log_group_identifiers`](Self::set_log_group_identifiers).
    ///
    /// <p>The log group identifiers to query. You can specify log group names or log group ARNs. If querying log groups in a source account from a monitoring account, you must specify the ARN of the log group.</p>
    pub fn log_group_identifiers(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut v = self.log_group_identifiers.unwrap_or_default();
        v.push(input.into());
        self.log_group_identifiers = ::std::option::Option::Some(v);
        self
    }
    /// <p>The log group identifiers to query. You can specify log group names or log group ARNs. If querying log groups in a source account from a monitoring account, you must specify the ARN of the log group.</p>
    pub fn set_log_group_identifiers(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.log_group_identifiers = input;
        self
    }
    /// <p>The log group identifiers to query. You can specify log group names or log group ARNs. If querying log groups in a source account from a monitoring account, you must specify the ARN of the log group.</p>
    pub fn get_log_group_identifiers(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        &self.log_group_identifiers
    }
    /// <p>A cron expression that defines when the scheduled query runs. The format is cron(fields) where fields consist of six space-separated values: minutes, hours, day_of_month, month, day_of_week, year.</p>
    /// This field is required.
    pub fn schedule_expression(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.schedule_expression = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>A cron expression that defines when the scheduled query runs. The format is cron(fields) where fields consist of six space-separated values: minutes, hours, day_of_month, month, day_of_week, year.</p>
    pub fn set_schedule_expression(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.schedule_expression = input;
        self
    }
    /// <p>A cron expression that defines when the scheduled query runs. The format is cron(fields) where fields consist of six space-separated values: minutes, hours, day_of_month, month, day_of_week, year.</p>
    pub fn get_schedule_expression(&self) -> &::std::option::Option<::std::string::String> {
        &self.schedule_expression
    }
    /// <p>The timezone in which the schedule expression is evaluated. If not provided, defaults to UTC.</p>
    pub fn timezone(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.timezone = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The timezone in which the schedule expression is evaluated. If not provided, defaults to UTC.</p>
    pub fn set_timezone(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.timezone = input;
        self
    }
    /// <p>The timezone in which the schedule expression is evaluated. If not provided, defaults to UTC.</p>
    pub fn get_timezone(&self) -> &::std::option::Option<::std::string::String> {
        &self.timezone
    }
    /// <p>Time offset in seconds from the execution time for the start of the query time range. This defines the lookback period for the query (for example, 3600 for the last hour).</p>
    pub fn start_time_offset(mut self, input: i64) -> Self {
        self.start_time_offset = ::std::option::Option::Some(input);
        self
    }
    /// <p>Time offset in seconds from the execution time for the start of the query time range. This defines the lookback period for the query (for example, 3600 for the last hour).</p>
    pub fn set_start_time_offset(mut self, input: ::std::option::Option<i64>) -> Self {
        self.start_time_offset = input;
        self
    }
    /// <p>Time offset in seconds from the execution time for the start of the query time range. This defines the lookback period for the query (for example, 3600 for the last hour).</p>
    pub fn get_start_time_offset(&self) -> &::std::option::Option<i64> {
        &self.start_time_offset
    }
    /// <p>Configuration for destinations where the query results will be delivered after successful execution. You can configure delivery to S3 buckets or EventBridge event buses.</p>
    pub fn destination_configuration(mut self, input: crate::types::DestinationConfiguration) -> Self {
        self.destination_configuration = ::std::option::Option::Some(input);
        self
    }
    /// <p>Configuration for destinations where the query results will be delivered after successful execution. You can configure delivery to S3 buckets or EventBridge event buses.</p>
    pub fn set_destination_configuration(mut self, input: ::std::option::Option<crate::types::DestinationConfiguration>) -> Self {
        self.destination_configuration = input;
        self
    }
    /// <p>Configuration for destinations where the query results will be delivered after successful execution. You can configure delivery to S3 buckets or EventBridge event buses.</p>
    pub fn get_destination_configuration(&self) -> &::std::option::Option<crate::types::DestinationConfiguration> {
        &self.destination_configuration
    }
    /// <p>The start time for the query schedule in Unix epoch time (seconds since January 1, 1970, 00:00:00 UTC). If not specified, the schedule starts immediately.</p>
    pub fn schedule_start_time(mut self, input: i64) -> Self {
        self.schedule_start_time = ::std::option::Option::Some(input);
        self
    }
    /// <p>The start time for the query schedule in Unix epoch time (seconds since January 1, 1970, 00:00:00 UTC). If not specified, the schedule starts immediately.</p>
    pub fn set_schedule_start_time(mut self, input: ::std::option::Option<i64>) -> Self {
        self.schedule_start_time = input;
        self
    }
    /// <p>The start time for the query schedule in Unix epoch time (seconds since January 1, 1970, 00:00:00 UTC). If not specified, the schedule starts immediately.</p>
    pub fn get_schedule_start_time(&self) -> &::std::option::Option<i64> {
        &self.schedule_start_time
    }
    /// <p>The end time for the query schedule in Unix epoch time (seconds since January 1, 1970, 00:00:00 UTC). If not specified, the schedule runs indefinitely.</p>
    pub fn schedule_end_time(mut self, input: i64) -> Self {
        self.schedule_end_time = ::std::option::Option::Some(input);
        self
    }
    /// <p>The end time for the query schedule in Unix epoch time (seconds since January 1, 1970, 00:00:00 UTC). If not specified, the schedule runs indefinitely.</p>
    pub fn set_schedule_end_time(mut self, input: ::std::option::Option<i64>) -> Self {
        self.schedule_end_time = input;
        self
    }
    /// <p>The end time for the query schedule in Unix epoch time (seconds since January 1, 1970, 00:00:00 UTC). If not specified, the schedule runs indefinitely.</p>
    pub fn get_schedule_end_time(&self) -> &::std::option::Option<i64> {
        &self.schedule_end_time
    }
    /// <p>The Amazon Resource Name (ARN) of the IAM role that CloudWatch Logs will assume to execute the scheduled query and deliver results to the specified destinations.</p>
    /// This field is required.
    pub fn execution_role_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.execution_role_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the IAM role that CloudWatch Logs will assume to execute the scheduled query and deliver results to the specified destinations.</p>
    pub fn set_execution_role_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.execution_role_arn = input;
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the IAM role that CloudWatch Logs will assume to execute the scheduled query and deliver results to the specified destinations.</p>
    pub fn get_execution_role_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.execution_role_arn
    }
    /// <p>The initial state of the scheduled query. Valid values are ENABLED (the query will run according to its schedule) and DISABLED (the query is paused and will not run). If not provided, defaults to ENABLED.</p>
    pub fn state(mut self, input: crate::types::ScheduledQueryState) -> Self {
        self.state = ::std::option::Option::Some(input);
        self
    }
    /// <p>The initial state of the scheduled query. Valid values are ENABLED (the query will run according to its schedule) and DISABLED (the query is paused and will not run). If not provided, defaults to ENABLED.</p>
    pub fn set_state(mut self, input: ::std::option::Option<crate::types::ScheduledQueryState>) -> Self {
        self.state = input;
        self
    }
    /// <p>The initial state of the scheduled query. Valid values are ENABLED (the query will run according to its schedule) and DISABLED (the query is paused and will not run). If not provided, defaults to ENABLED.</p>
    pub fn get_state(&self) -> &::std::option::Option<crate::types::ScheduledQueryState> {
        &self.state
    }
    /// Adds a key-value pair to `tags`.
    ///
    /// To override the contents of this collection use [`set_tags`](Self::set_tags).
    ///
    /// <p>An optional list of key-value pairs to associate with the resource.</p>
    /// <p>For more information about tagging, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging Amazon Web Services resources</a></p>
    pub fn tags(mut self, k: impl ::std::convert::Into<::std::string::String>, v: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut hash_map = self.tags.unwrap_or_default();
        hash_map.insert(k.into(), v.into());
        self.tags = ::std::option::Option::Some(hash_map);
        self
    }
    /// <p>An optional list of key-value pairs to associate with the resource.</p>
    /// <p>For more information about tagging, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging Amazon Web Services resources</a></p>
    pub fn set_tags(mut self, input: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>) -> Self {
        self.tags = input;
        self
    }
    /// <p>An optional list of key-value pairs to associate with the resource.</p>
    /// <p>For more information about tagging, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging Amazon Web Services resources</a></p>
    pub fn get_tags(&self) -> &::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        &self.tags
    }
    /// Consumes the builder and constructs a [`CreateScheduledQueryInput`](crate::operation::create_scheduled_query::CreateScheduledQueryInput).
    pub fn build(
        self,
    ) -> ::std::result::Result<crate::operation::create_scheduled_query::CreateScheduledQueryInput, ::aws_smithy_types::error::operation::BuildError>
    {
        ::std::result::Result::Ok(crate::operation::create_scheduled_query::CreateScheduledQueryInput {
            name: self.name,
            description: self.description,
            query_language: self.query_language,
            query_string: self.query_string,
            log_group_identifiers: self.log_group_identifiers,
            schedule_expression: self.schedule_expression,
            timezone: self.timezone,
            start_time_offset: self.start_time_offset,
            destination_configuration: self.destination_configuration,
            schedule_start_time: self.schedule_start_time,
            schedule_end_time: self.schedule_end_time,
            execution_role_arn: self.execution_role_arn,
            state: self.state,
            tags: self.tags,
        })
    }
}
