// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub use crate::operation::create_scheduled_query::_create_scheduled_query_output::CreateScheduledQueryOutputBuilder;

pub use crate::operation::create_scheduled_query::_create_scheduled_query_input::CreateScheduledQueryInputBuilder;

impl crate::operation::create_scheduled_query::builders::CreateScheduledQueryInputBuilder {
    /// Sends a request with this input using the given client.
    pub async fn send_with(
        self,
        client: &crate::Client,
    ) -> ::std::result::Result<
        crate::operation::create_scheduled_query::CreateScheduledQueryOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::create_scheduled_query::CreateScheduledQueryError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let mut fluent_builder = client.create_scheduled_query();
        fluent_builder.inner = self;
        fluent_builder.send().await
    }
}
/// Fluent builder constructing a request to `CreateScheduledQuery`.
///
/// <p>Creates a scheduled query that runs CloudWatch Logs Insights queries at regular intervals. Scheduled queries enable proactive monitoring by automatically executing queries to detect patterns and anomalies in your log data. Query results can be delivered to Amazon S3 for analysis or further processing.</p>
#[derive(::std::clone::Clone, ::std::fmt::Debug)]
pub struct CreateScheduledQueryFluentBuilder {
    handle: ::std::sync::Arc<crate::client::Handle>,
    inner: crate::operation::create_scheduled_query::builders::CreateScheduledQueryInputBuilder,
    config_override: ::std::option::Option<crate::config::Builder>,
}
impl
    crate::client::customize::internal::CustomizableSend<
        crate::operation::create_scheduled_query::CreateScheduledQueryOutput,
        crate::operation::create_scheduled_query::CreateScheduledQueryError,
    > for CreateScheduledQueryFluentBuilder
{
    fn send(
        self,
        config_override: crate::config::Builder,
    ) -> crate::client::customize::internal::BoxFuture<
        crate::client::customize::internal::SendResult<
            crate::operation::create_scheduled_query::CreateScheduledQueryOutput,
            crate::operation::create_scheduled_query::CreateScheduledQueryError,
        >,
    > {
        ::std::boxed::Box::pin(async move { self.config_override(config_override).send().await })
    }
}
impl CreateScheduledQueryFluentBuilder {
    /// Creates a new `CreateScheduledQueryFluentBuilder`.
    pub(crate) fn new(handle: ::std::sync::Arc<crate::client::Handle>) -> Self {
        Self {
            handle,
            inner: ::std::default::Default::default(),
            config_override: ::std::option::Option::None,
        }
    }
    /// Access the CreateScheduledQuery as a reference.
    pub fn as_input(&self) -> &crate::operation::create_scheduled_query::builders::CreateScheduledQueryInputBuilder {
        &self.inner
    }
    /// Sends the request and returns the response.
    ///
    /// If an error occurs, an `SdkError` will be returned with additional details that
    /// can be matched against.
    ///
    /// By default, any retryable failures will be retried twice. Retry behavior
    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
    /// set when configuring the client.
    pub async fn send(
        self,
    ) -> ::std::result::Result<
        crate::operation::create_scheduled_query::CreateScheduledQueryOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::create_scheduled_query::CreateScheduledQueryError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let input = self
            .inner
            .build()
            .map_err(::aws_smithy_runtime_api::client::result::SdkError::construction_failure)?;
        let runtime_plugins = crate::operation::create_scheduled_query::CreateScheduledQuery::operation_runtime_plugins(
            self.handle.runtime_plugins.clone(),
            &self.handle.conf,
            self.config_override,
        );
        crate::operation::create_scheduled_query::CreateScheduledQuery::orchestrate(&runtime_plugins, input).await
    }

    /// Consumes this builder, creating a customizable operation that can be modified before being sent.
    pub fn customize(
        self,
    ) -> crate::client::customize::CustomizableOperation<
        crate::operation::create_scheduled_query::CreateScheduledQueryOutput,
        crate::operation::create_scheduled_query::CreateScheduledQueryError,
        Self,
    > {
        crate::client::customize::CustomizableOperation::new(self)
    }
    pub(crate) fn config_override(mut self, config_override: impl ::std::convert::Into<crate::config::Builder>) -> Self {
        self.set_config_override(::std::option::Option::Some(config_override.into()));
        self
    }

    pub(crate) fn set_config_override(&mut self, config_override: ::std::option::Option<crate::config::Builder>) -> &mut Self {
        self.config_override = config_override;
        self
    }
    /// <p>The name of the scheduled query. The name must be unique within your account and region. Valid characters are alphanumeric characters, hyphens, underscores, and periods. Length must be between 1 and 255 characters.</p>
    pub fn name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.name(input.into());
        self
    }
    /// <p>The name of the scheduled query. The name must be unique within your account and region. Valid characters are alphanumeric characters, hyphens, underscores, and periods. Length must be between 1 and 255 characters.</p>
    pub fn set_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_name(input);
        self
    }
    /// <p>The name of the scheduled query. The name must be unique within your account and region. Valid characters are alphanumeric characters, hyphens, underscores, and periods. Length must be between 1 and 255 characters.</p>
    pub fn get_name(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_name()
    }
    /// <p>An optional description for the scheduled query to help identify its purpose and functionality.</p>
    pub fn description(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.description(input.into());
        self
    }
    /// <p>An optional description for the scheduled query to help identify its purpose and functionality.</p>
    pub fn set_description(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_description(input);
        self
    }
    /// <p>An optional description for the scheduled query to help identify its purpose and functionality.</p>
    pub fn get_description(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_description()
    }
    /// <p>The query language to use for the scheduled query. Valid values are <code>LogsQL</code>, <code>PPL</code>, and <code>SQL</code>.</p>
    pub fn query_language(mut self, input: crate::types::QueryLanguage) -> Self {
        self.inner = self.inner.query_language(input);
        self
    }
    /// <p>The query language to use for the scheduled query. Valid values are <code>LogsQL</code>, <code>PPL</code>, and <code>SQL</code>.</p>
    pub fn set_query_language(mut self, input: ::std::option::Option<crate::types::QueryLanguage>) -> Self {
        self.inner = self.inner.set_query_language(input);
        self
    }
    /// <p>The query language to use for the scheduled query. Valid values are <code>LogsQL</code>, <code>PPL</code>, and <code>SQL</code>.</p>
    pub fn get_query_language(&self) -> &::std::option::Option<crate::types::QueryLanguage> {
        self.inner.get_query_language()
    }
    /// <p>The query string to execute. This is the same query syntax used in CloudWatch Logs Insights. Maximum length is 10,000 characters.</p>
    pub fn query_string(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.query_string(input.into());
        self
    }
    /// <p>The query string to execute. This is the same query syntax used in CloudWatch Logs Insights. Maximum length is 10,000 characters.</p>
    pub fn set_query_string(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_query_string(input);
        self
    }
    /// <p>The query string to execute. This is the same query syntax used in CloudWatch Logs Insights. Maximum length is 10,000 characters.</p>
    pub fn get_query_string(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_query_string()
    }
    ///
    /// Appends an item to `logGroupIdentifiers`.
    ///
    /// To override the contents of this collection use [`set_log_group_identifiers`](Self::set_log_group_identifiers).
    ///
    /// <p>An array of log group names or ARNs to query. You can specify between 1 and 50 log groups. Log groups can be identified by name or full ARN.</p>
    pub fn log_group_identifiers(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.log_group_identifiers(input.into());
        self
    }
    /// <p>An array of log group names or ARNs to query. You can specify between 1 and 50 log groups. Log groups can be identified by name or full ARN.</p>
    pub fn set_log_group_identifiers(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.inner = self.inner.set_log_group_identifiers(input);
        self
    }
    /// <p>An array of log group names or ARNs to query. You can specify between 1 and 50 log groups. Log groups can be identified by name or full ARN.</p>
    pub fn get_log_group_identifiers(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        self.inner.get_log_group_identifiers()
    }
    /// <p>A cron expression that defines when the scheduled query runs. The expression uses standard cron syntax and supports minute-level precision. Maximum length is 256 characters.</p>
    pub fn schedule_expression(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.schedule_expression(input.into());
        self
    }
    /// <p>A cron expression that defines when the scheduled query runs. The expression uses standard cron syntax and supports minute-level precision. Maximum length is 256 characters.</p>
    pub fn set_schedule_expression(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_schedule_expression(input);
        self
    }
    /// <p>A cron expression that defines when the scheduled query runs. The expression uses standard cron syntax and supports minute-level precision. Maximum length is 256 characters.</p>
    pub fn get_schedule_expression(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_schedule_expression()
    }
    /// <p>The timezone for evaluating the schedule expression. This determines when the scheduled query executes relative to the specified timezone.</p>
    pub fn timezone(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.timezone(input.into());
        self
    }
    /// <p>The timezone for evaluating the schedule expression. This determines when the scheduled query executes relative to the specified timezone.</p>
    pub fn set_timezone(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_timezone(input);
        self
    }
    /// <p>The timezone for evaluating the schedule expression. This determines when the scheduled query executes relative to the specified timezone.</p>
    pub fn get_timezone(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_timezone()
    }
    /// <p>The time offset in seconds that defines the lookback period for the query. This determines how far back in time the query searches from the execution time.</p>
    pub fn start_time_offset(mut self, input: i64) -> Self {
        self.inner = self.inner.start_time_offset(input);
        self
    }
    /// <p>The time offset in seconds that defines the lookback period for the query. This determines how far back in time the query searches from the execution time.</p>
    pub fn set_start_time_offset(mut self, input: ::std::option::Option<i64>) -> Self {
        self.inner = self.inner.set_start_time_offset(input);
        self
    }
    /// <p>The time offset in seconds that defines the lookback period for the query. This determines how far back in time the query searches from the execution time.</p>
    pub fn get_start_time_offset(&self) -> &::std::option::Option<i64> {
        self.inner.get_start_time_offset()
    }
    /// <p>Configuration for where to deliver query results. Currently supports Amazon S3 destinations for storing query output.</p>
    pub fn destination_configuration(mut self, input: crate::types::DestinationConfiguration) -> Self {
        self.inner = self.inner.destination_configuration(input);
        self
    }
    /// <p>Configuration for where to deliver query results. Currently supports Amazon S3 destinations for storing query output.</p>
    pub fn set_destination_configuration(mut self, input: ::std::option::Option<crate::types::DestinationConfiguration>) -> Self {
        self.inner = self.inner.set_destination_configuration(input);
        self
    }
    /// <p>Configuration for where to deliver query results. Currently supports Amazon S3 destinations for storing query output.</p>
    pub fn get_destination_configuration(&self) -> &::std::option::Option<crate::types::DestinationConfiguration> {
        self.inner.get_destination_configuration()
    }
    /// <p>The start time for the scheduled query in Unix epoch format. The query will not execute before this time.</p>
    pub fn schedule_start_time(mut self, input: i64) -> Self {
        self.inner = self.inner.schedule_start_time(input);
        self
    }
    /// <p>The start time for the scheduled query in Unix epoch format. The query will not execute before this time.</p>
    pub fn set_schedule_start_time(mut self, input: ::std::option::Option<i64>) -> Self {
        self.inner = self.inner.set_schedule_start_time(input);
        self
    }
    /// <p>The start time for the scheduled query in Unix epoch format. The query will not execute before this time.</p>
    pub fn get_schedule_start_time(&self) -> &::std::option::Option<i64> {
        self.inner.get_schedule_start_time()
    }
    /// <p>The end time for the scheduled query in Unix epoch format. The query will stop executing after this time.</p>
    pub fn schedule_end_time(mut self, input: i64) -> Self {
        self.inner = self.inner.schedule_end_time(input);
        self
    }
    /// <p>The end time for the scheduled query in Unix epoch format. The query will stop executing after this time.</p>
    pub fn set_schedule_end_time(mut self, input: ::std::option::Option<i64>) -> Self {
        self.inner = self.inner.set_schedule_end_time(input);
        self
    }
    /// <p>The end time for the scheduled query in Unix epoch format. The query will stop executing after this time.</p>
    pub fn get_schedule_end_time(&self) -> &::std::option::Option<i64> {
        self.inner.get_schedule_end_time()
    }
    /// <p>The ARN of the IAM role that grants permissions to execute the query and deliver results to the specified destination. The role must have permissions to read from the specified log groups and write to the destination.</p>
    pub fn execution_role_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.execution_role_arn(input.into());
        self
    }
    /// <p>The ARN of the IAM role that grants permissions to execute the query and deliver results to the specified destination. The role must have permissions to read from the specified log groups and write to the destination.</p>
    pub fn set_execution_role_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_execution_role_arn(input);
        self
    }
    /// <p>The ARN of the IAM role that grants permissions to execute the query and deliver results to the specified destination. The role must have permissions to read from the specified log groups and write to the destination.</p>
    pub fn get_execution_role_arn(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_execution_role_arn()
    }
    /// <p>The initial state of the scheduled query. Valid values are <code>ENABLED</code> and <code>DISABLED</code>. Default is <code>ENABLED</code>.</p>
    pub fn state(mut self, input: crate::types::ScheduledQueryState) -> Self {
        self.inner = self.inner.state(input);
        self
    }
    /// <p>The initial state of the scheduled query. Valid values are <code>ENABLED</code> and <code>DISABLED</code>. Default is <code>ENABLED</code>.</p>
    pub fn set_state(mut self, input: ::std::option::Option<crate::types::ScheduledQueryState>) -> Self {
        self.inner = self.inner.set_state(input);
        self
    }
    /// <p>The initial state of the scheduled query. Valid values are <code>ENABLED</code> and <code>DISABLED</code>. Default is <code>ENABLED</code>.</p>
    pub fn get_state(&self) -> &::std::option::Option<crate::types::ScheduledQueryState> {
        self.inner.get_state()
    }
    ///
    /// Adds a key-value pair to `tags`.
    ///
    /// To override the contents of this collection use [`set_tags`](Self::set_tags).
    ///
    /// <p>Key-value pairs to associate with the scheduled query for resource management and cost allocation.</p>
    pub fn tags(mut self, k: impl ::std::convert::Into<::std::string::String>, v: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.tags(k.into(), v.into());
        self
    }
    /// <p>Key-value pairs to associate with the scheduled query for resource management and cost allocation.</p>
    pub fn set_tags(mut self, input: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>) -> Self {
        self.inner = self.inner.set_tags(input);
        self
    }
    /// <p>Key-value pairs to associate with the scheduled query for resource management and cost allocation.</p>
    pub fn get_tags(&self) -> &::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        self.inner.get_tags()
    }
}
