// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub fn create_export_task_deser_operation(
    input: &[u8],
    mut builder: crate::output::create_export_task_output::Builder,
) -> std::result::Result<crate::output::create_export_task_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::CreateExportTaskOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_task_id(parsed_body.task_id);
    Ok(builder)
}

pub fn delete_query_definition_deser_operation(
    input: &[u8],
    mut builder: crate::output::delete_query_definition_output::Builder,
) -> std::result::Result<crate::output::delete_query_definition_output::Builder, serde_json::Error>
{
    let parsed_body: crate::serializer::DeleteQueryDefinitionOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_success(Some(parsed_body.success));
    Ok(builder)
}

pub fn describe_destinations_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_destinations_output::Builder,
) -> std::result::Result<crate::output::describe_destinations_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DescribeDestinationsOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_destinations(parsed_body.destinations);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn describe_export_tasks_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_export_tasks_output::Builder,
) -> std::result::Result<crate::output::describe_export_tasks_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DescribeExportTasksOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_export_tasks(parsed_body.export_tasks);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn describe_log_groups_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_log_groups_output::Builder,
) -> std::result::Result<crate::output::describe_log_groups_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DescribeLogGroupsOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_log_groups(parsed_body.log_groups);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn describe_log_streams_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_log_streams_output::Builder,
) -> std::result::Result<crate::output::describe_log_streams_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DescribeLogStreamsOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_log_streams(parsed_body.log_streams);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn describe_metric_filters_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_metric_filters_output::Builder,
) -> std::result::Result<crate::output::describe_metric_filters_output::Builder, serde_json::Error>
{
    let parsed_body: crate::serializer::DescribeMetricFiltersOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_metric_filters(parsed_body.metric_filters);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn describe_queries_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_queries_output::Builder,
) -> std::result::Result<crate::output::describe_queries_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DescribeQueriesOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_queries(parsed_body.queries);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn describe_query_definitions_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_query_definitions_output::Builder,
) -> std::result::Result<crate::output::describe_query_definitions_output::Builder, serde_json::Error>
{
    let parsed_body: crate::serializer::DescribeQueryDefinitionsOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_query_definitions(parsed_body.query_definitions);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn describe_resource_policies_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_resource_policies_output::Builder,
) -> std::result::Result<crate::output::describe_resource_policies_output::Builder, serde_json::Error>
{
    let parsed_body: crate::serializer::DescribeResourcePoliciesOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_resource_policies(parsed_body.resource_policies);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn describe_subscription_filters_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_subscription_filters_output::Builder,
) -> std::result::Result<
    crate::output::describe_subscription_filters_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::DescribeSubscriptionFiltersOutputBody = if input.is_empty()
    {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_subscription_filters(parsed_body.subscription_filters);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn filter_log_events_deser_operation(
    input: &[u8],
    mut builder: crate::output::filter_log_events_output::Builder,
) -> std::result::Result<crate::output::filter_log_events_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::FilterLogEventsOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_events(parsed_body.events);
    builder = builder.set_searched_log_streams(parsed_body.searched_log_streams);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn get_log_events_deser_operation(
    input: &[u8],
    mut builder: crate::output::get_log_events_output::Builder,
) -> std::result::Result<crate::output::get_log_events_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::GetLogEventsOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_events(parsed_body.events);
    builder = builder.set_next_forward_token(parsed_body.next_forward_token);
    builder = builder.set_next_backward_token(parsed_body.next_backward_token);
    Ok(builder)
}

pub fn get_log_group_fields_deser_operation(
    input: &[u8],
    mut builder: crate::output::get_log_group_fields_output::Builder,
) -> std::result::Result<crate::output::get_log_group_fields_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::GetLogGroupFieldsOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_log_group_fields(parsed_body.log_group_fields);
    Ok(builder)
}

pub fn get_log_record_deser_operation(
    input: &[u8],
    mut builder: crate::output::get_log_record_output::Builder,
) -> std::result::Result<crate::output::get_log_record_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::GetLogRecordOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_log_record(parsed_body.log_record);
    Ok(builder)
}

pub fn get_query_results_deser_operation(
    input: &[u8],
    mut builder: crate::output::get_query_results_output::Builder,
) -> std::result::Result<crate::output::get_query_results_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::GetQueryResultsOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_results(parsed_body.results);
    builder = builder.set_statistics(parsed_body.statistics);
    builder = builder.set_status(parsed_body.status);
    Ok(builder)
}

pub fn list_tags_log_group_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_tags_log_group_output::Builder,
) -> std::result::Result<crate::output::list_tags_log_group_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ListTagsLogGroupOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_tags(parsed_body.tags);
    Ok(builder)
}

pub fn put_destination_deser_operation(
    input: &[u8],
    mut builder: crate::output::put_destination_output::Builder,
) -> std::result::Result<crate::output::put_destination_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::PutDestinationOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_destination(parsed_body.destination);
    Ok(builder)
}

pub fn put_log_events_deser_operation(
    input: &[u8],
    mut builder: crate::output::put_log_events_output::Builder,
) -> std::result::Result<crate::output::put_log_events_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::PutLogEventsOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_next_sequence_token(parsed_body.next_sequence_token);
    builder = builder.set_rejected_log_events_info(parsed_body.rejected_log_events_info);
    Ok(builder)
}

pub fn put_query_definition_deser_operation(
    input: &[u8],
    mut builder: crate::output::put_query_definition_output::Builder,
) -> std::result::Result<crate::output::put_query_definition_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::PutQueryDefinitionOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_query_definition_id(parsed_body.query_definition_id);
    Ok(builder)
}

pub fn put_resource_policy_deser_operation(
    input: &[u8],
    mut builder: crate::output::put_resource_policy_output::Builder,
) -> std::result::Result<crate::output::put_resource_policy_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::PutResourcePolicyOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_resource_policy(parsed_body.resource_policy);
    Ok(builder)
}

pub fn start_query_deser_operation(
    input: &[u8],
    mut builder: crate::output::start_query_output::Builder,
) -> std::result::Result<crate::output::start_query_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::StartQueryOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_query_id(parsed_body.query_id);
    Ok(builder)
}

pub fn stop_query_deser_operation(
    input: &[u8],
    mut builder: crate::output::stop_query_output::Builder,
) -> std::result::Result<crate::output::stop_query_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::StopQueryOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_success(Some(parsed_body.success));
    Ok(builder)
}

pub fn test_metric_filter_deser_operation(
    input: &[u8],
    mut builder: crate::output::test_metric_filter_output::Builder,
) -> std::result::Result<crate::output::test_metric_filter_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::TestMetricFilterOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_matches(parsed_body.matches);
    Ok(builder)
}
