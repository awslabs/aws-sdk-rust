// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AssociateKmsKeyInputBody<'a> {
    /// <p>The name of the log group.</p>
    pub log_group_name: &'a std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the CMK to use when encrypting log data. This must be a symmetric CMK.
    /// For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-kms">Amazon Resource Names - AWS Key Management Service (AWS KMS)</a> and <a href="https://docs.aws.amazon.com/kms/latest/developerguide/symmetric-asymmetric.html">Using Symmetric and Asymmetric Keys</a>.</p>
    pub kms_key_id: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for AssociateKmsKeyInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AssociateKmsKeyInputBody");
        formatter.field("log_group_name", &self.log_group_name);
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CancelExportTaskInputBody<'a> {
    /// <p>The ID of the export task.</p>
    pub task_id: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for CancelExportTaskInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CancelExportTaskInputBody");
        formatter.field("task_id", &self.task_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateExportTaskInputBody<'a> {
    /// <p>The name of the export task.</p>
    pub task_name: &'a std::option::Option<std::string::String>,
    /// <p>The name of the log group.</p>
    pub log_group_name: &'a std::option::Option<std::string::String>,
    /// <p>Export only log streams that match the provided prefix. If you don't
    /// specify a value, no prefix filter is applied.</p>
    pub log_stream_name_prefix: &'a std::option::Option<std::string::String>,
    /// <p>The start time of the range for the request, expressed as the number of milliseconds
    /// after Jan 1, 1970 00:00:00 UTC. Events with a timestamp earlier than this time are not
    /// exported.</p>
    pub from: &'a std::option::Option<i64>,
    /// <p>The end time of the range for the request, expreswatchlogsdocused as the number of milliseconds
    /// after Jan 1, 1970 00:00:00 UTC. Events with a timestamp later than this time are not
    /// exported.</p>
    pub to: &'a std::option::Option<i64>,
    /// <p>The name of S3 bucket for the exported log data. The bucket must be in the same AWS region.</p>
    pub destination: &'a std::option::Option<std::string::String>,
    /// <p>The prefix used as the start of the key for every object exported. If you don't
    /// specify a value, the default is <code>exportedlogs</code>.</p>
    pub destination_prefix: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for CreateExportTaskInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateExportTaskInputBody");
        formatter.field("task_name", &self.task_name);
        formatter.field("log_group_name", &self.log_group_name);
        formatter.field("log_stream_name_prefix", &self.log_stream_name_prefix);
        formatter.field("from", &self.from);
        formatter.field("to", &self.to);
        formatter.field("destination", &self.destination);
        formatter.field("destination_prefix", &self.destination_prefix);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateLogGroupInputBody<'a> {
    /// <p>The name of the log group.</p>
    pub log_group_name: &'a std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the CMK to use when encrypting log data.
    /// For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html#arn-syntax-kms">Amazon Resource Names - AWS Key Management Service (AWS KMS)</a>.</p>
    pub kms_key_id: &'a std::option::Option<std::string::String>,
    /// <p>The key-value pairs to use for the tags.</p>
    pub tags: &'a std::option::Option<
        std::collections::HashMap<std::string::String, std::string::String>,
    >,
}
impl<'a> std::fmt::Debug for CreateLogGroupInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateLogGroupInputBody");
        formatter.field("log_group_name", &self.log_group_name);
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateLogStreamInputBody<'a> {
    /// <p>The name of the log group.</p>
    pub log_group_name: &'a std::option::Option<std::string::String>,
    /// <p>The name of the log stream.</p>
    pub log_stream_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for CreateLogStreamInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateLogStreamInputBody");
        formatter.field("log_group_name", &self.log_group_name);
        formatter.field("log_stream_name", &self.log_stream_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteDestinationInputBody<'a> {
    /// <p>The name of the destination.</p>
    pub destination_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DeleteDestinationInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteDestinationInputBody");
        formatter.field("destination_name", &self.destination_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteLogGroupInputBody<'a> {
    /// <p>The name of the log group.</p>
    pub log_group_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DeleteLogGroupInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteLogGroupInputBody");
        formatter.field("log_group_name", &self.log_group_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteLogStreamInputBody<'a> {
    /// <p>The name of the log group.</p>
    pub log_group_name: &'a std::option::Option<std::string::String>,
    /// <p>The name of the log stream.</p>
    pub log_stream_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DeleteLogStreamInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteLogStreamInputBody");
        formatter.field("log_group_name", &self.log_group_name);
        formatter.field("log_stream_name", &self.log_stream_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteMetricFilterInputBody<'a> {
    /// <p>The name of the log group.</p>
    pub log_group_name: &'a std::option::Option<std::string::String>,
    /// <p>The name of the metric filter.</p>
    pub filter_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DeleteMetricFilterInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteMetricFilterInputBody");
        formatter.field("log_group_name", &self.log_group_name);
        formatter.field("filter_name", &self.filter_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteQueryDefinitionInputBody<'a> {
    /// <p>The ID of the query definition that you want to delete. You can use <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_DescribeQueryDefinitions.html">DescribeQueryDefinitions</a> to retrieve the
    /// IDs of your saved query definitions.</p>
    pub query_definition_id: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DeleteQueryDefinitionInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteQueryDefinitionInputBody");
        formatter.field("query_definition_id", &self.query_definition_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteResourcePolicyInputBody<'a> {
    /// <p>The name of the policy to be revoked. This parameter is required.</p>
    pub policy_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DeleteResourcePolicyInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteResourcePolicyInputBody");
        formatter.field("policy_name", &self.policy_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteRetentionPolicyInputBody<'a> {
    /// <p>The name of the log group.</p>
    pub log_group_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DeleteRetentionPolicyInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteRetentionPolicyInputBody");
        formatter.field("log_group_name", &self.log_group_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteSubscriptionFilterInputBody<'a> {
    /// <p>The name of the log group.</p>
    pub log_group_name: &'a std::option::Option<std::string::String>,
    /// <p>The name of the subscription filter.</p>
    pub filter_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DeleteSubscriptionFilterInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteSubscriptionFilterInputBody");
        formatter.field("log_group_name", &self.log_group_name);
        formatter.field("filter_name", &self.filter_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeDestinationsInputBody<'a> {
    /// <p>The prefix to match. If you don't specify a value, no prefix filter is applied.</p>
    pub destination_name_prefix: &'a std::option::Option<std::string::String>,
    /// <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>The maximum number of items returned. If you don't specify a value, the default is up to 50 items.</p>
    pub limit: &'a std::option::Option<i32>,
}
impl<'a> std::fmt::Debug for DescribeDestinationsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeDestinationsInputBody");
        formatter.field("destination_name_prefix", &self.destination_name_prefix);
        formatter.field("next_token", &self.next_token);
        formatter.field("limit", &self.limit);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeExportTasksInputBody<'a> {
    /// <p>The ID of the export task. Specifying a task ID filters the results to zero or one export tasks.</p>
    pub task_id: &'a std::option::Option<std::string::String>,
    /// <p>The status code of the export task. Specifying a status code filters the results to zero or more export tasks.</p>
    pub status_code: &'a std::option::Option<crate::model::ExportTaskStatusCode>,
    /// <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>The maximum number of items returned. If you don't specify a value, the default is up to 50 items.</p>
    pub limit: &'a std::option::Option<i32>,
}
impl<'a> std::fmt::Debug for DescribeExportTasksInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeExportTasksInputBody");
        formatter.field("task_id", &self.task_id);
        formatter.field("status_code", &self.status_code);
        formatter.field("next_token", &self.next_token);
        formatter.field("limit", &self.limit);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeLogGroupsInputBody<'a> {
    /// <p>The prefix to match.</p>
    pub log_group_name_prefix: &'a std::option::Option<std::string::String>,
    /// <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>The maximum number of items returned. If you don't specify a value, the default is up to 50 items.</p>
    pub limit: &'a std::option::Option<i32>,
}
impl<'a> std::fmt::Debug for DescribeLogGroupsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeLogGroupsInputBody");
        formatter.field("log_group_name_prefix", &self.log_group_name_prefix);
        formatter.field("next_token", &self.next_token);
        formatter.field("limit", &self.limit);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeLogStreamsInputBody<'a> {
    /// <p>The name of the log group.</p>
    pub log_group_name: &'a std::option::Option<std::string::String>,
    /// <p>The prefix to match.</p>
    /// <p>If <code>orderBy</code> is <code>LastEventTime</code>, you cannot specify this
    /// parameter.</p>
    pub log_stream_name_prefix: &'a std::option::Option<std::string::String>,
    /// <p>If the value is <code>LogStreamName</code>, the results are ordered by log stream name.
    /// If the value is <code>LastEventTime</code>, the results are ordered by the event time.
    /// The default value is <code>LogStreamName</code>.</p>
    /// <p>If you order the results by event time, you cannot specify the <code>logStreamNamePrefix</code> parameter.</p>
    /// <p>
    /// <code>lastEventTimestamp</code> represents the time of the most recent log event in the
    /// log stream in CloudWatch Logs. This number is expressed as the number of milliseconds after
    /// Jan 1, 1970 00:00:00 UTC. <code>lastEventTimestamp</code> updates on an eventual consistency
    /// basis. It typically updates in less than an hour from ingestion, but in rare situations might
    /// take longer.</p>
    pub order_by: &'a std::option::Option<crate::model::OrderBy>,
    /// <p>If the value is true, results are returned in descending order.
    /// If the value is to false, results are returned in ascending order.
    /// The default value is false.</p>
    pub descending: &'a std::option::Option<bool>,
    /// <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>The maximum number of items returned. If you don't specify a value, the default is up to 50 items.</p>
    pub limit: &'a std::option::Option<i32>,
}
impl<'a> std::fmt::Debug for DescribeLogStreamsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeLogStreamsInputBody");
        formatter.field("log_group_name", &self.log_group_name);
        formatter.field("log_stream_name_prefix", &self.log_stream_name_prefix);
        formatter.field("order_by", &self.order_by);
        formatter.field("descending", &self.descending);
        formatter.field("next_token", &self.next_token);
        formatter.field("limit", &self.limit);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeMetricFiltersInputBody<'a> {
    /// <p>The name of the log group.</p>
    pub log_group_name: &'a std::option::Option<std::string::String>,
    /// <p>The prefix to match. CloudWatch Logs uses the value you set here
    /// only if you also include the <code>logGroupName</code> parameter in your request.</p>
    pub filter_name_prefix: &'a std::option::Option<std::string::String>,
    /// <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>The maximum number of items returned. If you don't specify a value, the default is up to 50 items.</p>
    pub limit: &'a std::option::Option<i32>,
    /// <p>Filters results to include only those with the specified metric name. If you include this parameter in your request, you
    /// must also include the <code>metricNamespace</code> parameter.</p>
    pub metric_name: &'a std::option::Option<std::string::String>,
    /// <p>Filters results to include only those in the specified namespace. If you include this parameter in your request, you
    /// must also include the <code>metricName</code> parameter.</p>
    pub metric_namespace: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribeMetricFiltersInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeMetricFiltersInputBody");
        formatter.field("log_group_name", &self.log_group_name);
        formatter.field("filter_name_prefix", &self.filter_name_prefix);
        formatter.field("next_token", &self.next_token);
        formatter.field("limit", &self.limit);
        formatter.field("metric_name", &self.metric_name);
        formatter.field("metric_namespace", &self.metric_namespace);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeQueriesInputBody<'a> {
    /// <p>Limits the returned queries to only those for the specified log group.</p>
    pub log_group_name: &'a std::option::Option<std::string::String>,
    /// <p>Limits the returned queries to only those that have the specified status. Valid values are <code>Cancelled</code>,
    /// <code>Complete</code>, <code>Failed</code>, <code>Running</code>, and <code>Scheduled</code>.</p>
    pub status: &'a std::option::Option<crate::model::QueryStatus>,
    /// <p>Limits the number of returned queries to the specified number.</p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>The token for the next set of items to return. The token expires after 24 hours.</p>
    pub next_token: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribeQueriesInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeQueriesInputBody");
        formatter.field("log_group_name", &self.log_group_name);
        formatter.field("status", &self.status);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeQueryDefinitionsInputBody<'a> {
    /// <p>Use this parameter to filter your results to only the query definitions that have names that start with the prefix you specify.</p>
    pub query_definition_name_prefix: &'a std::option::Option<std::string::String>,
    /// <p>Limits the number of returned query definitions to the specified number.</p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>The token for the next set of items to return. The token expires after 24 hours.</p>
    pub next_token: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribeQueryDefinitionsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeQueryDefinitionsInputBody");
        formatter.field(
            "query_definition_name_prefix",
            &self.query_definition_name_prefix,
        );
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeResourcePoliciesInputBody<'a> {
    /// <p>The token for the next set of items to return. The token expires after 24 hours.</p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>The maximum number of resource policies to be displayed with one call of this API.</p>
    pub limit: &'a std::option::Option<i32>,
}
impl<'a> std::fmt::Debug for DescribeResourcePoliciesInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeResourcePoliciesInputBody");
        formatter.field("next_token", &self.next_token);
        formatter.field("limit", &self.limit);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeSubscriptionFiltersInputBody<'a> {
    /// <p>The name of the log group.</p>
    pub log_group_name: &'a std::option::Option<std::string::String>,
    /// <p>The prefix to match. If you don't specify a value, no prefix filter is applied.</p>
    pub filter_name_prefix: &'a std::option::Option<std::string::String>,
    /// <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>The maximum number of items returned. If you don't specify a value, the default is up to 50 items.</p>
    pub limit: &'a std::option::Option<i32>,
}
impl<'a> std::fmt::Debug for DescribeSubscriptionFiltersInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeSubscriptionFiltersInputBody");
        formatter.field("log_group_name", &self.log_group_name);
        formatter.field("filter_name_prefix", &self.filter_name_prefix);
        formatter.field("next_token", &self.next_token);
        formatter.field("limit", &self.limit);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DisassociateKmsKeyInputBody<'a> {
    /// <p>The name of the log group.</p>
    pub log_group_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DisassociateKmsKeyInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DisassociateKmsKeyInputBody");
        formatter.field("log_group_name", &self.log_group_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FilterLogEventsInputBody<'a> {
    /// <p>The name of the log group to search.</p>
    pub log_group_name: &'a std::option::Option<std::string::String>,
    /// <p>Filters the results to only logs from the log streams in this list.</p>
    /// <p>If you specify a value for both <code>logStreamNamePrefix</code> and <code>logStreamNames</code>, the action
    /// returns an <code>InvalidParameterException</code> error.</p>
    pub log_stream_names: &'a std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Filters the results to include only events from log streams that have names starting with this prefix.</p>
    /// <p>If you specify a value for both <code>logStreamNamePrefix</code> and <code>logStreamNames</code>, but the value for
    /// <code>logStreamNamePrefix</code> does not match any log stream names specified in <code>logStreamNames</code>, the action
    /// returns an <code>InvalidParameterException</code> error.</p>
    pub log_stream_name_prefix: &'a std::option::Option<std::string::String>,
    /// <p>The start of the time range, expressed as the number of milliseconds after Jan 1, 1970
    /// 00:00:00 UTC. Events with a timestamp before this time are not returned.</p>
    pub start_time: &'a std::option::Option<i64>,
    /// <p>The end of the time range, expressed as the number of milliseconds after Jan 1, 1970
    /// 00:00:00 UTC. Events with a timestamp later than this time are not returned.</p>
    pub end_time: &'a std::option::Option<i64>,
    /// <p>The filter pattern to use. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/FilterAndPatternSyntax.html">Filter and Pattern Syntax</a>.</p>
    /// <p>If not provided, all the events are matched.</p>
    pub filter_pattern: &'a std::option::Option<std::string::String>,
    /// <p>The token for the next set of events to return. (You received this token from a previous call.)</p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>The maximum number of events to return. The default is 10,000 events.</p>
    pub limit: &'a std::option::Option<i32>,
    /// <p>If the value is true, the operation makes a best effort to provide responses that
    /// contain events from multiple log streams within the log group, interleaved in a single
    /// response. If the value is false, all the matched log events in the first log stream are
    /// searched first, then those in the next log stream, and so on. The default is false.</p>
    /// <p>
    /// <b>Important:</b> Starting on June 17, 2019, this parameter
    /// is ignored and the value is assumed to be true. The response from this operation always
    /// interleaves events from multiple log streams within a log group.</p>
    pub interleaved: &'a std::option::Option<bool>,
}
impl<'a> std::fmt::Debug for FilterLogEventsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FilterLogEventsInputBody");
        formatter.field("log_group_name", &self.log_group_name);
        formatter.field("log_stream_names", &self.log_stream_names);
        formatter.field("log_stream_name_prefix", &self.log_stream_name_prefix);
        formatter.field("start_time", &self.start_time);
        formatter.field("end_time", &self.end_time);
        formatter.field("filter_pattern", &self.filter_pattern);
        formatter.field("next_token", &self.next_token);
        formatter.field("limit", &self.limit);
        formatter.field("interleaved", &self.interleaved);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetLogEventsInputBody<'a> {
    /// <p>The name of the log group.</p>
    pub log_group_name: &'a std::option::Option<std::string::String>,
    /// <p>The name of the log stream.</p>
    pub log_stream_name: &'a std::option::Option<std::string::String>,
    /// <p>The start of the time range, expressed as the number of milliseconds after Jan 1, 1970
    /// 00:00:00 UTC. Events with a timestamp equal to this time or later than this time are included.
    /// Events with a timestamp earlier than this time are not included.</p>
    pub start_time: &'a std::option::Option<i64>,
    /// <p>The end of the time range, expressed as the number of milliseconds after Jan 1, 1970
    /// 00:00:00 UTC. Events with a timestamp equal to or later than this time are not
    /// included.</p>
    pub end_time: &'a std::option::Option<i64>,
    /// <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
    /// <p>Using this token works only when you specify <code>true</code> for <code>startFromHead</code>.</p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>The maximum number of log events returned. If you don't specify a value, the maximum is
    /// as many log events as can fit in a response size of 1 MB, up to 10,000 log events.</p>
    pub limit: &'a std::option::Option<i32>,
    /// <p>If the value is true, the earliest log events are returned first.
    /// If the value is false, the latest log events are returned first.
    /// The default value is false.</p>
    /// <p>If you are using <code>nextToken</code> in this operation, you must specify <code>true</code> for <code>startFromHead</code>.</p>
    pub start_from_head: &'a std::option::Option<bool>,
}
impl<'a> std::fmt::Debug for GetLogEventsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetLogEventsInputBody");
        formatter.field("log_group_name", &self.log_group_name);
        formatter.field("log_stream_name", &self.log_stream_name);
        formatter.field("start_time", &self.start_time);
        formatter.field("end_time", &self.end_time);
        formatter.field("next_token", &self.next_token);
        formatter.field("limit", &self.limit);
        formatter.field("start_from_head", &self.start_from_head);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetLogGroupFieldsInputBody<'a> {
    /// <p>The name of the log group to search.</p>
    pub log_group_name: &'a std::option::Option<std::string::String>,
    /// <p>The time to set as the center of the query. If you specify <code>time</code>, the 15 minutes
    /// before this time are queries. If you omit <code>time</code> the 8
    /// minutes before and 8 minutes after this time are searched.</p>
    /// <p>The <code>time</code> value is specified as epoch time, the number of seconds since
    /// January 1, 1970, 00:00:00 UTC.</p>
    pub time: &'a std::option::Option<i64>,
}
impl<'a> std::fmt::Debug for GetLogGroupFieldsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetLogGroupFieldsInputBody");
        formatter.field("log_group_name", &self.log_group_name);
        formatter.field("time", &self.time);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetLogRecordInputBody<'a> {
    /// <p>The pointer corresponding to the log event record you want to retrieve. You get this from
    /// the response of a <code>GetQueryResults</code> operation. In that response, the value of the
    /// <code>@ptr</code> field for a log event is the value to use as <code>logRecordPointer</code>
    /// to retrieve that complete log event record.</p>
    pub log_record_pointer: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for GetLogRecordInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetLogRecordInputBody");
        formatter.field("log_record_pointer", &self.log_record_pointer);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetQueryResultsInputBody<'a> {
    /// <p>The ID number of the query.</p>
    pub query_id: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for GetQueryResultsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetQueryResultsInputBody");
        formatter.field("query_id", &self.query_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListTagsLogGroupInputBody<'a> {
    /// <p>The name of the log group.</p>
    pub log_group_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for ListTagsLogGroupInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListTagsLogGroupInputBody");
        formatter.field("log_group_name", &self.log_group_name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutDestinationInputBody<'a> {
    /// <p>A name for the destination.</p>
    pub destination_name: &'a std::option::Option<std::string::String>,
    /// <p>The ARN of an Amazon Kinesis stream to which to deliver matching log events.</p>
    pub target_arn: &'a std::option::Option<std::string::String>,
    /// <p>The ARN of an IAM role that grants CloudWatch Logs permissions to call the Amazon
    /// Kinesis <code>PutRecord</code> operation on the destination stream.</p>
    pub role_arn: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for PutDestinationInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutDestinationInputBody");
        formatter.field("destination_name", &self.destination_name);
        formatter.field("target_arn", &self.target_arn);
        formatter.field("role_arn", &self.role_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutDestinationPolicyInputBody<'a> {
    /// <p>A name for an existing destination.</p>
    pub destination_name: &'a std::option::Option<std::string::String>,
    /// <p>An IAM policy document that authorizes cross-account users to deliver their log events
    /// to the associated destination. This can be up to 5120 bytes.</p>
    pub access_policy: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for PutDestinationPolicyInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutDestinationPolicyInputBody");
        formatter.field("destination_name", &self.destination_name);
        formatter.field("access_policy", &self.access_policy);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutLogEventsInputBody<'a> {
    /// <p>The name of the log group.</p>
    pub log_group_name: &'a std::option::Option<std::string::String>,
    /// <p>The name of the log stream.</p>
    pub log_stream_name: &'a std::option::Option<std::string::String>,
    /// <p>The log events.</p>
    pub log_events: &'a std::option::Option<std::vec::Vec<crate::model::InputLogEvent>>,
    /// <p>The sequence token obtained from the response of the previous <code>PutLogEvents</code>
    /// call. An upload in a newly created log stream does not require a sequence token. You can also
    /// get the sequence token using <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_DescribeLogStreams.html">DescribeLogStreams</a>. If you call <code>PutLogEvents</code> twice within a narrow
    /// time period using the same value for <code>sequenceToken</code>, both calls might be
    /// successful or one might be rejected.</p>
    pub sequence_token: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for PutLogEventsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutLogEventsInputBody");
        formatter.field("log_group_name", &self.log_group_name);
        formatter.field("log_stream_name", &self.log_stream_name);
        formatter.field("log_events", &self.log_events);
        formatter.field("sequence_token", &self.sequence_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutMetricFilterInputBody<'a> {
    /// <p>The name of the log group.</p>
    pub log_group_name: &'a std::option::Option<std::string::String>,
    /// <p>A name for the metric filter.</p>
    pub filter_name: &'a std::option::Option<std::string::String>,
    /// <p>A filter pattern for extracting metric data out of ingested log events.</p>
    pub filter_pattern: &'a std::option::Option<std::string::String>,
    /// <p>A collection of information that defines how metric data gets emitted.</p>
    pub metric_transformations:
        &'a std::option::Option<std::vec::Vec<crate::model::MetricTransformation>>,
}
impl<'a> std::fmt::Debug for PutMetricFilterInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutMetricFilterInputBody");
        formatter.field("log_group_name", &self.log_group_name);
        formatter.field("filter_name", &self.filter_name);
        formatter.field("filter_pattern", &self.filter_pattern);
        formatter.field("metric_transformations", &self.metric_transformations);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutQueryDefinitionInputBody<'a> {
    /// <p>A name for the query definition. If you are saving a lot of query definitions, we
    /// recommend that you name them so that you can easily find the ones you want by using the first
    /// part of the name as a filter in the <code>queryDefinitionNamePrefix</code> parameter of <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_DescribeQueryDefinitions.html">DescribeQueryDefinitions</a>.</p>
    pub name: &'a std::option::Option<std::string::String>,
    /// <p>If you are updating a query definition, use this parameter to specify the ID of the query
    /// definition that you want to update. You can use <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_DescribeQueryDefinitions.html">DescribeQueryDefinitions</a> to retrieve the IDs of your saved query
    /// definitions.</p>
    /// <p>If you are creating a query definition, do not specify this parameter. CloudWatch
    /// generates a unique ID for the new query definition and include it in the response to this
    /// operation.</p>
    pub query_definition_id: &'a std::option::Option<std::string::String>,
    /// <p>Use this parameter to include specific log groups as part of your query definition.</p>
    /// <p>If you are updating a query definition and you omit this parameter, then the updated
    /// definition will contain no log groups.</p>
    pub log_group_names: &'a std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The query string to use for this definition.
    /// For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CWL_QuerySyntax.html">CloudWatch Logs Insights Query Syntax</a>.</p>
    pub query_string: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for PutQueryDefinitionInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutQueryDefinitionInputBody");
        formatter.field("name", &self.name);
        formatter.field("query_definition_id", &self.query_definition_id);
        formatter.field("log_group_names", &self.log_group_names);
        formatter.field("query_string", &self.query_string);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutResourcePolicyInputBody<'a> {
    /// <p>Name of the new policy. This parameter is required.</p>
    pub policy_name: &'a std::option::Option<std::string::String>,
    /// <p>Details of the new policy, including the identity of the principal that is enabled to put logs to this account. This is formatted as a JSON string.
    /// This parameter is required.</p>
    /// <p>The following example creates a resource policy enabling the Route 53 service to put
    /// DNS query logs in to the specified log group. Replace <code>"logArn"</code> with the ARN of your CloudWatch Logs resource, such as a log group or log stream.</p>
    /// <p>
    /// <code>{
    /// "Version": "2012-10-17",
    /// "Statement": [
    /// {
    /// "Sid": "Route53LogsToCloudWatchLogs",
    /// "Effect": "Allow",
    /// "Principal": {
    /// "Service": [
    /// "route53.amazonaws.com"
    /// ]
    /// },
    /// "Action":"logs:PutLogEvents",
    /// "Resource": "logArn"
    /// }
    /// ]
    /// } </code>
    /// </p>
    pub policy_document: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for PutResourcePolicyInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutResourcePolicyInputBody");
        formatter.field("policy_name", &self.policy_name);
        formatter.field("policy_document", &self.policy_document);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutRetentionPolicyInputBody<'a> {
    /// <p>The name of the log group.</p>
    pub log_group_name: &'a std::option::Option<std::string::String>,
    /// <p>The number of days to retain the log events in the specified log group.
    /// Possible values are: 1, 3, 5, 7, 14, 30, 60, 90, 120, 150, 180, 365, 400, 545, 731, 1827, and 3653.</p>
    /// <p>If you omit <code>retentionInDays</code> in a <code>PutRetentionPolicy</code> operation,
    /// the events in the log group are always retained and never expire.</p>
    pub retention_in_days: &'a std::option::Option<i32>,
}
impl<'a> std::fmt::Debug for PutRetentionPolicyInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutRetentionPolicyInputBody");
        formatter.field("log_group_name", &self.log_group_name);
        formatter.field("retention_in_days", &self.retention_in_days);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutSubscriptionFilterInputBody<'a> {
    /// <p>The name of the log group.</p>
    pub log_group_name: &'a std::option::Option<std::string::String>,
    /// <p>A name for the subscription filter. If you are updating an existing filter, you must
    /// specify the correct name in <code>filterName</code>. To find the name of the filter currently
    /// associated with a log group, use <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_DescribeSubscriptionFilters.html">DescribeSubscriptionFilters</a>.</p>
    pub filter_name: &'a std::option::Option<std::string::String>,
    /// <p>A filter pattern for subscribing to a filtered stream of log events.</p>
    pub filter_pattern: &'a std::option::Option<std::string::String>,
    /// <p>The ARN of the destination to deliver matching log events to. Currently, the supported
    /// destinations are:</p>
    /// <ul>
    /// <li>
    /// <p>An Amazon Kinesis stream belonging to the same account as the subscription filter,
    /// for same-account delivery.</p>
    /// </li>
    /// <li>
    /// <p>A logical destination (specified using an ARN) belonging to a different account,
    /// for cross-account delivery.</p>
    /// <p>If you are setting up a cross-account subscription, the destination must have an
    /// IAM policy associated with it that allows the sender to send logs to the destination.
    /// For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_PutDestinationPolicy.html">PutDestinationPolicy</a>.</p>
    /// </li>
    /// <li>
    /// <p>An Amazon Kinesis Firehose delivery stream belonging to the same account as the
    /// subscription filter, for same-account delivery.</p>
    /// </li>
    /// <li>
    /// <p>An AWS Lambda function belonging to the same account as the subscription filter,
    /// for same-account delivery.</p>
    /// </li>
    /// </ul>
    pub destination_arn: &'a std::option::Option<std::string::String>,
    /// <p>The ARN of an IAM role that grants CloudWatch Logs permissions to deliver ingested log
    /// events to the destination stream. You don't need to provide the ARN when you are working with
    /// a logical destination for cross-account delivery.</p>
    pub role_arn: &'a std::option::Option<std::string::String>,
    /// <p>The method used to distribute log data to the destination. By default, log data is
    /// grouped by log stream, but the grouping can be set to random for a more even distribution.
    /// This property is only applicable when the destination is an Amazon Kinesis stream. </p>
    pub distribution: &'a std::option::Option<crate::model::Distribution>,
}
impl<'a> std::fmt::Debug for PutSubscriptionFilterInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutSubscriptionFilterInputBody");
        formatter.field("log_group_name", &self.log_group_name);
        formatter.field("filter_name", &self.filter_name);
        formatter.field("filter_pattern", &self.filter_pattern);
        formatter.field("destination_arn", &self.destination_arn);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("distribution", &self.distribution);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StartQueryInputBody<'a> {
    /// <p>The log group on which to perform the query.</p>
    /// <p>A <code>StartQuery</code> operation must include a <code>logGroupNames</code> or a <code>logGroupName</code> parameter, but
    /// not both.</p>
    pub log_group_name: &'a std::option::Option<std::string::String>,
    /// <p>The list of log groups to be queried. You can include up to 20 log groups.</p>
    /// <p>A <code>StartQuery</code> operation must include a <code>logGroupNames</code> or a <code>logGroupName</code> parameter, but
    /// not both.</p>
    pub log_group_names: &'a std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The beginning of the time range to query. The range is inclusive, so the specified
    /// start time is included in the query. Specified as epoch time, the
    /// number of seconds since January 1, 1970, 00:00:00 UTC.</p>
    pub start_time: &'a std::option::Option<i64>,
    /// <p>The end of the time range to query. The range is inclusive, so the specified
    /// end time is included in the query. Specified as epoch
    /// time, the number of seconds since January 1, 1970, 00:00:00 UTC.</p>
    pub end_time: &'a std::option::Option<i64>,
    /// <p>The query string to use.
    /// For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CWL_QuerySyntax.html">CloudWatch Logs Insights Query Syntax</a>.</p>
    pub query_string: &'a std::option::Option<std::string::String>,
    /// <p>The maximum number of log events to return in the query. If the query string uses the <code>fields</code> command,
    /// only the specified fields and their values are returned. The default is 1000.</p>
    pub limit: &'a std::option::Option<i32>,
}
impl<'a> std::fmt::Debug for StartQueryInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartQueryInputBody");
        formatter.field("log_group_name", &self.log_group_name);
        formatter.field("log_group_names", &self.log_group_names);
        formatter.field("start_time", &self.start_time);
        formatter.field("end_time", &self.end_time);
        formatter.field("query_string", &self.query_string);
        formatter.field("limit", &self.limit);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StopQueryInputBody<'a> {
    /// <p>The ID number of the query to stop. To find this ID number, use
    /// <code>DescribeQueries</code>.</p>
    pub query_id: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for StopQueryInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StopQueryInputBody");
        formatter.field("query_id", &self.query_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TagLogGroupInputBody<'a> {
    /// <p>The name of the log group.</p>
    pub log_group_name: &'a std::option::Option<std::string::String>,
    /// <p>The key-value pairs to use for the tags.</p>
    pub tags: &'a std::option::Option<
        std::collections::HashMap<std::string::String, std::string::String>,
    >,
}
impl<'a> std::fmt::Debug for TagLogGroupInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TagLogGroupInputBody");
        formatter.field("log_group_name", &self.log_group_name);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TestMetricFilterInputBody<'a> {
    /// <p>A symbolic description of how CloudWatch Logs should interpret the data in each log
    /// event. For example, a log event can contain timestamps, IP addresses, strings, and so on. You
    /// use the filter pattern to specify what to look for in the log event message.</p>
    pub filter_pattern: &'a std::option::Option<std::string::String>,
    /// <p>The log event messages to test.</p>
    pub log_event_messages: &'a std::option::Option<std::vec::Vec<std::string::String>>,
}
impl<'a> std::fmt::Debug for TestMetricFilterInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TestMetricFilterInputBody");
        formatter.field("filter_pattern", &self.filter_pattern);
        formatter.field("log_event_messages", &self.log_event_messages);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UntagLogGroupInputBody<'a> {
    /// <p>The name of the log group.</p>
    pub log_group_name: &'a std::option::Option<std::string::String>,
    /// <p>The tag keys. The corresponding tags are removed from the log group.</p>
    pub tags: &'a std::option::Option<std::vec::Vec<std::string::String>>,
}
impl<'a> std::fmt::Debug for UntagLogGroupInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UntagLogGroupInputBody");
        formatter.field("log_group_name", &self.log_group_name);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateExportTaskOutputBody {
    /// <p>The ID of the export task.</p>
    #[serde(rename = "taskId")]
    #[serde(default)]
    pub task_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateExportTaskOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateExportTaskOutputBody");
        formatter.field("task_id", &self.task_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteQueryDefinitionOutputBody {
    /// <p>A value of TRUE indicates that the operation succeeded. FALSE indicates that the operation
    /// failed.</p>
    #[serde(rename = "success")]
    #[serde(default)]
    pub success: bool,
}
impl std::fmt::Debug for DeleteQueryDefinitionOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteQueryDefinitionOutputBody");
        formatter.field("success", &self.success);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeDestinationsOutputBody {
    /// <p>The destinations.</p>
    #[serde(rename = "destinations")]
    #[serde(default)]
    pub destinations: std::option::Option<std::vec::Vec<crate::model::Destination>>,
    /// <p>The token for the next set of items to return. The token expires after 24 hours.</p>
    #[serde(rename = "nextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeDestinationsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeDestinationsOutputBody");
        formatter.field("destinations", &self.destinations);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeExportTasksOutputBody {
    /// <p>The export tasks.</p>
    #[serde(rename = "exportTasks")]
    #[serde(default)]
    pub export_tasks: std::option::Option<std::vec::Vec<crate::model::ExportTask>>,
    /// <p>The token for the next set of items to return. The token expires after 24 hours.</p>
    #[serde(rename = "nextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeExportTasksOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeExportTasksOutputBody");
        formatter.field("export_tasks", &self.export_tasks);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeLogGroupsOutputBody {
    /// <p>The log groups.</p>
    /// <p>If the <code>retentionInDays</code> value if not included for a log group, then that log group
    /// is set to have its events never expire.</p>
    #[serde(rename = "logGroups")]
    #[serde(default)]
    pub log_groups: std::option::Option<std::vec::Vec<crate::model::LogGroup>>,
    /// <p>The token for the next set of items to return. The token expires after 24 hours.</p>
    #[serde(rename = "nextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeLogGroupsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeLogGroupsOutputBody");
        formatter.field("log_groups", &self.log_groups);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeLogStreamsOutputBody {
    /// <p>The log streams.</p>
    #[serde(rename = "logStreams")]
    #[serde(default)]
    pub log_streams: std::option::Option<std::vec::Vec<crate::model::LogStream>>,
    /// <p>The token for the next set of items to return. The token expires after 24 hours.</p>
    #[serde(rename = "nextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeLogStreamsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeLogStreamsOutputBody");
        formatter.field("log_streams", &self.log_streams);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeMetricFiltersOutputBody {
    /// <p>The metric filters.</p>
    #[serde(rename = "metricFilters")]
    #[serde(default)]
    pub metric_filters: std::option::Option<std::vec::Vec<crate::model::MetricFilter>>,
    /// <p>The token for the next set of items to return. The token expires after 24 hours.</p>
    #[serde(rename = "nextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeMetricFiltersOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeMetricFiltersOutputBody");
        formatter.field("metric_filters", &self.metric_filters);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeQueriesOutputBody {
    /// <p>The list of queries that match the request.</p>
    #[serde(rename = "queries")]
    #[serde(default)]
    pub queries: std::option::Option<std::vec::Vec<crate::model::QueryInfo>>,
    /// <p>The token for the next set of items to return. The token expires after 24 hours.</p>
    #[serde(rename = "nextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeQueriesOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeQueriesOutputBody");
        formatter.field("queries", &self.queries);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeQueryDefinitionsOutputBody {
    /// <p>The list of query definitions that match your request.</p>
    #[serde(rename = "queryDefinitions")]
    #[serde(default)]
    pub query_definitions: std::option::Option<std::vec::Vec<crate::model::QueryDefinition>>,
    /// <p>The token for the next set of items to return. The token expires after 24 hours.</p>
    #[serde(rename = "nextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeQueryDefinitionsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeQueryDefinitionsOutputBody");
        formatter.field("query_definitions", &self.query_definitions);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeResourcePoliciesOutputBody {
    /// <p>The resource policies that exist in this account.</p>
    #[serde(rename = "resourcePolicies")]
    #[serde(default)]
    pub resource_policies: std::option::Option<std::vec::Vec<crate::model::ResourcePolicy>>,
    /// <p>The token for the next set of items to return. The token expires after 24 hours.</p>
    #[serde(rename = "nextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeResourcePoliciesOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeResourcePoliciesOutputBody");
        formatter.field("resource_policies", &self.resource_policies);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeSubscriptionFiltersOutputBody {
    /// <p>The subscription filters.</p>
    #[serde(rename = "subscriptionFilters")]
    #[serde(default)]
    pub subscription_filters: std::option::Option<std::vec::Vec<crate::model::SubscriptionFilter>>,
    /// <p>The token for the next set of items to return. The token expires after 24 hours.</p>
    #[serde(rename = "nextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeSubscriptionFiltersOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeSubscriptionFiltersOutputBody");
        formatter.field("subscription_filters", &self.subscription_filters);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct FilterLogEventsOutputBody {
    /// <p>The matched events.</p>
    #[serde(rename = "events")]
    #[serde(default)]
    pub events: std::option::Option<std::vec::Vec<crate::model::FilteredLogEvent>>,
    /// <p>
    /// <b>IMPORTANT</b> Starting on May 15, 2020,
    /// this parameter will be deprecated. This parameter will be an empty list
    /// after the deprecation occurs.</p>
    /// <p>Indicates which log streams have been searched and whether each has been searched completely.</p>
    #[serde(rename = "searchedLogStreams")]
    #[serde(default)]
    pub searched_log_streams: std::option::Option<std::vec::Vec<crate::model::SearchedLogStream>>,
    /// <p>The token to use when requesting the next set of items. The token expires after 24 hours.</p>
    #[serde(rename = "nextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for FilterLogEventsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FilterLogEventsOutputBody");
        formatter.field("events", &self.events);
        formatter.field("searched_log_streams", &self.searched_log_streams);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GetLogEventsOutputBody {
    /// <p>The events.</p>
    #[serde(rename = "events")]
    #[serde(default)]
    pub events: std::option::Option<std::vec::Vec<crate::model::OutputLogEvent>>,
    /// <p>The token for the next set of items in the forward direction. The token expires after
    /// 24 hours. If you have reached the end of the stream, it returns the same token you passed
    /// in.</p>
    #[serde(rename = "nextForwardToken")]
    #[serde(default)]
    pub next_forward_token: std::option::Option<std::string::String>,
    /// <p>The token for the next set of items in the backward direction. The token expires after
    /// 24 hours. This token is never null. If you have reached the end of the stream, it returns the
    /// same token you passed in.</p>
    #[serde(rename = "nextBackwardToken")]
    #[serde(default)]
    pub next_backward_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetLogEventsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetLogEventsOutputBody");
        formatter.field("events", &self.events);
        formatter.field("next_forward_token", &self.next_forward_token);
        formatter.field("next_backward_token", &self.next_backward_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GetLogGroupFieldsOutputBody {
    /// <p>The array of fields found in the query. Each object in the array contains the name of the field, along with the
    /// percentage of time it appeared in the log events that were queried.</p>
    #[serde(rename = "logGroupFields")]
    #[serde(default)]
    pub log_group_fields: std::option::Option<std::vec::Vec<crate::model::LogGroupField>>,
}
impl std::fmt::Debug for GetLogGroupFieldsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetLogGroupFieldsOutputBody");
        formatter.field("log_group_fields", &self.log_group_fields);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GetLogRecordOutputBody {
    /// <p>The requested log event, as a JSON string.</p>
    #[serde(rename = "logRecord")]
    #[serde(default)]
    pub log_record:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl std::fmt::Debug for GetLogRecordOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetLogRecordOutputBody");
        formatter.field("log_record", &self.log_record);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GetQueryResultsOutputBody {
    /// <p>The log events that matched the query criteria during the most recent time it ran.</p>
    /// <p>The <code>results</code> value is an array of arrays. Each log event is one object in the
    /// top-level array. Each of these log event objects is an array of
    /// <code>field</code>/<code>value</code> pairs.</p>
    #[serde(rename = "results")]
    #[serde(default)]
    pub results: std::option::Option<std::vec::Vec<std::vec::Vec<crate::model::ResultField>>>,
    /// <p>Includes the number of log events scanned by the query, the number of log events that matched the
    /// query criteria, and the total number of bytes in the log events that were scanned. These values
    /// reflect the full raw results of the query.</p>
    #[serde(rename = "statistics")]
    #[serde(default)]
    pub statistics: std::option::Option<crate::model::QueryStatistics>,
    /// <p>The status of the most recent running of the query. Possible values are <code>Cancelled</code>,
    /// <code>Complete</code>, <code>Failed</code>, <code>Running</code>, <code>Scheduled</code>,
    /// <code>Timeout</code>, and <code>Unknown</code>.</p>
    /// <p>Queries time out after 15 minutes of execution. To avoid having your queries time out,
    /// reduce the time range being searched or partition your query into a number of queries.</p>
    #[serde(rename = "status")]
    #[serde(default)]
    pub status: std::option::Option<crate::model::QueryStatus>,
}
impl std::fmt::Debug for GetQueryResultsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetQueryResultsOutputBody");
        formatter.field("results", &self.results);
        formatter.field("statistics", &self.statistics);
        formatter.field("status", &self.status);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListTagsLogGroupOutputBody {
    /// <p>The tags for the log group.</p>
    #[serde(rename = "tags")]
    #[serde(default)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl std::fmt::Debug for ListTagsLogGroupOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListTagsLogGroupOutputBody");
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct PutDestinationOutputBody {
    /// <p>The destination.</p>
    #[serde(rename = "destination")]
    #[serde(default)]
    pub destination: std::option::Option<crate::model::Destination>,
}
impl std::fmt::Debug for PutDestinationOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutDestinationOutputBody");
        formatter.field("destination", &self.destination);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct PutLogEventsOutputBody {
    /// <p>The next sequence token.</p>
    #[serde(rename = "nextSequenceToken")]
    #[serde(default)]
    pub next_sequence_token: std::option::Option<std::string::String>,
    /// <p>The rejected events.</p>
    #[serde(rename = "rejectedLogEventsInfo")]
    #[serde(default)]
    pub rejected_log_events_info: std::option::Option<crate::model::RejectedLogEventsInfo>,
}
impl std::fmt::Debug for PutLogEventsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutLogEventsOutputBody");
        formatter.field("next_sequence_token", &self.next_sequence_token);
        formatter.field("rejected_log_events_info", &self.rejected_log_events_info);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct PutQueryDefinitionOutputBody {
    /// <p>The ID of the query definition.</p>
    #[serde(rename = "queryDefinitionId")]
    #[serde(default)]
    pub query_definition_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PutQueryDefinitionOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutQueryDefinitionOutputBody");
        formatter.field("query_definition_id", &self.query_definition_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct PutResourcePolicyOutputBody {
    /// <p>The new policy.</p>
    #[serde(rename = "resourcePolicy")]
    #[serde(default)]
    pub resource_policy: std::option::Option<crate::model::ResourcePolicy>,
}
impl std::fmt::Debug for PutResourcePolicyOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutResourcePolicyOutputBody");
        formatter.field("resource_policy", &self.resource_policy);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct StartQueryOutputBody {
    /// <p>The unique ID of the query. </p>
    #[serde(rename = "queryId")]
    #[serde(default)]
    pub query_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for StartQueryOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartQueryOutputBody");
        formatter.field("query_id", &self.query_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct StopQueryOutputBody {
    /// <p>This is true if the query was stopped by the <code>StopQuery</code> operation.</p>
    #[serde(rename = "success")]
    #[serde(default)]
    pub success: bool,
}
impl std::fmt::Debug for StopQueryOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StopQueryOutputBody");
        formatter.field("success", &self.success);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct TestMetricFilterOutputBody {
    /// <p>The matched events.</p>
    #[serde(rename = "matches")]
    #[serde(default)]
    pub matches: std::option::Option<std::vec::Vec<crate::model::MetricFilterMatchRecord>>,
}
impl std::fmt::Debug for TestMetricFilterOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TestMetricFilterOutputBody");
        formatter.field("matches", &self.matches);
        formatter.finish()
    }
}
