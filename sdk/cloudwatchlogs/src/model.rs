// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>Represents a matched event.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MetricFilterMatchRecord {
    /// <p>The event number.</p>
    pub event_number: i64,
    /// <p>The raw event data.</p>
    pub event_message: std::option::Option<std::string::String>,
    /// <p>The values extracted from the event data by the filter.</p>
    pub extracted_values:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl std::fmt::Debug for MetricFilterMatchRecord {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MetricFilterMatchRecord");
        formatter.field("event_number", &self.event_number);
        formatter.field("event_message", &self.event_message);
        formatter.field("extracted_values", &self.extracted_values);
        formatter.finish()
    }
}
/// See [`MetricFilterMatchRecord`](crate::model::MetricFilterMatchRecord)
pub mod metric_filter_match_record {
    /// A builder for [`MetricFilterMatchRecord`](crate::model::MetricFilterMatchRecord)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) event_number: std::option::Option<i64>,
        pub(crate) event_message: std::option::Option<std::string::String>,
        pub(crate) extracted_values: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The event number.</p>
        pub fn event_number(mut self, input: i64) -> Self {
            self.event_number = Some(input);
            self
        }
        /// <p>The event number.</p>
        pub fn set_event_number(mut self, input: std::option::Option<i64>) -> Self {
            self.event_number = input;
            self
        }
        /// <p>The raw event data.</p>
        pub fn event_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.event_message = Some(input.into());
            self
        }
        /// <p>The raw event data.</p>
        pub fn set_event_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.event_message = input;
            self
        }
        /// Adds a key-value pair to `extracted_values`.
        ///
        /// To override the contents of this collection use [`set_extracted_values`](Self::set_extracted_values).
        ///
        /// <p>The values extracted from the event data by the filter.</p>
        pub fn extracted_values(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.extracted_values.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.extracted_values = Some(hash_map);
            self
        }
        /// <p>The values extracted from the event data by the filter.</p>
        pub fn set_extracted_values(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.extracted_values = input;
            self
        }
        /// Consumes the builder and constructs a [`MetricFilterMatchRecord`](crate::model::MetricFilterMatchRecord)
        pub fn build(self) -> crate::model::MetricFilterMatchRecord {
            crate::model::MetricFilterMatchRecord {
                event_number: self.event_number.unwrap_or_default(),
                event_message: self.event_message,
                extracted_values: self.extracted_values,
            }
        }
    }
}
impl MetricFilterMatchRecord {
    /// Creates a new builder-style object to manufacture [`MetricFilterMatchRecord`](crate::model::MetricFilterMatchRecord)
    pub fn builder() -> crate::model::metric_filter_match_record::Builder {
        crate::model::metric_filter_match_record::Builder::default()
    }
}

/// <p>Reserved.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct QueryCompileError {
    /// <p>Reserved.</p>
    pub location: std::option::Option<crate::model::QueryCompileErrorLocation>,
    /// <p>Reserved.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for QueryCompileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("QueryCompileError");
        formatter.field("location", &self.location);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
/// See [`QueryCompileError`](crate::model::QueryCompileError)
pub mod query_compile_error {
    /// A builder for [`QueryCompileError`](crate::model::QueryCompileError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) location: std::option::Option<crate::model::QueryCompileErrorLocation>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Reserved.</p>
        pub fn location(mut self, input: crate::model::QueryCompileErrorLocation) -> Self {
            self.location = Some(input);
            self
        }
        /// <p>Reserved.</p>
        pub fn set_location(
            mut self,
            input: std::option::Option<crate::model::QueryCompileErrorLocation>,
        ) -> Self {
            self.location = input;
            self
        }
        /// <p>Reserved.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Reserved.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`QueryCompileError`](crate::model::QueryCompileError)
        pub fn build(self) -> crate::model::QueryCompileError {
            crate::model::QueryCompileError {
                location: self.location,
                message: self.message,
            }
        }
    }
}
impl QueryCompileError {
    /// Creates a new builder-style object to manufacture [`QueryCompileError`](crate::model::QueryCompileError)
    pub fn builder() -> crate::model::query_compile_error::Builder {
        crate::model::query_compile_error::Builder::default()
    }
}

/// <p>Reserved.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct QueryCompileErrorLocation {
    /// <p>Reserved.</p>
    pub start_char_offset: std::option::Option<i32>,
    /// <p>Reserved.</p>
    pub end_char_offset: std::option::Option<i32>,
}
impl std::fmt::Debug for QueryCompileErrorLocation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("QueryCompileErrorLocation");
        formatter.field("start_char_offset", &self.start_char_offset);
        formatter.field("end_char_offset", &self.end_char_offset);
        formatter.finish()
    }
}
/// See [`QueryCompileErrorLocation`](crate::model::QueryCompileErrorLocation)
pub mod query_compile_error_location {
    /// A builder for [`QueryCompileErrorLocation`](crate::model::QueryCompileErrorLocation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) start_char_offset: std::option::Option<i32>,
        pub(crate) end_char_offset: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>Reserved.</p>
        pub fn start_char_offset(mut self, input: i32) -> Self {
            self.start_char_offset = Some(input);
            self
        }
        /// <p>Reserved.</p>
        pub fn set_start_char_offset(mut self, input: std::option::Option<i32>) -> Self {
            self.start_char_offset = input;
            self
        }
        /// <p>Reserved.</p>
        pub fn end_char_offset(mut self, input: i32) -> Self {
            self.end_char_offset = Some(input);
            self
        }
        /// <p>Reserved.</p>
        pub fn set_end_char_offset(mut self, input: std::option::Option<i32>) -> Self {
            self.end_char_offset = input;
            self
        }
        /// Consumes the builder and constructs a [`QueryCompileErrorLocation`](crate::model::QueryCompileErrorLocation)
        pub fn build(self) -> crate::model::QueryCompileErrorLocation {
            crate::model::QueryCompileErrorLocation {
                start_char_offset: self.start_char_offset,
                end_char_offset: self.end_char_offset,
            }
        }
    }
}
impl QueryCompileErrorLocation {
    /// Creates a new builder-style object to manufacture [`QueryCompileErrorLocation`](crate::model::QueryCompileErrorLocation)
    pub fn builder() -> crate::model::query_compile_error_location::Builder {
        crate::model::query_compile_error_location::Builder::default()
    }
}

/// <p>The method used to distribute log data to the destination, which can be either
/// random or grouped by log stream.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Distribution {
    #[allow(missing_docs)] // documentation missing in model
    ByLogStream,
    #[allow(missing_docs)] // documentation missing in model
    Random,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for Distribution {
    fn from(s: &str) -> Self {
        match s {
            "ByLogStream" => Distribution::ByLogStream,
            "Random" => Distribution::Random,
            other => Distribution::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for Distribution {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Distribution::from(s))
    }
}
impl Distribution {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Distribution::ByLogStream => "ByLogStream",
            Distribution::Random => "Random",
            Distribution::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["ByLogStream", "Random"]
    }
}
impl AsRef<str> for Distribution {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A policy enabling one or more entities to put logs to a log group in this account.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourcePolicy {
    /// <p>The name of the resource policy.</p>
    pub policy_name: std::option::Option<std::string::String>,
    /// <p>The details of the policy.</p>
    pub policy_document: std::option::Option<std::string::String>,
    /// <p>Timestamp showing when this policy was last updated, expressed as the number of
    /// milliseconds after Jan 1, 1970 00:00:00 UTC.</p>
    pub last_updated_time: std::option::Option<i64>,
}
impl std::fmt::Debug for ResourcePolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourcePolicy");
        formatter.field("policy_name", &self.policy_name);
        formatter.field("policy_document", &self.policy_document);
        formatter.field("last_updated_time", &self.last_updated_time);
        formatter.finish()
    }
}
/// See [`ResourcePolicy`](crate::model::ResourcePolicy)
pub mod resource_policy {
    /// A builder for [`ResourcePolicy`](crate::model::ResourcePolicy)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) policy_name: std::option::Option<std::string::String>,
        pub(crate) policy_document: std::option::Option<std::string::String>,
        pub(crate) last_updated_time: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The name of the resource policy.</p>
        pub fn policy_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_name = Some(input.into());
            self
        }
        /// <p>The name of the resource policy.</p>
        pub fn set_policy_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.policy_name = input;
            self
        }
        /// <p>The details of the policy.</p>
        pub fn policy_document(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_document = Some(input.into());
            self
        }
        /// <p>The details of the policy.</p>
        pub fn set_policy_document(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.policy_document = input;
            self
        }
        /// <p>Timestamp showing when this policy was last updated, expressed as the number of
        /// milliseconds after Jan 1, 1970 00:00:00 UTC.</p>
        pub fn last_updated_time(mut self, input: i64) -> Self {
            self.last_updated_time = Some(input);
            self
        }
        /// <p>Timestamp showing when this policy was last updated, expressed as the number of
        /// milliseconds after Jan 1, 1970 00:00:00 UTC.</p>
        pub fn set_last_updated_time(mut self, input: std::option::Option<i64>) -> Self {
            self.last_updated_time = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourcePolicy`](crate::model::ResourcePolicy)
        pub fn build(self) -> crate::model::ResourcePolicy {
            crate::model::ResourcePolicy {
                policy_name: self.policy_name,
                policy_document: self.policy_document,
                last_updated_time: self.last_updated_time,
            }
        }
    }
}
impl ResourcePolicy {
    /// Creates a new builder-style object to manufacture [`ResourcePolicy`](crate::model::ResourcePolicy)
    pub fn builder() -> crate::model::resource_policy::Builder {
        crate::model::resource_policy::Builder::default()
    }
}

/// <p>Indicates how to transform ingested log events to metric data in a CloudWatch
/// metric.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MetricTransformation {
    /// <p>The name of the CloudWatch metric.</p>
    pub metric_name: std::option::Option<std::string::String>,
    /// <p>A custom namespace to contain your metric in CloudWatch. Use namespaces to group together metrics
    /// that are similar. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/cloudwatch_concepts.html#Namespace">Namespaces</a>.</p>
    pub metric_namespace: std::option::Option<std::string::String>,
    /// <p>The value to publish to the CloudWatch metric when a filter pattern matches a log event.</p>
    pub metric_value: std::option::Option<std::string::String>,
    /// <p>(Optional) The value to emit when a filter pattern does not match a log event.
    /// This value can be null.</p>
    pub default_value: std::option::Option<f64>,
    /// <p>The fields to use as dimensions for the metric. One metric filter can include
    /// as many as three dimensions.</p>
    /// <important>
    /// <p>Metrics extracted from log events are charged as custom metrics.
    /// To prevent unexpected high charges, do not specify high-cardinality fields such as
    /// <code>IPAddress</code> or <code>requestID</code> as dimensions. Each different value
    /// found for
    /// a dimension is treated as a separate metric and accrues charges as a separate custom metric.
    /// </p>
    /// <p>To help prevent accidental high charges, Amazon disables a metric filter
    /// if it generates 1000 different name/value pairs for the dimensions that you
    /// have specified within a certain amount of time.</p>
    /// <p>You can also set up a billing alarm to alert you if your charges are higher than
    /// expected. For more information,
    /// see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/monitor_estimated_charges_with_cloudwatch.html">
    /// Creating a Billing Alarm to Monitor Your Estimated Amazon Web Services Charges</a>.
    /// </p>
    /// </important>
    pub dimensions:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The unit to assign to the metric. If you omit this, the unit is set as <code>None</code>.</p>
    pub unit: std::option::Option<crate::model::StandardUnit>,
}
impl std::fmt::Debug for MetricTransformation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MetricTransformation");
        formatter.field("metric_name", &self.metric_name);
        formatter.field("metric_namespace", &self.metric_namespace);
        formatter.field("metric_value", &self.metric_value);
        formatter.field("default_value", &self.default_value);
        formatter.field("dimensions", &self.dimensions);
        formatter.field("unit", &self.unit);
        formatter.finish()
    }
}
/// See [`MetricTransformation`](crate::model::MetricTransformation)
pub mod metric_transformation {
    /// A builder for [`MetricTransformation`](crate::model::MetricTransformation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) metric_name: std::option::Option<std::string::String>,
        pub(crate) metric_namespace: std::option::Option<std::string::String>,
        pub(crate) metric_value: std::option::Option<std::string::String>,
        pub(crate) default_value: std::option::Option<f64>,
        pub(crate) dimensions: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) unit: std::option::Option<crate::model::StandardUnit>,
    }
    impl Builder {
        /// <p>The name of the CloudWatch metric.</p>
        pub fn metric_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.metric_name = Some(input.into());
            self
        }
        /// <p>The name of the CloudWatch metric.</p>
        pub fn set_metric_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.metric_name = input;
            self
        }
        /// <p>A custom namespace to contain your metric in CloudWatch. Use namespaces to group together metrics
        /// that are similar. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/cloudwatch_concepts.html#Namespace">Namespaces</a>.</p>
        pub fn metric_namespace(mut self, input: impl Into<std::string::String>) -> Self {
            self.metric_namespace = Some(input.into());
            self
        }
        /// <p>A custom namespace to contain your metric in CloudWatch. Use namespaces to group together metrics
        /// that are similar. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/cloudwatch_concepts.html#Namespace">Namespaces</a>.</p>
        pub fn set_metric_namespace(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.metric_namespace = input;
            self
        }
        /// <p>The value to publish to the CloudWatch metric when a filter pattern matches a log event.</p>
        pub fn metric_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.metric_value = Some(input.into());
            self
        }
        /// <p>The value to publish to the CloudWatch metric when a filter pattern matches a log event.</p>
        pub fn set_metric_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.metric_value = input;
            self
        }
        /// <p>(Optional) The value to emit when a filter pattern does not match a log event.
        /// This value can be null.</p>
        pub fn default_value(mut self, input: f64) -> Self {
            self.default_value = Some(input);
            self
        }
        /// <p>(Optional) The value to emit when a filter pattern does not match a log event.
        /// This value can be null.</p>
        pub fn set_default_value(mut self, input: std::option::Option<f64>) -> Self {
            self.default_value = input;
            self
        }
        /// Adds a key-value pair to `dimensions`.
        ///
        /// To override the contents of this collection use [`set_dimensions`](Self::set_dimensions).
        ///
        /// <p>The fields to use as dimensions for the metric. One metric filter can include
        /// as many as three dimensions.</p>
        /// <important>
        /// <p>Metrics extracted from log events are charged as custom metrics.
        /// To prevent unexpected high charges, do not specify high-cardinality fields such as
        /// <code>IPAddress</code> or <code>requestID</code> as dimensions. Each different value
        /// found for
        /// a dimension is treated as a separate metric and accrues charges as a separate custom metric.
        /// </p>
        /// <p>To help prevent accidental high charges, Amazon disables a metric filter
        /// if it generates 1000 different name/value pairs for the dimensions that you
        /// have specified within a certain amount of time.</p>
        /// <p>You can also set up a billing alarm to alert you if your charges are higher than
        /// expected. For more information,
        /// see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/monitor_estimated_charges_with_cloudwatch.html">
        /// Creating a Billing Alarm to Monitor Your Estimated Amazon Web Services Charges</a>.
        /// </p>
        /// </important>
        pub fn dimensions(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.dimensions.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.dimensions = Some(hash_map);
            self
        }
        /// <p>The fields to use as dimensions for the metric. One metric filter can include
        /// as many as three dimensions.</p>
        /// <important>
        /// <p>Metrics extracted from log events are charged as custom metrics.
        /// To prevent unexpected high charges, do not specify high-cardinality fields such as
        /// <code>IPAddress</code> or <code>requestID</code> as dimensions. Each different value
        /// found for
        /// a dimension is treated as a separate metric and accrues charges as a separate custom metric.
        /// </p>
        /// <p>To help prevent accidental high charges, Amazon disables a metric filter
        /// if it generates 1000 different name/value pairs for the dimensions that you
        /// have specified within a certain amount of time.</p>
        /// <p>You can also set up a billing alarm to alert you if your charges are higher than
        /// expected. For more information,
        /// see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/monitor_estimated_charges_with_cloudwatch.html">
        /// Creating a Billing Alarm to Monitor Your Estimated Amazon Web Services Charges</a>.
        /// </p>
        /// </important>
        pub fn set_dimensions(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.dimensions = input;
            self
        }
        /// <p>The unit to assign to the metric. If you omit this, the unit is set as <code>None</code>.</p>
        pub fn unit(mut self, input: crate::model::StandardUnit) -> Self {
            self.unit = Some(input);
            self
        }
        /// <p>The unit to assign to the metric. If you omit this, the unit is set as <code>None</code>.</p>
        pub fn set_unit(mut self, input: std::option::Option<crate::model::StandardUnit>) -> Self {
            self.unit = input;
            self
        }
        /// Consumes the builder and constructs a [`MetricTransformation`](crate::model::MetricTransformation)
        pub fn build(self) -> crate::model::MetricTransformation {
            crate::model::MetricTransformation {
                metric_name: self.metric_name,
                metric_namespace: self.metric_namespace,
                metric_value: self.metric_value,
                default_value: self.default_value,
                dimensions: self.dimensions,
                unit: self.unit,
            }
        }
    }
}
impl MetricTransformation {
    /// Creates a new builder-style object to manufacture [`MetricTransformation`](crate::model::MetricTransformation)
    pub fn builder() -> crate::model::metric_transformation::Builder {
        crate::model::metric_transformation::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StandardUnit {
    #[allow(missing_docs)] // documentation missing in model
    Bits,
    #[allow(missing_docs)] // documentation missing in model
    BitsSecond,
    #[allow(missing_docs)] // documentation missing in model
    Bytes,
    #[allow(missing_docs)] // documentation missing in model
    BytesSecond,
    #[allow(missing_docs)] // documentation missing in model
    Count,
    #[allow(missing_docs)] // documentation missing in model
    CountSecond,
    #[allow(missing_docs)] // documentation missing in model
    Gigabits,
    #[allow(missing_docs)] // documentation missing in model
    GigabitsSecond,
    #[allow(missing_docs)] // documentation missing in model
    Gigabytes,
    #[allow(missing_docs)] // documentation missing in model
    GigabytesSecond,
    #[allow(missing_docs)] // documentation missing in model
    Kilobits,
    #[allow(missing_docs)] // documentation missing in model
    KilobitsSecond,
    #[allow(missing_docs)] // documentation missing in model
    Kilobytes,
    #[allow(missing_docs)] // documentation missing in model
    KilobytesSecond,
    #[allow(missing_docs)] // documentation missing in model
    Megabits,
    #[allow(missing_docs)] // documentation missing in model
    MegabitsSecond,
    #[allow(missing_docs)] // documentation missing in model
    Megabytes,
    #[allow(missing_docs)] // documentation missing in model
    MegabytesSecond,
    #[allow(missing_docs)] // documentation missing in model
    Microseconds,
    #[allow(missing_docs)] // documentation missing in model
    Milliseconds,
    #[allow(missing_docs)] // documentation missing in model
    None,
    #[allow(missing_docs)] // documentation missing in model
    Percent,
    #[allow(missing_docs)] // documentation missing in model
    Seconds,
    #[allow(missing_docs)] // documentation missing in model
    Terabits,
    #[allow(missing_docs)] // documentation missing in model
    TerabitsSecond,
    #[allow(missing_docs)] // documentation missing in model
    Terabytes,
    #[allow(missing_docs)] // documentation missing in model
    TerabytesSecond,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for StandardUnit {
    fn from(s: &str) -> Self {
        match s {
            "Bits" => StandardUnit::Bits,
            "Bits/Second" => StandardUnit::BitsSecond,
            "Bytes" => StandardUnit::Bytes,
            "Bytes/Second" => StandardUnit::BytesSecond,
            "Count" => StandardUnit::Count,
            "Count/Second" => StandardUnit::CountSecond,
            "Gigabits" => StandardUnit::Gigabits,
            "Gigabits/Second" => StandardUnit::GigabitsSecond,
            "Gigabytes" => StandardUnit::Gigabytes,
            "Gigabytes/Second" => StandardUnit::GigabytesSecond,
            "Kilobits" => StandardUnit::Kilobits,
            "Kilobits/Second" => StandardUnit::KilobitsSecond,
            "Kilobytes" => StandardUnit::Kilobytes,
            "Kilobytes/Second" => StandardUnit::KilobytesSecond,
            "Megabits" => StandardUnit::Megabits,
            "Megabits/Second" => StandardUnit::MegabitsSecond,
            "Megabytes" => StandardUnit::Megabytes,
            "Megabytes/Second" => StandardUnit::MegabytesSecond,
            "Microseconds" => StandardUnit::Microseconds,
            "Milliseconds" => StandardUnit::Milliseconds,
            "None" => StandardUnit::None,
            "Percent" => StandardUnit::Percent,
            "Seconds" => StandardUnit::Seconds,
            "Terabits" => StandardUnit::Terabits,
            "Terabits/Second" => StandardUnit::TerabitsSecond,
            "Terabytes" => StandardUnit::Terabytes,
            "Terabytes/Second" => StandardUnit::TerabytesSecond,
            other => StandardUnit::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for StandardUnit {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StandardUnit::from(s))
    }
}
impl StandardUnit {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            StandardUnit::Bits => "Bits",
            StandardUnit::BitsSecond => "Bits/Second",
            StandardUnit::Bytes => "Bytes",
            StandardUnit::BytesSecond => "Bytes/Second",
            StandardUnit::Count => "Count",
            StandardUnit::CountSecond => "Count/Second",
            StandardUnit::Gigabits => "Gigabits",
            StandardUnit::GigabitsSecond => "Gigabits/Second",
            StandardUnit::Gigabytes => "Gigabytes",
            StandardUnit::GigabytesSecond => "Gigabytes/Second",
            StandardUnit::Kilobits => "Kilobits",
            StandardUnit::KilobitsSecond => "Kilobits/Second",
            StandardUnit::Kilobytes => "Kilobytes",
            StandardUnit::KilobytesSecond => "Kilobytes/Second",
            StandardUnit::Megabits => "Megabits",
            StandardUnit::MegabitsSecond => "Megabits/Second",
            StandardUnit::Megabytes => "Megabytes",
            StandardUnit::MegabytesSecond => "Megabytes/Second",
            StandardUnit::Microseconds => "Microseconds",
            StandardUnit::Milliseconds => "Milliseconds",
            StandardUnit::None => "None",
            StandardUnit::Percent => "Percent",
            StandardUnit::Seconds => "Seconds",
            StandardUnit::Terabits => "Terabits",
            StandardUnit::TerabitsSecond => "Terabits/Second",
            StandardUnit::Terabytes => "Terabytes",
            StandardUnit::TerabytesSecond => "Terabytes/Second",
            StandardUnit::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "Bits",
            "Bits/Second",
            "Bytes",
            "Bytes/Second",
            "Count",
            "Count/Second",
            "Gigabits",
            "Gigabits/Second",
            "Gigabytes",
            "Gigabytes/Second",
            "Kilobits",
            "Kilobits/Second",
            "Kilobytes",
            "Kilobytes/Second",
            "Megabits",
            "Megabits/Second",
            "Megabytes",
            "Megabytes/Second",
            "Microseconds",
            "Milliseconds",
            "None",
            "Percent",
            "Seconds",
            "Terabits",
            "Terabits/Second",
            "Terabytes",
            "Terabytes/Second",
        ]
    }
}
impl AsRef<str> for StandardUnit {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Represents the rejected events.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RejectedLogEventsInfo {
    /// <p>The log events that are too new.</p>
    pub too_new_log_event_start_index: std::option::Option<i32>,
    /// <p>The log events that are too old.</p>
    pub too_old_log_event_end_index: std::option::Option<i32>,
    /// <p>The expired log events.</p>
    pub expired_log_event_end_index: std::option::Option<i32>,
}
impl std::fmt::Debug for RejectedLogEventsInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RejectedLogEventsInfo");
        formatter.field(
            "too_new_log_event_start_index",
            &self.too_new_log_event_start_index,
        );
        formatter.field(
            "too_old_log_event_end_index",
            &self.too_old_log_event_end_index,
        );
        formatter.field(
            "expired_log_event_end_index",
            &self.expired_log_event_end_index,
        );
        formatter.finish()
    }
}
/// See [`RejectedLogEventsInfo`](crate::model::RejectedLogEventsInfo)
pub mod rejected_log_events_info {
    /// A builder for [`RejectedLogEventsInfo`](crate::model::RejectedLogEventsInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) too_new_log_event_start_index: std::option::Option<i32>,
        pub(crate) too_old_log_event_end_index: std::option::Option<i32>,
        pub(crate) expired_log_event_end_index: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The log events that are too new.</p>
        pub fn too_new_log_event_start_index(mut self, input: i32) -> Self {
            self.too_new_log_event_start_index = Some(input);
            self
        }
        /// <p>The log events that are too new.</p>
        pub fn set_too_new_log_event_start_index(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.too_new_log_event_start_index = input;
            self
        }
        /// <p>The log events that are too old.</p>
        pub fn too_old_log_event_end_index(mut self, input: i32) -> Self {
            self.too_old_log_event_end_index = Some(input);
            self
        }
        /// <p>The log events that are too old.</p>
        pub fn set_too_old_log_event_end_index(mut self, input: std::option::Option<i32>) -> Self {
            self.too_old_log_event_end_index = input;
            self
        }
        /// <p>The expired log events.</p>
        pub fn expired_log_event_end_index(mut self, input: i32) -> Self {
            self.expired_log_event_end_index = Some(input);
            self
        }
        /// <p>The expired log events.</p>
        pub fn set_expired_log_event_end_index(mut self, input: std::option::Option<i32>) -> Self {
            self.expired_log_event_end_index = input;
            self
        }
        /// Consumes the builder and constructs a [`RejectedLogEventsInfo`](crate::model::RejectedLogEventsInfo)
        pub fn build(self) -> crate::model::RejectedLogEventsInfo {
            crate::model::RejectedLogEventsInfo {
                too_new_log_event_start_index: self.too_new_log_event_start_index,
                too_old_log_event_end_index: self.too_old_log_event_end_index,
                expired_log_event_end_index: self.expired_log_event_end_index,
            }
        }
    }
}
impl RejectedLogEventsInfo {
    /// Creates a new builder-style object to manufacture [`RejectedLogEventsInfo`](crate::model::RejectedLogEventsInfo)
    pub fn builder() -> crate::model::rejected_log_events_info::Builder {
        crate::model::rejected_log_events_info::Builder::default()
    }
}

/// <p>Represents a log event, which is a record of activity that was recorded
/// by the application or resource being monitored.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InputLogEvent {
    /// <p>The time the event occurred, expressed as the number of milliseconds after Jan 1, 1970
    /// 00:00:00 UTC.</p>
    pub timestamp: std::option::Option<i64>,
    /// <p>The raw event message.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InputLogEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InputLogEvent");
        formatter.field("timestamp", &self.timestamp);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
/// See [`InputLogEvent`](crate::model::InputLogEvent)
pub mod input_log_event {
    /// A builder for [`InputLogEvent`](crate::model::InputLogEvent)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) timestamp: std::option::Option<i64>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The time the event occurred, expressed as the number of milliseconds after Jan 1, 1970
        /// 00:00:00 UTC.</p>
        pub fn timestamp(mut self, input: i64) -> Self {
            self.timestamp = Some(input);
            self
        }
        /// <p>The time the event occurred, expressed as the number of milliseconds after Jan 1, 1970
        /// 00:00:00 UTC.</p>
        pub fn set_timestamp(mut self, input: std::option::Option<i64>) -> Self {
            self.timestamp = input;
            self
        }
        /// <p>The raw event message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The raw event message.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InputLogEvent`](crate::model::InputLogEvent)
        pub fn build(self) -> crate::model::InputLogEvent {
            crate::model::InputLogEvent {
                timestamp: self.timestamp,
                message: self.message,
            }
        }
    }
}
impl InputLogEvent {
    /// Creates a new builder-style object to manufacture [`InputLogEvent`](crate::model::InputLogEvent)
    pub fn builder() -> crate::model::input_log_event::Builder {
        crate::model::input_log_event::Builder::default()
    }
}

/// <p>Represents a cross-account destination that receives subscription log events.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Destination {
    /// <p>The name of the destination.</p>
    pub destination_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the physical target where the log events are
    /// delivered (for example, a Kinesis stream).</p>
    pub target_arn: std::option::Option<std::string::String>,
    /// <p>A role for impersonation, used when delivering log events to the target.</p>
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>An IAM policy document that governs which Amazon Web Services accounts can create subscription filters
    /// against this destination.</p>
    pub access_policy: std::option::Option<std::string::String>,
    /// <p>The ARN of this destination.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The creation time of the destination, expressed as the number of milliseconds after Jan
    /// 1, 1970 00:00:00 UTC.</p>
    pub creation_time: std::option::Option<i64>,
}
impl std::fmt::Debug for Destination {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Destination");
        formatter.field("destination_name", &self.destination_name);
        formatter.field("target_arn", &self.target_arn);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("access_policy", &self.access_policy);
        formatter.field("arn", &self.arn);
        formatter.field("creation_time", &self.creation_time);
        formatter.finish()
    }
}
/// See [`Destination`](crate::model::Destination)
pub mod destination {
    /// A builder for [`Destination`](crate::model::Destination)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) destination_name: std::option::Option<std::string::String>,
        pub(crate) target_arn: std::option::Option<std::string::String>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
        pub(crate) access_policy: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The name of the destination.</p>
        pub fn destination_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination_name = Some(input.into());
            self
        }
        /// <p>The name of the destination.</p>
        pub fn set_destination_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.destination_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the physical target where the log events are
        /// delivered (for example, a Kinesis stream).</p>
        pub fn target_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.target_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the physical target where the log events are
        /// delivered (for example, a Kinesis stream).</p>
        pub fn set_target_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.target_arn = input;
            self
        }
        /// <p>A role for impersonation, used when delivering log events to the target.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>A role for impersonation, used when delivering log events to the target.</p>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// <p>An IAM policy document that governs which Amazon Web Services accounts can create subscription filters
        /// against this destination.</p>
        pub fn access_policy(mut self, input: impl Into<std::string::String>) -> Self {
            self.access_policy = Some(input.into());
            self
        }
        /// <p>An IAM policy document that governs which Amazon Web Services accounts can create subscription filters
        /// against this destination.</p>
        pub fn set_access_policy(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.access_policy = input;
            self
        }
        /// <p>The ARN of this destination.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The ARN of this destination.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The creation time of the destination, expressed as the number of milliseconds after Jan
        /// 1, 1970 00:00:00 UTC.</p>
        pub fn creation_time(mut self, input: i64) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The creation time of the destination, expressed as the number of milliseconds after Jan
        /// 1, 1970 00:00:00 UTC.</p>
        pub fn set_creation_time(mut self, input: std::option::Option<i64>) -> Self {
            self.creation_time = input;
            self
        }
        /// Consumes the builder and constructs a [`Destination`](crate::model::Destination)
        pub fn build(self) -> crate::model::Destination {
            crate::model::Destination {
                destination_name: self.destination_name,
                target_arn: self.target_arn,
                role_arn: self.role_arn,
                access_policy: self.access_policy,
                arn: self.arn,
                creation_time: self.creation_time,
            }
        }
    }
}
impl Destination {
    /// Creates a new builder-style object to manufacture [`Destination`](crate::model::Destination)
    pub fn builder() -> crate::model::destination::Builder {
        crate::model::destination::Builder::default()
    }
}

/// _Note: `QueryStatus::Unknown` has been renamed to `::UnknownValue`._
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum QueryStatus {
    #[allow(missing_docs)] // documentation missing in model
    Cancelled,
    #[allow(missing_docs)] // documentation missing in model
    Complete,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Running,
    #[allow(missing_docs)] // documentation missing in model
    Scheduled,
    #[allow(missing_docs)] // documentation missing in model
    Timeout,
    /// _Note: `::Unknown` has been renamed to `::UnknownValue`._
    UnknownValue,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for QueryStatus {
    fn from(s: &str) -> Self {
        match s {
            "Cancelled" => QueryStatus::Cancelled,
            "Complete" => QueryStatus::Complete,
            "Failed" => QueryStatus::Failed,
            "Running" => QueryStatus::Running,
            "Scheduled" => QueryStatus::Scheduled,
            "Timeout" => QueryStatus::Timeout,
            "Unknown" => QueryStatus::UnknownValue,
            other => QueryStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for QueryStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(QueryStatus::from(s))
    }
}
impl QueryStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            QueryStatus::Cancelled => "Cancelled",
            QueryStatus::Complete => "Complete",
            QueryStatus::Failed => "Failed",
            QueryStatus::Running => "Running",
            QueryStatus::Scheduled => "Scheduled",
            QueryStatus::Timeout => "Timeout",
            QueryStatus::UnknownValue => "Unknown",
            QueryStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "Cancelled",
            "Complete",
            "Failed",
            "Running",
            "Scheduled",
            "Timeout",
            "Unknown",
        ]
    }
}
impl AsRef<str> for QueryStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains the number of log events scanned by the query, the number of log events that matched the
/// query criteria, and the total number of bytes in the log events that were scanned.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct QueryStatistics {
    /// <p>The number of log events that matched the query string.</p>
    pub records_matched: f64,
    /// <p>The total number of log events scanned during the query.</p>
    pub records_scanned: f64,
    /// <p>The total number of bytes in the log events scanned during the query.</p>
    pub bytes_scanned: f64,
}
impl std::fmt::Debug for QueryStatistics {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("QueryStatistics");
        formatter.field("records_matched", &self.records_matched);
        formatter.field("records_scanned", &self.records_scanned);
        formatter.field("bytes_scanned", &self.bytes_scanned);
        formatter.finish()
    }
}
/// See [`QueryStatistics`](crate::model::QueryStatistics)
pub mod query_statistics {
    /// A builder for [`QueryStatistics`](crate::model::QueryStatistics)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) records_matched: std::option::Option<f64>,
        pub(crate) records_scanned: std::option::Option<f64>,
        pub(crate) bytes_scanned: std::option::Option<f64>,
    }
    impl Builder {
        /// <p>The number of log events that matched the query string.</p>
        pub fn records_matched(mut self, input: f64) -> Self {
            self.records_matched = Some(input);
            self
        }
        /// <p>The number of log events that matched the query string.</p>
        pub fn set_records_matched(mut self, input: std::option::Option<f64>) -> Self {
            self.records_matched = input;
            self
        }
        /// <p>The total number of log events scanned during the query.</p>
        pub fn records_scanned(mut self, input: f64) -> Self {
            self.records_scanned = Some(input);
            self
        }
        /// <p>The total number of log events scanned during the query.</p>
        pub fn set_records_scanned(mut self, input: std::option::Option<f64>) -> Self {
            self.records_scanned = input;
            self
        }
        /// <p>The total number of bytes in the log events scanned during the query.</p>
        pub fn bytes_scanned(mut self, input: f64) -> Self {
            self.bytes_scanned = Some(input);
            self
        }
        /// <p>The total number of bytes in the log events scanned during the query.</p>
        pub fn set_bytes_scanned(mut self, input: std::option::Option<f64>) -> Self {
            self.bytes_scanned = input;
            self
        }
        /// Consumes the builder and constructs a [`QueryStatistics`](crate::model::QueryStatistics)
        pub fn build(self) -> crate::model::QueryStatistics {
            crate::model::QueryStatistics {
                records_matched: self.records_matched.unwrap_or_default(),
                records_scanned: self.records_scanned.unwrap_or_default(),
                bytes_scanned: self.bytes_scanned.unwrap_or_default(),
            }
        }
    }
}
impl QueryStatistics {
    /// Creates a new builder-style object to manufacture [`QueryStatistics`](crate::model::QueryStatistics)
    pub fn builder() -> crate::model::query_statistics::Builder {
        crate::model::query_statistics::Builder::default()
    }
}

/// <p>Contains one field from one log event returned by a CloudWatch Logs Insights query, along with the value of that field.</p>
/// <p>For more information about the fields that are
/// generated by CloudWatch logs, see
/// <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CWL_AnalyzeLogData-discoverable-fields.html">Supported Logs and Discovered Fields</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResultField {
    /// <p>The log event field.</p>
    pub field: std::option::Option<std::string::String>,
    /// <p>The value of this field.</p>
    pub value: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResultField {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResultField");
        formatter.field("field", &self.field);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`ResultField`](crate::model::ResultField)
pub mod result_field {
    /// A builder for [`ResultField`](crate::model::ResultField)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) field: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The log event field.</p>
        pub fn field(mut self, input: impl Into<std::string::String>) -> Self {
            self.field = Some(input.into());
            self
        }
        /// <p>The log event field.</p>
        pub fn set_field(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.field = input;
            self
        }
        /// <p>The value of this field.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The value of this field.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`ResultField`](crate::model::ResultField)
        pub fn build(self) -> crate::model::ResultField {
            crate::model::ResultField {
                field: self.field,
                value: self.value,
            }
        }
    }
}
impl ResultField {
    /// Creates a new builder-style object to manufacture [`ResultField`](crate::model::ResultField)
    pub fn builder() -> crate::model::result_field::Builder {
        crate::model::result_field::Builder::default()
    }
}

/// <p>The fields contained in log events found by a <code>GetLogGroupFields</code> operation,
/// along with the percentage of queried log events in which each field appears.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LogGroupField {
    /// <p>The name of a log field.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The percentage of log events queried that contained the field.</p>
    pub percent: i32,
}
impl std::fmt::Debug for LogGroupField {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LogGroupField");
        formatter.field("name", &self.name);
        formatter.field("percent", &self.percent);
        formatter.finish()
    }
}
/// See [`LogGroupField`](crate::model::LogGroupField)
pub mod log_group_field {
    /// A builder for [`LogGroupField`](crate::model::LogGroupField)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) percent: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The name of a log field.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of a log field.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The percentage of log events queried that contained the field.</p>
        pub fn percent(mut self, input: i32) -> Self {
            self.percent = Some(input);
            self
        }
        /// <p>The percentage of log events queried that contained the field.</p>
        pub fn set_percent(mut self, input: std::option::Option<i32>) -> Self {
            self.percent = input;
            self
        }
        /// Consumes the builder and constructs a [`LogGroupField`](crate::model::LogGroupField)
        pub fn build(self) -> crate::model::LogGroupField {
            crate::model::LogGroupField {
                name: self.name,
                percent: self.percent.unwrap_or_default(),
            }
        }
    }
}
impl LogGroupField {
    /// Creates a new builder-style object to manufacture [`LogGroupField`](crate::model::LogGroupField)
    pub fn builder() -> crate::model::log_group_field::Builder {
        crate::model::log_group_field::Builder::default()
    }
}

/// <p>Represents a log event.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct OutputLogEvent {
    /// <p>The time the event occurred, expressed as the number of milliseconds after Jan 1, 1970
    /// 00:00:00 UTC.</p>
    pub timestamp: std::option::Option<i64>,
    /// <p>The data contained in the log event.</p>
    pub message: std::option::Option<std::string::String>,
    /// <p>The time the event was ingested, expressed as the number of milliseconds after Jan 1,
    /// 1970 00:00:00 UTC.</p>
    pub ingestion_time: std::option::Option<i64>,
}
impl std::fmt::Debug for OutputLogEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OutputLogEvent");
        formatter.field("timestamp", &self.timestamp);
        formatter.field("message", &self.message);
        formatter.field("ingestion_time", &self.ingestion_time);
        formatter.finish()
    }
}
/// See [`OutputLogEvent`](crate::model::OutputLogEvent)
pub mod output_log_event {
    /// A builder for [`OutputLogEvent`](crate::model::OutputLogEvent)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) timestamp: std::option::Option<i64>,
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) ingestion_time: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The time the event occurred, expressed as the number of milliseconds after Jan 1, 1970
        /// 00:00:00 UTC.</p>
        pub fn timestamp(mut self, input: i64) -> Self {
            self.timestamp = Some(input);
            self
        }
        /// <p>The time the event occurred, expressed as the number of milliseconds after Jan 1, 1970
        /// 00:00:00 UTC.</p>
        pub fn set_timestamp(mut self, input: std::option::Option<i64>) -> Self {
            self.timestamp = input;
            self
        }
        /// <p>The data contained in the log event.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The data contained in the log event.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The time the event was ingested, expressed as the number of milliseconds after Jan 1,
        /// 1970 00:00:00 UTC.</p>
        pub fn ingestion_time(mut self, input: i64) -> Self {
            self.ingestion_time = Some(input);
            self
        }
        /// <p>The time the event was ingested, expressed as the number of milliseconds after Jan 1,
        /// 1970 00:00:00 UTC.</p>
        pub fn set_ingestion_time(mut self, input: std::option::Option<i64>) -> Self {
            self.ingestion_time = input;
            self
        }
        /// Consumes the builder and constructs a [`OutputLogEvent`](crate::model::OutputLogEvent)
        pub fn build(self) -> crate::model::OutputLogEvent {
            crate::model::OutputLogEvent {
                timestamp: self.timestamp,
                message: self.message,
                ingestion_time: self.ingestion_time,
            }
        }
    }
}
impl OutputLogEvent {
    /// Creates a new builder-style object to manufacture [`OutputLogEvent`](crate::model::OutputLogEvent)
    pub fn builder() -> crate::model::output_log_event::Builder {
        crate::model::output_log_event::Builder::default()
    }
}

/// <p>Represents the search status of a log stream.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SearchedLogStream {
    /// <p>The name of the log stream.</p>
    pub log_stream_name: std::option::Option<std::string::String>,
    /// <p>Indicates whether all the events in this log stream were searched.</p>
    pub searched_completely: std::option::Option<bool>,
}
impl std::fmt::Debug for SearchedLogStream {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SearchedLogStream");
        formatter.field("log_stream_name", &self.log_stream_name);
        formatter.field("searched_completely", &self.searched_completely);
        formatter.finish()
    }
}
/// See [`SearchedLogStream`](crate::model::SearchedLogStream)
pub mod searched_log_stream {
    /// A builder for [`SearchedLogStream`](crate::model::SearchedLogStream)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) log_stream_name: std::option::Option<std::string::String>,
        pub(crate) searched_completely: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The name of the log stream.</p>
        pub fn log_stream_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.log_stream_name = Some(input.into());
            self
        }
        /// <p>The name of the log stream.</p>
        pub fn set_log_stream_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.log_stream_name = input;
            self
        }
        /// <p>Indicates whether all the events in this log stream were searched.</p>
        pub fn searched_completely(mut self, input: bool) -> Self {
            self.searched_completely = Some(input);
            self
        }
        /// <p>Indicates whether all the events in this log stream were searched.</p>
        pub fn set_searched_completely(mut self, input: std::option::Option<bool>) -> Self {
            self.searched_completely = input;
            self
        }
        /// Consumes the builder and constructs a [`SearchedLogStream`](crate::model::SearchedLogStream)
        pub fn build(self) -> crate::model::SearchedLogStream {
            crate::model::SearchedLogStream {
                log_stream_name: self.log_stream_name,
                searched_completely: self.searched_completely,
            }
        }
    }
}
impl SearchedLogStream {
    /// Creates a new builder-style object to manufacture [`SearchedLogStream`](crate::model::SearchedLogStream)
    pub fn builder() -> crate::model::searched_log_stream::Builder {
        crate::model::searched_log_stream::Builder::default()
    }
}

/// <p>Represents a matched event.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FilteredLogEvent {
    /// <p>The name of the log stream to which this event belongs.</p>
    pub log_stream_name: std::option::Option<std::string::String>,
    /// <p>The time the event occurred, expressed as the number of milliseconds after Jan 1, 1970
    /// 00:00:00 UTC.</p>
    pub timestamp: std::option::Option<i64>,
    /// <p>The data contained in the log event.</p>
    pub message: std::option::Option<std::string::String>,
    /// <p>The time the event was ingested, expressed as the number of milliseconds after Jan 1,
    /// 1970 00:00:00 UTC.</p>
    pub ingestion_time: std::option::Option<i64>,
    /// <p>The ID of the event.</p>
    pub event_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for FilteredLogEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FilteredLogEvent");
        formatter.field("log_stream_name", &self.log_stream_name);
        formatter.field("timestamp", &self.timestamp);
        formatter.field("message", &self.message);
        formatter.field("ingestion_time", &self.ingestion_time);
        formatter.field("event_id", &self.event_id);
        formatter.finish()
    }
}
/// See [`FilteredLogEvent`](crate::model::FilteredLogEvent)
pub mod filtered_log_event {
    /// A builder for [`FilteredLogEvent`](crate::model::FilteredLogEvent)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) log_stream_name: std::option::Option<std::string::String>,
        pub(crate) timestamp: std::option::Option<i64>,
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) ingestion_time: std::option::Option<i64>,
        pub(crate) event_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the log stream to which this event belongs.</p>
        pub fn log_stream_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.log_stream_name = Some(input.into());
            self
        }
        /// <p>The name of the log stream to which this event belongs.</p>
        pub fn set_log_stream_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.log_stream_name = input;
            self
        }
        /// <p>The time the event occurred, expressed as the number of milliseconds after Jan 1, 1970
        /// 00:00:00 UTC.</p>
        pub fn timestamp(mut self, input: i64) -> Self {
            self.timestamp = Some(input);
            self
        }
        /// <p>The time the event occurred, expressed as the number of milliseconds after Jan 1, 1970
        /// 00:00:00 UTC.</p>
        pub fn set_timestamp(mut self, input: std::option::Option<i64>) -> Self {
            self.timestamp = input;
            self
        }
        /// <p>The data contained in the log event.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The data contained in the log event.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The time the event was ingested, expressed as the number of milliseconds after Jan 1,
        /// 1970 00:00:00 UTC.</p>
        pub fn ingestion_time(mut self, input: i64) -> Self {
            self.ingestion_time = Some(input);
            self
        }
        /// <p>The time the event was ingested, expressed as the number of milliseconds after Jan 1,
        /// 1970 00:00:00 UTC.</p>
        pub fn set_ingestion_time(mut self, input: std::option::Option<i64>) -> Self {
            self.ingestion_time = input;
            self
        }
        /// <p>The ID of the event.</p>
        pub fn event_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.event_id = Some(input.into());
            self
        }
        /// <p>The ID of the event.</p>
        pub fn set_event_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.event_id = input;
            self
        }
        /// Consumes the builder and constructs a [`FilteredLogEvent`](crate::model::FilteredLogEvent)
        pub fn build(self) -> crate::model::FilteredLogEvent {
            crate::model::FilteredLogEvent {
                log_stream_name: self.log_stream_name,
                timestamp: self.timestamp,
                message: self.message,
                ingestion_time: self.ingestion_time,
                event_id: self.event_id,
            }
        }
    }
}
impl FilteredLogEvent {
    /// Creates a new builder-style object to manufacture [`FilteredLogEvent`](crate::model::FilteredLogEvent)
    pub fn builder() -> crate::model::filtered_log_event::Builder {
        crate::model::filtered_log_event::Builder::default()
    }
}

/// <p>Represents a subscription filter.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SubscriptionFilter {
    /// <p>The name of the subscription filter.</p>
    pub filter_name: std::option::Option<std::string::String>,
    /// <p>The name of the log group.</p>
    pub log_group_name: std::option::Option<std::string::String>,
    /// <p>A symbolic description of how CloudWatch Logs should interpret the data in each log
    /// event. For example, a log event can contain timestamps, IP addresses, strings, and so on. You
    /// use the filter pattern to specify what to look for in the log event message.</p>
    pub filter_pattern: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the destination.</p>
    pub destination_arn: std::option::Option<std::string::String>,
    /// <p></p>
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>The method used to distribute log data to the destination, which can be either
    /// random or grouped by log stream.</p>
    pub distribution: std::option::Option<crate::model::Distribution>,
    /// <p>The creation time of the subscription filter, expressed as the number of milliseconds
    /// after Jan 1, 1970 00:00:00 UTC.</p>
    pub creation_time: std::option::Option<i64>,
}
impl std::fmt::Debug for SubscriptionFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SubscriptionFilter");
        formatter.field("filter_name", &self.filter_name);
        formatter.field("log_group_name", &self.log_group_name);
        formatter.field("filter_pattern", &self.filter_pattern);
        formatter.field("destination_arn", &self.destination_arn);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("distribution", &self.distribution);
        formatter.field("creation_time", &self.creation_time);
        formatter.finish()
    }
}
/// See [`SubscriptionFilter`](crate::model::SubscriptionFilter)
pub mod subscription_filter {
    /// A builder for [`SubscriptionFilter`](crate::model::SubscriptionFilter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) filter_name: std::option::Option<std::string::String>,
        pub(crate) log_group_name: std::option::Option<std::string::String>,
        pub(crate) filter_pattern: std::option::Option<std::string::String>,
        pub(crate) destination_arn: std::option::Option<std::string::String>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
        pub(crate) distribution: std::option::Option<crate::model::Distribution>,
        pub(crate) creation_time: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The name of the subscription filter.</p>
        pub fn filter_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.filter_name = Some(input.into());
            self
        }
        /// <p>The name of the subscription filter.</p>
        pub fn set_filter_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.filter_name = input;
            self
        }
        /// <p>The name of the log group.</p>
        pub fn log_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.log_group_name = Some(input.into());
            self
        }
        /// <p>The name of the log group.</p>
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.log_group_name = input;
            self
        }
        /// <p>A symbolic description of how CloudWatch Logs should interpret the data in each log
        /// event. For example, a log event can contain timestamps, IP addresses, strings, and so on. You
        /// use the filter pattern to specify what to look for in the log event message.</p>
        pub fn filter_pattern(mut self, input: impl Into<std::string::String>) -> Self {
            self.filter_pattern = Some(input.into());
            self
        }
        /// <p>A symbolic description of how CloudWatch Logs should interpret the data in each log
        /// event. For example, a log event can contain timestamps, IP addresses, strings, and so on. You
        /// use the filter pattern to specify what to look for in the log event message.</p>
        pub fn set_filter_pattern(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.filter_pattern = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the destination.</p>
        pub fn destination_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the destination.</p>
        pub fn set_destination_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.destination_arn = input;
            self
        }
        /// <p></p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p></p>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// <p>The method used to distribute log data to the destination, which can be either
        /// random or grouped by log stream.</p>
        pub fn distribution(mut self, input: crate::model::Distribution) -> Self {
            self.distribution = Some(input);
            self
        }
        /// <p>The method used to distribute log data to the destination, which can be either
        /// random or grouped by log stream.</p>
        pub fn set_distribution(
            mut self,
            input: std::option::Option<crate::model::Distribution>,
        ) -> Self {
            self.distribution = input;
            self
        }
        /// <p>The creation time of the subscription filter, expressed as the number of milliseconds
        /// after Jan 1, 1970 00:00:00 UTC.</p>
        pub fn creation_time(mut self, input: i64) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The creation time of the subscription filter, expressed as the number of milliseconds
        /// after Jan 1, 1970 00:00:00 UTC.</p>
        pub fn set_creation_time(mut self, input: std::option::Option<i64>) -> Self {
            self.creation_time = input;
            self
        }
        /// Consumes the builder and constructs a [`SubscriptionFilter`](crate::model::SubscriptionFilter)
        pub fn build(self) -> crate::model::SubscriptionFilter {
            crate::model::SubscriptionFilter {
                filter_name: self.filter_name,
                log_group_name: self.log_group_name,
                filter_pattern: self.filter_pattern,
                destination_arn: self.destination_arn,
                role_arn: self.role_arn,
                distribution: self.distribution,
                creation_time: self.creation_time,
            }
        }
    }
}
impl SubscriptionFilter {
    /// Creates a new builder-style object to manufacture [`SubscriptionFilter`](crate::model::SubscriptionFilter)
    pub fn builder() -> crate::model::subscription_filter::Builder {
        crate::model::subscription_filter::Builder::default()
    }
}

/// <p>This structure contains details about a saved CloudWatch Logs Insights query definition.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct QueryDefinition {
    /// <p>The unique ID of the query definition.</p>
    pub query_definition_id: std::option::Option<std::string::String>,
    /// <p>The name of the query definition.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The query string to use for this definition.
    /// For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CWL_QuerySyntax.html">CloudWatch Logs Insights Query Syntax</a>.</p>
    pub query_string: std::option::Option<std::string::String>,
    /// <p>The date that the query definition was most recently modified.</p>
    pub last_modified: std::option::Option<i64>,
    /// <p>If this query definition contains a list of log groups that it is limited to, that list appears here.</p>
    pub log_group_names: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for QueryDefinition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("QueryDefinition");
        formatter.field("query_definition_id", &self.query_definition_id);
        formatter.field("name", &self.name);
        formatter.field("query_string", &self.query_string);
        formatter.field("last_modified", &self.last_modified);
        formatter.field("log_group_names", &self.log_group_names);
        formatter.finish()
    }
}
/// See [`QueryDefinition`](crate::model::QueryDefinition)
pub mod query_definition {
    /// A builder for [`QueryDefinition`](crate::model::QueryDefinition)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) query_definition_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) query_string: std::option::Option<std::string::String>,
        pub(crate) last_modified: std::option::Option<i64>,
        pub(crate) log_group_names: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The unique ID of the query definition.</p>
        pub fn query_definition_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.query_definition_id = Some(input.into());
            self
        }
        /// <p>The unique ID of the query definition.</p>
        pub fn set_query_definition_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.query_definition_id = input;
            self
        }
        /// <p>The name of the query definition.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the query definition.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The query string to use for this definition.
        /// For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CWL_QuerySyntax.html">CloudWatch Logs Insights Query Syntax</a>.</p>
        pub fn query_string(mut self, input: impl Into<std::string::String>) -> Self {
            self.query_string = Some(input.into());
            self
        }
        /// <p>The query string to use for this definition.
        /// For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CWL_QuerySyntax.html">CloudWatch Logs Insights Query Syntax</a>.</p>
        pub fn set_query_string(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.query_string = input;
            self
        }
        /// <p>The date that the query definition was most recently modified.</p>
        pub fn last_modified(mut self, input: i64) -> Self {
            self.last_modified = Some(input);
            self
        }
        /// <p>The date that the query definition was most recently modified.</p>
        pub fn set_last_modified(mut self, input: std::option::Option<i64>) -> Self {
            self.last_modified = input;
            self
        }
        /// Appends an item to `log_group_names`.
        ///
        /// To override the contents of this collection use [`set_log_group_names`](Self::set_log_group_names).
        ///
        /// <p>If this query definition contains a list of log groups that it is limited to, that list appears here.</p>
        pub fn log_group_names(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.log_group_names.unwrap_or_default();
            v.push(input.into());
            self.log_group_names = Some(v);
            self
        }
        /// <p>If this query definition contains a list of log groups that it is limited to, that list appears here.</p>
        pub fn set_log_group_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.log_group_names = input;
            self
        }
        /// Consumes the builder and constructs a [`QueryDefinition`](crate::model::QueryDefinition)
        pub fn build(self) -> crate::model::QueryDefinition {
            crate::model::QueryDefinition {
                query_definition_id: self.query_definition_id,
                name: self.name,
                query_string: self.query_string,
                last_modified: self.last_modified,
                log_group_names: self.log_group_names,
            }
        }
    }
}
impl QueryDefinition {
    /// Creates a new builder-style object to manufacture [`QueryDefinition`](crate::model::QueryDefinition)
    pub fn builder() -> crate::model::query_definition::Builder {
        crate::model::query_definition::Builder::default()
    }
}

/// <p>Information about one CloudWatch Logs Insights query that matches the request in a <code>DescribeQueries</code> operation. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct QueryInfo {
    /// <p>The unique ID number of this query.</p>
    pub query_id: std::option::Option<std::string::String>,
    /// <p>The query string used in this query.</p>
    pub query_string: std::option::Option<std::string::String>,
    /// <p>The status of this query. Possible values are <code>Cancelled</code>,
    /// <code>Complete</code>, <code>Failed</code>, <code>Running</code>, <code>Scheduled</code>, and <code>Unknown</code>.</p>
    pub status: std::option::Option<crate::model::QueryStatus>,
    /// <p>The date and time that this query was created.</p>
    pub create_time: std::option::Option<i64>,
    /// <p>The name of the log group scanned by this query.</p>
    pub log_group_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for QueryInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("QueryInfo");
        formatter.field("query_id", &self.query_id);
        formatter.field("query_string", &self.query_string);
        formatter.field("status", &self.status);
        formatter.field("create_time", &self.create_time);
        formatter.field("log_group_name", &self.log_group_name);
        formatter.finish()
    }
}
/// See [`QueryInfo`](crate::model::QueryInfo)
pub mod query_info {
    /// A builder for [`QueryInfo`](crate::model::QueryInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) query_id: std::option::Option<std::string::String>,
        pub(crate) query_string: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::QueryStatus>,
        pub(crate) create_time: std::option::Option<i64>,
        pub(crate) log_group_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique ID number of this query.</p>
        pub fn query_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.query_id = Some(input.into());
            self
        }
        /// <p>The unique ID number of this query.</p>
        pub fn set_query_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.query_id = input;
            self
        }
        /// <p>The query string used in this query.</p>
        pub fn query_string(mut self, input: impl Into<std::string::String>) -> Self {
            self.query_string = Some(input.into());
            self
        }
        /// <p>The query string used in this query.</p>
        pub fn set_query_string(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.query_string = input;
            self
        }
        /// <p>The status of this query. Possible values are <code>Cancelled</code>,
        /// <code>Complete</code>, <code>Failed</code>, <code>Running</code>, <code>Scheduled</code>, and <code>Unknown</code>.</p>
        pub fn status(mut self, input: crate::model::QueryStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of this query. Possible values are <code>Cancelled</code>,
        /// <code>Complete</code>, <code>Failed</code>, <code>Running</code>, <code>Scheduled</code>, and <code>Unknown</code>.</p>
        pub fn set_status(mut self, input: std::option::Option<crate::model::QueryStatus>) -> Self {
            self.status = input;
            self
        }
        /// <p>The date and time that this query was created.</p>
        pub fn create_time(mut self, input: i64) -> Self {
            self.create_time = Some(input);
            self
        }
        /// <p>The date and time that this query was created.</p>
        pub fn set_create_time(mut self, input: std::option::Option<i64>) -> Self {
            self.create_time = input;
            self
        }
        /// <p>The name of the log group scanned by this query.</p>
        pub fn log_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.log_group_name = Some(input.into());
            self
        }
        /// <p>The name of the log group scanned by this query.</p>
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.log_group_name = input;
            self
        }
        /// Consumes the builder and constructs a [`QueryInfo`](crate::model::QueryInfo)
        pub fn build(self) -> crate::model::QueryInfo {
            crate::model::QueryInfo {
                query_id: self.query_id,
                query_string: self.query_string,
                status: self.status,
                create_time: self.create_time,
                log_group_name: self.log_group_name,
            }
        }
    }
}
impl QueryInfo {
    /// Creates a new builder-style object to manufacture [`QueryInfo`](crate::model::QueryInfo)
    pub fn builder() -> crate::model::query_info::Builder {
        crate::model::query_info::Builder::default()
    }
}

/// <p>Metric filters express how CloudWatch Logs would extract metric observations
/// from ingested log events and transform them into metric data in a CloudWatch metric.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MetricFilter {
    /// <p>The name of the metric filter.</p>
    pub filter_name: std::option::Option<std::string::String>,
    /// <p>A symbolic description of how CloudWatch Logs should interpret the data in each log
    /// event. For example, a log event can contain timestamps, IP addresses, strings, and so on. You
    /// use the filter pattern to specify what to look for in the log event message.</p>
    pub filter_pattern: std::option::Option<std::string::String>,
    /// <p>The metric transformations.</p>
    pub metric_transformations:
        std::option::Option<std::vec::Vec<crate::model::MetricTransformation>>,
    /// <p>The creation time of the metric filter, expressed as the number of milliseconds after
    /// Jan 1, 1970 00:00:00 UTC.</p>
    pub creation_time: std::option::Option<i64>,
    /// <p>The name of the log group.</p>
    pub log_group_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MetricFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MetricFilter");
        formatter.field("filter_name", &self.filter_name);
        formatter.field("filter_pattern", &self.filter_pattern);
        formatter.field("metric_transformations", &self.metric_transformations);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("log_group_name", &self.log_group_name);
        formatter.finish()
    }
}
/// See [`MetricFilter`](crate::model::MetricFilter)
pub mod metric_filter {
    /// A builder for [`MetricFilter`](crate::model::MetricFilter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) filter_name: std::option::Option<std::string::String>,
        pub(crate) filter_pattern: std::option::Option<std::string::String>,
        pub(crate) metric_transformations:
            std::option::Option<std::vec::Vec<crate::model::MetricTransformation>>,
        pub(crate) creation_time: std::option::Option<i64>,
        pub(crate) log_group_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the metric filter.</p>
        pub fn filter_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.filter_name = Some(input.into());
            self
        }
        /// <p>The name of the metric filter.</p>
        pub fn set_filter_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.filter_name = input;
            self
        }
        /// <p>A symbolic description of how CloudWatch Logs should interpret the data in each log
        /// event. For example, a log event can contain timestamps, IP addresses, strings, and so on. You
        /// use the filter pattern to specify what to look for in the log event message.</p>
        pub fn filter_pattern(mut self, input: impl Into<std::string::String>) -> Self {
            self.filter_pattern = Some(input.into());
            self
        }
        /// <p>A symbolic description of how CloudWatch Logs should interpret the data in each log
        /// event. For example, a log event can contain timestamps, IP addresses, strings, and so on. You
        /// use the filter pattern to specify what to look for in the log event message.</p>
        pub fn set_filter_pattern(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.filter_pattern = input;
            self
        }
        /// Appends an item to `metric_transformations`.
        ///
        /// To override the contents of this collection use [`set_metric_transformations`](Self::set_metric_transformations).
        ///
        /// <p>The metric transformations.</p>
        pub fn metric_transformations(
            mut self,
            input: impl Into<crate::model::MetricTransformation>,
        ) -> Self {
            let mut v = self.metric_transformations.unwrap_or_default();
            v.push(input.into());
            self.metric_transformations = Some(v);
            self
        }
        /// <p>The metric transformations.</p>
        pub fn set_metric_transformations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MetricTransformation>>,
        ) -> Self {
            self.metric_transformations = input;
            self
        }
        /// <p>The creation time of the metric filter, expressed as the number of milliseconds after
        /// Jan 1, 1970 00:00:00 UTC.</p>
        pub fn creation_time(mut self, input: i64) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The creation time of the metric filter, expressed as the number of milliseconds after
        /// Jan 1, 1970 00:00:00 UTC.</p>
        pub fn set_creation_time(mut self, input: std::option::Option<i64>) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The name of the log group.</p>
        pub fn log_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.log_group_name = Some(input.into());
            self
        }
        /// <p>The name of the log group.</p>
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.log_group_name = input;
            self
        }
        /// Consumes the builder and constructs a [`MetricFilter`](crate::model::MetricFilter)
        pub fn build(self) -> crate::model::MetricFilter {
            crate::model::MetricFilter {
                filter_name: self.filter_name,
                filter_pattern: self.filter_pattern,
                metric_transformations: self.metric_transformations,
                creation_time: self.creation_time,
                log_group_name: self.log_group_name,
            }
        }
    }
}
impl MetricFilter {
    /// Creates a new builder-style object to manufacture [`MetricFilter`](crate::model::MetricFilter)
    pub fn builder() -> crate::model::metric_filter::Builder {
        crate::model::metric_filter::Builder::default()
    }
}

/// <p>Represents a log stream, which is a sequence of log events from
/// a single emitter of logs.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LogStream {
    /// <p>The name of the log stream.</p>
    pub log_stream_name: std::option::Option<std::string::String>,
    /// <p>The creation time of the stream, expressed as the number of milliseconds after Jan 1,
    /// 1970 00:00:00 UTC.</p>
    pub creation_time: std::option::Option<i64>,
    /// <p>The time of the first event, expressed as the number of milliseconds after Jan 1, 1970
    /// 00:00:00 UTC.</p>
    pub first_event_timestamp: std::option::Option<i64>,
    /// <p>The time of the most recent log event in the log stream in CloudWatch Logs. This number
    /// is expressed as the number of milliseconds after Jan 1, 1970 00:00:00 UTC. The
    /// <code>lastEventTime</code> value updates on an eventual consistency basis. It typically
    /// updates in less than an hour from ingestion, but in rare situations might take
    /// longer.</p>
    pub last_event_timestamp: std::option::Option<i64>,
    /// <p>The ingestion time, expressed as the number of milliseconds after Jan 1, 1970 00:00:00
    /// UTC.</p>
    pub last_ingestion_time: std::option::Option<i64>,
    /// <p>The sequence token.</p>
    pub upload_sequence_token: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the log stream.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The number of bytes stored.</p>
    /// <p>
    /// <b>Important:</b> On June 17, 2019, this parameter was
    /// deprecated for log streams, and is always reported as zero. This change applies only to log
    /// streams. The <code>storedBytes</code> parameter for log groups is not affected.</p>
    pub stored_bytes: std::option::Option<i64>,
}
impl std::fmt::Debug for LogStream {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LogStream");
        formatter.field("log_stream_name", &self.log_stream_name);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("first_event_timestamp", &self.first_event_timestamp);
        formatter.field("last_event_timestamp", &self.last_event_timestamp);
        formatter.field("last_ingestion_time", &self.last_ingestion_time);
        formatter.field("upload_sequence_token", &self.upload_sequence_token);
        formatter.field("arn", &self.arn);
        formatter.field("stored_bytes", &self.stored_bytes);
        formatter.finish()
    }
}
/// See [`LogStream`](crate::model::LogStream)
pub mod log_stream {
    /// A builder for [`LogStream`](crate::model::LogStream)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) log_stream_name: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<i64>,
        pub(crate) first_event_timestamp: std::option::Option<i64>,
        pub(crate) last_event_timestamp: std::option::Option<i64>,
        pub(crate) last_ingestion_time: std::option::Option<i64>,
        pub(crate) upload_sequence_token: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) stored_bytes: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The name of the log stream.</p>
        pub fn log_stream_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.log_stream_name = Some(input.into());
            self
        }
        /// <p>The name of the log stream.</p>
        pub fn set_log_stream_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.log_stream_name = input;
            self
        }
        /// <p>The creation time of the stream, expressed as the number of milliseconds after Jan 1,
        /// 1970 00:00:00 UTC.</p>
        pub fn creation_time(mut self, input: i64) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The creation time of the stream, expressed as the number of milliseconds after Jan 1,
        /// 1970 00:00:00 UTC.</p>
        pub fn set_creation_time(mut self, input: std::option::Option<i64>) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The time of the first event, expressed as the number of milliseconds after Jan 1, 1970
        /// 00:00:00 UTC.</p>
        pub fn first_event_timestamp(mut self, input: i64) -> Self {
            self.first_event_timestamp = Some(input);
            self
        }
        /// <p>The time of the first event, expressed as the number of milliseconds after Jan 1, 1970
        /// 00:00:00 UTC.</p>
        pub fn set_first_event_timestamp(mut self, input: std::option::Option<i64>) -> Self {
            self.first_event_timestamp = input;
            self
        }
        /// <p>The time of the most recent log event in the log stream in CloudWatch Logs. This number
        /// is expressed as the number of milliseconds after Jan 1, 1970 00:00:00 UTC. The
        /// <code>lastEventTime</code> value updates on an eventual consistency basis. It typically
        /// updates in less than an hour from ingestion, but in rare situations might take
        /// longer.</p>
        pub fn last_event_timestamp(mut self, input: i64) -> Self {
            self.last_event_timestamp = Some(input);
            self
        }
        /// <p>The time of the most recent log event in the log stream in CloudWatch Logs. This number
        /// is expressed as the number of milliseconds after Jan 1, 1970 00:00:00 UTC. The
        /// <code>lastEventTime</code> value updates on an eventual consistency basis. It typically
        /// updates in less than an hour from ingestion, but in rare situations might take
        /// longer.</p>
        pub fn set_last_event_timestamp(mut self, input: std::option::Option<i64>) -> Self {
            self.last_event_timestamp = input;
            self
        }
        /// <p>The ingestion time, expressed as the number of milliseconds after Jan 1, 1970 00:00:00
        /// UTC.</p>
        pub fn last_ingestion_time(mut self, input: i64) -> Self {
            self.last_ingestion_time = Some(input);
            self
        }
        /// <p>The ingestion time, expressed as the number of milliseconds after Jan 1, 1970 00:00:00
        /// UTC.</p>
        pub fn set_last_ingestion_time(mut self, input: std::option::Option<i64>) -> Self {
            self.last_ingestion_time = input;
            self
        }
        /// <p>The sequence token.</p>
        pub fn upload_sequence_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.upload_sequence_token = Some(input.into());
            self
        }
        /// <p>The sequence token.</p>
        pub fn set_upload_sequence_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.upload_sequence_token = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the log stream.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the log stream.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The number of bytes stored.</p>
        /// <p>
        /// <b>Important:</b> On June 17, 2019, this parameter was
        /// deprecated for log streams, and is always reported as zero. This change applies only to log
        /// streams. The <code>storedBytes</code> parameter for log groups is not affected.</p>
        pub fn stored_bytes(mut self, input: i64) -> Self {
            self.stored_bytes = Some(input);
            self
        }
        /// <p>The number of bytes stored.</p>
        /// <p>
        /// <b>Important:</b> On June 17, 2019, this parameter was
        /// deprecated for log streams, and is always reported as zero. This change applies only to log
        /// streams. The <code>storedBytes</code> parameter for log groups is not affected.</p>
        pub fn set_stored_bytes(mut self, input: std::option::Option<i64>) -> Self {
            self.stored_bytes = input;
            self
        }
        /// Consumes the builder and constructs a [`LogStream`](crate::model::LogStream)
        pub fn build(self) -> crate::model::LogStream {
            crate::model::LogStream {
                log_stream_name: self.log_stream_name,
                creation_time: self.creation_time,
                first_event_timestamp: self.first_event_timestamp,
                last_event_timestamp: self.last_event_timestamp,
                last_ingestion_time: self.last_ingestion_time,
                upload_sequence_token: self.upload_sequence_token,
                arn: self.arn,
                stored_bytes: self.stored_bytes,
            }
        }
    }
}
impl LogStream {
    /// Creates a new builder-style object to manufacture [`LogStream`](crate::model::LogStream)
    pub fn builder() -> crate::model::log_stream::Builder {
        crate::model::log_stream::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum OrderBy {
    #[allow(missing_docs)] // documentation missing in model
    LastEventTime,
    #[allow(missing_docs)] // documentation missing in model
    LogStreamName,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for OrderBy {
    fn from(s: &str) -> Self {
        match s {
            "LastEventTime" => OrderBy::LastEventTime,
            "LogStreamName" => OrderBy::LogStreamName,
            other => OrderBy::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for OrderBy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(OrderBy::from(s))
    }
}
impl OrderBy {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            OrderBy::LastEventTime => "LastEventTime",
            OrderBy::LogStreamName => "LogStreamName",
            OrderBy::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["LastEventTime", "LogStreamName"]
    }
}
impl AsRef<str> for OrderBy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Represents a log group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LogGroup {
    /// <p>The name of the log group.</p>
    pub log_group_name: std::option::Option<std::string::String>,
    /// <p>The creation time of the log group, expressed as the number of milliseconds after Jan
    /// 1, 1970 00:00:00 UTC.</p>
    pub creation_time: std::option::Option<i64>,
    /// <p>The number of days to retain the log events in the specified log group.
    /// Possible values are: 1, 3, 5, 7, 14, 30, 60, 90, 120, 150, 180, 365, 400, 545, 731, 1827, and 3653.</p>
    /// <p>To set a log group to never have log events expire, use
    /// <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_DeleteRetentionPolicy.html">DeleteRetentionPolicy</a>.
    /// </p>
    pub retention_in_days: std::option::Option<i32>,
    /// <p>The number of metric filters.</p>
    pub metric_filter_count: std::option::Option<i32>,
    /// <p>The Amazon Resource Name (ARN) of the log group.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The number of bytes stored.</p>
    pub stored_bytes: std::option::Option<i64>,
    /// <p>The Amazon Resource Name (ARN) of the CMK to use when encrypting log data.</p>
    pub kms_key_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LogGroup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LogGroup");
        formatter.field("log_group_name", &self.log_group_name);
        formatter.field("creation_time", &self.creation_time);
        formatter.field("retention_in_days", &self.retention_in_days);
        formatter.field("metric_filter_count", &self.metric_filter_count);
        formatter.field("arn", &self.arn);
        formatter.field("stored_bytes", &self.stored_bytes);
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.finish()
    }
}
/// See [`LogGroup`](crate::model::LogGroup)
pub mod log_group {
    /// A builder for [`LogGroup`](crate::model::LogGroup)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) log_group_name: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<i64>,
        pub(crate) retention_in_days: std::option::Option<i32>,
        pub(crate) metric_filter_count: std::option::Option<i32>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) stored_bytes: std::option::Option<i64>,
        pub(crate) kms_key_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the log group.</p>
        pub fn log_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.log_group_name = Some(input.into());
            self
        }
        /// <p>The name of the log group.</p>
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.log_group_name = input;
            self
        }
        /// <p>The creation time of the log group, expressed as the number of milliseconds after Jan
        /// 1, 1970 00:00:00 UTC.</p>
        pub fn creation_time(mut self, input: i64) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The creation time of the log group, expressed as the number of milliseconds after Jan
        /// 1, 1970 00:00:00 UTC.</p>
        pub fn set_creation_time(mut self, input: std::option::Option<i64>) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The number of days to retain the log events in the specified log group.
        /// Possible values are: 1, 3, 5, 7, 14, 30, 60, 90, 120, 150, 180, 365, 400, 545, 731, 1827, and 3653.</p>
        /// <p>To set a log group to never have log events expire, use
        /// <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_DeleteRetentionPolicy.html">DeleteRetentionPolicy</a>.
        /// </p>
        pub fn retention_in_days(mut self, input: i32) -> Self {
            self.retention_in_days = Some(input);
            self
        }
        /// <p>The number of days to retain the log events in the specified log group.
        /// Possible values are: 1, 3, 5, 7, 14, 30, 60, 90, 120, 150, 180, 365, 400, 545, 731, 1827, and 3653.</p>
        /// <p>To set a log group to never have log events expire, use
        /// <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_DeleteRetentionPolicy.html">DeleteRetentionPolicy</a>.
        /// </p>
        pub fn set_retention_in_days(mut self, input: std::option::Option<i32>) -> Self {
            self.retention_in_days = input;
            self
        }
        /// <p>The number of metric filters.</p>
        pub fn metric_filter_count(mut self, input: i32) -> Self {
            self.metric_filter_count = Some(input);
            self
        }
        /// <p>The number of metric filters.</p>
        pub fn set_metric_filter_count(mut self, input: std::option::Option<i32>) -> Self {
            self.metric_filter_count = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the log group.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the log group.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The number of bytes stored.</p>
        pub fn stored_bytes(mut self, input: i64) -> Self {
            self.stored_bytes = Some(input);
            self
        }
        /// <p>The number of bytes stored.</p>
        pub fn set_stored_bytes(mut self, input: std::option::Option<i64>) -> Self {
            self.stored_bytes = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the CMK to use when encrypting log data.</p>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the CMK to use when encrypting log data.</p>
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = input;
            self
        }
        /// Consumes the builder and constructs a [`LogGroup`](crate::model::LogGroup)
        pub fn build(self) -> crate::model::LogGroup {
            crate::model::LogGroup {
                log_group_name: self.log_group_name,
                creation_time: self.creation_time,
                retention_in_days: self.retention_in_days,
                metric_filter_count: self.metric_filter_count,
                arn: self.arn,
                stored_bytes: self.stored_bytes,
                kms_key_id: self.kms_key_id,
            }
        }
    }
}
impl LogGroup {
    /// Creates a new builder-style object to manufacture [`LogGroup`](crate::model::LogGroup)
    pub fn builder() -> crate::model::log_group::Builder {
        crate::model::log_group::Builder::default()
    }
}

/// <p>Represents an export task.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ExportTask {
    /// <p>The ID of the export task.</p>
    pub task_id: std::option::Option<std::string::String>,
    /// <p>The name of the export task.</p>
    pub task_name: std::option::Option<std::string::String>,
    /// <p>The name of the log group from which logs data was exported.</p>
    pub log_group_name: std::option::Option<std::string::String>,
    /// <p>The start time, expressed as the number of milliseconds after Jan 1, 1970 00:00:00 UTC.
    /// Events with a timestamp before this time are not exported.</p>
    pub from: std::option::Option<i64>,
    /// <p>The end time, expressed as the number of milliseconds after Jan 1, 1970 00:00:00 UTC.
    /// Events with a timestamp later than this time are not exported.</p>
    pub to: std::option::Option<i64>,
    /// <p>The name of the S3 bucket to which the log data was exported.</p>
    pub destination: std::option::Option<std::string::String>,
    /// <p>The prefix that was used as the start of Amazon S3 key for every object exported.</p>
    pub destination_prefix: std::option::Option<std::string::String>,
    /// <p>The status of the export task.</p>
    pub status: std::option::Option<crate::model::ExportTaskStatus>,
    /// <p>Execution information about the export task.</p>
    pub execution_info: std::option::Option<crate::model::ExportTaskExecutionInfo>,
}
impl std::fmt::Debug for ExportTask {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ExportTask");
        formatter.field("task_id", &self.task_id);
        formatter.field("task_name", &self.task_name);
        formatter.field("log_group_name", &self.log_group_name);
        formatter.field("from", &self.from);
        formatter.field("to", &self.to);
        formatter.field("destination", &self.destination);
        formatter.field("destination_prefix", &self.destination_prefix);
        formatter.field("status", &self.status);
        formatter.field("execution_info", &self.execution_info);
        formatter.finish()
    }
}
/// See [`ExportTask`](crate::model::ExportTask)
pub mod export_task {
    /// A builder for [`ExportTask`](crate::model::ExportTask)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) task_id: std::option::Option<std::string::String>,
        pub(crate) task_name: std::option::Option<std::string::String>,
        pub(crate) log_group_name: std::option::Option<std::string::String>,
        pub(crate) from: std::option::Option<i64>,
        pub(crate) to: std::option::Option<i64>,
        pub(crate) destination: std::option::Option<std::string::String>,
        pub(crate) destination_prefix: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::ExportTaskStatus>,
        pub(crate) execution_info: std::option::Option<crate::model::ExportTaskExecutionInfo>,
    }
    impl Builder {
        /// <p>The ID of the export task.</p>
        pub fn task_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.task_id = Some(input.into());
            self
        }
        /// <p>The ID of the export task.</p>
        pub fn set_task_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.task_id = input;
            self
        }
        /// <p>The name of the export task.</p>
        pub fn task_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.task_name = Some(input.into());
            self
        }
        /// <p>The name of the export task.</p>
        pub fn set_task_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.task_name = input;
            self
        }
        /// <p>The name of the log group from which logs data was exported.</p>
        pub fn log_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.log_group_name = Some(input.into());
            self
        }
        /// <p>The name of the log group from which logs data was exported.</p>
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.log_group_name = input;
            self
        }
        /// <p>The start time, expressed as the number of milliseconds after Jan 1, 1970 00:00:00 UTC.
        /// Events with a timestamp before this time are not exported.</p>
        pub fn from(mut self, input: i64) -> Self {
            self.from = Some(input);
            self
        }
        /// <p>The start time, expressed as the number of milliseconds after Jan 1, 1970 00:00:00 UTC.
        /// Events with a timestamp before this time are not exported.</p>
        pub fn set_from(mut self, input: std::option::Option<i64>) -> Self {
            self.from = input;
            self
        }
        /// <p>The end time, expressed as the number of milliseconds after Jan 1, 1970 00:00:00 UTC.
        /// Events with a timestamp later than this time are not exported.</p>
        pub fn to(mut self, input: i64) -> Self {
            self.to = Some(input);
            self
        }
        /// <p>The end time, expressed as the number of milliseconds after Jan 1, 1970 00:00:00 UTC.
        /// Events with a timestamp later than this time are not exported.</p>
        pub fn set_to(mut self, input: std::option::Option<i64>) -> Self {
            self.to = input;
            self
        }
        /// <p>The name of the S3 bucket to which the log data was exported.</p>
        pub fn destination(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination = Some(input.into());
            self
        }
        /// <p>The name of the S3 bucket to which the log data was exported.</p>
        pub fn set_destination(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.destination = input;
            self
        }
        /// <p>The prefix that was used as the start of Amazon S3 key for every object exported.</p>
        pub fn destination_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination_prefix = Some(input.into());
            self
        }
        /// <p>The prefix that was used as the start of Amazon S3 key for every object exported.</p>
        pub fn set_destination_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.destination_prefix = input;
            self
        }
        /// <p>The status of the export task.</p>
        pub fn status(mut self, input: crate::model::ExportTaskStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the export task.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ExportTaskStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>Execution information about the export task.</p>
        pub fn execution_info(mut self, input: crate::model::ExportTaskExecutionInfo) -> Self {
            self.execution_info = Some(input);
            self
        }
        /// <p>Execution information about the export task.</p>
        pub fn set_execution_info(
            mut self,
            input: std::option::Option<crate::model::ExportTaskExecutionInfo>,
        ) -> Self {
            self.execution_info = input;
            self
        }
        /// Consumes the builder and constructs a [`ExportTask`](crate::model::ExportTask)
        pub fn build(self) -> crate::model::ExportTask {
            crate::model::ExportTask {
                task_id: self.task_id,
                task_name: self.task_name,
                log_group_name: self.log_group_name,
                from: self.from,
                to: self.to,
                destination: self.destination,
                destination_prefix: self.destination_prefix,
                status: self.status,
                execution_info: self.execution_info,
            }
        }
    }
}
impl ExportTask {
    /// Creates a new builder-style object to manufacture [`ExportTask`](crate::model::ExportTask)
    pub fn builder() -> crate::model::export_task::Builder {
        crate::model::export_task::Builder::default()
    }
}

/// <p>Represents the status of an export task.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ExportTaskExecutionInfo {
    /// <p>The creation time of the export task, expressed as the number of milliseconds after Jan
    /// 1, 1970 00:00:00 UTC.</p>
    pub creation_time: std::option::Option<i64>,
    /// <p>The completion time of the export task, expressed as the number of milliseconds after
    /// Jan 1, 1970 00:00:00 UTC.</p>
    pub completion_time: std::option::Option<i64>,
}
impl std::fmt::Debug for ExportTaskExecutionInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ExportTaskExecutionInfo");
        formatter.field("creation_time", &self.creation_time);
        formatter.field("completion_time", &self.completion_time);
        formatter.finish()
    }
}
/// See [`ExportTaskExecutionInfo`](crate::model::ExportTaskExecutionInfo)
pub mod export_task_execution_info {
    /// A builder for [`ExportTaskExecutionInfo`](crate::model::ExportTaskExecutionInfo)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) creation_time: std::option::Option<i64>,
        pub(crate) completion_time: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The creation time of the export task, expressed as the number of milliseconds after Jan
        /// 1, 1970 00:00:00 UTC.</p>
        pub fn creation_time(mut self, input: i64) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The creation time of the export task, expressed as the number of milliseconds after Jan
        /// 1, 1970 00:00:00 UTC.</p>
        pub fn set_creation_time(mut self, input: std::option::Option<i64>) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The completion time of the export task, expressed as the number of milliseconds after
        /// Jan 1, 1970 00:00:00 UTC.</p>
        pub fn completion_time(mut self, input: i64) -> Self {
            self.completion_time = Some(input);
            self
        }
        /// <p>The completion time of the export task, expressed as the number of milliseconds after
        /// Jan 1, 1970 00:00:00 UTC.</p>
        pub fn set_completion_time(mut self, input: std::option::Option<i64>) -> Self {
            self.completion_time = input;
            self
        }
        /// Consumes the builder and constructs a [`ExportTaskExecutionInfo`](crate::model::ExportTaskExecutionInfo)
        pub fn build(self) -> crate::model::ExportTaskExecutionInfo {
            crate::model::ExportTaskExecutionInfo {
                creation_time: self.creation_time,
                completion_time: self.completion_time,
            }
        }
    }
}
impl ExportTaskExecutionInfo {
    /// Creates a new builder-style object to manufacture [`ExportTaskExecutionInfo`](crate::model::ExportTaskExecutionInfo)
    pub fn builder() -> crate::model::export_task_execution_info::Builder {
        crate::model::export_task_execution_info::Builder::default()
    }
}

/// <p>Represents the status of an export task.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ExportTaskStatus {
    /// <p>The status code of the export task.</p>
    pub code: std::option::Option<crate::model::ExportTaskStatusCode>,
    /// <p>The status message related to the status code.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ExportTaskStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ExportTaskStatus");
        formatter.field("code", &self.code);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
/// See [`ExportTaskStatus`](crate::model::ExportTaskStatus)
pub mod export_task_status {
    /// A builder for [`ExportTaskStatus`](crate::model::ExportTaskStatus)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<crate::model::ExportTaskStatusCode>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The status code of the export task.</p>
        pub fn code(mut self, input: crate::model::ExportTaskStatusCode) -> Self {
            self.code = Some(input);
            self
        }
        /// <p>The status code of the export task.</p>
        pub fn set_code(
            mut self,
            input: std::option::Option<crate::model::ExportTaskStatusCode>,
        ) -> Self {
            self.code = input;
            self
        }
        /// <p>The status message related to the status code.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The status message related to the status code.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ExportTaskStatus`](crate::model::ExportTaskStatus)
        pub fn build(self) -> crate::model::ExportTaskStatus {
            crate::model::ExportTaskStatus {
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl ExportTaskStatus {
    /// Creates a new builder-style object to manufacture [`ExportTaskStatus`](crate::model::ExportTaskStatus)
    pub fn builder() -> crate::model::export_task_status::Builder {
        crate::model::export_task_status::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ExportTaskStatusCode {
    #[allow(missing_docs)] // documentation missing in model
    Cancelled,
    #[allow(missing_docs)] // documentation missing in model
    Completed,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    #[allow(missing_docs)] // documentation missing in model
    PendingCancel,
    #[allow(missing_docs)] // documentation missing in model
    Running,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ExportTaskStatusCode {
    fn from(s: &str) -> Self {
        match s {
            "CANCELLED" => ExportTaskStatusCode::Cancelled,
            "COMPLETED" => ExportTaskStatusCode::Completed,
            "FAILED" => ExportTaskStatusCode::Failed,
            "PENDING" => ExportTaskStatusCode::Pending,
            "PENDING_CANCEL" => ExportTaskStatusCode::PendingCancel,
            "RUNNING" => ExportTaskStatusCode::Running,
            other => ExportTaskStatusCode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ExportTaskStatusCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ExportTaskStatusCode::from(s))
    }
}
impl ExportTaskStatusCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ExportTaskStatusCode::Cancelled => "CANCELLED",
            ExportTaskStatusCode::Completed => "COMPLETED",
            ExportTaskStatusCode::Failed => "FAILED",
            ExportTaskStatusCode::Pending => "PENDING",
            ExportTaskStatusCode::PendingCancel => "PENDING_CANCEL",
            ExportTaskStatusCode::Running => "RUNNING",
            ExportTaskStatusCode::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "CANCELLED",
            "COMPLETED",
            "FAILED",
            "PENDING",
            "PENDING_CANCEL",
            "RUNNING",
        ]
    }
}
impl AsRef<str> for ExportTaskStatusCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
