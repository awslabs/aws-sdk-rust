// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use std::fmt::Write;

/// See [`CreateBudgetInput`](crate::input::CreateBudgetInput).
pub mod create_budget_input {
    
    /// A builder for [`CreateBudgetInput`](crate::input::CreateBudgetInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) budget: std::option::Option<crate::model::Budget>,
        pub(crate) notifications_with_subscribers: std::option::Option<std::vec::Vec<crate::model::NotificationWithSubscribers>>,
    }
    impl Builder {
        /// <p>The <code>accountId</code> that is associated with the budget.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The <code>accountId</code> that is associated with the budget.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input; self
        }
        /// <p>The budget object that you want to create.</p>
        pub fn budget(mut self, input: crate::model::Budget) -> Self {
            self.budget = Some(input);
            self
        }
        /// <p>The budget object that you want to create.</p>
        pub fn set_budget(mut self, input: std::option::Option<crate::model::Budget>) -> Self {
            self.budget = input; self
        }
        /// Appends an item to `notifications_with_subscribers`.
        ///
        /// To override the contents of this collection use [`set_notifications_with_subscribers`](Self::set_notifications_with_subscribers).
        ///
        /// <p>A notification that you want to associate with a budget. A budget can have up to five notifications, and each notification can have one SNS subscriber and up to 10 email subscribers. If you include notifications and subscribers in your <code>CreateBudget</code> call, Amazon Web Services creates the notifications and subscribers for you.</p>
        pub fn notifications_with_subscribers(mut self, input: crate::model::NotificationWithSubscribers) -> Self {
            let mut v = self.notifications_with_subscribers.unwrap_or_default();
                            v.push(input);
                            self.notifications_with_subscribers = Some(v);
                            self
        }
        /// <p>A notification that you want to associate with a budget. A budget can have up to five notifications, and each notification can have one SNS subscriber and up to 10 email subscribers. If you include notifications and subscribers in your <code>CreateBudget</code> call, Amazon Web Services creates the notifications and subscribers for you.</p>
        pub fn set_notifications_with_subscribers(mut self, input: std::option::Option<std::vec::Vec<crate::model::NotificationWithSubscribers>>) -> Self {
            self.notifications_with_subscribers = input; self
        }
        /// Consumes the builder and constructs a [`CreateBudgetInput`](crate::input::CreateBudgetInput).
        pub fn build(self) -> Result<crate::input::CreateBudgetInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::CreateBudgetInput {
                    account_id: self.account_id
                    ,
                    budget: self.budget
                    ,
                    notifications_with_subscribers: self.notifications_with_subscribers
                    ,
                }
            )
        }
    }
    
    
}
impl CreateBudgetInput {
    /// Consumes the builder and constructs an Operation<[`CreateBudget`](crate::operation::CreateBudget)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::CreateBudget, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::CreateBudgetInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::CreateBudgetInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/x-amz-json-1.1");
            builder = aws_smithy_http::header::set_request_header_if_absent(
                                builder,
                                http::header::HeaderName::from_static("x-amz-target"),
                                "AWSBudgetServiceGateway.CreateBudget"
                            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_budget(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::CreateBudget::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("CreateBudget", "budgets"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateBudgetInput`](crate::input::CreateBudgetInput).
    pub fn builder() -> crate::input::create_budget_input::Builder {
        crate::input::create_budget_input::Builder::default()
    }
}

/// See [`CreateBudgetActionInput`](crate::input::CreateBudgetActionInput).
pub mod create_budget_action_input {
    
    /// A builder for [`CreateBudgetActionInput`](crate::input::CreateBudgetActionInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) budget_name: std::option::Option<std::string::String>,
        pub(crate) notification_type: std::option::Option<crate::model::NotificationType>,
        pub(crate) action_type: std::option::Option<crate::model::ActionType>,
        pub(crate) action_threshold: std::option::Option<crate::model::ActionThreshold>,
        pub(crate) definition: std::option::Option<crate::model::Definition>,
        pub(crate) execution_role_arn: std::option::Option<std::string::String>,
        pub(crate) approval_model: std::option::Option<crate::model::ApprovalModel>,
        pub(crate) subscribers: std::option::Option<std::vec::Vec<crate::model::Subscriber>>,
    }
    impl Builder {
        /// <p>The account ID of the user. It's a 12-digit number.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The account ID of the user. It's a 12-digit number.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input; self
        }
        /// <p> A string that represents the budget name. The ":" and "\" characters aren't allowed.</p>
        pub fn budget_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.budget_name = Some(input.into());
            self
        }
        /// <p> A string that represents the budget name. The ":" and "\" characters aren't allowed.</p>
        pub fn set_budget_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.budget_name = input; self
        }
        /// <p> The type of a notification. It must be ACTUAL or FORECASTED.</p>
        pub fn notification_type(mut self, input: crate::model::NotificationType) -> Self {
            self.notification_type = Some(input);
            self
        }
        /// <p> The type of a notification. It must be ACTUAL or FORECASTED.</p>
        pub fn set_notification_type(mut self, input: std::option::Option<crate::model::NotificationType>) -> Self {
            self.notification_type = input; self
        }
        /// <p> The type of action. This defines the type of tasks that can be carried out by this action. This field also determines the format for definition. </p>
        pub fn action_type(mut self, input: crate::model::ActionType) -> Self {
            self.action_type = Some(input);
            self
        }
        /// <p> The type of action. This defines the type of tasks that can be carried out by this action. This field also determines the format for definition. </p>
        pub fn set_action_type(mut self, input: std::option::Option<crate::model::ActionType>) -> Self {
            self.action_type = input; self
        }
        /// <p>The trigger threshold of the action. </p>
        pub fn action_threshold(mut self, input: crate::model::ActionThreshold) -> Self {
            self.action_threshold = Some(input);
            self
        }
        /// <p>The trigger threshold of the action. </p>
        pub fn set_action_threshold(mut self, input: std::option::Option<crate::model::ActionThreshold>) -> Self {
            self.action_threshold = input; self
        }
        /// <p>Specifies all of the type-specific parameters. </p>
        pub fn definition(mut self, input: crate::model::Definition) -> Self {
            self.definition = Some(input);
            self
        }
        /// <p>Specifies all of the type-specific parameters. </p>
        pub fn set_definition(mut self, input: std::option::Option<crate::model::Definition>) -> Self {
            self.definition = input; self
        }
        /// <p> The role passed for action execution and reversion. Roles and actions must be in the same account. </p>
        pub fn execution_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.execution_role_arn = Some(input.into());
            self
        }
        /// <p> The role passed for action execution and reversion. Roles and actions must be in the same account. </p>
        pub fn set_execution_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.execution_role_arn = input; self
        }
        /// <p> This specifies if the action needs manual or automatic approval. </p>
        pub fn approval_model(mut self, input: crate::model::ApprovalModel) -> Self {
            self.approval_model = Some(input);
            self
        }
        /// <p> This specifies if the action needs manual or automatic approval. </p>
        pub fn set_approval_model(mut self, input: std::option::Option<crate::model::ApprovalModel>) -> Self {
            self.approval_model = input; self
        }
        /// Appends an item to `subscribers`.
        ///
        /// To override the contents of this collection use [`set_subscribers`](Self::set_subscribers).
        ///
        /// <p> A list of subscribers.</p>
        pub fn subscribers(mut self, input: crate::model::Subscriber) -> Self {
            let mut v = self.subscribers.unwrap_or_default();
                            v.push(input);
                            self.subscribers = Some(v);
                            self
        }
        /// <p> A list of subscribers.</p>
        pub fn set_subscribers(mut self, input: std::option::Option<std::vec::Vec<crate::model::Subscriber>>) -> Self {
            self.subscribers = input; self
        }
        /// Consumes the builder and constructs a [`CreateBudgetActionInput`](crate::input::CreateBudgetActionInput).
        pub fn build(self) -> Result<crate::input::CreateBudgetActionInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::CreateBudgetActionInput {
                    account_id: self.account_id
                    ,
                    budget_name: self.budget_name
                    ,
                    notification_type: self.notification_type
                    ,
                    action_type: self.action_type
                    ,
                    action_threshold: self.action_threshold
                    ,
                    definition: self.definition
                    ,
                    execution_role_arn: self.execution_role_arn
                    ,
                    approval_model: self.approval_model
                    ,
                    subscribers: self.subscribers
                    ,
                }
            )
        }
    }
    
    
}
impl CreateBudgetActionInput {
    /// Consumes the builder and constructs an Operation<[`CreateBudgetAction`](crate::operation::CreateBudgetAction)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::CreateBudgetAction, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::CreateBudgetActionInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::CreateBudgetActionInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/x-amz-json-1.1");
            builder = aws_smithy_http::header::set_request_header_if_absent(
                                builder,
                                http::header::HeaderName::from_static("x-amz-target"),
                                "AWSBudgetServiceGateway.CreateBudgetAction"
                            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_budget_action(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::CreateBudgetAction::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("CreateBudgetAction", "budgets"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateBudgetActionInput`](crate::input::CreateBudgetActionInput).
    pub fn builder() -> crate::input::create_budget_action_input::Builder {
        crate::input::create_budget_action_input::Builder::default()
    }
}

/// See [`CreateNotificationInput`](crate::input::CreateNotificationInput).
pub mod create_notification_input {
    
    /// A builder for [`CreateNotificationInput`](crate::input::CreateNotificationInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) budget_name: std::option::Option<std::string::String>,
        pub(crate) notification: std::option::Option<crate::model::Notification>,
        pub(crate) subscribers: std::option::Option<std::vec::Vec<crate::model::Subscriber>>,
    }
    impl Builder {
        /// <p>The <code>accountId</code> that is associated with the budget that you want to create a notification for.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The <code>accountId</code> that is associated with the budget that you want to create a notification for.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input; self
        }
        /// <p>The name of the budget that you want Amazon Web Services to notify you about. Budget names must be unique within an account.</p>
        pub fn budget_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.budget_name = Some(input.into());
            self
        }
        /// <p>The name of the budget that you want Amazon Web Services to notify you about. Budget names must be unique within an account.</p>
        pub fn set_budget_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.budget_name = input; self
        }
        /// <p>The notification that you want to create.</p>
        pub fn notification(mut self, input: crate::model::Notification) -> Self {
            self.notification = Some(input);
            self
        }
        /// <p>The notification that you want to create.</p>
        pub fn set_notification(mut self, input: std::option::Option<crate::model::Notification>) -> Self {
            self.notification = input; self
        }
        /// Appends an item to `subscribers`.
        ///
        /// To override the contents of this collection use [`set_subscribers`](Self::set_subscribers).
        ///
        /// <p>A list of subscribers that you want to associate with the notification. Each notification can have one SNS subscriber and up to 10 email subscribers.</p>
        pub fn subscribers(mut self, input: crate::model::Subscriber) -> Self {
            let mut v = self.subscribers.unwrap_or_default();
                            v.push(input);
                            self.subscribers = Some(v);
                            self
        }
        /// <p>A list of subscribers that you want to associate with the notification. Each notification can have one SNS subscriber and up to 10 email subscribers.</p>
        pub fn set_subscribers(mut self, input: std::option::Option<std::vec::Vec<crate::model::Subscriber>>) -> Self {
            self.subscribers = input; self
        }
        /// Consumes the builder and constructs a [`CreateNotificationInput`](crate::input::CreateNotificationInput).
        pub fn build(self) -> Result<crate::input::CreateNotificationInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::CreateNotificationInput {
                    account_id: self.account_id
                    ,
                    budget_name: self.budget_name
                    ,
                    notification: self.notification
                    ,
                    subscribers: self.subscribers
                    ,
                }
            )
        }
    }
    
    
}
impl CreateNotificationInput {
    /// Consumes the builder and constructs an Operation<[`CreateNotification`](crate::operation::CreateNotification)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::CreateNotification, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::CreateNotificationInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::CreateNotificationInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/x-amz-json-1.1");
            builder = aws_smithy_http::header::set_request_header_if_absent(
                                builder,
                                http::header::HeaderName::from_static("x-amz-target"),
                                "AWSBudgetServiceGateway.CreateNotification"
                            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_notification(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::CreateNotification::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("CreateNotification", "budgets"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateNotificationInput`](crate::input::CreateNotificationInput).
    pub fn builder() -> crate::input::create_notification_input::Builder {
        crate::input::create_notification_input::Builder::default()
    }
}

/// See [`CreateSubscriberInput`](crate::input::CreateSubscriberInput).
pub mod create_subscriber_input {
    
    /// A builder for [`CreateSubscriberInput`](crate::input::CreateSubscriberInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) budget_name: std::option::Option<std::string::String>,
        pub(crate) notification: std::option::Option<crate::model::Notification>,
        pub(crate) subscriber: std::option::Option<crate::model::Subscriber>,
    }
    impl Builder {
        /// <p>The <code>accountId</code> that is associated with the budget that you want to create a subscriber for.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The <code>accountId</code> that is associated with the budget that you want to create a subscriber for.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input; self
        }
        /// <p>The name of the budget that you want to subscribe to. Budget names must be unique within an account.</p>
        pub fn budget_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.budget_name = Some(input.into());
            self
        }
        /// <p>The name of the budget that you want to subscribe to. Budget names must be unique within an account.</p>
        pub fn set_budget_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.budget_name = input; self
        }
        /// <p>The notification that you want to create a subscriber for.</p>
        pub fn notification(mut self, input: crate::model::Notification) -> Self {
            self.notification = Some(input);
            self
        }
        /// <p>The notification that you want to create a subscriber for.</p>
        pub fn set_notification(mut self, input: std::option::Option<crate::model::Notification>) -> Self {
            self.notification = input; self
        }
        /// <p>The subscriber that you want to associate with a budget notification.</p>
        pub fn subscriber(mut self, input: crate::model::Subscriber) -> Self {
            self.subscriber = Some(input);
            self
        }
        /// <p>The subscriber that you want to associate with a budget notification.</p>
        pub fn set_subscriber(mut self, input: std::option::Option<crate::model::Subscriber>) -> Self {
            self.subscriber = input; self
        }
        /// Consumes the builder and constructs a [`CreateSubscriberInput`](crate::input::CreateSubscriberInput).
        pub fn build(self) -> Result<crate::input::CreateSubscriberInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::CreateSubscriberInput {
                    account_id: self.account_id
                    ,
                    budget_name: self.budget_name
                    ,
                    notification: self.notification
                    ,
                    subscriber: self.subscriber
                    ,
                }
            )
        }
    }
    
    
}
impl CreateSubscriberInput {
    /// Consumes the builder and constructs an Operation<[`CreateSubscriber`](crate::operation::CreateSubscriber)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::CreateSubscriber, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::CreateSubscriberInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::CreateSubscriberInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/x-amz-json-1.1");
            builder = aws_smithy_http::header::set_request_header_if_absent(
                                builder,
                                http::header::HeaderName::from_static("x-amz-target"),
                                "AWSBudgetServiceGateway.CreateSubscriber"
                            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_subscriber(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::CreateSubscriber::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("CreateSubscriber", "budgets"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateSubscriberInput`](crate::input::CreateSubscriberInput).
    pub fn builder() -> crate::input::create_subscriber_input::Builder {
        crate::input::create_subscriber_input::Builder::default()
    }
}

/// See [`DeleteBudgetInput`](crate::input::DeleteBudgetInput).
pub mod delete_budget_input {
    
    /// A builder for [`DeleteBudgetInput`](crate::input::DeleteBudgetInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) budget_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The <code>accountId</code> that is associated with the budget that you want to delete.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The <code>accountId</code> that is associated with the budget that you want to delete.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input; self
        }
        /// <p>The name of the budget that you want to delete.</p>
        pub fn budget_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.budget_name = Some(input.into());
            self
        }
        /// <p>The name of the budget that you want to delete.</p>
        pub fn set_budget_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.budget_name = input; self
        }
        /// Consumes the builder and constructs a [`DeleteBudgetInput`](crate::input::DeleteBudgetInput).
        pub fn build(self) -> Result<crate::input::DeleteBudgetInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DeleteBudgetInput {
                    account_id: self.account_id
                    ,
                    budget_name: self.budget_name
                    ,
                }
            )
        }
    }
    
    
}
impl DeleteBudgetInput {
    /// Consumes the builder and constructs an Operation<[`DeleteBudget`](crate::operation::DeleteBudget)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DeleteBudget, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::DeleteBudgetInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DeleteBudgetInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/x-amz-json-1.1");
            builder = aws_smithy_http::header::set_request_header_if_absent(
                                builder,
                                http::header::HeaderName::from_static("x-amz-target"),
                                "AWSBudgetServiceGateway.DeleteBudget"
                            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_delete_budget(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DeleteBudget::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DeleteBudget", "budgets"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteBudgetInput`](crate::input::DeleteBudgetInput).
    pub fn builder() -> crate::input::delete_budget_input::Builder {
        crate::input::delete_budget_input::Builder::default()
    }
}

/// See [`DeleteBudgetActionInput`](crate::input::DeleteBudgetActionInput).
pub mod delete_budget_action_input {
    
    /// A builder for [`DeleteBudgetActionInput`](crate::input::DeleteBudgetActionInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) budget_name: std::option::Option<std::string::String>,
        pub(crate) action_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The account ID of the user. It's a 12-digit number.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The account ID of the user. It's a 12-digit number.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input; self
        }
        /// <p> A string that represents the budget name. The ":" and "\" characters aren't allowed.</p>
        pub fn budget_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.budget_name = Some(input.into());
            self
        }
        /// <p> A string that represents the budget name. The ":" and "\" characters aren't allowed.</p>
        pub fn set_budget_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.budget_name = input; self
        }
        /// <p> A system-generated universally unique identifier (UUID) for the action. </p>
        pub fn action_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.action_id = Some(input.into());
            self
        }
        /// <p> A system-generated universally unique identifier (UUID) for the action. </p>
        pub fn set_action_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.action_id = input; self
        }
        /// Consumes the builder and constructs a [`DeleteBudgetActionInput`](crate::input::DeleteBudgetActionInput).
        pub fn build(self) -> Result<crate::input::DeleteBudgetActionInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DeleteBudgetActionInput {
                    account_id: self.account_id
                    ,
                    budget_name: self.budget_name
                    ,
                    action_id: self.action_id
                    ,
                }
            )
        }
    }
    
    
}
impl DeleteBudgetActionInput {
    /// Consumes the builder and constructs an Operation<[`DeleteBudgetAction`](crate::operation::DeleteBudgetAction)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DeleteBudgetAction, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::DeleteBudgetActionInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DeleteBudgetActionInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/x-amz-json-1.1");
            builder = aws_smithy_http::header::set_request_header_if_absent(
                                builder,
                                http::header::HeaderName::from_static("x-amz-target"),
                                "AWSBudgetServiceGateway.DeleteBudgetAction"
                            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_delete_budget_action(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DeleteBudgetAction::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DeleteBudgetAction", "budgets"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteBudgetActionInput`](crate::input::DeleteBudgetActionInput).
    pub fn builder() -> crate::input::delete_budget_action_input::Builder {
        crate::input::delete_budget_action_input::Builder::default()
    }
}

/// See [`DeleteNotificationInput`](crate::input::DeleteNotificationInput).
pub mod delete_notification_input {
    
    /// A builder for [`DeleteNotificationInput`](crate::input::DeleteNotificationInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) budget_name: std::option::Option<std::string::String>,
        pub(crate) notification: std::option::Option<crate::model::Notification>,
    }
    impl Builder {
        /// <p>The <code>accountId</code> that is associated with the budget whose notification you want to delete.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The <code>accountId</code> that is associated with the budget whose notification you want to delete.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input; self
        }
        /// <p>The name of the budget whose notification you want to delete.</p>
        pub fn budget_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.budget_name = Some(input.into());
            self
        }
        /// <p>The name of the budget whose notification you want to delete.</p>
        pub fn set_budget_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.budget_name = input; self
        }
        /// <p>The notification that you want to delete.</p>
        pub fn notification(mut self, input: crate::model::Notification) -> Self {
            self.notification = Some(input);
            self
        }
        /// <p>The notification that you want to delete.</p>
        pub fn set_notification(mut self, input: std::option::Option<crate::model::Notification>) -> Self {
            self.notification = input; self
        }
        /// Consumes the builder and constructs a [`DeleteNotificationInput`](crate::input::DeleteNotificationInput).
        pub fn build(self) -> Result<crate::input::DeleteNotificationInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DeleteNotificationInput {
                    account_id: self.account_id
                    ,
                    budget_name: self.budget_name
                    ,
                    notification: self.notification
                    ,
                }
            )
        }
    }
    
    
}
impl DeleteNotificationInput {
    /// Consumes the builder and constructs an Operation<[`DeleteNotification`](crate::operation::DeleteNotification)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DeleteNotification, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::DeleteNotificationInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DeleteNotificationInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/x-amz-json-1.1");
            builder = aws_smithy_http::header::set_request_header_if_absent(
                                builder,
                                http::header::HeaderName::from_static("x-amz-target"),
                                "AWSBudgetServiceGateway.DeleteNotification"
                            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_delete_notification(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DeleteNotification::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DeleteNotification", "budgets"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteNotificationInput`](crate::input::DeleteNotificationInput).
    pub fn builder() -> crate::input::delete_notification_input::Builder {
        crate::input::delete_notification_input::Builder::default()
    }
}

/// See [`DeleteSubscriberInput`](crate::input::DeleteSubscriberInput).
pub mod delete_subscriber_input {
    
    /// A builder for [`DeleteSubscriberInput`](crate::input::DeleteSubscriberInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) budget_name: std::option::Option<std::string::String>,
        pub(crate) notification: std::option::Option<crate::model::Notification>,
        pub(crate) subscriber: std::option::Option<crate::model::Subscriber>,
    }
    impl Builder {
        /// <p>The <code>accountId</code> that is associated with the budget whose subscriber you want to delete.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The <code>accountId</code> that is associated with the budget whose subscriber you want to delete.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input; self
        }
        /// <p>The name of the budget whose subscriber you want to delete.</p>
        pub fn budget_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.budget_name = Some(input.into());
            self
        }
        /// <p>The name of the budget whose subscriber you want to delete.</p>
        pub fn set_budget_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.budget_name = input; self
        }
        /// <p>The notification whose subscriber you want to delete.</p>
        pub fn notification(mut self, input: crate::model::Notification) -> Self {
            self.notification = Some(input);
            self
        }
        /// <p>The notification whose subscriber you want to delete.</p>
        pub fn set_notification(mut self, input: std::option::Option<crate::model::Notification>) -> Self {
            self.notification = input; self
        }
        /// <p>The subscriber that you want to delete.</p>
        pub fn subscriber(mut self, input: crate::model::Subscriber) -> Self {
            self.subscriber = Some(input);
            self
        }
        /// <p>The subscriber that you want to delete.</p>
        pub fn set_subscriber(mut self, input: std::option::Option<crate::model::Subscriber>) -> Self {
            self.subscriber = input; self
        }
        /// Consumes the builder and constructs a [`DeleteSubscriberInput`](crate::input::DeleteSubscriberInput).
        pub fn build(self) -> Result<crate::input::DeleteSubscriberInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DeleteSubscriberInput {
                    account_id: self.account_id
                    ,
                    budget_name: self.budget_name
                    ,
                    notification: self.notification
                    ,
                    subscriber: self.subscriber
                    ,
                }
            )
        }
    }
    
    
}
impl DeleteSubscriberInput {
    /// Consumes the builder and constructs an Operation<[`DeleteSubscriber`](crate::operation::DeleteSubscriber)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DeleteSubscriber, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::DeleteSubscriberInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DeleteSubscriberInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/x-amz-json-1.1");
            builder = aws_smithy_http::header::set_request_header_if_absent(
                                builder,
                                http::header::HeaderName::from_static("x-amz-target"),
                                "AWSBudgetServiceGateway.DeleteSubscriber"
                            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_delete_subscriber(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DeleteSubscriber::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DeleteSubscriber", "budgets"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteSubscriberInput`](crate::input::DeleteSubscriberInput).
    pub fn builder() -> crate::input::delete_subscriber_input::Builder {
        crate::input::delete_subscriber_input::Builder::default()
    }
}

/// See [`DescribeBudgetInput`](crate::input::DescribeBudgetInput).
pub mod describe_budget_input {
    
    /// A builder for [`DescribeBudgetInput`](crate::input::DescribeBudgetInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) budget_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The <code>accountId</code> that is associated with the budget that you want a description of.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The <code>accountId</code> that is associated with the budget that you want a description of.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input; self
        }
        /// <p>The name of the budget that you want a description of.</p>
        pub fn budget_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.budget_name = Some(input.into());
            self
        }
        /// <p>The name of the budget that you want a description of.</p>
        pub fn set_budget_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.budget_name = input; self
        }
        /// Consumes the builder and constructs a [`DescribeBudgetInput`](crate::input::DescribeBudgetInput).
        pub fn build(self) -> Result<crate::input::DescribeBudgetInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DescribeBudgetInput {
                    account_id: self.account_id
                    ,
                    budget_name: self.budget_name
                    ,
                }
            )
        }
    }
    
    
}
impl DescribeBudgetInput {
    /// Consumes the builder and constructs an Operation<[`DescribeBudget`](crate::operation::DescribeBudget)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DescribeBudget, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::DescribeBudgetInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DescribeBudgetInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/x-amz-json-1.1");
            builder = aws_smithy_http::header::set_request_header_if_absent(
                                builder,
                                http::header::HeaderName::from_static("x-amz-target"),
                                "AWSBudgetServiceGateway.DescribeBudget"
                            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_describe_budget(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DescribeBudget::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DescribeBudget", "budgets"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DescribeBudgetInput`](crate::input::DescribeBudgetInput).
    pub fn builder() -> crate::input::describe_budget_input::Builder {
        crate::input::describe_budget_input::Builder::default()
    }
}

/// See [`DescribeBudgetActionInput`](crate::input::DescribeBudgetActionInput).
pub mod describe_budget_action_input {
    
    /// A builder for [`DescribeBudgetActionInput`](crate::input::DescribeBudgetActionInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) budget_name: std::option::Option<std::string::String>,
        pub(crate) action_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The account ID of the user. It's a 12-digit number.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The account ID of the user. It's a 12-digit number.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input; self
        }
        /// <p> A string that represents the budget name. The ":" and "\" characters aren't allowed.</p>
        pub fn budget_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.budget_name = Some(input.into());
            self
        }
        /// <p> A string that represents the budget name. The ":" and "\" characters aren't allowed.</p>
        pub fn set_budget_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.budget_name = input; self
        }
        /// <p> A system-generated universally unique identifier (UUID) for the action. </p>
        pub fn action_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.action_id = Some(input.into());
            self
        }
        /// <p> A system-generated universally unique identifier (UUID) for the action. </p>
        pub fn set_action_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.action_id = input; self
        }
        /// Consumes the builder and constructs a [`DescribeBudgetActionInput`](crate::input::DescribeBudgetActionInput).
        pub fn build(self) -> Result<crate::input::DescribeBudgetActionInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DescribeBudgetActionInput {
                    account_id: self.account_id
                    ,
                    budget_name: self.budget_name
                    ,
                    action_id: self.action_id
                    ,
                }
            )
        }
    }
    
    
}
impl DescribeBudgetActionInput {
    /// Consumes the builder and constructs an Operation<[`DescribeBudgetAction`](crate::operation::DescribeBudgetAction)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DescribeBudgetAction, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::DescribeBudgetActionInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DescribeBudgetActionInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/x-amz-json-1.1");
            builder = aws_smithy_http::header::set_request_header_if_absent(
                                builder,
                                http::header::HeaderName::from_static("x-amz-target"),
                                "AWSBudgetServiceGateway.DescribeBudgetAction"
                            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_describe_budget_action(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DescribeBudgetAction::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DescribeBudgetAction", "budgets"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DescribeBudgetActionInput`](crate::input::DescribeBudgetActionInput).
    pub fn builder() -> crate::input::describe_budget_action_input::Builder {
        crate::input::describe_budget_action_input::Builder::default()
    }
}

/// See [`DescribeBudgetActionHistoriesInput`](crate::input::DescribeBudgetActionHistoriesInput).
pub mod describe_budget_action_histories_input {
    
    /// A builder for [`DescribeBudgetActionHistoriesInput`](crate::input::DescribeBudgetActionHistoriesInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) budget_name: std::option::Option<std::string::String>,
        pub(crate) action_id: std::option::Option<std::string::String>,
        pub(crate) time_period: std::option::Option<crate::model::TimePeriod>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The account ID of the user. It's a 12-digit number.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The account ID of the user. It's a 12-digit number.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input; self
        }
        /// <p> A string that represents the budget name. The ":" and "\" characters aren't allowed.</p>
        pub fn budget_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.budget_name = Some(input.into());
            self
        }
        /// <p> A string that represents the budget name. The ":" and "\" characters aren't allowed.</p>
        pub fn set_budget_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.budget_name = input; self
        }
        /// <p> A system-generated universally unique identifier (UUID) for the action. </p>
        pub fn action_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.action_id = Some(input.into());
            self
        }
        /// <p> A system-generated universally unique identifier (UUID) for the action. </p>
        pub fn set_action_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.action_id = input; self
        }
        /// <p>The period of time that's covered by a budget. The period has a start date and an end date. The start date must come before the end date. There are no restrictions on the end date. </p>
        pub fn time_period(mut self, input: crate::model::TimePeriod) -> Self {
            self.time_period = Some(input);
            self
        }
        /// <p>The period of time that's covered by a budget. The period has a start date and an end date. The start date must come before the end date. There are no restrictions on the end date. </p>
        pub fn set_time_period(mut self, input: std::option::Option<crate::model::TimePeriod>) -> Self {
            self.time_period = input; self
        }
        /// <p> An integer that represents how many entries a paginated response contains. The maximum is 100.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p> An integer that represents how many entries a paginated response contains. The maximum is 100.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// <p> A generic string.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p> A generic string.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// Consumes the builder and constructs a [`DescribeBudgetActionHistoriesInput`](crate::input::DescribeBudgetActionHistoriesInput).
        pub fn build(self) -> Result<crate::input::DescribeBudgetActionHistoriesInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DescribeBudgetActionHistoriesInput {
                    account_id: self.account_id
                    ,
                    budget_name: self.budget_name
                    ,
                    action_id: self.action_id
                    ,
                    time_period: self.time_period
                    ,
                    max_results: self.max_results
                    ,
                    next_token: self.next_token
                    ,
                }
            )
        }
    }
    
    
}
impl DescribeBudgetActionHistoriesInput {
    /// Consumes the builder and constructs an Operation<[`DescribeBudgetActionHistories`](crate::operation::DescribeBudgetActionHistories)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DescribeBudgetActionHistories, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::DescribeBudgetActionHistoriesInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DescribeBudgetActionHistoriesInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/x-amz-json-1.1");
            builder = aws_smithy_http::header::set_request_header_if_absent(
                                builder,
                                http::header::HeaderName::from_static("x-amz-target"),
                                "AWSBudgetServiceGateway.DescribeBudgetActionHistories"
                            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_describe_budget_action_histories(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DescribeBudgetActionHistories::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DescribeBudgetActionHistories", "budgets"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DescribeBudgetActionHistoriesInput`](crate::input::DescribeBudgetActionHistoriesInput).
    pub fn builder() -> crate::input::describe_budget_action_histories_input::Builder {
        crate::input::describe_budget_action_histories_input::Builder::default()
    }
}

/// See [`DescribeBudgetActionsForAccountInput`](crate::input::DescribeBudgetActionsForAccountInput).
pub mod describe_budget_actions_for_account_input {
    
    /// A builder for [`DescribeBudgetActionsForAccountInput`](crate::input::DescribeBudgetActionsForAccountInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The account ID of the user. It's a 12-digit number.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The account ID of the user. It's a 12-digit number.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input; self
        }
        /// <p> An integer that represents how many entries a paginated response contains. The maximum is 100.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p> An integer that represents how many entries a paginated response contains. The maximum is 100.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// <p> A generic string.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p> A generic string.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// Consumes the builder and constructs a [`DescribeBudgetActionsForAccountInput`](crate::input::DescribeBudgetActionsForAccountInput).
        pub fn build(self) -> Result<crate::input::DescribeBudgetActionsForAccountInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DescribeBudgetActionsForAccountInput {
                    account_id: self.account_id
                    ,
                    max_results: self.max_results
                    ,
                    next_token: self.next_token
                    ,
                }
            )
        }
    }
    
    
}
impl DescribeBudgetActionsForAccountInput {
    /// Consumes the builder and constructs an Operation<[`DescribeBudgetActionsForAccount`](crate::operation::DescribeBudgetActionsForAccount)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DescribeBudgetActionsForAccount, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::DescribeBudgetActionsForAccountInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DescribeBudgetActionsForAccountInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/x-amz-json-1.1");
            builder = aws_smithy_http::header::set_request_header_if_absent(
                                builder,
                                http::header::HeaderName::from_static("x-amz-target"),
                                "AWSBudgetServiceGateway.DescribeBudgetActionsForAccount"
                            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_describe_budget_actions_for_account(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DescribeBudgetActionsForAccount::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DescribeBudgetActionsForAccount", "budgets"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DescribeBudgetActionsForAccountInput`](crate::input::DescribeBudgetActionsForAccountInput).
    pub fn builder() -> crate::input::describe_budget_actions_for_account_input::Builder {
        crate::input::describe_budget_actions_for_account_input::Builder::default()
    }
}

/// See [`DescribeBudgetActionsForBudgetInput`](crate::input::DescribeBudgetActionsForBudgetInput).
pub mod describe_budget_actions_for_budget_input {
    
    /// A builder for [`DescribeBudgetActionsForBudgetInput`](crate::input::DescribeBudgetActionsForBudgetInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) budget_name: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The account ID of the user. It's a 12-digit number.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The account ID of the user. It's a 12-digit number.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input; self
        }
        /// <p> A string that represents the budget name. The ":" and "\" characters aren't allowed.</p>
        pub fn budget_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.budget_name = Some(input.into());
            self
        }
        /// <p> A string that represents the budget name. The ":" and "\" characters aren't allowed.</p>
        pub fn set_budget_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.budget_name = input; self
        }
        /// <p> An integer that represents how many entries a paginated response contains. The maximum is 100.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p> An integer that represents how many entries a paginated response contains. The maximum is 100.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// <p> A generic string.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p> A generic string.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// Consumes the builder and constructs a [`DescribeBudgetActionsForBudgetInput`](crate::input::DescribeBudgetActionsForBudgetInput).
        pub fn build(self) -> Result<crate::input::DescribeBudgetActionsForBudgetInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DescribeBudgetActionsForBudgetInput {
                    account_id: self.account_id
                    ,
                    budget_name: self.budget_name
                    ,
                    max_results: self.max_results
                    ,
                    next_token: self.next_token
                    ,
                }
            )
        }
    }
    
    
}
impl DescribeBudgetActionsForBudgetInput {
    /// Consumes the builder and constructs an Operation<[`DescribeBudgetActionsForBudget`](crate::operation::DescribeBudgetActionsForBudget)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DescribeBudgetActionsForBudget, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::DescribeBudgetActionsForBudgetInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DescribeBudgetActionsForBudgetInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/x-amz-json-1.1");
            builder = aws_smithy_http::header::set_request_header_if_absent(
                                builder,
                                http::header::HeaderName::from_static("x-amz-target"),
                                "AWSBudgetServiceGateway.DescribeBudgetActionsForBudget"
                            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_describe_budget_actions_for_budget(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DescribeBudgetActionsForBudget::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DescribeBudgetActionsForBudget", "budgets"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DescribeBudgetActionsForBudgetInput`](crate::input::DescribeBudgetActionsForBudgetInput).
    pub fn builder() -> crate::input::describe_budget_actions_for_budget_input::Builder {
        crate::input::describe_budget_actions_for_budget_input::Builder::default()
    }
}

/// See [`DescribeBudgetNotificationsForAccountInput`](crate::input::DescribeBudgetNotificationsForAccountInput).
pub mod describe_budget_notifications_for_account_input {
    
    /// A builder for [`DescribeBudgetNotificationsForAccountInput`](crate::input::DescribeBudgetNotificationsForAccountInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The account ID of the user. It's a 12-digit number.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The account ID of the user. It's a 12-digit number.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input; self
        }
        /// <p> An integer that shows how many budget name entries a paginated response contains. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p> An integer that shows how many budget name entries a paginated response contains. </p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// <p> A generic string.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p> A generic string.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// Consumes the builder and constructs a [`DescribeBudgetNotificationsForAccountInput`](crate::input::DescribeBudgetNotificationsForAccountInput).
        pub fn build(self) -> Result<crate::input::DescribeBudgetNotificationsForAccountInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DescribeBudgetNotificationsForAccountInput {
                    account_id: self.account_id
                    ,
                    max_results: self.max_results
                    ,
                    next_token: self.next_token
                    ,
                }
            )
        }
    }
    
    
}
impl DescribeBudgetNotificationsForAccountInput {
    /// Consumes the builder and constructs an Operation<[`DescribeBudgetNotificationsForAccount`](crate::operation::DescribeBudgetNotificationsForAccount)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DescribeBudgetNotificationsForAccount, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::DescribeBudgetNotificationsForAccountInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DescribeBudgetNotificationsForAccountInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/x-amz-json-1.1");
            builder = aws_smithy_http::header::set_request_header_if_absent(
                                builder,
                                http::header::HeaderName::from_static("x-amz-target"),
                                "AWSBudgetServiceGateway.DescribeBudgetNotificationsForAccount"
                            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_describe_budget_notifications_for_account(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DescribeBudgetNotificationsForAccount::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DescribeBudgetNotificationsForAccount", "budgets"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DescribeBudgetNotificationsForAccountInput`](crate::input::DescribeBudgetNotificationsForAccountInput).
    pub fn builder() -> crate::input::describe_budget_notifications_for_account_input::Builder {
        crate::input::describe_budget_notifications_for_account_input::Builder::default()
    }
}

/// See [`DescribeBudgetPerformanceHistoryInput`](crate::input::DescribeBudgetPerformanceHistoryInput).
pub mod describe_budget_performance_history_input {
    
    /// A builder for [`DescribeBudgetPerformanceHistoryInput`](crate::input::DescribeBudgetPerformanceHistoryInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) budget_name: std::option::Option<std::string::String>,
        pub(crate) time_period: std::option::Option<crate::model::TimePeriod>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The account ID of the user. It's a 12-digit number.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The account ID of the user. It's a 12-digit number.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input; self
        }
        /// <p> A string that represents the budget name. The ":" and "\" characters aren't allowed.</p>
        pub fn budget_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.budget_name = Some(input.into());
            self
        }
        /// <p> A string that represents the budget name. The ":" and "\" characters aren't allowed.</p>
        pub fn set_budget_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.budget_name = input; self
        }
        /// <p>Retrieves how often the budget went into an <code>ALARM</code> state for the specified time period.</p>
        pub fn time_period(mut self, input: crate::model::TimePeriod) -> Self {
            self.time_period = Some(input);
            self
        }
        /// <p>Retrieves how often the budget went into an <code>ALARM</code> state for the specified time period.</p>
        pub fn set_time_period(mut self, input: std::option::Option<crate::model::TimePeriod>) -> Self {
            self.time_period = input; self
        }
        /// <p> An integer that represents how many entries a paginated response contains. The maximum is 100.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p> An integer that represents how many entries a paginated response contains. The maximum is 100.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// <p> A generic string.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p> A generic string.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// Consumes the builder and constructs a [`DescribeBudgetPerformanceHistoryInput`](crate::input::DescribeBudgetPerformanceHistoryInput).
        pub fn build(self) -> Result<crate::input::DescribeBudgetPerformanceHistoryInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DescribeBudgetPerformanceHistoryInput {
                    account_id: self.account_id
                    ,
                    budget_name: self.budget_name
                    ,
                    time_period: self.time_period
                    ,
                    max_results: self.max_results
                    ,
                    next_token: self.next_token
                    ,
                }
            )
        }
    }
    
    
}
impl DescribeBudgetPerformanceHistoryInput {
    /// Consumes the builder and constructs an Operation<[`DescribeBudgetPerformanceHistory`](crate::operation::DescribeBudgetPerformanceHistory)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DescribeBudgetPerformanceHistory, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::DescribeBudgetPerformanceHistoryInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DescribeBudgetPerformanceHistoryInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/x-amz-json-1.1");
            builder = aws_smithy_http::header::set_request_header_if_absent(
                                builder,
                                http::header::HeaderName::from_static("x-amz-target"),
                                "AWSBudgetServiceGateway.DescribeBudgetPerformanceHistory"
                            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_describe_budget_performance_history(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DescribeBudgetPerformanceHistory::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DescribeBudgetPerformanceHistory", "budgets"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DescribeBudgetPerformanceHistoryInput`](crate::input::DescribeBudgetPerformanceHistoryInput).
    pub fn builder() -> crate::input::describe_budget_performance_history_input::Builder {
        crate::input::describe_budget_performance_history_input::Builder::default()
    }
}

/// See [`DescribeBudgetsInput`](crate::input::DescribeBudgetsInput).
pub mod describe_budgets_input {
    
    /// A builder for [`DescribeBudgetsInput`](crate::input::DescribeBudgetsInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The <code>accountId</code> that is associated with the budgets that you want descriptions of.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The <code>accountId</code> that is associated with the budgets that you want descriptions of.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input; self
        }
        /// <p>An optional integer that represents how many entries a paginated response contains. The maximum is 100.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>An optional integer that represents how many entries a paginated response contains. The maximum is 100.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// <p>The pagination token that you include in your request to indicate the next set of results that you want to retrieve.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The pagination token that you include in your request to indicate the next set of results that you want to retrieve.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// Consumes the builder and constructs a [`DescribeBudgetsInput`](crate::input::DescribeBudgetsInput).
        pub fn build(self) -> Result<crate::input::DescribeBudgetsInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DescribeBudgetsInput {
                    account_id: self.account_id
                    ,
                    max_results: self.max_results
                    ,
                    next_token: self.next_token
                    ,
                }
            )
        }
    }
    
    
}
impl DescribeBudgetsInput {
    /// Consumes the builder and constructs an Operation<[`DescribeBudgets`](crate::operation::DescribeBudgets)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DescribeBudgets, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::DescribeBudgetsInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DescribeBudgetsInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/x-amz-json-1.1");
            builder = aws_smithy_http::header::set_request_header_if_absent(
                                builder,
                                http::header::HeaderName::from_static("x-amz-target"),
                                "AWSBudgetServiceGateway.DescribeBudgets"
                            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_describe_budgets(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DescribeBudgets::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DescribeBudgets", "budgets"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DescribeBudgetsInput`](crate::input::DescribeBudgetsInput).
    pub fn builder() -> crate::input::describe_budgets_input::Builder {
        crate::input::describe_budgets_input::Builder::default()
    }
}

/// See [`DescribeNotificationsForBudgetInput`](crate::input::DescribeNotificationsForBudgetInput).
pub mod describe_notifications_for_budget_input {
    
    /// A builder for [`DescribeNotificationsForBudgetInput`](crate::input::DescribeNotificationsForBudgetInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) budget_name: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The <code>accountId</code> that is associated with the budget whose notifications you want descriptions of.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The <code>accountId</code> that is associated with the budget whose notifications you want descriptions of.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input; self
        }
        /// <p>The name of the budget whose notifications you want descriptions of.</p>
        pub fn budget_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.budget_name = Some(input.into());
            self
        }
        /// <p>The name of the budget whose notifications you want descriptions of.</p>
        pub fn set_budget_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.budget_name = input; self
        }
        /// <p>An optional integer that represents how many entries a paginated response contains. The maximum is 100.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>An optional integer that represents how many entries a paginated response contains. The maximum is 100.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// <p>The pagination token that you include in your request to indicate the next set of results that you want to retrieve.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The pagination token that you include in your request to indicate the next set of results that you want to retrieve.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// Consumes the builder and constructs a [`DescribeNotificationsForBudgetInput`](crate::input::DescribeNotificationsForBudgetInput).
        pub fn build(self) -> Result<crate::input::DescribeNotificationsForBudgetInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DescribeNotificationsForBudgetInput {
                    account_id: self.account_id
                    ,
                    budget_name: self.budget_name
                    ,
                    max_results: self.max_results
                    ,
                    next_token: self.next_token
                    ,
                }
            )
        }
    }
    
    
}
impl DescribeNotificationsForBudgetInput {
    /// Consumes the builder and constructs an Operation<[`DescribeNotificationsForBudget`](crate::operation::DescribeNotificationsForBudget)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DescribeNotificationsForBudget, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::DescribeNotificationsForBudgetInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DescribeNotificationsForBudgetInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/x-amz-json-1.1");
            builder = aws_smithy_http::header::set_request_header_if_absent(
                                builder,
                                http::header::HeaderName::from_static("x-amz-target"),
                                "AWSBudgetServiceGateway.DescribeNotificationsForBudget"
                            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_describe_notifications_for_budget(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DescribeNotificationsForBudget::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DescribeNotificationsForBudget", "budgets"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DescribeNotificationsForBudgetInput`](crate::input::DescribeNotificationsForBudgetInput).
    pub fn builder() -> crate::input::describe_notifications_for_budget_input::Builder {
        crate::input::describe_notifications_for_budget_input::Builder::default()
    }
}

/// See [`DescribeSubscribersForNotificationInput`](crate::input::DescribeSubscribersForNotificationInput).
pub mod describe_subscribers_for_notification_input {
    
    /// A builder for [`DescribeSubscribersForNotificationInput`](crate::input::DescribeSubscribersForNotificationInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) budget_name: std::option::Option<std::string::String>,
        pub(crate) notification: std::option::Option<crate::model::Notification>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The <code>accountId</code> that is associated with the budget whose subscribers you want descriptions of.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The <code>accountId</code> that is associated with the budget whose subscribers you want descriptions of.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input; self
        }
        /// <p>The name of the budget whose subscribers you want descriptions of.</p>
        pub fn budget_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.budget_name = Some(input.into());
            self
        }
        /// <p>The name of the budget whose subscribers you want descriptions of.</p>
        pub fn set_budget_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.budget_name = input; self
        }
        /// <p>The notification whose subscribers you want to list.</p>
        pub fn notification(mut self, input: crate::model::Notification) -> Self {
            self.notification = Some(input);
            self
        }
        /// <p>The notification whose subscribers you want to list.</p>
        pub fn set_notification(mut self, input: std::option::Option<crate::model::Notification>) -> Self {
            self.notification = input; self
        }
        /// <p>An optional integer that represents how many entries a paginated response contains. The maximum is 100.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>An optional integer that represents how many entries a paginated response contains. The maximum is 100.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// <p>The pagination token that you include in your request to indicate the next set of results that you want to retrieve.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The pagination token that you include in your request to indicate the next set of results that you want to retrieve.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// Consumes the builder and constructs a [`DescribeSubscribersForNotificationInput`](crate::input::DescribeSubscribersForNotificationInput).
        pub fn build(self) -> Result<crate::input::DescribeSubscribersForNotificationInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DescribeSubscribersForNotificationInput {
                    account_id: self.account_id
                    ,
                    budget_name: self.budget_name
                    ,
                    notification: self.notification
                    ,
                    max_results: self.max_results
                    ,
                    next_token: self.next_token
                    ,
                }
            )
        }
    }
    
    
}
impl DescribeSubscribersForNotificationInput {
    /// Consumes the builder and constructs an Operation<[`DescribeSubscribersForNotification`](crate::operation::DescribeSubscribersForNotification)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DescribeSubscribersForNotification, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::DescribeSubscribersForNotificationInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DescribeSubscribersForNotificationInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/x-amz-json-1.1");
            builder = aws_smithy_http::header::set_request_header_if_absent(
                                builder,
                                http::header::HeaderName::from_static("x-amz-target"),
                                "AWSBudgetServiceGateway.DescribeSubscribersForNotification"
                            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_describe_subscribers_for_notification(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DescribeSubscribersForNotification::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DescribeSubscribersForNotification", "budgets"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DescribeSubscribersForNotificationInput`](crate::input::DescribeSubscribersForNotificationInput).
    pub fn builder() -> crate::input::describe_subscribers_for_notification_input::Builder {
        crate::input::describe_subscribers_for_notification_input::Builder::default()
    }
}

/// See [`ExecuteBudgetActionInput`](crate::input::ExecuteBudgetActionInput).
pub mod execute_budget_action_input {
    
    /// A builder for [`ExecuteBudgetActionInput`](crate::input::ExecuteBudgetActionInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) budget_name: std::option::Option<std::string::String>,
        pub(crate) action_id: std::option::Option<std::string::String>,
        pub(crate) execution_type: std::option::Option<crate::model::ExecutionType>,
    }
    impl Builder {
        /// <p>The account ID of the user. It's a 12-digit number.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The account ID of the user. It's a 12-digit number.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input; self
        }
        /// <p> A string that represents the budget name. The ":" and "\" characters aren't allowed.</p>
        pub fn budget_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.budget_name = Some(input.into());
            self
        }
        /// <p> A string that represents the budget name. The ":" and "\" characters aren't allowed.</p>
        pub fn set_budget_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.budget_name = input; self
        }
        /// <p> A system-generated universally unique identifier (UUID) for the action. </p>
        pub fn action_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.action_id = Some(input.into());
            self
        }
        /// <p> A system-generated universally unique identifier (UUID) for the action. </p>
        pub fn set_action_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.action_id = input; self
        }
        /// <p> The type of execution. </p>
        pub fn execution_type(mut self, input: crate::model::ExecutionType) -> Self {
            self.execution_type = Some(input);
            self
        }
        /// <p> The type of execution. </p>
        pub fn set_execution_type(mut self, input: std::option::Option<crate::model::ExecutionType>) -> Self {
            self.execution_type = input; self
        }
        /// Consumes the builder and constructs a [`ExecuteBudgetActionInput`](crate::input::ExecuteBudgetActionInput).
        pub fn build(self) -> Result<crate::input::ExecuteBudgetActionInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ExecuteBudgetActionInput {
                    account_id: self.account_id
                    ,
                    budget_name: self.budget_name
                    ,
                    action_id: self.action_id
                    ,
                    execution_type: self.execution_type
                    ,
                }
            )
        }
    }
    
    
}
impl ExecuteBudgetActionInput {
    /// Consumes the builder and constructs an Operation<[`ExecuteBudgetAction`](crate::operation::ExecuteBudgetAction)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ExecuteBudgetAction, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ExecuteBudgetActionInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ExecuteBudgetActionInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/x-amz-json-1.1");
            builder = aws_smithy_http::header::set_request_header_if_absent(
                                builder,
                                http::header::HeaderName::from_static("x-amz-target"),
                                "AWSBudgetServiceGateway.ExecuteBudgetAction"
                            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_execute_budget_action(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ExecuteBudgetAction::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ExecuteBudgetAction", "budgets"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ExecuteBudgetActionInput`](crate::input::ExecuteBudgetActionInput).
    pub fn builder() -> crate::input::execute_budget_action_input::Builder {
        crate::input::execute_budget_action_input::Builder::default()
    }
}

/// See [`UpdateBudgetInput`](crate::input::UpdateBudgetInput).
pub mod update_budget_input {
    
    /// A builder for [`UpdateBudgetInput`](crate::input::UpdateBudgetInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) new_budget: std::option::Option<crate::model::Budget>,
    }
    impl Builder {
        /// <p>The <code>accountId</code> that is associated with the budget that you want to update.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The <code>accountId</code> that is associated with the budget that you want to update.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input; self
        }
        /// <p>The budget that you want to update your budget to.</p>
        pub fn new_budget(mut self, input: crate::model::Budget) -> Self {
            self.new_budget = Some(input);
            self
        }
        /// <p>The budget that you want to update your budget to.</p>
        pub fn set_new_budget(mut self, input: std::option::Option<crate::model::Budget>) -> Self {
            self.new_budget = input; self
        }
        /// Consumes the builder and constructs a [`UpdateBudgetInput`](crate::input::UpdateBudgetInput).
        pub fn build(self) -> Result<crate::input::UpdateBudgetInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::UpdateBudgetInput {
                    account_id: self.account_id
                    ,
                    new_budget: self.new_budget
                    ,
                }
            )
        }
    }
    
    
}
impl UpdateBudgetInput {
    /// Consumes the builder and constructs an Operation<[`UpdateBudget`](crate::operation::UpdateBudget)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::UpdateBudget, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::UpdateBudgetInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::UpdateBudgetInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/x-amz-json-1.1");
            builder = aws_smithy_http::header::set_request_header_if_absent(
                                builder,
                                http::header::HeaderName::from_static("x-amz-target"),
                                "AWSBudgetServiceGateway.UpdateBudget"
                            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_budget(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::UpdateBudget::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("UpdateBudget", "budgets"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateBudgetInput`](crate::input::UpdateBudgetInput).
    pub fn builder() -> crate::input::update_budget_input::Builder {
        crate::input::update_budget_input::Builder::default()
    }
}

/// See [`UpdateBudgetActionInput`](crate::input::UpdateBudgetActionInput).
pub mod update_budget_action_input {
    
    /// A builder for [`UpdateBudgetActionInput`](crate::input::UpdateBudgetActionInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) budget_name: std::option::Option<std::string::String>,
        pub(crate) action_id: std::option::Option<std::string::String>,
        pub(crate) notification_type: std::option::Option<crate::model::NotificationType>,
        pub(crate) action_threshold: std::option::Option<crate::model::ActionThreshold>,
        pub(crate) definition: std::option::Option<crate::model::Definition>,
        pub(crate) execution_role_arn: std::option::Option<std::string::String>,
        pub(crate) approval_model: std::option::Option<crate::model::ApprovalModel>,
        pub(crate) subscribers: std::option::Option<std::vec::Vec<crate::model::Subscriber>>,
    }
    impl Builder {
        /// <p>The account ID of the user. It's a 12-digit number.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The account ID of the user. It's a 12-digit number.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input; self
        }
        /// <p> A string that represents the budget name. The ":" and "\" characters aren't allowed.</p>
        pub fn budget_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.budget_name = Some(input.into());
            self
        }
        /// <p> A string that represents the budget name. The ":" and "\" characters aren't allowed.</p>
        pub fn set_budget_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.budget_name = input; self
        }
        /// <p> A system-generated universally unique identifier (UUID) for the action. </p>
        pub fn action_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.action_id = Some(input.into());
            self
        }
        /// <p> A system-generated universally unique identifier (UUID) for the action. </p>
        pub fn set_action_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.action_id = input; self
        }
        /// <p> The type of a notification. It must be ACTUAL or FORECASTED.</p>
        pub fn notification_type(mut self, input: crate::model::NotificationType) -> Self {
            self.notification_type = Some(input);
            self
        }
        /// <p> The type of a notification. It must be ACTUAL or FORECASTED.</p>
        pub fn set_notification_type(mut self, input: std::option::Option<crate::model::NotificationType>) -> Self {
            self.notification_type = input; self
        }
        /// <p>The trigger threshold of the action. </p>
        pub fn action_threshold(mut self, input: crate::model::ActionThreshold) -> Self {
            self.action_threshold = Some(input);
            self
        }
        /// <p>The trigger threshold of the action. </p>
        pub fn set_action_threshold(mut self, input: std::option::Option<crate::model::ActionThreshold>) -> Self {
            self.action_threshold = input; self
        }
        /// <p>Specifies all of the type-specific parameters. </p>
        pub fn definition(mut self, input: crate::model::Definition) -> Self {
            self.definition = Some(input);
            self
        }
        /// <p>Specifies all of the type-specific parameters. </p>
        pub fn set_definition(mut self, input: std::option::Option<crate::model::Definition>) -> Self {
            self.definition = input; self
        }
        /// <p> The role passed for action execution and reversion. Roles and actions must be in the same account. </p>
        pub fn execution_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.execution_role_arn = Some(input.into());
            self
        }
        /// <p> The role passed for action execution and reversion. Roles and actions must be in the same account. </p>
        pub fn set_execution_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.execution_role_arn = input; self
        }
        /// <p> This specifies if the action needs manual or automatic approval. </p>
        pub fn approval_model(mut self, input: crate::model::ApprovalModel) -> Self {
            self.approval_model = Some(input);
            self
        }
        /// <p> This specifies if the action needs manual or automatic approval. </p>
        pub fn set_approval_model(mut self, input: std::option::Option<crate::model::ApprovalModel>) -> Self {
            self.approval_model = input; self
        }
        /// Appends an item to `subscribers`.
        ///
        /// To override the contents of this collection use [`set_subscribers`](Self::set_subscribers).
        ///
        /// <p> A list of subscribers.</p>
        pub fn subscribers(mut self, input: crate::model::Subscriber) -> Self {
            let mut v = self.subscribers.unwrap_or_default();
                            v.push(input);
                            self.subscribers = Some(v);
                            self
        }
        /// <p> A list of subscribers.</p>
        pub fn set_subscribers(mut self, input: std::option::Option<std::vec::Vec<crate::model::Subscriber>>) -> Self {
            self.subscribers = input; self
        }
        /// Consumes the builder and constructs a [`UpdateBudgetActionInput`](crate::input::UpdateBudgetActionInput).
        pub fn build(self) -> Result<crate::input::UpdateBudgetActionInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::UpdateBudgetActionInput {
                    account_id: self.account_id
                    ,
                    budget_name: self.budget_name
                    ,
                    action_id: self.action_id
                    ,
                    notification_type: self.notification_type
                    ,
                    action_threshold: self.action_threshold
                    ,
                    definition: self.definition
                    ,
                    execution_role_arn: self.execution_role_arn
                    ,
                    approval_model: self.approval_model
                    ,
                    subscribers: self.subscribers
                    ,
                }
            )
        }
    }
    
    
}
impl UpdateBudgetActionInput {
    /// Consumes the builder and constructs an Operation<[`UpdateBudgetAction`](crate::operation::UpdateBudgetAction)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::UpdateBudgetAction, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::UpdateBudgetActionInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::UpdateBudgetActionInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/x-amz-json-1.1");
            builder = aws_smithy_http::header::set_request_header_if_absent(
                                builder,
                                http::header::HeaderName::from_static("x-amz-target"),
                                "AWSBudgetServiceGateway.UpdateBudgetAction"
                            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_budget_action(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::UpdateBudgetAction::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("UpdateBudgetAction", "budgets"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateBudgetActionInput`](crate::input::UpdateBudgetActionInput).
    pub fn builder() -> crate::input::update_budget_action_input::Builder {
        crate::input::update_budget_action_input::Builder::default()
    }
}

/// See [`UpdateNotificationInput`](crate::input::UpdateNotificationInput).
pub mod update_notification_input {
    
    /// A builder for [`UpdateNotificationInput`](crate::input::UpdateNotificationInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) budget_name: std::option::Option<std::string::String>,
        pub(crate) old_notification: std::option::Option<crate::model::Notification>,
        pub(crate) new_notification: std::option::Option<crate::model::Notification>,
    }
    impl Builder {
        /// <p>The <code>accountId</code> that is associated with the budget whose notification you want to update.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The <code>accountId</code> that is associated with the budget whose notification you want to update.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input; self
        }
        /// <p>The name of the budget whose notification you want to update.</p>
        pub fn budget_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.budget_name = Some(input.into());
            self
        }
        /// <p>The name of the budget whose notification you want to update.</p>
        pub fn set_budget_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.budget_name = input; self
        }
        /// <p>The previous notification that is associated with a budget.</p>
        pub fn old_notification(mut self, input: crate::model::Notification) -> Self {
            self.old_notification = Some(input);
            self
        }
        /// <p>The previous notification that is associated with a budget.</p>
        pub fn set_old_notification(mut self, input: std::option::Option<crate::model::Notification>) -> Self {
            self.old_notification = input; self
        }
        /// <p>The updated notification to be associated with a budget.</p>
        pub fn new_notification(mut self, input: crate::model::Notification) -> Self {
            self.new_notification = Some(input);
            self
        }
        /// <p>The updated notification to be associated with a budget.</p>
        pub fn set_new_notification(mut self, input: std::option::Option<crate::model::Notification>) -> Self {
            self.new_notification = input; self
        }
        /// Consumes the builder and constructs a [`UpdateNotificationInput`](crate::input::UpdateNotificationInput).
        pub fn build(self) -> Result<crate::input::UpdateNotificationInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::UpdateNotificationInput {
                    account_id: self.account_id
                    ,
                    budget_name: self.budget_name
                    ,
                    old_notification: self.old_notification
                    ,
                    new_notification: self.new_notification
                    ,
                }
            )
        }
    }
    
    
}
impl UpdateNotificationInput {
    /// Consumes the builder and constructs an Operation<[`UpdateNotification`](crate::operation::UpdateNotification)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::UpdateNotification, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::UpdateNotificationInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::UpdateNotificationInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/x-amz-json-1.1");
            builder = aws_smithy_http::header::set_request_header_if_absent(
                                builder,
                                http::header::HeaderName::from_static("x-amz-target"),
                                "AWSBudgetServiceGateway.UpdateNotification"
                            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_notification(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::UpdateNotification::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("UpdateNotification", "budgets"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateNotificationInput`](crate::input::UpdateNotificationInput).
    pub fn builder() -> crate::input::update_notification_input::Builder {
        crate::input::update_notification_input::Builder::default()
    }
}

/// See [`UpdateSubscriberInput`](crate::input::UpdateSubscriberInput).
pub mod update_subscriber_input {
    
    /// A builder for [`UpdateSubscriberInput`](crate::input::UpdateSubscriberInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) budget_name: std::option::Option<std::string::String>,
        pub(crate) notification: std::option::Option<crate::model::Notification>,
        pub(crate) old_subscriber: std::option::Option<crate::model::Subscriber>,
        pub(crate) new_subscriber: std::option::Option<crate::model::Subscriber>,
    }
    impl Builder {
        /// <p>The <code>accountId</code> that is associated with the budget whose subscriber you want to update.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The <code>accountId</code> that is associated with the budget whose subscriber you want to update.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input; self
        }
        /// <p>The name of the budget whose subscriber you want to update.</p>
        pub fn budget_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.budget_name = Some(input.into());
            self
        }
        /// <p>The name of the budget whose subscriber you want to update.</p>
        pub fn set_budget_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.budget_name = input; self
        }
        /// <p>The notification whose subscriber you want to update.</p>
        pub fn notification(mut self, input: crate::model::Notification) -> Self {
            self.notification = Some(input);
            self
        }
        /// <p>The notification whose subscriber you want to update.</p>
        pub fn set_notification(mut self, input: std::option::Option<crate::model::Notification>) -> Self {
            self.notification = input; self
        }
        /// <p>The previous subscriber that is associated with a budget notification.</p>
        pub fn old_subscriber(mut self, input: crate::model::Subscriber) -> Self {
            self.old_subscriber = Some(input);
            self
        }
        /// <p>The previous subscriber that is associated with a budget notification.</p>
        pub fn set_old_subscriber(mut self, input: std::option::Option<crate::model::Subscriber>) -> Self {
            self.old_subscriber = input; self
        }
        /// <p>The updated subscriber that is associated with a budget notification.</p>
        pub fn new_subscriber(mut self, input: crate::model::Subscriber) -> Self {
            self.new_subscriber = Some(input);
            self
        }
        /// <p>The updated subscriber that is associated with a budget notification.</p>
        pub fn set_new_subscriber(mut self, input: std::option::Option<crate::model::Subscriber>) -> Self {
            self.new_subscriber = input; self
        }
        /// Consumes the builder and constructs a [`UpdateSubscriberInput`](crate::input::UpdateSubscriberInput).
        pub fn build(self) -> Result<crate::input::UpdateSubscriberInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::UpdateSubscriberInput {
                    account_id: self.account_id
                    ,
                    budget_name: self.budget_name
                    ,
                    notification: self.notification
                    ,
                    old_subscriber: self.old_subscriber
                    ,
                    new_subscriber: self.new_subscriber
                    ,
                }
            )
        }
    }
    
    
}
impl UpdateSubscriberInput {
    /// Consumes the builder and constructs an Operation<[`UpdateSubscriber`](crate::operation::UpdateSubscriber)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::UpdateSubscriber, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::UpdateSubscriberInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::UpdateSubscriberInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/x-amz-json-1.1");
            builder = aws_smithy_http::header::set_request_header_if_absent(
                                builder,
                                http::header::HeaderName::from_static("x-amz-target"),
                                "AWSBudgetServiceGateway.UpdateSubscriber"
                            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_subscriber(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::UpdateSubscriber::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("UpdateSubscriber", "budgets"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateSubscriberInput`](crate::input::UpdateSubscriberInput).
    pub fn builder() -> crate::input::update_subscriber_input::Builder {
        crate::input::update_subscriber_input::Builder::default()
    }
}

/// <p> Request of UpdateSubscriber </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateSubscriberInput  {
    /// <p>The <code>accountId</code> that is associated with the budget whose subscriber you want to update.</p>
    #[doc(hidden)]
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The name of the budget whose subscriber you want to update.</p>
    #[doc(hidden)]
    pub budget_name: std::option::Option<std::string::String>,
    /// <p>The notification whose subscriber you want to update.</p>
    #[doc(hidden)]
    pub notification: std::option::Option<crate::model::Notification>,
    /// <p>The previous subscriber that is associated with a budget notification.</p>
    #[doc(hidden)]
    pub old_subscriber: std::option::Option<crate::model::Subscriber>,
    /// <p>The updated subscriber that is associated with a budget notification.</p>
    #[doc(hidden)]
    pub new_subscriber: std::option::Option<crate::model::Subscriber>,
}
impl UpdateSubscriberInput {
    /// <p>The <code>accountId</code> that is associated with the budget whose subscriber you want to update.</p>
    pub fn account_id(&self) -> std::option::Option<& str> {
        self.account_id.as_deref()
    }
    /// <p>The name of the budget whose subscriber you want to update.</p>
    pub fn budget_name(&self) -> std::option::Option<& str> {
        self.budget_name.as_deref()
    }
    /// <p>The notification whose subscriber you want to update.</p>
    pub fn notification(&self) -> std::option::Option<& crate::model::Notification> {
        self.notification.as_ref()
    }
    /// <p>The previous subscriber that is associated with a budget notification.</p>
    pub fn old_subscriber(&self) -> std::option::Option<& crate::model::Subscriber> {
        self.old_subscriber.as_ref()
    }
    /// <p>The updated subscriber that is associated with a budget notification.</p>
    pub fn new_subscriber(&self) -> std::option::Option<& crate::model::Subscriber> {
        self.new_subscriber.as_ref()
    }
}

/// <p> Request of UpdateNotification </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateNotificationInput  {
    /// <p>The <code>accountId</code> that is associated with the budget whose notification you want to update.</p>
    #[doc(hidden)]
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The name of the budget whose notification you want to update.</p>
    #[doc(hidden)]
    pub budget_name: std::option::Option<std::string::String>,
    /// <p>The previous notification that is associated with a budget.</p>
    #[doc(hidden)]
    pub old_notification: std::option::Option<crate::model::Notification>,
    /// <p>The updated notification to be associated with a budget.</p>
    #[doc(hidden)]
    pub new_notification: std::option::Option<crate::model::Notification>,
}
impl UpdateNotificationInput {
    /// <p>The <code>accountId</code> that is associated with the budget whose notification you want to update.</p>
    pub fn account_id(&self) -> std::option::Option<& str> {
        self.account_id.as_deref()
    }
    /// <p>The name of the budget whose notification you want to update.</p>
    pub fn budget_name(&self) -> std::option::Option<& str> {
        self.budget_name.as_deref()
    }
    /// <p>The previous notification that is associated with a budget.</p>
    pub fn old_notification(&self) -> std::option::Option<& crate::model::Notification> {
        self.old_notification.as_ref()
    }
    /// <p>The updated notification to be associated with a budget.</p>
    pub fn new_notification(&self) -> std::option::Option<& crate::model::Notification> {
        self.new_notification.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateBudgetActionInput  {
    /// <p>The account ID of the user. It's a 12-digit number.</p>
    #[doc(hidden)]
    pub account_id: std::option::Option<std::string::String>,
    /// <p> A string that represents the budget name. The ":" and "\" characters aren't allowed.</p>
    #[doc(hidden)]
    pub budget_name: std::option::Option<std::string::String>,
    /// <p> A system-generated universally unique identifier (UUID) for the action. </p>
    #[doc(hidden)]
    pub action_id: std::option::Option<std::string::String>,
    /// <p> The type of a notification. It must be ACTUAL or FORECASTED.</p>
    #[doc(hidden)]
    pub notification_type: std::option::Option<crate::model::NotificationType>,
    /// <p>The trigger threshold of the action. </p>
    #[doc(hidden)]
    pub action_threshold: std::option::Option<crate::model::ActionThreshold>,
    /// <p>Specifies all of the type-specific parameters. </p>
    #[doc(hidden)]
    pub definition: std::option::Option<crate::model::Definition>,
    /// <p> The role passed for action execution and reversion. Roles and actions must be in the same account. </p>
    #[doc(hidden)]
    pub execution_role_arn: std::option::Option<std::string::String>,
    /// <p> This specifies if the action needs manual or automatic approval. </p>
    #[doc(hidden)]
    pub approval_model: std::option::Option<crate::model::ApprovalModel>,
    /// <p> A list of subscribers.</p>
    #[doc(hidden)]
    pub subscribers: std::option::Option<std::vec::Vec<crate::model::Subscriber>>,
}
impl UpdateBudgetActionInput {
    /// <p>The account ID of the user. It's a 12-digit number.</p>
    pub fn account_id(&self) -> std::option::Option<& str> {
        self.account_id.as_deref()
    }
    /// <p> A string that represents the budget name. The ":" and "\" characters aren't allowed.</p>
    pub fn budget_name(&self) -> std::option::Option<& str> {
        self.budget_name.as_deref()
    }
    /// <p> A system-generated universally unique identifier (UUID) for the action. </p>
    pub fn action_id(&self) -> std::option::Option<& str> {
        self.action_id.as_deref()
    }
    /// <p> The type of a notification. It must be ACTUAL or FORECASTED.</p>
    pub fn notification_type(&self) -> std::option::Option<& crate::model::NotificationType> {
        self.notification_type.as_ref()
    }
    /// <p>The trigger threshold of the action. </p>
    pub fn action_threshold(&self) -> std::option::Option<& crate::model::ActionThreshold> {
        self.action_threshold.as_ref()
    }
    /// <p>Specifies all of the type-specific parameters. </p>
    pub fn definition(&self) -> std::option::Option<& crate::model::Definition> {
        self.definition.as_ref()
    }
    /// <p> The role passed for action execution and reversion. Roles and actions must be in the same account. </p>
    pub fn execution_role_arn(&self) -> std::option::Option<& str> {
        self.execution_role_arn.as_deref()
    }
    /// <p> This specifies if the action needs manual or automatic approval. </p>
    pub fn approval_model(&self) -> std::option::Option<& crate::model::ApprovalModel> {
        self.approval_model.as_ref()
    }
    /// <p> A list of subscribers.</p>
    pub fn subscribers(&self) -> std::option::Option<& [crate::model::Subscriber]> {
        self.subscribers.as_deref()
    }
}

/// <p> Request of UpdateBudget </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateBudgetInput  {
    /// <p>The <code>accountId</code> that is associated with the budget that you want to update.</p>
    #[doc(hidden)]
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The budget that you want to update your budget to.</p>
    #[doc(hidden)]
    pub new_budget: std::option::Option<crate::model::Budget>,
}
impl UpdateBudgetInput {
    /// <p>The <code>accountId</code> that is associated with the budget that you want to update.</p>
    pub fn account_id(&self) -> std::option::Option<& str> {
        self.account_id.as_deref()
    }
    /// <p>The budget that you want to update your budget to.</p>
    pub fn new_budget(&self) -> std::option::Option<& crate::model::Budget> {
        self.new_budget.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ExecuteBudgetActionInput  {
    /// <p>The account ID of the user. It's a 12-digit number.</p>
    #[doc(hidden)]
    pub account_id: std::option::Option<std::string::String>,
    /// <p> A string that represents the budget name. The ":" and "\" characters aren't allowed.</p>
    #[doc(hidden)]
    pub budget_name: std::option::Option<std::string::String>,
    /// <p> A system-generated universally unique identifier (UUID) for the action. </p>
    #[doc(hidden)]
    pub action_id: std::option::Option<std::string::String>,
    /// <p> The type of execution. </p>
    #[doc(hidden)]
    pub execution_type: std::option::Option<crate::model::ExecutionType>,
}
impl ExecuteBudgetActionInput {
    /// <p>The account ID of the user. It's a 12-digit number.</p>
    pub fn account_id(&self) -> std::option::Option<& str> {
        self.account_id.as_deref()
    }
    /// <p> A string that represents the budget name. The ":" and "\" characters aren't allowed.</p>
    pub fn budget_name(&self) -> std::option::Option<& str> {
        self.budget_name.as_deref()
    }
    /// <p> A system-generated universally unique identifier (UUID) for the action. </p>
    pub fn action_id(&self) -> std::option::Option<& str> {
        self.action_id.as_deref()
    }
    /// <p> The type of execution. </p>
    pub fn execution_type(&self) -> std::option::Option<& crate::model::ExecutionType> {
        self.execution_type.as_ref()
    }
}

/// <p> Request of DescribeSubscribersForNotification </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DescribeSubscribersForNotificationInput  {
    /// <p>The <code>accountId</code> that is associated with the budget whose subscribers you want descriptions of.</p>
    #[doc(hidden)]
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The name of the budget whose subscribers you want descriptions of.</p>
    #[doc(hidden)]
    pub budget_name: std::option::Option<std::string::String>,
    /// <p>The notification whose subscribers you want to list.</p>
    #[doc(hidden)]
    pub notification: std::option::Option<crate::model::Notification>,
    /// <p>An optional integer that represents how many entries a paginated response contains. The maximum is 100.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>The pagination token that you include in your request to indicate the next set of results that you want to retrieve.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl DescribeSubscribersForNotificationInput {
    /// <p>The <code>accountId</code> that is associated with the budget whose subscribers you want descriptions of.</p>
    pub fn account_id(&self) -> std::option::Option<& str> {
        self.account_id.as_deref()
    }
    /// <p>The name of the budget whose subscribers you want descriptions of.</p>
    pub fn budget_name(&self) -> std::option::Option<& str> {
        self.budget_name.as_deref()
    }
    /// <p>The notification whose subscribers you want to list.</p>
    pub fn notification(&self) -> std::option::Option<& crate::model::Notification> {
        self.notification.as_ref()
    }
    /// <p>An optional integer that represents how many entries a paginated response contains. The maximum is 100.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The pagination token that you include in your request to indicate the next set of results that you want to retrieve.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
}

/// <p> Request of DescribeNotificationsForBudget </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DescribeNotificationsForBudgetInput  {
    /// <p>The <code>accountId</code> that is associated with the budget whose notifications you want descriptions of.</p>
    #[doc(hidden)]
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The name of the budget whose notifications you want descriptions of.</p>
    #[doc(hidden)]
    pub budget_name: std::option::Option<std::string::String>,
    /// <p>An optional integer that represents how many entries a paginated response contains. The maximum is 100.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>The pagination token that you include in your request to indicate the next set of results that you want to retrieve.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl DescribeNotificationsForBudgetInput {
    /// <p>The <code>accountId</code> that is associated with the budget whose notifications you want descriptions of.</p>
    pub fn account_id(&self) -> std::option::Option<& str> {
        self.account_id.as_deref()
    }
    /// <p>The name of the budget whose notifications you want descriptions of.</p>
    pub fn budget_name(&self) -> std::option::Option<& str> {
        self.budget_name.as_deref()
    }
    /// <p>An optional integer that represents how many entries a paginated response contains. The maximum is 100.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The pagination token that you include in your request to indicate the next set of results that you want to retrieve.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
}

/// <p> Request of DescribeBudgets </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DescribeBudgetsInput  {
    /// <p>The <code>accountId</code> that is associated with the budgets that you want descriptions of.</p>
    #[doc(hidden)]
    pub account_id: std::option::Option<std::string::String>,
    /// <p>An optional integer that represents how many entries a paginated response contains. The maximum is 100.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>The pagination token that you include in your request to indicate the next set of results that you want to retrieve.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl DescribeBudgetsInput {
    /// <p>The <code>accountId</code> that is associated with the budgets that you want descriptions of.</p>
    pub fn account_id(&self) -> std::option::Option<& str> {
        self.account_id.as_deref()
    }
    /// <p>An optional integer that represents how many entries a paginated response contains. The maximum is 100.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The pagination token that you include in your request to indicate the next set of results that you want to retrieve.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DescribeBudgetPerformanceHistoryInput  {
    /// <p>The account ID of the user. It's a 12-digit number.</p>
    #[doc(hidden)]
    pub account_id: std::option::Option<std::string::String>,
    /// <p> A string that represents the budget name. The ":" and "\" characters aren't allowed.</p>
    #[doc(hidden)]
    pub budget_name: std::option::Option<std::string::String>,
    /// <p>Retrieves how often the budget went into an <code>ALARM</code> state for the specified time period.</p>
    #[doc(hidden)]
    pub time_period: std::option::Option<crate::model::TimePeriod>,
    /// <p> An integer that represents how many entries a paginated response contains. The maximum is 100.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p> A generic string.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl DescribeBudgetPerformanceHistoryInput {
    /// <p>The account ID of the user. It's a 12-digit number.</p>
    pub fn account_id(&self) -> std::option::Option<& str> {
        self.account_id.as_deref()
    }
    /// <p> A string that represents the budget name. The ":" and "\" characters aren't allowed.</p>
    pub fn budget_name(&self) -> std::option::Option<& str> {
        self.budget_name.as_deref()
    }
    /// <p>Retrieves how often the budget went into an <code>ALARM</code> state for the specified time period.</p>
    pub fn time_period(&self) -> std::option::Option<& crate::model::TimePeriod> {
        self.time_period.as_ref()
    }
    /// <p> An integer that represents how many entries a paginated response contains. The maximum is 100.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p> A generic string.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DescribeBudgetNotificationsForAccountInput  {
    /// <p>The account ID of the user. It's a 12-digit number.</p>
    #[doc(hidden)]
    pub account_id: std::option::Option<std::string::String>,
    /// <p> An integer that shows how many budget name entries a paginated response contains. </p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p> A generic string.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl DescribeBudgetNotificationsForAccountInput {
    /// <p>The account ID of the user. It's a 12-digit number.</p>
    pub fn account_id(&self) -> std::option::Option<& str> {
        self.account_id.as_deref()
    }
    /// <p> An integer that shows how many budget name entries a paginated response contains. </p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p> A generic string.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DescribeBudgetActionsForBudgetInput  {
    /// <p>The account ID of the user. It's a 12-digit number.</p>
    #[doc(hidden)]
    pub account_id: std::option::Option<std::string::String>,
    /// <p> A string that represents the budget name. The ":" and "\" characters aren't allowed.</p>
    #[doc(hidden)]
    pub budget_name: std::option::Option<std::string::String>,
    /// <p> An integer that represents how many entries a paginated response contains. The maximum is 100.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p> A generic string.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl DescribeBudgetActionsForBudgetInput {
    /// <p>The account ID of the user. It's a 12-digit number.</p>
    pub fn account_id(&self) -> std::option::Option<& str> {
        self.account_id.as_deref()
    }
    /// <p> A string that represents the budget name. The ":" and "\" characters aren't allowed.</p>
    pub fn budget_name(&self) -> std::option::Option<& str> {
        self.budget_name.as_deref()
    }
    /// <p> An integer that represents how many entries a paginated response contains. The maximum is 100.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p> A generic string.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DescribeBudgetActionsForAccountInput  {
    /// <p>The account ID of the user. It's a 12-digit number.</p>
    #[doc(hidden)]
    pub account_id: std::option::Option<std::string::String>,
    /// <p> An integer that represents how many entries a paginated response contains. The maximum is 100.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p> A generic string.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl DescribeBudgetActionsForAccountInput {
    /// <p>The account ID of the user. It's a 12-digit number.</p>
    pub fn account_id(&self) -> std::option::Option<& str> {
        self.account_id.as_deref()
    }
    /// <p> An integer that represents how many entries a paginated response contains. The maximum is 100.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p> A generic string.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DescribeBudgetActionHistoriesInput  {
    /// <p>The account ID of the user. It's a 12-digit number.</p>
    #[doc(hidden)]
    pub account_id: std::option::Option<std::string::String>,
    /// <p> A string that represents the budget name. The ":" and "\" characters aren't allowed.</p>
    #[doc(hidden)]
    pub budget_name: std::option::Option<std::string::String>,
    /// <p> A system-generated universally unique identifier (UUID) for the action. </p>
    #[doc(hidden)]
    pub action_id: std::option::Option<std::string::String>,
    /// <p>The period of time that's covered by a budget. The period has a start date and an end date. The start date must come before the end date. There are no restrictions on the end date. </p>
    #[doc(hidden)]
    pub time_period: std::option::Option<crate::model::TimePeriod>,
    /// <p> An integer that represents how many entries a paginated response contains. The maximum is 100.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p> A generic string.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl DescribeBudgetActionHistoriesInput {
    /// <p>The account ID of the user. It's a 12-digit number.</p>
    pub fn account_id(&self) -> std::option::Option<& str> {
        self.account_id.as_deref()
    }
    /// <p> A string that represents the budget name. The ":" and "\" characters aren't allowed.</p>
    pub fn budget_name(&self) -> std::option::Option<& str> {
        self.budget_name.as_deref()
    }
    /// <p> A system-generated universally unique identifier (UUID) for the action. </p>
    pub fn action_id(&self) -> std::option::Option<& str> {
        self.action_id.as_deref()
    }
    /// <p>The period of time that's covered by a budget. The period has a start date and an end date. The start date must come before the end date. There are no restrictions on the end date. </p>
    pub fn time_period(&self) -> std::option::Option<& crate::model::TimePeriod> {
        self.time_period.as_ref()
    }
    /// <p> An integer that represents how many entries a paginated response contains. The maximum is 100.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p> A generic string.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DescribeBudgetActionInput  {
    /// <p>The account ID of the user. It's a 12-digit number.</p>
    #[doc(hidden)]
    pub account_id: std::option::Option<std::string::String>,
    /// <p> A string that represents the budget name. The ":" and "\" characters aren't allowed.</p>
    #[doc(hidden)]
    pub budget_name: std::option::Option<std::string::String>,
    /// <p> A system-generated universally unique identifier (UUID) for the action. </p>
    #[doc(hidden)]
    pub action_id: std::option::Option<std::string::String>,
}
impl DescribeBudgetActionInput {
    /// <p>The account ID of the user. It's a 12-digit number.</p>
    pub fn account_id(&self) -> std::option::Option<& str> {
        self.account_id.as_deref()
    }
    /// <p> A string that represents the budget name. The ":" and "\" characters aren't allowed.</p>
    pub fn budget_name(&self) -> std::option::Option<& str> {
        self.budget_name.as_deref()
    }
    /// <p> A system-generated universally unique identifier (UUID) for the action. </p>
    pub fn action_id(&self) -> std::option::Option<& str> {
        self.action_id.as_deref()
    }
}

/// <p> Request of DescribeBudget </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DescribeBudgetInput  {
    /// <p>The <code>accountId</code> that is associated with the budget that you want a description of.</p>
    #[doc(hidden)]
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The name of the budget that you want a description of.</p>
    #[doc(hidden)]
    pub budget_name: std::option::Option<std::string::String>,
}
impl DescribeBudgetInput {
    /// <p>The <code>accountId</code> that is associated with the budget that you want a description of.</p>
    pub fn account_id(&self) -> std::option::Option<& str> {
        self.account_id.as_deref()
    }
    /// <p>The name of the budget that you want a description of.</p>
    pub fn budget_name(&self) -> std::option::Option<& str> {
        self.budget_name.as_deref()
    }
}

/// <p> Request of DeleteSubscriber </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteSubscriberInput  {
    /// <p>The <code>accountId</code> that is associated with the budget whose subscriber you want to delete.</p>
    #[doc(hidden)]
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The name of the budget whose subscriber you want to delete.</p>
    #[doc(hidden)]
    pub budget_name: std::option::Option<std::string::String>,
    /// <p>The notification whose subscriber you want to delete.</p>
    #[doc(hidden)]
    pub notification: std::option::Option<crate::model::Notification>,
    /// <p>The subscriber that you want to delete.</p>
    #[doc(hidden)]
    pub subscriber: std::option::Option<crate::model::Subscriber>,
}
impl DeleteSubscriberInput {
    /// <p>The <code>accountId</code> that is associated with the budget whose subscriber you want to delete.</p>
    pub fn account_id(&self) -> std::option::Option<& str> {
        self.account_id.as_deref()
    }
    /// <p>The name of the budget whose subscriber you want to delete.</p>
    pub fn budget_name(&self) -> std::option::Option<& str> {
        self.budget_name.as_deref()
    }
    /// <p>The notification whose subscriber you want to delete.</p>
    pub fn notification(&self) -> std::option::Option<& crate::model::Notification> {
        self.notification.as_ref()
    }
    /// <p>The subscriber that you want to delete.</p>
    pub fn subscriber(&self) -> std::option::Option<& crate::model::Subscriber> {
        self.subscriber.as_ref()
    }
}

/// <p> Request of DeleteNotification </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteNotificationInput  {
    /// <p>The <code>accountId</code> that is associated with the budget whose notification you want to delete.</p>
    #[doc(hidden)]
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The name of the budget whose notification you want to delete.</p>
    #[doc(hidden)]
    pub budget_name: std::option::Option<std::string::String>,
    /// <p>The notification that you want to delete.</p>
    #[doc(hidden)]
    pub notification: std::option::Option<crate::model::Notification>,
}
impl DeleteNotificationInput {
    /// <p>The <code>accountId</code> that is associated with the budget whose notification you want to delete.</p>
    pub fn account_id(&self) -> std::option::Option<& str> {
        self.account_id.as_deref()
    }
    /// <p>The name of the budget whose notification you want to delete.</p>
    pub fn budget_name(&self) -> std::option::Option<& str> {
        self.budget_name.as_deref()
    }
    /// <p>The notification that you want to delete.</p>
    pub fn notification(&self) -> std::option::Option<& crate::model::Notification> {
        self.notification.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteBudgetActionInput  {
    /// <p>The account ID of the user. It's a 12-digit number.</p>
    #[doc(hidden)]
    pub account_id: std::option::Option<std::string::String>,
    /// <p> A string that represents the budget name. The ":" and "\" characters aren't allowed.</p>
    #[doc(hidden)]
    pub budget_name: std::option::Option<std::string::String>,
    /// <p> A system-generated universally unique identifier (UUID) for the action. </p>
    #[doc(hidden)]
    pub action_id: std::option::Option<std::string::String>,
}
impl DeleteBudgetActionInput {
    /// <p>The account ID of the user. It's a 12-digit number.</p>
    pub fn account_id(&self) -> std::option::Option<& str> {
        self.account_id.as_deref()
    }
    /// <p> A string that represents the budget name. The ":" and "\" characters aren't allowed.</p>
    pub fn budget_name(&self) -> std::option::Option<& str> {
        self.budget_name.as_deref()
    }
    /// <p> A system-generated universally unique identifier (UUID) for the action. </p>
    pub fn action_id(&self) -> std::option::Option<& str> {
        self.action_id.as_deref()
    }
}

/// <p> Request of DeleteBudget </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteBudgetInput  {
    /// <p>The <code>accountId</code> that is associated with the budget that you want to delete.</p>
    #[doc(hidden)]
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The name of the budget that you want to delete.</p>
    #[doc(hidden)]
    pub budget_name: std::option::Option<std::string::String>,
}
impl DeleteBudgetInput {
    /// <p>The <code>accountId</code> that is associated with the budget that you want to delete.</p>
    pub fn account_id(&self) -> std::option::Option<& str> {
        self.account_id.as_deref()
    }
    /// <p>The name of the budget that you want to delete.</p>
    pub fn budget_name(&self) -> std::option::Option<& str> {
        self.budget_name.as_deref()
    }
}

/// <p> Request of CreateSubscriber </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateSubscriberInput  {
    /// <p>The <code>accountId</code> that is associated with the budget that you want to create a subscriber for.</p>
    #[doc(hidden)]
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The name of the budget that you want to subscribe to. Budget names must be unique within an account.</p>
    #[doc(hidden)]
    pub budget_name: std::option::Option<std::string::String>,
    /// <p>The notification that you want to create a subscriber for.</p>
    #[doc(hidden)]
    pub notification: std::option::Option<crate::model::Notification>,
    /// <p>The subscriber that you want to associate with a budget notification.</p>
    #[doc(hidden)]
    pub subscriber: std::option::Option<crate::model::Subscriber>,
}
impl CreateSubscriberInput {
    /// <p>The <code>accountId</code> that is associated with the budget that you want to create a subscriber for.</p>
    pub fn account_id(&self) -> std::option::Option<& str> {
        self.account_id.as_deref()
    }
    /// <p>The name of the budget that you want to subscribe to. Budget names must be unique within an account.</p>
    pub fn budget_name(&self) -> std::option::Option<& str> {
        self.budget_name.as_deref()
    }
    /// <p>The notification that you want to create a subscriber for.</p>
    pub fn notification(&self) -> std::option::Option<& crate::model::Notification> {
        self.notification.as_ref()
    }
    /// <p>The subscriber that you want to associate with a budget notification.</p>
    pub fn subscriber(&self) -> std::option::Option<& crate::model::Subscriber> {
        self.subscriber.as_ref()
    }
}

/// <p> Request of CreateNotification </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateNotificationInput  {
    /// <p>The <code>accountId</code> that is associated with the budget that you want to create a notification for.</p>
    #[doc(hidden)]
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The name of the budget that you want Amazon Web Services to notify you about. Budget names must be unique within an account.</p>
    #[doc(hidden)]
    pub budget_name: std::option::Option<std::string::String>,
    /// <p>The notification that you want to create.</p>
    #[doc(hidden)]
    pub notification: std::option::Option<crate::model::Notification>,
    /// <p>A list of subscribers that you want to associate with the notification. Each notification can have one SNS subscriber and up to 10 email subscribers.</p>
    #[doc(hidden)]
    pub subscribers: std::option::Option<std::vec::Vec<crate::model::Subscriber>>,
}
impl CreateNotificationInput {
    /// <p>The <code>accountId</code> that is associated with the budget that you want to create a notification for.</p>
    pub fn account_id(&self) -> std::option::Option<& str> {
        self.account_id.as_deref()
    }
    /// <p>The name of the budget that you want Amazon Web Services to notify you about. Budget names must be unique within an account.</p>
    pub fn budget_name(&self) -> std::option::Option<& str> {
        self.budget_name.as_deref()
    }
    /// <p>The notification that you want to create.</p>
    pub fn notification(&self) -> std::option::Option<& crate::model::Notification> {
        self.notification.as_ref()
    }
    /// <p>A list of subscribers that you want to associate with the notification. Each notification can have one SNS subscriber and up to 10 email subscribers.</p>
    pub fn subscribers(&self) -> std::option::Option<& [crate::model::Subscriber]> {
        self.subscribers.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateBudgetActionInput  {
    /// <p>The account ID of the user. It's a 12-digit number.</p>
    #[doc(hidden)]
    pub account_id: std::option::Option<std::string::String>,
    /// <p> A string that represents the budget name. The ":" and "\" characters aren't allowed.</p>
    #[doc(hidden)]
    pub budget_name: std::option::Option<std::string::String>,
    /// <p> The type of a notification. It must be ACTUAL or FORECASTED.</p>
    #[doc(hidden)]
    pub notification_type: std::option::Option<crate::model::NotificationType>,
    /// <p> The type of action. This defines the type of tasks that can be carried out by this action. This field also determines the format for definition. </p>
    #[doc(hidden)]
    pub action_type: std::option::Option<crate::model::ActionType>,
    /// <p>The trigger threshold of the action. </p>
    #[doc(hidden)]
    pub action_threshold: std::option::Option<crate::model::ActionThreshold>,
    /// <p>Specifies all of the type-specific parameters. </p>
    #[doc(hidden)]
    pub definition: std::option::Option<crate::model::Definition>,
    /// <p> The role passed for action execution and reversion. Roles and actions must be in the same account. </p>
    #[doc(hidden)]
    pub execution_role_arn: std::option::Option<std::string::String>,
    /// <p> This specifies if the action needs manual or automatic approval. </p>
    #[doc(hidden)]
    pub approval_model: std::option::Option<crate::model::ApprovalModel>,
    /// <p> A list of subscribers.</p>
    #[doc(hidden)]
    pub subscribers: std::option::Option<std::vec::Vec<crate::model::Subscriber>>,
}
impl CreateBudgetActionInput {
    /// <p>The account ID of the user. It's a 12-digit number.</p>
    pub fn account_id(&self) -> std::option::Option<& str> {
        self.account_id.as_deref()
    }
    /// <p> A string that represents the budget name. The ":" and "\" characters aren't allowed.</p>
    pub fn budget_name(&self) -> std::option::Option<& str> {
        self.budget_name.as_deref()
    }
    /// <p> The type of a notification. It must be ACTUAL or FORECASTED.</p>
    pub fn notification_type(&self) -> std::option::Option<& crate::model::NotificationType> {
        self.notification_type.as_ref()
    }
    /// <p> The type of action. This defines the type of tasks that can be carried out by this action. This field also determines the format for definition. </p>
    pub fn action_type(&self) -> std::option::Option<& crate::model::ActionType> {
        self.action_type.as_ref()
    }
    /// <p>The trigger threshold of the action. </p>
    pub fn action_threshold(&self) -> std::option::Option<& crate::model::ActionThreshold> {
        self.action_threshold.as_ref()
    }
    /// <p>Specifies all of the type-specific parameters. </p>
    pub fn definition(&self) -> std::option::Option<& crate::model::Definition> {
        self.definition.as_ref()
    }
    /// <p> The role passed for action execution and reversion. Roles and actions must be in the same account. </p>
    pub fn execution_role_arn(&self) -> std::option::Option<& str> {
        self.execution_role_arn.as_deref()
    }
    /// <p> This specifies if the action needs manual or automatic approval. </p>
    pub fn approval_model(&self) -> std::option::Option<& crate::model::ApprovalModel> {
        self.approval_model.as_ref()
    }
    /// <p> A list of subscribers.</p>
    pub fn subscribers(&self) -> std::option::Option<& [crate::model::Subscriber]> {
        self.subscribers.as_deref()
    }
}

/// <p> Request of CreateBudget </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateBudgetInput  {
    /// <p>The <code>accountId</code> that is associated with the budget.</p>
    #[doc(hidden)]
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The budget object that you want to create.</p>
    #[doc(hidden)]
    pub budget: std::option::Option<crate::model::Budget>,
    /// <p>A notification that you want to associate with a budget. A budget can have up to five notifications, and each notification can have one SNS subscriber and up to 10 email subscribers. If you include notifications and subscribers in your <code>CreateBudget</code> call, Amazon Web Services creates the notifications and subscribers for you.</p>
    #[doc(hidden)]
    pub notifications_with_subscribers: std::option::Option<std::vec::Vec<crate::model::NotificationWithSubscribers>>,
}
impl CreateBudgetInput {
    /// <p>The <code>accountId</code> that is associated with the budget.</p>
    pub fn account_id(&self) -> std::option::Option<& str> {
        self.account_id.as_deref()
    }
    /// <p>The budget object that you want to create.</p>
    pub fn budget(&self) -> std::option::Option<& crate::model::Budget> {
        self.budget.as_ref()
    }
    /// <p>A notification that you want to associate with a budget. A budget can have up to five notifications, and each notification can have one SNS subscriber and up to 10 email subscribers. If you include notifications and subscribers in your <code>CreateBudget</code> call, Amazon Web Services creates the notifications and subscribers for you.</p>
    pub fn notifications_with_subscribers(&self) -> std::option::Option<& [crate::model::NotificationWithSubscribers]> {
        self.notifications_with_subscribers.as_deref()
    }
}

