// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(Debug)]
pub(crate) struct Handle<
    C = smithy_client::erase::DynConnector,
    M = aws_hyper::AwsMiddleware,
    R = smithy_client::retry::Standard,
> {
    client: smithy_client::Client<C, M, R>,
    conf: crate::Config,
}

/// An ergonomic service client for `AWSAcuityReader`.
///
/// This client allows ergonomic access to a `AWSAcuityReader`-shaped service.
/// Each method corresponds to an endpoint defined in the service's Smithy model,
/// and the request and response shapes are auto-generated from that same model.
///
/// # Using a Client
///
/// Once you have a client set up, you can access the service's endpoints
/// by calling the appropriate method on [`Client`]. Each such method
/// returns a request builder for that endpoint, with methods for setting
/// the various fields of the request. Once your request is complete, use
/// the `send` method to send the request. `send` returns a future, which
/// you then have to `.await` to get the service's response.
///
/// [builder pattern]: https://rust-lang.github.io/api-guidelines/type-safety.html#c-builder
/// [SigV4-signed requests]: https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html
#[derive(std::fmt::Debug)]
pub struct Client<
    C = smithy_client::erase::DynConnector,
    M = aws_hyper::AwsMiddleware,
    R = smithy_client::retry::Standard,
> {
    handle: std::sync::Arc<Handle<C, M, R>>,
}

impl<C, M, R> std::clone::Clone for Client<C, M, R> {
    fn clone(&self) -> Self {
        Self {
            handle: self.handle.clone(),
        }
    }
}

#[doc(inline)]
pub use smithy_client::Builder;

impl<C, M, R> From<smithy_client::Client<C, M, R>> for Client<C, M, R> {
    fn from(client: smithy_client::Client<C, M, R>) -> Self {
        Self::with_config(client, crate::Config::builder().build())
    }
}

impl<C, M, R> Client<C, M, R> {
    pub fn with_config(client: smithy_client::Client<C, M, R>, conf: crate::Config) -> Self {
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl<C, M, R> Client<C, M, R>
where
    C: smithy_client::bounds::SmithyConnector,
    M: smithy_client::bounds::SmithyMiddleware<C>,
    R: smithy_client::retry::NewRequestPolicy,
{
    pub fn get_clip(&self) -> fluent_builders::GetClip<C, M, R> {
        fluent_builders::GetClip::new(self.handle.clone())
    }
    pub fn get_dash_streaming_session_url(
        &self,
    ) -> fluent_builders::GetDASHStreamingSessionURL<C, M, R> {
        fluent_builders::GetDASHStreamingSessionURL::new(self.handle.clone())
    }
    pub fn get_hls_streaming_session_url(
        &self,
    ) -> fluent_builders::GetHLSStreamingSessionURL<C, M, R> {
        fluent_builders::GetHLSStreamingSessionURL::new(self.handle.clone())
    }
    pub fn get_media_for_fragment_list(&self) -> fluent_builders::GetMediaForFragmentList<C, M, R> {
        fluent_builders::GetMediaForFragmentList::new(self.handle.clone())
    }
    pub fn list_fragments(&self) -> fluent_builders::ListFragments<C, M, R> {
        fluent_builders::ListFragments::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct GetClip<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_clip_input::Builder,
    }
    impl<C, M, R> GetClip<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetClipOutput,
            smithy_http::result::SdkError<crate::error::GetClipError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetClipInputOperationOutputAlias,
                crate::output::GetClipOutput,
                crate::error::GetClipError,
                crate::input::GetClipInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the stream for which to retrieve the media clip. </p>
        /// <p>You must specify either the StreamName or the StreamARN. </p>
        pub fn stream_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.stream_name(inp);
            self
        }
        pub fn set_stream_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_stream_name(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the stream for which to retrieve the media clip. </p>
        /// <p>You must specify either the StreamName or the StreamARN. </p>
        pub fn stream_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.stream_arn(inp);
            self
        }
        pub fn set_stream_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_stream_arn(input);
            self
        }
        /// <p>The time range of the requested clip and the source of the timestamps.</p>
        pub fn clip_fragment_selector(mut self, inp: crate::model::ClipFragmentSelector) -> Self {
            self.inner = self.inner.clip_fragment_selector(inp);
            self
        }
        pub fn set_clip_fragment_selector(
            mut self,
            input: std::option::Option<crate::model::ClipFragmentSelector>,
        ) -> Self {
            self.inner = self.inner.set_clip_fragment_selector(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetDASHStreamingSessionURL<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_dash_streaming_session_url_input::Builder,
    }
    impl<C, M, R> GetDASHStreamingSessionURL<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetDashStreamingSessionUrlOutput,
            smithy_http::result::SdkError<crate::error::GetDASHStreamingSessionURLError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetDashStreamingSessionUrlInputOperationOutputAlias,
                crate::output::GetDashStreamingSessionUrlOutput,
                crate::error::GetDASHStreamingSessionURLError,
                crate::input::GetDashStreamingSessionUrlInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the stream for which to retrieve the MPEG-DASH manifest URL.</p>
        /// <p>You must specify either the <code>StreamName</code> or the
        /// <code>StreamARN</code>.</p>
        pub fn stream_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.stream_name(inp);
            self
        }
        pub fn set_stream_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_stream_name(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the stream for which to retrieve the MPEG-DASH
        /// manifest URL.</p>
        /// <p>You must specify either the <code>StreamName</code> or the
        /// <code>StreamARN</code>.</p>
        pub fn stream_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.stream_arn(inp);
            self
        }
        pub fn set_stream_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_stream_arn(input);
            self
        }
        /// <p>Whether to retrieve live, live replay, or archived, on-demand data.</p>
        /// <p>Features of the three types of sessions include the following:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>
        /// <code>LIVE</code>
        /// </b>: For sessions of this type, the MPEG-DASH manifest is continually
        /// updated with the latest fragments as they become available. We recommend that
        /// the media player retrieve a new manifest on a one-second interval. When this
        /// type of session is played in a media player, the user interface typically
        /// displays a "live" notification, with no scrubber control for choosing the
        /// position in the playback window to display.</p>
        /// <note>
        /// <p>In <code>LIVE</code> mode, the newest available fragments are included in
        /// an MPEG-DASH manifest, even if there is a gap between fragments (that is, if
        /// a fragment is missing). A gap like this might cause a media player to halt
        /// or cause a jump in playback. In this mode, fragments are not added to the
        /// MPEG-DASH manifest if they are older than the newest fragment in the
        /// playlist. If the missing fragment becomes available after a subsequent
        /// fragment is added to the manifest, the older fragment is not added, and the
        /// gap is not filled.</p>
        /// </note>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>LIVE_REPLAY</code>
        /// </b>: For sessions of this type, the MPEG-DASH manifest is updated
        /// similarly to how it is updated for <code>LIVE</code> mode except that it starts
        /// by including fragments from a given start time. Instead of fragments being added
        /// as they are ingested, fragments are added as the duration of the next fragment
        /// elapses. For example, if the fragments in the session are two seconds long, then
        /// a new fragment is added to the manifest every two seconds. This mode is useful
        /// to be able to start playback from when an event is detected and continue live
        /// streaming media that has not yet been ingested as of the time of the session
        /// creation. This mode is also useful to stream previously archived media without
        /// being limited by the 1,000 fragment limit in the <code>ON_DEMAND</code> mode.
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>ON_DEMAND</code>
        /// </b>: For sessions of this type, the MPEG-DASH manifest contains all the
        /// fragments for the session, up to the number that is specified in
        /// <code>MaxManifestFragmentResults</code>. The manifest must be retrieved only
        /// once for each session. When this type of session is played in a media player,
        /// the user interface typically displays a scrubber control for choosing the
        /// position in the playback window to display.</p>
        /// </li>
        /// </ul>
        /// <p>In all playback modes, if <code>FragmentSelectorType</code> is
        /// <code>PRODUCER_TIMESTAMP</code>, and if there are multiple fragments with the same
        /// start timestamp, the fragment that has the larger fragment number (that is, the newer
        /// fragment) is included in the MPEG-DASH manifest. The other fragments are not included.
        /// Fragments that have different timestamps but have overlapping durations are still
        /// included in the MPEG-DASH manifest. This can lead to unexpected behavior in the media
        /// player.</p>
        /// <p>The default is <code>LIVE</code>.</p>
        pub fn playback_mode(mut self, inp: crate::model::DashPlaybackMode) -> Self {
            self.inner = self.inner.playback_mode(inp);
            self
        }
        pub fn set_playback_mode(
            mut self,
            input: std::option::Option<crate::model::DashPlaybackMode>,
        ) -> Self {
            self.inner = self.inner.set_playback_mode(input);
            self
        }
        /// <p>Per the MPEG-DASH specification, the wall-clock time of fragments in the manifest file
        /// can be derived using attributes in the manifest itself. However, typically, MPEG-DASH
        /// compatible media players do not properly handle gaps in the media timeline. Kinesis
        /// Video Streams adjusts the media timeline in the manifest file to enable playback of
        /// media with discontinuities. Therefore, the wall-clock time derived from the manifest
        /// file may be inaccurate. If DisplayFragmentTimestamp is set to <code>ALWAYS</code>, the
        /// accurate fragment timestamp is added to each S element in the manifest file with the
        /// attribute name “kvs:ts”. A custom MPEG-DASH media player is necessary to leverage this
        /// custom attribute.</p>
        /// <p>The default value is <code>NEVER</code>. When <a>DASHFragmentSelector</a>
        /// is <code>SERVER_TIMESTAMP</code>, the timestamps will be the server start timestamps.
        /// Similarly, when <a>DASHFragmentSelector</a> is
        /// <code>PRODUCER_TIMESTAMP</code>, the timestamps will be the producer start
        /// timestamps. </p>
        pub fn display_fragment_timestamp(
            mut self,
            inp: crate::model::DashDisplayFragmentTimestamp,
        ) -> Self {
            self.inner = self.inner.display_fragment_timestamp(inp);
            self
        }
        pub fn set_display_fragment_timestamp(
            mut self,
            input: std::option::Option<crate::model::DashDisplayFragmentTimestamp>,
        ) -> Self {
            self.inner = self.inner.set_display_fragment_timestamp(input);
            self
        }
        /// <p>Fragments are identified in the manifest file based on their sequence number in the
        /// session. If DisplayFragmentNumber is set to <code>ALWAYS</code>, the Kinesis Video
        /// Streams fragment number is added to each S element in the manifest file with the
        /// attribute name “kvs:fn”. These fragment numbers can be used for logging or for use with
        /// other APIs (e.g. <code>GetMedia</code> and <code>GetMediaForFragmentList</code>). A
        /// custom MPEG-DASH media player is necessary to leverage these this custom
        /// attribute.</p>
        /// <p>The default value is <code>NEVER</code>.</p>
        pub fn display_fragment_number(
            mut self,
            inp: crate::model::DashDisplayFragmentNumber,
        ) -> Self {
            self.inner = self.inner.display_fragment_number(inp);
            self
        }
        pub fn set_display_fragment_number(
            mut self,
            input: std::option::Option<crate::model::DashDisplayFragmentNumber>,
        ) -> Self {
            self.inner = self.inner.set_display_fragment_number(input);
            self
        }
        /// <p>The time range of the requested fragment and the source of the timestamps.</p>
        /// <p>This parameter is required if <code>PlaybackMode</code> is <code>ON_DEMAND</code> or
        /// <code>LIVE_REPLAY</code>. This parameter is optional if PlaybackMode is<code></code>
        /// <code>LIVE</code>. If <code>PlaybackMode</code> is <code>LIVE</code>, the
        /// <code>FragmentSelectorType</code> can be set, but the <code>TimestampRange</code>
        /// should not be set. If <code>PlaybackMode</code> is <code>ON_DEMAND</code> or
        /// <code>LIVE_REPLAY</code>, both <code>FragmentSelectorType</code> and
        /// <code>TimestampRange</code> must be set.</p>
        pub fn dash_fragment_selector(mut self, inp: crate::model::DashFragmentSelector) -> Self {
            self.inner = self.inner.dash_fragment_selector(inp);
            self
        }
        pub fn set_dash_fragment_selector(
            mut self,
            input: std::option::Option<crate::model::DashFragmentSelector>,
        ) -> Self {
            self.inner = self.inner.set_dash_fragment_selector(input);
            self
        }
        /// <p>The time in seconds until the requested session expires. This value can be between 300
        /// (5 minutes) and 43200 (12 hours).</p>
        /// <p>When a session expires, no new calls to <code>GetDashManifest</code>,
        /// <code>GetMP4InitFragment</code>, or <code>GetMP4MediaFragment</code> can be made for
        /// that session.</p>
        /// <p>The default is 300 (5 minutes).</p>
        pub fn expires(mut self, inp: i32) -> Self {
            self.inner = self.inner.expires(inp);
            self
        }
        pub fn set_expires(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_expires(input);
            self
        }
        /// <p>The maximum number of fragments that are returned in the MPEG-DASH manifest.</p>
        /// <p>When the <code>PlaybackMode</code> is <code>LIVE</code>, the most recent fragments are
        /// returned up to this value. When the <code>PlaybackMode</code> is <code>ON_DEMAND</code>,
        /// the oldest fragments are returned, up to this maximum number.</p>
        /// <p>When there are a higher number of fragments available in a live MPEG-DASH manifest,
        /// video players often buffer content before starting playback. Increasing the buffer size
        /// increases the playback latency, but it decreases the likelihood that rebuffering will
        /// occur during playback. We recommend that a live MPEG-DASH manifest have a minimum of 3
        /// fragments and a maximum of 10 fragments.</p>
        /// <p>The default is 5 fragments if <code>PlaybackMode</code> is <code>LIVE</code> or
        /// <code>LIVE_REPLAY</code>, and 1,000 if <code>PlaybackMode</code> is
        /// <code>ON_DEMAND</code>. </p>
        /// <p>The maximum value of 1,000 fragments corresponds to more than 16 minutes of video on
        /// streams with 1-second fragments, and more than 2 1/2 hours of video on streams with
        /// 10-second fragments.</p>
        pub fn max_manifest_fragment_results(mut self, inp: i64) -> Self {
            self.inner = self.inner.max_manifest_fragment_results(inp);
            self
        }
        pub fn set_max_manifest_fragment_results(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.inner = self.inner.set_max_manifest_fragment_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetHLSStreamingSessionURL<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_hls_streaming_session_url_input::Builder,
    }
    impl<C, M, R> GetHLSStreamingSessionURL<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetHlsStreamingSessionUrlOutput,
            smithy_http::result::SdkError<crate::error::GetHLSStreamingSessionURLError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetHlsStreamingSessionUrlInputOperationOutputAlias,
                crate::output::GetHlsStreamingSessionUrlOutput,
                crate::error::GetHLSStreamingSessionURLError,
                crate::input::GetHlsStreamingSessionUrlInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the stream for which to retrieve the HLS master playlist URL.</p>
        /// <p>You must specify either the <code>StreamName</code> or the
        /// <code>StreamARN</code>.</p>
        pub fn stream_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.stream_name(inp);
            self
        }
        pub fn set_stream_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_stream_name(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the stream for which to retrieve the HLS master
        /// playlist URL.</p>
        /// <p>You must specify either the <code>StreamName</code> or the
        /// <code>StreamARN</code>.</p>
        pub fn stream_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.stream_arn(inp);
            self
        }
        pub fn set_stream_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_stream_arn(input);
            self
        }
        /// <p>Whether to retrieve live, live replay, or archived, on-demand data.</p>
        /// <p>Features of the three types of sessions include the following:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>
        /// <code>LIVE</code>
        /// </b>: For sessions of this type, the HLS media playlist is continually
        /// updated with the latest fragments as they become available. We recommend that
        /// the media player retrieve a new playlist on a one-second interval. When this
        /// type of session is played in a media player, the user interface typically
        /// displays a "live" notification, with no scrubber control for choosing the
        /// position in the playback window to display.</p>
        /// <note>
        /// <p>In <code>LIVE</code> mode, the newest available fragments are included in
        /// an HLS media playlist, even if there is a gap between fragments (that is, if
        /// a fragment is missing). A gap like this might cause a media player to halt
        /// or cause a jump in playback. In this mode, fragments are not added to the
        /// HLS media playlist if they are older than the newest fragment in the
        /// playlist. If the missing fragment becomes available after a subsequent
        /// fragment is added to the playlist, the older fragment is not added, and the
        /// gap is not filled.</p>
        /// </note>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>LIVE_REPLAY</code>
        /// </b>: For sessions of this type, the HLS media playlist is updated
        /// similarly to how it is updated for <code>LIVE</code> mode except that it starts
        /// by including fragments from a given start time. Instead of fragments being added
        /// as they are ingested, fragments are added as the duration of the next fragment
        /// elapses. For example, if the fragments in the session are two seconds long, then
        /// a new fragment is added to the media playlist every two seconds. This mode is
        /// useful to be able to start playback from when an event is detected and continue
        /// live streaming media that has not yet been ingested as of the time of the
        /// session creation. This mode is also useful to stream previously archived media
        /// without being limited by the 1,000 fragment limit in the <code>ON_DEMAND</code>
        /// mode. </p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>
        /// <code>ON_DEMAND</code>
        /// </b>: For sessions of this type, the HLS media playlist contains all the
        /// fragments for the session, up to the number that is specified in
        /// <code>MaxMediaPlaylistFragmentResults</code>. The playlist must be retrieved
        /// only once for each session. When this type of session is played in a media
        /// player, the user interface typically displays a scrubber control for choosing
        /// the position in the playback window to display.</p>
        /// </li>
        /// </ul>
        /// <p>In all playback modes, if <code>FragmentSelectorType</code> is
        /// <code>PRODUCER_TIMESTAMP</code>, and if there are multiple fragments with the same
        /// start timestamp, the fragment that has the largest fragment number (that is, the newest
        /// fragment) is included in the HLS media playlist. The other fragments are not included.
        /// Fragments that have different timestamps but have overlapping durations are still
        /// included in the HLS media playlist. This can lead to unexpected behavior in the media
        /// player.</p>
        /// <p>The default is <code>LIVE</code>.</p>
        pub fn playback_mode(mut self, inp: crate::model::HlsPlaybackMode) -> Self {
            self.inner = self.inner.playback_mode(inp);
            self
        }
        pub fn set_playback_mode(
            mut self,
            input: std::option::Option<crate::model::HlsPlaybackMode>,
        ) -> Self {
            self.inner = self.inner.set_playback_mode(input);
            self
        }
        /// <p>The time range of the requested fragment and the source of the timestamps.</p>
        /// <p>This parameter is required if <code>PlaybackMode</code> is <code>ON_DEMAND</code> or
        /// <code>LIVE_REPLAY</code>. This parameter is optional if PlaybackMode is<code></code>
        /// <code>LIVE</code>. If <code>PlaybackMode</code> is <code>LIVE</code>, the
        /// <code>FragmentSelectorType</code> can be set, but the <code>TimestampRange</code>
        /// should not be set. If <code>PlaybackMode</code> is <code>ON_DEMAND</code> or
        /// <code>LIVE_REPLAY</code>, both <code>FragmentSelectorType</code> and
        /// <code>TimestampRange</code> must be set.</p>
        pub fn hls_fragment_selector(mut self, inp: crate::model::HlsFragmentSelector) -> Self {
            self.inner = self.inner.hls_fragment_selector(inp);
            self
        }
        pub fn set_hls_fragment_selector(
            mut self,
            input: std::option::Option<crate::model::HlsFragmentSelector>,
        ) -> Self {
            self.inner = self.inner.set_hls_fragment_selector(input);
            self
        }
        /// <p>Specifies which format should be used for packaging the media. Specifying the
        /// <code>FRAGMENTED_MP4</code> container format packages the media into MP4 fragments
        /// (fMP4 or CMAF). This is the recommended packaging because there is minimal packaging
        /// overhead. The other container format option is <code>MPEG_TS</code>. HLS has supported
        /// MPEG TS chunks since it was released and is sometimes the only supported packaging on
        /// older HLS players. MPEG TS typically has a 5-25 percent packaging overhead. This means
        /// MPEG TS typically requires 5-25 percent more bandwidth and cost than fMP4.</p>
        /// <p>The default is <code>FRAGMENTED_MP4</code>.</p>
        pub fn container_format(mut self, inp: crate::model::ContainerFormat) -> Self {
            self.inner = self.inner.container_format(inp);
            self
        }
        pub fn set_container_format(
            mut self,
            input: std::option::Option<crate::model::ContainerFormat>,
        ) -> Self {
            self.inner = self.inner.set_container_format(input);
            self
        }
        /// <p>Specifies when flags marking discontinuities between fragments are added to the media
        /// playlists.</p>
        /// <p>Media players typically build a timeline of media content to play, based on the
        /// timestamps of each fragment. This means that if there is any overlap or gap between
        /// fragments (as is typical if <a>HLSFragmentSelector</a> is set to
        /// <code>SERVER_TIMESTAMP</code>), the media player timeline will also have small gaps
        /// between fragments in some places, and will overwrite frames in other places. Gaps in the
        /// media player timeline can cause playback to stall and overlaps can cause playback to be
        /// jittery. When there are discontinuity flags between fragments, the media player is
        /// expected to reset the timeline, resulting in the next fragment being played immediately
        /// after the previous fragment. </p>
        /// <p>The following modes are supported:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>ALWAYS</code>: a discontinuity marker is placed between every fragment in
        /// the HLS media playlist. It is recommended to use a value of <code>ALWAYS</code>
        /// if the fragment timestamps are not accurate.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>NEVER</code>: no discontinuity markers are placed anywhere. It is
        /// recommended to use a value of <code>NEVER</code> to ensure the media player
        /// timeline most accurately maps to the producer timestamps. </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ON_DISCONTINUITY</code>: a discontinuity marker is placed between
        /// fragments that have a gap or overlap of more than 50 milliseconds. For most
        /// playback scenarios, it is recommended to use a value of
        /// <code>ON_DISCONTINUITY</code> so that the media player timeline is only
        /// reset when there is a significant issue with the media timeline (e.g. a missing
        /// fragment).</p>
        /// </li>
        /// </ul>
        /// <p>The default is <code>ALWAYS</code> when <a>HLSFragmentSelector</a> is set
        /// to <code>SERVER_TIMESTAMP</code>, and <code>NEVER</code> when it is set to
        /// <code>PRODUCER_TIMESTAMP</code>.</p>
        pub fn discontinuity_mode(mut self, inp: crate::model::HlsDiscontinuityMode) -> Self {
            self.inner = self.inner.discontinuity_mode(inp);
            self
        }
        pub fn set_discontinuity_mode(
            mut self,
            input: std::option::Option<crate::model::HlsDiscontinuityMode>,
        ) -> Self {
            self.inner = self.inner.set_discontinuity_mode(input);
            self
        }
        /// <p>Specifies when the fragment start timestamps should be included in the HLS media
        /// playlist. Typically, media players report the playhead position as a time relative to
        /// the start of the first fragment in the playback session. However, when the start
        /// timestamps are included in the HLS media playlist, some media players might report the
        /// current playhead as an absolute time based on the fragment timestamps. This can be
        /// useful for creating a playback experience that shows viewers the wall-clock time of the
        /// media.</p>
        /// <p>The default is <code>NEVER</code>. When <a>HLSFragmentSelector</a> is
        /// <code>SERVER_TIMESTAMP</code>, the timestamps will be the server start timestamps.
        /// Similarly, when <a>HLSFragmentSelector</a> is
        /// <code>PRODUCER_TIMESTAMP</code>, the timestamps will be the producer start timestamps.
        /// </p>
        pub fn display_fragment_timestamp(
            mut self,
            inp: crate::model::HlsDisplayFragmentTimestamp,
        ) -> Self {
            self.inner = self.inner.display_fragment_timestamp(inp);
            self
        }
        pub fn set_display_fragment_timestamp(
            mut self,
            input: std::option::Option<crate::model::HlsDisplayFragmentTimestamp>,
        ) -> Self {
            self.inner = self.inner.set_display_fragment_timestamp(input);
            self
        }
        /// <p>The time in seconds until the requested session expires. This value can be between 300
        /// (5 minutes) and 43200 (12 hours).</p>
        /// <p>When a session expires, no new calls to <code>GetHLSMasterPlaylist</code>,
        /// <code>GetHLSMediaPlaylist</code>, <code>GetMP4InitFragment</code>,
        /// <code>GetMP4MediaFragment</code>, or <code>GetTSFragment</code> can be made for that
        /// session.</p>
        /// <p>The default is 300 (5 minutes).</p>
        pub fn expires(mut self, inp: i32) -> Self {
            self.inner = self.inner.expires(inp);
            self
        }
        pub fn set_expires(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_expires(input);
            self
        }
        /// <p>The maximum number of fragments that are returned in the HLS media playlists.</p>
        /// <p>When the <code>PlaybackMode</code> is <code>LIVE</code>, the most recent fragments are
        /// returned up to this value. When the <code>PlaybackMode</code> is <code>ON_DEMAND</code>,
        /// the oldest fragments are returned, up to this maximum number.</p>
        /// <p>When there are a higher number of fragments available in a live HLS media playlist,
        /// video players often buffer content before starting playback. Increasing the buffer size
        /// increases the playback latency, but it decreases the likelihood that rebuffering will
        /// occur during playback. We recommend that a live HLS media playlist have a minimum of 3
        /// fragments and a maximum of 10 fragments.</p>
        /// <p>The default is 5 fragments if <code>PlaybackMode</code> is <code>LIVE</code> or
        /// <code>LIVE_REPLAY</code>, and 1,000 if <code>PlaybackMode</code> is
        /// <code>ON_DEMAND</code>. </p>
        /// <p>The maximum value of 5,000 fragments corresponds to more than 80 minutes of video on
        /// streams with 1-second fragments, and more than 13 hours of video on streams with
        /// 10-second fragments.</p>
        pub fn max_media_playlist_fragment_results(mut self, inp: i64) -> Self {
            self.inner = self.inner.max_media_playlist_fragment_results(inp);
            self
        }
        pub fn set_max_media_playlist_fragment_results(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.inner = self.inner.set_max_media_playlist_fragment_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetMediaForFragmentList<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_media_for_fragment_list_input::Builder,
    }
    impl<C, M, R> GetMediaForFragmentList<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetMediaForFragmentListOutput,
            smithy_http::result::SdkError<crate::error::GetMediaForFragmentListError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetMediaForFragmentListInputOperationOutputAlias,
                crate::output::GetMediaForFragmentListOutput,
                crate::error::GetMediaForFragmentListError,
                crate::input::GetMediaForFragmentListInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the stream from which to retrieve fragment media. Specify either this parameter or the <code>StreamARN</code> parameter.</p>
        pub fn stream_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.stream_name(inp);
            self
        }
        pub fn set_stream_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_stream_name(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the stream from which to retrieve fragment media. Specify either this parameter or the <code>StreamName</code> parameter.</p>
        pub fn stream_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.stream_arn(inp);
            self
        }
        pub fn set_stream_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_stream_arn(input);
            self
        }
        /// Appends an item to `Fragments`.
        ///
        /// To override the contents of this collection use [`set_fragments`](Self::set_fragments).
        /// <p>A list of the numbers of fragments for which to retrieve media. You retrieve these
        /// values with <a>ListFragments</a>.</p>
        pub fn fragments(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.fragments(inp);
            self
        }
        pub fn set_fragments(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_fragments(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListFragments<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_fragments_input::Builder,
    }
    impl<C, M, R> ListFragments<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListFragmentsOutput,
            smithy_http::result::SdkError<crate::error::ListFragmentsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListFragmentsInputOperationOutputAlias,
                crate::output::ListFragmentsOutput,
                crate::error::ListFragmentsError,
                crate::input::ListFragmentsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the stream from which to retrieve a fragment list. Specify either this parameter or the <code>StreamARN</code> parameter.</p>
        pub fn stream_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.stream_name(inp);
            self
        }
        pub fn set_stream_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_stream_name(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the stream from which to retrieve a fragment list. Specify either this parameter or the <code>StreamName</code> parameter.</p>
        pub fn stream_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.stream_arn(inp);
            self
        }
        pub fn set_stream_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_stream_arn(input);
            self
        }
        /// <p>The total number of fragments to return. If the total number of fragments available is
        /// more than the value specified in <code>max-results</code>, then a <a>ListFragmentsOutput$NextToken</a> is provided in the output that you can use
        /// to resume pagination.</p>
        pub fn max_results(mut self, inp: i64) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>A token to specify where to start paginating. This is the <a>ListFragmentsOutput$NextToken</a> from a previously truncated
        /// response.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>Describes the timestamp range and timestamp origin for the range of fragments to
        /// return.</p>
        pub fn fragment_selector(mut self, inp: crate::model::FragmentSelector) -> Self {
            self.inner = self.inner.fragment_selector(inp);
            self
        }
        pub fn set_fragment_selector(
            mut self,
            input: std::option::Option<crate::model::FragmentSelector>,
        ) -> Self {
            self.inner = self.inner.set_fragment_selector(input);
            self
        }
    }
}
impl<C> Client<C, aws_hyper::AwsMiddleware, smithy_client::retry::Standard> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl
    Client<
        smithy_client::erase::DynConnector,
        aws_hyper::AwsMiddleware,
        smithy_client::retry::Standard,
    >
{
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn new(config: &aws_types::config::Config) -> Self {
        Self::from_conf(config.into())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let client = aws_hyper::Client::https();
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
