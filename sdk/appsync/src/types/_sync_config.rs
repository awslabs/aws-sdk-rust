// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Describes a Sync configuration for a resolver.</p>
/// <p>Specifies which Conflict Detection strategy and Resolution strategy to use when the resolver is invoked.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SyncConfig {
    /// <p>The Conflict Resolution strategy to perform in the event of a conflict.</p>
    /// <ul>
    /// <li> <p> <b>OPTIMISTIC_CONCURRENCY</b>: Resolve conflicts by rejecting mutations when versions don't match the latest version at the server.</p> </li>
    /// <li> <p> <b>AUTOMERGE</b>: Resolve conflicts with the Automerge conflict resolution strategy.</p> </li>
    /// <li> <p> <b>LAMBDA</b>: Resolve conflicts with an Lambda function supplied in the <code>LambdaConflictHandlerConfig</code>.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub conflict_handler: std::option::Option<crate::types::ConflictHandlerType>,
    /// <p>The Conflict Detection strategy to use.</p>
    /// <ul>
    /// <li> <p> <b>VERSION</b>: Detect conflicts based on object versions for this resolver.</p> </li>
    /// <li> <p> <b>NONE</b>: Do not detect conflicts when invoking this resolver.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub conflict_detection: std::option::Option<crate::types::ConflictDetectionType>,
    /// <p>The <code>LambdaConflictHandlerConfig</code> when configuring <code>LAMBDA</code> as the Conflict Handler.</p>
    #[doc(hidden)]
    pub lambda_conflict_handler_config:
        std::option::Option<crate::types::LambdaConflictHandlerConfig>,
}
impl SyncConfig {
    /// <p>The Conflict Resolution strategy to perform in the event of a conflict.</p>
    /// <ul>
    /// <li> <p> <b>OPTIMISTIC_CONCURRENCY</b>: Resolve conflicts by rejecting mutations when versions don't match the latest version at the server.</p> </li>
    /// <li> <p> <b>AUTOMERGE</b>: Resolve conflicts with the Automerge conflict resolution strategy.</p> </li>
    /// <li> <p> <b>LAMBDA</b>: Resolve conflicts with an Lambda function supplied in the <code>LambdaConflictHandlerConfig</code>.</p> </li>
    /// </ul>
    pub fn conflict_handler(&self) -> std::option::Option<&crate::types::ConflictHandlerType> {
        self.conflict_handler.as_ref()
    }
    /// <p>The Conflict Detection strategy to use.</p>
    /// <ul>
    /// <li> <p> <b>VERSION</b>: Detect conflicts based on object versions for this resolver.</p> </li>
    /// <li> <p> <b>NONE</b>: Do not detect conflicts when invoking this resolver.</p> </li>
    /// </ul>
    pub fn conflict_detection(&self) -> std::option::Option<&crate::types::ConflictDetectionType> {
        self.conflict_detection.as_ref()
    }
    /// <p>The <code>LambdaConflictHandlerConfig</code> when configuring <code>LAMBDA</code> as the Conflict Handler.</p>
    pub fn lambda_conflict_handler_config(
        &self,
    ) -> std::option::Option<&crate::types::LambdaConflictHandlerConfig> {
        self.lambda_conflict_handler_config.as_ref()
    }
}
impl SyncConfig {
    /// Creates a new builder-style object to manufacture [`SyncConfig`](crate::types::SyncConfig).
    pub fn builder() -> crate::types::builders::SyncConfigBuilder {
        crate::types::builders::SyncConfigBuilder::default()
    }
}

/// A builder for [`SyncConfig`](crate::types::SyncConfig).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct SyncConfigBuilder {
    pub(crate) conflict_handler: std::option::Option<crate::types::ConflictHandlerType>,
    pub(crate) conflict_detection: std::option::Option<crate::types::ConflictDetectionType>,
    pub(crate) lambda_conflict_handler_config:
        std::option::Option<crate::types::LambdaConflictHandlerConfig>,
}
impl SyncConfigBuilder {
    /// <p>The Conflict Resolution strategy to perform in the event of a conflict.</p>
    /// <ul>
    /// <li> <p> <b>OPTIMISTIC_CONCURRENCY</b>: Resolve conflicts by rejecting mutations when versions don't match the latest version at the server.</p> </li>
    /// <li> <p> <b>AUTOMERGE</b>: Resolve conflicts with the Automerge conflict resolution strategy.</p> </li>
    /// <li> <p> <b>LAMBDA</b>: Resolve conflicts with an Lambda function supplied in the <code>LambdaConflictHandlerConfig</code>.</p> </li>
    /// </ul>
    pub fn conflict_handler(mut self, input: crate::types::ConflictHandlerType) -> Self {
        self.conflict_handler = Some(input);
        self
    }
    /// <p>The Conflict Resolution strategy to perform in the event of a conflict.</p>
    /// <ul>
    /// <li> <p> <b>OPTIMISTIC_CONCURRENCY</b>: Resolve conflicts by rejecting mutations when versions don't match the latest version at the server.</p> </li>
    /// <li> <p> <b>AUTOMERGE</b>: Resolve conflicts with the Automerge conflict resolution strategy.</p> </li>
    /// <li> <p> <b>LAMBDA</b>: Resolve conflicts with an Lambda function supplied in the <code>LambdaConflictHandlerConfig</code>.</p> </li>
    /// </ul>
    pub fn set_conflict_handler(
        mut self,
        input: std::option::Option<crate::types::ConflictHandlerType>,
    ) -> Self {
        self.conflict_handler = input;
        self
    }
    /// <p>The Conflict Detection strategy to use.</p>
    /// <ul>
    /// <li> <p> <b>VERSION</b>: Detect conflicts based on object versions for this resolver.</p> </li>
    /// <li> <p> <b>NONE</b>: Do not detect conflicts when invoking this resolver.</p> </li>
    /// </ul>
    pub fn conflict_detection(mut self, input: crate::types::ConflictDetectionType) -> Self {
        self.conflict_detection = Some(input);
        self
    }
    /// <p>The Conflict Detection strategy to use.</p>
    /// <ul>
    /// <li> <p> <b>VERSION</b>: Detect conflicts based on object versions for this resolver.</p> </li>
    /// <li> <p> <b>NONE</b>: Do not detect conflicts when invoking this resolver.</p> </li>
    /// </ul>
    pub fn set_conflict_detection(
        mut self,
        input: std::option::Option<crate::types::ConflictDetectionType>,
    ) -> Self {
        self.conflict_detection = input;
        self
    }
    /// <p>The <code>LambdaConflictHandlerConfig</code> when configuring <code>LAMBDA</code> as the Conflict Handler.</p>
    pub fn lambda_conflict_handler_config(
        mut self,
        input: crate::types::LambdaConflictHandlerConfig,
    ) -> Self {
        self.lambda_conflict_handler_config = Some(input);
        self
    }
    /// <p>The <code>LambdaConflictHandlerConfig</code> when configuring <code>LAMBDA</code> as the Conflict Handler.</p>
    pub fn set_lambda_conflict_handler_config(
        mut self,
        input: std::option::Option<crate::types::LambdaConflictHandlerConfig>,
    ) -> Self {
        self.lambda_conflict_handler_config = input;
        self
    }
    /// Consumes the builder and constructs a [`SyncConfig`](crate::types::SyncConfig).
    pub fn build(self) -> crate::types::SyncConfig {
        crate::types::SyncConfig {
            conflict_handler: self.conflict_handler,
            conflict_detection: self.conflict_detection,
            lambda_conflict_handler_config: self.lambda_conflict_handler_config,
        }
    }
}
