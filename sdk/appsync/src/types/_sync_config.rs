// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Describes a Sync configuration for a resolver.</p> 
/// <p>Specifies which Conflict Detection strategy and Resolution strategy to use when the resolver is invoked.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SyncConfig  {
    /// <p>The Conflict Resolution strategy to perform in the event of a conflict.</p> 
    /// <ul> 
    /// <li> <p> <b>OPTIMISTIC_CONCURRENCY</b>: Resolve conflicts by rejecting mutations when versions don't match the latest version at the server.</p> </li> 
    /// <li> <p> <b>AUTOMERGE</b>: Resolve conflicts with the Automerge conflict resolution strategy.</p> </li> 
    /// <li> <p> <b>LAMBDA</b>: Resolve conflicts with an Lambda function supplied in the <code>LambdaConflictHandlerConfig</code>.</p> </li> 
    /// </ul>
    #[doc(hidden)]
    pub conflict_handler: std::option::Option<crate::types::ConflictHandlerType>,
    /// <p>The Conflict Detection strategy to use.</p> 
    /// <ul> 
    /// <li> <p> <b>VERSION</b>: Detect conflicts based on object versions for this resolver.</p> </li> 
    /// <li> <p> <b>NONE</b>: Do not detect conflicts when invoking this resolver.</p> </li> 
    /// </ul>
    #[doc(hidden)]
    pub conflict_detection: std::option::Option<crate::types::ConflictDetectionType>,
    /// <p>The <code>LambdaConflictHandlerConfig</code> when configuring <code>LAMBDA</code> as the Conflict Handler.</p>
    #[doc(hidden)]
    pub lambda_conflict_handler_config: std::option::Option<crate::types::LambdaConflictHandlerConfig>,
}
impl SyncConfig {
    /// <p>The Conflict Resolution strategy to perform in the event of a conflict.</p> 
    /// <ul> 
    /// <li> <p> <b>OPTIMISTIC_CONCURRENCY</b>: Resolve conflicts by rejecting mutations when versions don't match the latest version at the server.</p> </li> 
    /// <li> <p> <b>AUTOMERGE</b>: Resolve conflicts with the Automerge conflict resolution strategy.</p> </li> 
    /// <li> <p> <b>LAMBDA</b>: Resolve conflicts with an Lambda function supplied in the <code>LambdaConflictHandlerConfig</code>.</p> </li> 
    /// </ul>
    pub fn conflict_handler(&self) -> std::option::Option<& crate::types::ConflictHandlerType> {
        self.conflict_handler.as_ref()
    }
    /// <p>The Conflict Detection strategy to use.</p> 
    /// <ul> 
    /// <li> <p> <b>VERSION</b>: Detect conflicts based on object versions for this resolver.</p> </li> 
    /// <li> <p> <b>NONE</b>: Do not detect conflicts when invoking this resolver.</p> </li> 
    /// </ul>
    pub fn conflict_detection(&self) -> std::option::Option<& crate::types::ConflictDetectionType> {
        self.conflict_detection.as_ref()
    }
    /// <p>The <code>LambdaConflictHandlerConfig</code> when configuring <code>LAMBDA</code> as the Conflict Handler.</p>
    pub fn lambda_conflict_handler_config(&self) -> std::option::Option<& crate::types::LambdaConflictHandlerConfig> {
        self.lambda_conflict_handler_config.as_ref()
    }
}
impl SyncConfig {
    /// Creates a new builder-style object to manufacture [`SyncConfig`](crate::types::SyncConfig).
    pub fn builder() -> crate::types::builders::SyncConfigBuilder {
        crate::types::builders::SyncConfigBuilder::default()
    }
}

/// A builder for [`SyncConfig`](crate::types::SyncConfig).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct SyncConfigBuilder {
    pub(crate) conflict_handler: std::option::Option<crate::types::ConflictHandlerType>,
    pub(crate) conflict_detection: std::option::Option<crate::types::ConflictDetectionType>,
    pub(crate) lambda_conflict_handler_config: std::option::Option<crate::types::LambdaConflictHandlerConfig>,
}
impl SyncConfigBuilder {
    /// <p>The Conflict Resolution strategy to perform in the event of a conflict.</p> 
    /// <ul> 
    /// <li> <p> <b>OPTIMISTIC_CONCURRENCY</b>: Resolve conflicts by rejecting mutations when versions don't match the latest version at the server.</p> </li> 
    /// <li> <p> <b>AUTOMERGE</b>: Resolve conflicts with the Automerge conflict resolution strategy.</p> </li> 
    /// <li> <p> <b>LAMBDA</b>: Resolve conflicts with an Lambda function supplied in the <code>LambdaConflictHandlerConfig</code>.</p> </li> 
    /// </ul>
    pub fn conflict_handler(mut self, input: crate::types::ConflictHandlerType) -> Self {
        self.conflict_handler = Some(input);
        self
    }
    /// <p>The Conflict Resolution strategy to perform in the event of a conflict.</p> 
    /// <ul> 
    /// <li> <p> <b>OPTIMISTIC_CONCURRENCY</b>: Resolve conflicts by rejecting mutations when versions don't match the latest version at the server.</p> </li> 
    /// <li> <p> <b>AUTOMERGE</b>: Resolve conflicts with the Automerge conflict resolution strategy.</p> </li> 
    /// <li> <p> <b>LAMBDA</b>: Resolve conflicts with an Lambda function supplied in the <code>LambdaConflictHandlerConfig</code>.</p> </li> 
    /// </ul>
    pub fn set_conflict_handler(mut self, input: std::option::Option<crate::types::ConflictHandlerType>) -> Self {
        self.conflict_handler = input; self
    }
    /// <p>The Conflict Detection strategy to use.</p> 
    /// <ul> 
    /// <li> <p> <b>VERSION</b>: Detect conflicts based on object versions for this resolver.</p> </li> 
    /// <li> <p> <b>NONE</b>: Do not detect conflicts when invoking this resolver.</p> </li> 
    /// </ul>
    pub fn conflict_detection(mut self, input: crate::types::ConflictDetectionType) -> Self {
        self.conflict_detection = Some(input);
        self
    }
    /// <p>The Conflict Detection strategy to use.</p> 
    /// <ul> 
    /// <li> <p> <b>VERSION</b>: Detect conflicts based on object versions for this resolver.</p> </li> 
    /// <li> <p> <b>NONE</b>: Do not detect conflicts when invoking this resolver.</p> </li> 
    /// </ul>
    pub fn set_conflict_detection(mut self, input: std::option::Option<crate::types::ConflictDetectionType>) -> Self {
        self.conflict_detection = input; self
    }
    /// <p>The <code>LambdaConflictHandlerConfig</code> when configuring <code>LAMBDA</code> as the Conflict Handler.</p>
    pub fn lambda_conflict_handler_config(mut self, input: crate::types::LambdaConflictHandlerConfig) -> Self {
        self.lambda_conflict_handler_config = Some(input);
        self
    }
    /// <p>The <code>LambdaConflictHandlerConfig</code> when configuring <code>LAMBDA</code> as the Conflict Handler.</p>
    pub fn set_lambda_conflict_handler_config(mut self, input: std::option::Option<crate::types::LambdaConflictHandlerConfig>) -> Self {
        self.lambda_conflict_handler_config = input; self
    }
    /// Consumes the builder and constructs a [`SyncConfig`](crate::types::SyncConfig).
    pub fn build(self) -> crate::types::SyncConfig {
        crate::types::SyncConfig {
            conflict_handler: self.conflict_handler
            ,
            conflict_detection: self.conflict_detection
            ,
            lambda_conflict_handler_config: self.lambda_conflict_handler_config
            ,
        }
    }
}

