// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(std::fmt::Debug)]
pub(crate) struct Handle<C = aws_hyper::DynConnector> {
    client: aws_hyper::Client<C>,
    conf: crate::Config,
}

#[derive(Clone, std::fmt::Debug)]
pub struct Client<C = aws_hyper::DynConnector> {
    handle: std::sync::Arc<Handle<C>>,
}
impl<C> Client<C> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl Client {
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_env() -> Self {
        Self::from_conf(crate::Config::builder().build())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let client = aws_hyper::Client::https();
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl<C> Client<C>
where
    C: aws_hyper::SmithyConnector,
{
    pub fn create_api_cache(&self) -> fluent_builders::CreateApiCache<C> {
        fluent_builders::CreateApiCache::new(self.handle.clone())
    }
    pub fn create_api_key(&self) -> fluent_builders::CreateApiKey<C> {
        fluent_builders::CreateApiKey::new(self.handle.clone())
    }
    pub fn create_data_source(&self) -> fluent_builders::CreateDataSource<C> {
        fluent_builders::CreateDataSource::new(self.handle.clone())
    }
    pub fn create_function(&self) -> fluent_builders::CreateFunction<C> {
        fluent_builders::CreateFunction::new(self.handle.clone())
    }
    pub fn create_graphql_api(&self) -> fluent_builders::CreateGraphqlApi<C> {
        fluent_builders::CreateGraphqlApi::new(self.handle.clone())
    }
    pub fn create_resolver(&self) -> fluent_builders::CreateResolver<C> {
        fluent_builders::CreateResolver::new(self.handle.clone())
    }
    pub fn create_type(&self) -> fluent_builders::CreateType<C> {
        fluent_builders::CreateType::new(self.handle.clone())
    }
    pub fn delete_api_cache(&self) -> fluent_builders::DeleteApiCache<C> {
        fluent_builders::DeleteApiCache::new(self.handle.clone())
    }
    pub fn delete_api_key(&self) -> fluent_builders::DeleteApiKey<C> {
        fluent_builders::DeleteApiKey::new(self.handle.clone())
    }
    pub fn delete_data_source(&self) -> fluent_builders::DeleteDataSource<C> {
        fluent_builders::DeleteDataSource::new(self.handle.clone())
    }
    pub fn delete_function(&self) -> fluent_builders::DeleteFunction<C> {
        fluent_builders::DeleteFunction::new(self.handle.clone())
    }
    pub fn delete_graphql_api(&self) -> fluent_builders::DeleteGraphqlApi<C> {
        fluent_builders::DeleteGraphqlApi::new(self.handle.clone())
    }
    pub fn delete_resolver(&self) -> fluent_builders::DeleteResolver<C> {
        fluent_builders::DeleteResolver::new(self.handle.clone())
    }
    pub fn delete_type(&self) -> fluent_builders::DeleteType<C> {
        fluent_builders::DeleteType::new(self.handle.clone())
    }
    pub fn flush_api_cache(&self) -> fluent_builders::FlushApiCache<C> {
        fluent_builders::FlushApiCache::new(self.handle.clone())
    }
    pub fn get_api_cache(&self) -> fluent_builders::GetApiCache<C> {
        fluent_builders::GetApiCache::new(self.handle.clone())
    }
    pub fn get_data_source(&self) -> fluent_builders::GetDataSource<C> {
        fluent_builders::GetDataSource::new(self.handle.clone())
    }
    pub fn get_function(&self) -> fluent_builders::GetFunction<C> {
        fluent_builders::GetFunction::new(self.handle.clone())
    }
    pub fn get_graphql_api(&self) -> fluent_builders::GetGraphqlApi<C> {
        fluent_builders::GetGraphqlApi::new(self.handle.clone())
    }
    pub fn get_introspection_schema(&self) -> fluent_builders::GetIntrospectionSchema<C> {
        fluent_builders::GetIntrospectionSchema::new(self.handle.clone())
    }
    pub fn get_resolver(&self) -> fluent_builders::GetResolver<C> {
        fluent_builders::GetResolver::new(self.handle.clone())
    }
    pub fn get_schema_creation_status(&self) -> fluent_builders::GetSchemaCreationStatus<C> {
        fluent_builders::GetSchemaCreationStatus::new(self.handle.clone())
    }
    pub fn get_type(&self) -> fluent_builders::GetType<C> {
        fluent_builders::GetType::new(self.handle.clone())
    }
    pub fn list_api_keys(&self) -> fluent_builders::ListApiKeys<C> {
        fluent_builders::ListApiKeys::new(self.handle.clone())
    }
    pub fn list_data_sources(&self) -> fluent_builders::ListDataSources<C> {
        fluent_builders::ListDataSources::new(self.handle.clone())
    }
    pub fn list_functions(&self) -> fluent_builders::ListFunctions<C> {
        fluent_builders::ListFunctions::new(self.handle.clone())
    }
    pub fn list_graphql_apis(&self) -> fluent_builders::ListGraphqlApis<C> {
        fluent_builders::ListGraphqlApis::new(self.handle.clone())
    }
    pub fn list_resolvers(&self) -> fluent_builders::ListResolvers<C> {
        fluent_builders::ListResolvers::new(self.handle.clone())
    }
    pub fn list_resolvers_by_function(&self) -> fluent_builders::ListResolversByFunction<C> {
        fluent_builders::ListResolversByFunction::new(self.handle.clone())
    }
    pub fn list_tags_for_resource(&self) -> fluent_builders::ListTagsForResource<C> {
        fluent_builders::ListTagsForResource::new(self.handle.clone())
    }
    pub fn list_types(&self) -> fluent_builders::ListTypes<C> {
        fluent_builders::ListTypes::new(self.handle.clone())
    }
    pub fn start_schema_creation(&self) -> fluent_builders::StartSchemaCreation<C> {
        fluent_builders::StartSchemaCreation::new(self.handle.clone())
    }
    pub fn tag_resource(&self) -> fluent_builders::TagResource<C> {
        fluent_builders::TagResource::new(self.handle.clone())
    }
    pub fn untag_resource(&self) -> fluent_builders::UntagResource<C> {
        fluent_builders::UntagResource::new(self.handle.clone())
    }
    pub fn update_api_cache(&self) -> fluent_builders::UpdateApiCache<C> {
        fluent_builders::UpdateApiCache::new(self.handle.clone())
    }
    pub fn update_api_key(&self) -> fluent_builders::UpdateApiKey<C> {
        fluent_builders::UpdateApiKey::new(self.handle.clone())
    }
    pub fn update_data_source(&self) -> fluent_builders::UpdateDataSource<C> {
        fluent_builders::UpdateDataSource::new(self.handle.clone())
    }
    pub fn update_function(&self) -> fluent_builders::UpdateFunction<C> {
        fluent_builders::UpdateFunction::new(self.handle.clone())
    }
    pub fn update_graphql_api(&self) -> fluent_builders::UpdateGraphqlApi<C> {
        fluent_builders::UpdateGraphqlApi::new(self.handle.clone())
    }
    pub fn update_resolver(&self) -> fluent_builders::UpdateResolver<C> {
        fluent_builders::UpdateResolver::new(self.handle.clone())
    }
    pub fn update_type(&self) -> fluent_builders::UpdateType<C> {
        fluent_builders::UpdateType::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct CreateApiCache<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_api_cache_input::Builder,
    }
    impl<C> CreateApiCache<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateApiCacheOutput,
            smithy_http::result::SdkError<crate::error::CreateApiCacheError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The GraphQL API Id.</p>
        pub fn api_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.api_id(input);
            self
        }
        pub fn set_api_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_api_id(input);
            self
        }
        /// <p>TTL in seconds for cache entries.</p>
        /// <p>Valid values are between 1 and 3600 seconds.</p>
        pub fn ttl(mut self, input: i64) -> Self {
            self.inner = self.inner.ttl(input);
            self
        }
        pub fn set_ttl(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_ttl(input);
            self
        }
        /// <p>Transit encryption flag when connecting to cache. This setting cannot be updated after
        /// creation.</p>
        pub fn transit_encryption_enabled(mut self, input: bool) -> Self {
            self.inner = self.inner.transit_encryption_enabled(input);
            self
        }
        pub fn set_transit_encryption_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_transit_encryption_enabled(input);
            self
        }
        /// <p>At rest encryption flag for cache. This setting cannot be updated after creation.</p>
        pub fn at_rest_encryption_enabled(mut self, input: bool) -> Self {
            self.inner = self.inner.at_rest_encryption_enabled(input);
            self
        }
        pub fn set_at_rest_encryption_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_at_rest_encryption_enabled(input);
            self
        }
        /// <p>Caching behavior.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>FULL_REQUEST_CACHING</b>: All requests are fully
        /// cached.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>PER_RESOLVER_CACHING</b>: Individual resolvers
        /// that you specify are cached.</p>
        /// </li>
        /// </ul>
        pub fn api_caching_behavior(mut self, input: crate::model::ApiCachingBehavior) -> Self {
            self.inner = self.inner.api_caching_behavior(input);
            self
        }
        pub fn set_api_caching_behavior(
            mut self,
            input: std::option::Option<crate::model::ApiCachingBehavior>,
        ) -> Self {
            self.inner = self.inner.set_api_caching_behavior(input);
            self
        }
        /// <p>The cache instance type. Valid values are </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>SMALL</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>MEDIUM</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>LARGE</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>XLARGE</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>LARGE_2X</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>LARGE_4X</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>LARGE_8X</code> (not available in all regions)</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>LARGE_12X</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>Historically, instance types were identified by an EC2-style value. As of July 2020, this is deprecated, and the generic identifiers above should be used.</p>
        /// <p>The following legacy instance types are available, but their use is discouraged:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>T2_SMALL</b>: A t2.small instance type.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>T2_MEDIUM</b>: A t2.medium instance type.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>R4_LARGE</b>: A r4.large instance type.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>R4_XLARGE</b>: A r4.xlarge instance type.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>R4_2XLARGE</b>: A r4.2xlarge instance type.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>R4_4XLARGE</b>: A r4.4xlarge instance type.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>R4_8XLARGE</b>: A r4.8xlarge instance type.</p>
        /// </li>
        /// </ul>
        pub fn r#type(mut self, input: crate::model::ApiCacheType) -> Self {
            self.inner = self.inner.r#type(input);
            self
        }
        pub fn set_type(mut self, input: std::option::Option<crate::model::ApiCacheType>) -> Self {
            self.inner = self.inner.set_type(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateApiKey<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_api_key_input::Builder,
    }
    impl<C> CreateApiKey<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateApiKeyOutput,
            smithy_http::result::SdkError<crate::error::CreateApiKeyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID for your GraphQL API.</p>
        pub fn api_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.api_id(input);
            self
        }
        pub fn set_api_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_api_id(input);
            self
        }
        /// <p>A description of the purpose of the API key.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The time from creation time after which the API key expires. The date is represented as
        /// seconds since the epoch, rounded down to the nearest hour. The default value for this
        /// parameter is 7 days from creation time. For more information, see .</p>
        pub fn expires(mut self, input: i64) -> Self {
            self.inner = self.inner.expires(input);
            self
        }
        pub fn set_expires(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_expires(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateDataSource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_data_source_input::Builder,
    }
    impl<C> CreateDataSource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateDataSourceOutput,
            smithy_http::result::SdkError<crate::error::CreateDataSourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The API ID for the GraphQL API for the <code>DataSource</code>.</p>
        pub fn api_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.api_id(input);
            self
        }
        pub fn set_api_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_api_id(input);
            self
        }
        /// <p>A user-supplied name for the <code>DataSource</code>.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>A description of the <code>DataSource</code>.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The type of the <code>DataSource</code>.</p>
        pub fn r#type(mut self, input: crate::model::DataSourceType) -> Self {
            self.inner = self.inner.r#type(input);
            self
        }
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::DataSourceType>,
        ) -> Self {
            self.inner = self.inner.set_type(input);
            self
        }
        /// <p>The Identity and Access Management service role ARN for the data source. The system assumes this role when
        /// accessing the data source.</p>
        pub fn service_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.service_role_arn(input);
            self
        }
        pub fn set_service_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_service_role_arn(input);
            self
        }
        /// <p>Amazon DynamoDB settings.</p>
        pub fn dynamodb_config(mut self, input: crate::model::DynamodbDataSourceConfig) -> Self {
            self.inner = self.inner.dynamodb_config(input);
            self
        }
        pub fn set_dynamodb_config(
            mut self,
            input: std::option::Option<crate::model::DynamodbDataSourceConfig>,
        ) -> Self {
            self.inner = self.inner.set_dynamodb_config(input);
            self
        }
        /// <p>Amazon Web Services Lambda settings.</p>
        pub fn lambda_config(mut self, input: crate::model::LambdaDataSourceConfig) -> Self {
            self.inner = self.inner.lambda_config(input);
            self
        }
        pub fn set_lambda_config(
            mut self,
            input: std::option::Option<crate::model::LambdaDataSourceConfig>,
        ) -> Self {
            self.inner = self.inner.set_lambda_config(input);
            self
        }
        /// <p>Amazon Elasticsearch Service settings.</p>
        pub fn elasticsearch_config(
            mut self,
            input: crate::model::ElasticsearchDataSourceConfig,
        ) -> Self {
            self.inner = self.inner.elasticsearch_config(input);
            self
        }
        pub fn set_elasticsearch_config(
            mut self,
            input: std::option::Option<crate::model::ElasticsearchDataSourceConfig>,
        ) -> Self {
            self.inner = self.inner.set_elasticsearch_config(input);
            self
        }
        /// <p>HTTP endpoint settings.</p>
        pub fn http_config(mut self, input: crate::model::HttpDataSourceConfig) -> Self {
            self.inner = self.inner.http_config(input);
            self
        }
        pub fn set_http_config(
            mut self,
            input: std::option::Option<crate::model::HttpDataSourceConfig>,
        ) -> Self {
            self.inner = self.inner.set_http_config(input);
            self
        }
        /// <p>Relational database settings.</p>
        pub fn relational_database_config(
            mut self,
            input: crate::model::RelationalDatabaseDataSourceConfig,
        ) -> Self {
            self.inner = self.inner.relational_database_config(input);
            self
        }
        pub fn set_relational_database_config(
            mut self,
            input: std::option::Option<crate::model::RelationalDatabaseDataSourceConfig>,
        ) -> Self {
            self.inner = self.inner.set_relational_database_config(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateFunction<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_function_input::Builder,
    }
    impl<C> CreateFunction<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateFunctionOutput,
            smithy_http::result::SdkError<crate::error::CreateFunctionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The GraphQL API ID.</p>
        pub fn api_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.api_id(input);
            self
        }
        pub fn set_api_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_api_id(input);
            self
        }
        /// <p>The <code>Function</code> name. The function name does not have to be unique.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The <code>Function</code> description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The <code>Function</code>
        /// <code>DataSource</code> name.</p>
        pub fn data_source_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.data_source_name(input);
            self
        }
        pub fn set_data_source_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_data_source_name(input);
            self
        }
        /// <p>The <code>Function</code> request mapping template. Functions support only the
        /// 2018-05-29 version of the request mapping template.</p>
        pub fn request_mapping_template(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.request_mapping_template(input);
            self
        }
        pub fn set_request_mapping_template(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_request_mapping_template(input);
            self
        }
        /// <p>The <code>Function</code> response mapping template. </p>
        pub fn response_mapping_template(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.response_mapping_template(input);
            self
        }
        pub fn set_response_mapping_template(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_response_mapping_template(input);
            self
        }
        /// <p>The <code>version</code> of the request mapping template. Currently the supported value
        /// is 2018-05-29. </p>
        pub fn function_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.function_version(input);
            self
        }
        pub fn set_function_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_function_version(input);
            self
        }
        /// <p>Describes a Sync configuration for a resolver.</p>
        /// <p>Contains information on which Conflict Detection as well as Resolution strategy should
        /// be performed when the resolver is invoked.</p>
        pub fn sync_config(mut self, input: crate::model::SyncConfig) -> Self {
            self.inner = self.inner.sync_config(input);
            self
        }
        pub fn set_sync_config(
            mut self,
            input: std::option::Option<crate::model::SyncConfig>,
        ) -> Self {
            self.inner = self.inner.set_sync_config(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateGraphqlApi<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_graphql_api_input::Builder,
    }
    impl<C> CreateGraphqlApi<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateGraphqlApiOutput,
            smithy_http::result::SdkError<crate::error::CreateGraphqlApiError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A user-supplied name for the <code>GraphqlApi</code>.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The Amazon CloudWatch Logs configuration.</p>
        pub fn log_config(mut self, input: crate::model::LogConfig) -> Self {
            self.inner = self.inner.log_config(input);
            self
        }
        pub fn set_log_config(
            mut self,
            input: std::option::Option<crate::model::LogConfig>,
        ) -> Self {
            self.inner = self.inner.set_log_config(input);
            self
        }
        /// <p>The authentication type: API key, Identity and Access Management, OIDC, or Amazon Cognito user pools.</p>
        pub fn authentication_type(mut self, input: crate::model::AuthenticationType) -> Self {
            self.inner = self.inner.authentication_type(input);
            self
        }
        pub fn set_authentication_type(
            mut self,
            input: std::option::Option<crate::model::AuthenticationType>,
        ) -> Self {
            self.inner = self.inner.set_authentication_type(input);
            self
        }
        /// <p>The Amazon Cognito user pool configuration.</p>
        pub fn user_pool_config(mut self, input: crate::model::UserPoolConfig) -> Self {
            self.inner = self.inner.user_pool_config(input);
            self
        }
        pub fn set_user_pool_config(
            mut self,
            input: std::option::Option<crate::model::UserPoolConfig>,
        ) -> Self {
            self.inner = self.inner.set_user_pool_config(input);
            self
        }
        /// <p>The OpenID Connect configuration.</p>
        pub fn open_id_connect_config(mut self, input: crate::model::OpenIdConnectConfig) -> Self {
            self.inner = self.inner.open_id_connect_config(input);
            self
        }
        pub fn set_open_id_connect_config(
            mut self,
            input: std::option::Option<crate::model::OpenIdConnectConfig>,
        ) -> Self {
            self.inner = self.inner.set_open_id_connect_config(input);
            self
        }
        /// <p>A <code>TagMap</code> object.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>A list of additional authentication providers for the <code>GraphqlApi</code>
        /// API.</p>
        pub fn additional_authentication_providers(
            mut self,
            inp: impl Into<crate::model::AdditionalAuthenticationProvider>,
        ) -> Self {
            self.inner = self.inner.additional_authentication_providers(inp);
            self
        }
        pub fn set_additional_authentication_providers(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::AdditionalAuthenticationProvider>,
            >,
        ) -> Self {
            self.inner = self.inner.set_additional_authentication_providers(input);
            self
        }
        /// <p>A flag indicating whether to enable X-Ray tracing for the
        /// <code>GraphqlApi</code>.</p>
        pub fn xray_enabled(mut self, input: bool) -> Self {
            self.inner = self.inner.xray_enabled(input);
            self
        }
        pub fn set_xray_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_xray_enabled(input);
            self
        }
        /// <p>Configuration for AWS Lambda function authorization.</p>
        pub fn lambda_authorizer_config(
            mut self,
            input: crate::model::LambdaAuthorizerConfig,
        ) -> Self {
            self.inner = self.inner.lambda_authorizer_config(input);
            self
        }
        pub fn set_lambda_authorizer_config(
            mut self,
            input: std::option::Option<crate::model::LambdaAuthorizerConfig>,
        ) -> Self {
            self.inner = self.inner.set_lambda_authorizer_config(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateResolver<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_resolver_input::Builder,
    }
    impl<C> CreateResolver<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateResolverOutput,
            smithy_http::result::SdkError<crate::error::CreateResolverError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID for the GraphQL API for which the resolver is being created.</p>
        pub fn api_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.api_id(input);
            self
        }
        pub fn set_api_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_api_id(input);
            self
        }
        /// <p>The name of the <code>Type</code>.</p>
        pub fn type_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.type_name(input);
            self
        }
        pub fn set_type_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_type_name(input);
            self
        }
        /// <p>The name of the field to attach the resolver to.</p>
        pub fn field_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.field_name(input);
            self
        }
        pub fn set_field_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_field_name(input);
            self
        }
        /// <p>The name of the data source for which the resolver is being created.</p>
        pub fn data_source_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.data_source_name(input);
            self
        }
        pub fn set_data_source_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_data_source_name(input);
            self
        }
        /// <p>The mapping template to be used for requests.</p>
        /// <p>A resolver uses a request mapping template to convert a GraphQL expression into a format
        /// that a data source can understand. Mapping templates are written in Apache Velocity
        /// Template Language (VTL).</p>
        /// <p>VTL request mapping templates are optional when using a Lambda data source. For all
        /// other data sources, VTL request and response mapping templates are required.</p>
        pub fn request_mapping_template(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.request_mapping_template(input);
            self
        }
        pub fn set_request_mapping_template(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_request_mapping_template(input);
            self
        }
        /// <p>The mapping template to be used for responses from the data source.</p>
        pub fn response_mapping_template(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.response_mapping_template(input);
            self
        }
        pub fn set_response_mapping_template(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_response_mapping_template(input);
            self
        }
        /// <p>The resolver type.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>UNIT</b>: A UNIT resolver type. A UNIT resolver is
        /// the default resolver type. A UNIT resolver enables you to execute a GraphQL query
        /// against a single data source.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>PIPELINE</b>: A PIPELINE resolver type. A PIPELINE
        /// resolver enables you to execute a series of <code>Function</code> in a serial manner.
        /// You can use a pipeline resolver to execute a GraphQL query against multiple data
        /// sources.</p>
        /// </li>
        /// </ul>
        pub fn kind(mut self, input: crate::model::ResolverKind) -> Self {
            self.inner = self.inner.kind(input);
            self
        }
        pub fn set_kind(mut self, input: std::option::Option<crate::model::ResolverKind>) -> Self {
            self.inner = self.inner.set_kind(input);
            self
        }
        /// <p>The <code>PipelineConfig</code>.</p>
        pub fn pipeline_config(mut self, input: crate::model::PipelineConfig) -> Self {
            self.inner = self.inner.pipeline_config(input);
            self
        }
        pub fn set_pipeline_config(
            mut self,
            input: std::option::Option<crate::model::PipelineConfig>,
        ) -> Self {
            self.inner = self.inner.set_pipeline_config(input);
            self
        }
        /// <p>The <code>SyncConfig</code> for a resolver attached to a versioned datasource.</p>
        pub fn sync_config(mut self, input: crate::model::SyncConfig) -> Self {
            self.inner = self.inner.sync_config(input);
            self
        }
        pub fn set_sync_config(
            mut self,
            input: std::option::Option<crate::model::SyncConfig>,
        ) -> Self {
            self.inner = self.inner.set_sync_config(input);
            self
        }
        /// <p>The caching configuration for the resolver.</p>
        pub fn caching_config(mut self, input: crate::model::CachingConfig) -> Self {
            self.inner = self.inner.caching_config(input);
            self
        }
        pub fn set_caching_config(
            mut self,
            input: std::option::Option<crate::model::CachingConfig>,
        ) -> Self {
            self.inner = self.inner.set_caching_config(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateType<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_type_input::Builder,
    }
    impl<C> CreateType<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateTypeOutput,
            smithy_http::result::SdkError<crate::error::CreateTypeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The API ID.</p>
        pub fn api_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.api_id(input);
            self
        }
        pub fn set_api_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_api_id(input);
            self
        }
        /// <p>The type definition, in GraphQL Schema Definition Language (SDL) format.</p>
        /// <p>For more information, see the <a href="http://graphql.org/learn/schema/">GraphQL SDL
        /// documentation</a>.</p>
        pub fn definition(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.definition(input);
            self
        }
        pub fn set_definition(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_definition(input);
            self
        }
        /// <p>The type format: SDL or JSON.</p>
        pub fn format(mut self, input: crate::model::TypeDefinitionFormat) -> Self {
            self.inner = self.inner.format(input);
            self
        }
        pub fn set_format(
            mut self,
            input: std::option::Option<crate::model::TypeDefinitionFormat>,
        ) -> Self {
            self.inner = self.inner.set_format(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteApiCache<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_api_cache_input::Builder,
    }
    impl<C> DeleteApiCache<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteApiCacheOutput,
            smithy_http::result::SdkError<crate::error::DeleteApiCacheError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The API ID.</p>
        pub fn api_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.api_id(input);
            self
        }
        pub fn set_api_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_api_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteApiKey<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_api_key_input::Builder,
    }
    impl<C> DeleteApiKey<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteApiKeyOutput,
            smithy_http::result::SdkError<crate::error::DeleteApiKeyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The API ID.</p>
        pub fn api_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.api_id(input);
            self
        }
        pub fn set_api_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_api_id(input);
            self
        }
        /// <p>The ID for the API key.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteDataSource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_data_source_input::Builder,
    }
    impl<C> DeleteDataSource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteDataSourceOutput,
            smithy_http::result::SdkError<crate::error::DeleteDataSourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The API ID.</p>
        pub fn api_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.api_id(input);
            self
        }
        pub fn set_api_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_api_id(input);
            self
        }
        /// <p>The name of the data source.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteFunction<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_function_input::Builder,
    }
    impl<C> DeleteFunction<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteFunctionOutput,
            smithy_http::result::SdkError<crate::error::DeleteFunctionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The GraphQL API ID.</p>
        pub fn api_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.api_id(input);
            self
        }
        pub fn set_api_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_api_id(input);
            self
        }
        /// <p>The <code>Function</code> ID.</p>
        pub fn function_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.function_id(input);
            self
        }
        pub fn set_function_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_function_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteGraphqlApi<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_graphql_api_input::Builder,
    }
    impl<C> DeleteGraphqlApi<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteGraphqlApiOutput,
            smithy_http::result::SdkError<crate::error::DeleteGraphqlApiError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The API ID.</p>
        pub fn api_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.api_id(input);
            self
        }
        pub fn set_api_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_api_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteResolver<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_resolver_input::Builder,
    }
    impl<C> DeleteResolver<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteResolverOutput,
            smithy_http::result::SdkError<crate::error::DeleteResolverError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The API ID.</p>
        pub fn api_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.api_id(input);
            self
        }
        pub fn set_api_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_api_id(input);
            self
        }
        /// <p>The name of the resolver type.</p>
        pub fn type_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.type_name(input);
            self
        }
        pub fn set_type_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_type_name(input);
            self
        }
        /// <p>The resolver field name.</p>
        pub fn field_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.field_name(input);
            self
        }
        pub fn set_field_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_field_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteType<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_type_input::Builder,
    }
    impl<C> DeleteType<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteTypeOutput,
            smithy_http::result::SdkError<crate::error::DeleteTypeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The API ID.</p>
        pub fn api_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.api_id(input);
            self
        }
        pub fn set_api_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_api_id(input);
            self
        }
        /// <p>The type name.</p>
        pub fn type_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.type_name(input);
            self
        }
        pub fn set_type_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_type_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct FlushApiCache<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::flush_api_cache_input::Builder,
    }
    impl<C> FlushApiCache<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::FlushApiCacheOutput,
            smithy_http::result::SdkError<crate::error::FlushApiCacheError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The API ID.</p>
        pub fn api_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.api_id(input);
            self
        }
        pub fn set_api_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_api_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetApiCache<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_api_cache_input::Builder,
    }
    impl<C> GetApiCache<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetApiCacheOutput,
            smithy_http::result::SdkError<crate::error::GetApiCacheError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The API ID.</p>
        pub fn api_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.api_id(input);
            self
        }
        pub fn set_api_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_api_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetDataSource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_data_source_input::Builder,
    }
    impl<C> GetDataSource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetDataSourceOutput,
            smithy_http::result::SdkError<crate::error::GetDataSourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The API ID.</p>
        pub fn api_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.api_id(input);
            self
        }
        pub fn set_api_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_api_id(input);
            self
        }
        /// <p>The name of the data source.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetFunction<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_function_input::Builder,
    }
    impl<C> GetFunction<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetFunctionOutput,
            smithy_http::result::SdkError<crate::error::GetFunctionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The GraphQL API ID.</p>
        pub fn api_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.api_id(input);
            self
        }
        pub fn set_api_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_api_id(input);
            self
        }
        /// <p>The <code>Function</code> ID.</p>
        pub fn function_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.function_id(input);
            self
        }
        pub fn set_function_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_function_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetGraphqlApi<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_graphql_api_input::Builder,
    }
    impl<C> GetGraphqlApi<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetGraphqlApiOutput,
            smithy_http::result::SdkError<crate::error::GetGraphqlApiError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The API ID for the GraphQL API.</p>
        pub fn api_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.api_id(input);
            self
        }
        pub fn set_api_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_api_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetIntrospectionSchema<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_introspection_schema_input::Builder,
    }
    impl<C> GetIntrospectionSchema<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetIntrospectionSchemaOutput,
            smithy_http::result::SdkError<crate::error::GetIntrospectionSchemaError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The API ID.</p>
        pub fn api_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.api_id(input);
            self
        }
        pub fn set_api_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_api_id(input);
            self
        }
        /// <p>The schema format: SDL or JSON.</p>
        pub fn format(mut self, input: crate::model::OutputType) -> Self {
            self.inner = self.inner.format(input);
            self
        }
        pub fn set_format(mut self, input: std::option::Option<crate::model::OutputType>) -> Self {
            self.inner = self.inner.set_format(input);
            self
        }
        /// <p>A flag that specifies whether the schema introspection should contain directives.</p>
        pub fn include_directives(mut self, input: bool) -> Self {
            self.inner = self.inner.include_directives(input);
            self
        }
        pub fn set_include_directives(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_include_directives(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetResolver<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_resolver_input::Builder,
    }
    impl<C> GetResolver<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetResolverOutput,
            smithy_http::result::SdkError<crate::error::GetResolverError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The API ID.</p>
        pub fn api_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.api_id(input);
            self
        }
        pub fn set_api_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_api_id(input);
            self
        }
        /// <p>The resolver type name.</p>
        pub fn type_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.type_name(input);
            self
        }
        pub fn set_type_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_type_name(input);
            self
        }
        /// <p>The resolver field name.</p>
        pub fn field_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.field_name(input);
            self
        }
        pub fn set_field_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_field_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetSchemaCreationStatus<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_schema_creation_status_input::Builder,
    }
    impl<C> GetSchemaCreationStatus<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetSchemaCreationStatusOutput,
            smithy_http::result::SdkError<crate::error::GetSchemaCreationStatusError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The API ID.</p>
        pub fn api_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.api_id(input);
            self
        }
        pub fn set_api_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_api_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetType<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_type_input::Builder,
    }
    impl<C> GetType<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetTypeOutput,
            smithy_http::result::SdkError<crate::error::GetTypeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The API ID.</p>
        pub fn api_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.api_id(input);
            self
        }
        pub fn set_api_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_api_id(input);
            self
        }
        /// <p>The type name.</p>
        pub fn type_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.type_name(input);
            self
        }
        pub fn set_type_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_type_name(input);
            self
        }
        /// <p>The type format: SDL or JSON.</p>
        pub fn format(mut self, input: crate::model::TypeDefinitionFormat) -> Self {
            self.inner = self.inner.format(input);
            self
        }
        pub fn set_format(
            mut self,
            input: std::option::Option<crate::model::TypeDefinitionFormat>,
        ) -> Self {
            self.inner = self.inner.set_format(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListApiKeys<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_api_keys_input::Builder,
    }
    impl<C> ListApiKeys<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListApiKeysOutput,
            smithy_http::result::SdkError<crate::error::ListApiKeysError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The API ID.</p>
        pub fn api_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.api_id(input);
            self
        }
        pub fn set_api_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_api_id(input);
            self
        }
        /// <p>An identifier that was returned from the previous call to this operation, which can be
        /// used to return the next set of items in the list.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of results you want the request to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListDataSources<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_data_sources_input::Builder,
    }
    impl<C> ListDataSources<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListDataSourcesOutput,
            smithy_http::result::SdkError<crate::error::ListDataSourcesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The API ID.</p>
        pub fn api_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.api_id(input);
            self
        }
        pub fn set_api_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_api_id(input);
            self
        }
        /// <p>An identifier that was returned from the previous call to this operation, which can be
        /// used to return the next set of items in the list. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of results you want the request to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListFunctions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_functions_input::Builder,
    }
    impl<C> ListFunctions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListFunctionsOutput,
            smithy_http::result::SdkError<crate::error::ListFunctionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The GraphQL API ID.</p>
        pub fn api_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.api_id(input);
            self
        }
        pub fn set_api_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_api_id(input);
            self
        }
        /// <p>An identifier that was returned from the previous call to this operation, which can be
        /// used to return the next set of items in the list.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of results you want the request to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListGraphqlApis<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_graphql_apis_input::Builder,
    }
    impl<C> ListGraphqlApis<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListGraphqlApisOutput,
            smithy_http::result::SdkError<crate::error::ListGraphqlApisError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An identifier that was returned from the previous call to this operation, which can be
        /// used to return the next set of items in the list. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of results you want the request to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListResolvers<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_resolvers_input::Builder,
    }
    impl<C> ListResolvers<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListResolversOutput,
            smithy_http::result::SdkError<crate::error::ListResolversError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The API ID.</p>
        pub fn api_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.api_id(input);
            self
        }
        pub fn set_api_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_api_id(input);
            self
        }
        /// <p>The type name.</p>
        pub fn type_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.type_name(input);
            self
        }
        pub fn set_type_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_type_name(input);
            self
        }
        /// <p>An identifier that was returned from the previous call to this operation, which can be
        /// used to return the next set of items in the list. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of results you want the request to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListResolversByFunction<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_resolvers_by_function_input::Builder,
    }
    impl<C> ListResolversByFunction<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListResolversByFunctionOutput,
            smithy_http::result::SdkError<crate::error::ListResolversByFunctionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The API ID.</p>
        pub fn api_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.api_id(input);
            self
        }
        pub fn set_api_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_api_id(input);
            self
        }
        /// <p>The Function ID.</p>
        pub fn function_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.function_id(input);
            self
        }
        pub fn set_function_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_function_id(input);
            self
        }
        /// <p>An identifier that was returned from the previous call to this operation, which you can
        /// use to return the next set of items in the list.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of results you want the request to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTagsForResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_tags_for_resource_input::Builder,
    }
    impl<C> ListTagsForResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTagsForResourceOutput,
            smithy_http::result::SdkError<crate::error::ListTagsForResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The <code>GraphqlApi</code> ARN.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTypes<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_types_input::Builder,
    }
    impl<C> ListTypes<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTypesOutput,
            smithy_http::result::SdkError<crate::error::ListTypesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The API ID.</p>
        pub fn api_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.api_id(input);
            self
        }
        pub fn set_api_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_api_id(input);
            self
        }
        /// <p>The type format: SDL or JSON.</p>
        pub fn format(mut self, input: crate::model::TypeDefinitionFormat) -> Self {
            self.inner = self.inner.format(input);
            self
        }
        pub fn set_format(
            mut self,
            input: std::option::Option<crate::model::TypeDefinitionFormat>,
        ) -> Self {
            self.inner = self.inner.set_format(input);
            self
        }
        /// <p>An identifier that was returned from the previous call to this operation, which can be
        /// used to return the next set of items in the list. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of results you want the request to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StartSchemaCreation<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::start_schema_creation_input::Builder,
    }
    impl<C> StartSchemaCreation<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StartSchemaCreationOutput,
            smithy_http::result::SdkError<crate::error::StartSchemaCreationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The API ID.</p>
        pub fn api_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.api_id(input);
            self
        }
        pub fn set_api_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_api_id(input);
            self
        }
        /// <p>The schema definition, in GraphQL schema language format.</p>
        pub fn definition(mut self, input: smithy_types::Blob) -> Self {
            self.inner = self.inner.definition(input);
            self
        }
        pub fn set_definition(mut self, input: std::option::Option<smithy_types::Blob>) -> Self {
            self.inner = self.inner.set_definition(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TagResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::tag_resource_input::Builder,
    }
    impl<C> TagResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::TagResourceOutput,
            smithy_http::result::SdkError<crate::error::TagResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The <code>GraphqlApi</code> ARN.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>A <code>TagMap</code> object.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UntagResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::untag_resource_input::Builder,
    }
    impl<C> UntagResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UntagResourceOutput,
            smithy_http::result::SdkError<crate::error::UntagResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The <code>GraphqlApi</code> ARN.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>A list of <code>TagKey</code> objects.</p>
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tag_keys(inp);
            self
        }
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tag_keys(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateApiCache<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_api_cache_input::Builder,
    }
    impl<C> UpdateApiCache<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateApiCacheOutput,
            smithy_http::result::SdkError<crate::error::UpdateApiCacheError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The GraphQL API Id.</p>
        pub fn api_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.api_id(input);
            self
        }
        pub fn set_api_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_api_id(input);
            self
        }
        /// <p>TTL in seconds for cache entries.</p>
        /// <p>Valid values are between 1 and 3600 seconds.</p>
        pub fn ttl(mut self, input: i64) -> Self {
            self.inner = self.inner.ttl(input);
            self
        }
        pub fn set_ttl(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_ttl(input);
            self
        }
        /// <p>Caching behavior.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>FULL_REQUEST_CACHING</b>: All requests are fully
        /// cached.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>PER_RESOLVER_CACHING</b>: Individual resolvers
        /// that you specify are cached.</p>
        /// </li>
        /// </ul>
        pub fn api_caching_behavior(mut self, input: crate::model::ApiCachingBehavior) -> Self {
            self.inner = self.inner.api_caching_behavior(input);
            self
        }
        pub fn set_api_caching_behavior(
            mut self,
            input: std::option::Option<crate::model::ApiCachingBehavior>,
        ) -> Self {
            self.inner = self.inner.set_api_caching_behavior(input);
            self
        }
        /// <p>The cache instance type. Valid values are </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>SMALL</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>MEDIUM</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>LARGE</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>XLARGE</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>LARGE_2X</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>LARGE_4X</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>LARGE_8X</code> (not available in all regions)</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>LARGE_12X</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>Historically, instance types were identified by an EC2-style value. As of July 2020, this is deprecated, and the generic identifiers above should be used.</p>
        /// <p>The following legacy instance types are available, but their use is discouraged:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>T2_SMALL</b>: A t2.small instance type.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>T2_MEDIUM</b>: A t2.medium instance type.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>R4_LARGE</b>: A r4.large instance type.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>R4_XLARGE</b>: A r4.xlarge instance type.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>R4_2XLARGE</b>: A r4.2xlarge instance type.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>R4_4XLARGE</b>: A r4.4xlarge instance type.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>R4_8XLARGE</b>: A r4.8xlarge instance type.</p>
        /// </li>
        /// </ul>
        pub fn r#type(mut self, input: crate::model::ApiCacheType) -> Self {
            self.inner = self.inner.r#type(input);
            self
        }
        pub fn set_type(mut self, input: std::option::Option<crate::model::ApiCacheType>) -> Self {
            self.inner = self.inner.set_type(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateApiKey<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_api_key_input::Builder,
    }
    impl<C> UpdateApiKey<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateApiKeyOutput,
            smithy_http::result::SdkError<crate::error::UpdateApiKeyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID for the GraphQL API.</p>
        pub fn api_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.api_id(input);
            self
        }
        pub fn set_api_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_api_id(input);
            self
        }
        /// <p>The API key ID.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.id(input);
            self
        }
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_id(input);
            self
        }
        /// <p>A description of the purpose of the API key.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The time from update time after which the API key expires. The date is represented as
        /// seconds since the epoch. For more information, see .</p>
        pub fn expires(mut self, input: i64) -> Self {
            self.inner = self.inner.expires(input);
            self
        }
        pub fn set_expires(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_expires(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateDataSource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_data_source_input::Builder,
    }
    impl<C> UpdateDataSource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateDataSourceOutput,
            smithy_http::result::SdkError<crate::error::UpdateDataSourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The API ID.</p>
        pub fn api_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.api_id(input);
            self
        }
        pub fn set_api_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_api_id(input);
            self
        }
        /// <p>The new name for the data source.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The new description for the data source.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The new data source type.</p>
        pub fn r#type(mut self, input: crate::model::DataSourceType) -> Self {
            self.inner = self.inner.r#type(input);
            self
        }
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::DataSourceType>,
        ) -> Self {
            self.inner = self.inner.set_type(input);
            self
        }
        /// <p>The new service role ARN for the data source.</p>
        pub fn service_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.service_role_arn(input);
            self
        }
        pub fn set_service_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_service_role_arn(input);
            self
        }
        /// <p>The new Amazon DynamoDB configuration.</p>
        pub fn dynamodb_config(mut self, input: crate::model::DynamodbDataSourceConfig) -> Self {
            self.inner = self.inner.dynamodb_config(input);
            self
        }
        pub fn set_dynamodb_config(
            mut self,
            input: std::option::Option<crate::model::DynamodbDataSourceConfig>,
        ) -> Self {
            self.inner = self.inner.set_dynamodb_config(input);
            self
        }
        /// <p>The new Amazon Web Services Lambda configuration.</p>
        pub fn lambda_config(mut self, input: crate::model::LambdaDataSourceConfig) -> Self {
            self.inner = self.inner.lambda_config(input);
            self
        }
        pub fn set_lambda_config(
            mut self,
            input: std::option::Option<crate::model::LambdaDataSourceConfig>,
        ) -> Self {
            self.inner = self.inner.set_lambda_config(input);
            self
        }
        /// <p>The new Elasticsearch Service configuration.</p>
        pub fn elasticsearch_config(
            mut self,
            input: crate::model::ElasticsearchDataSourceConfig,
        ) -> Self {
            self.inner = self.inner.elasticsearch_config(input);
            self
        }
        pub fn set_elasticsearch_config(
            mut self,
            input: std::option::Option<crate::model::ElasticsearchDataSourceConfig>,
        ) -> Self {
            self.inner = self.inner.set_elasticsearch_config(input);
            self
        }
        /// <p>The new HTTP endpoint configuration.</p>
        pub fn http_config(mut self, input: crate::model::HttpDataSourceConfig) -> Self {
            self.inner = self.inner.http_config(input);
            self
        }
        pub fn set_http_config(
            mut self,
            input: std::option::Option<crate::model::HttpDataSourceConfig>,
        ) -> Self {
            self.inner = self.inner.set_http_config(input);
            self
        }
        /// <p>The new relational database configuration.</p>
        pub fn relational_database_config(
            mut self,
            input: crate::model::RelationalDatabaseDataSourceConfig,
        ) -> Self {
            self.inner = self.inner.relational_database_config(input);
            self
        }
        pub fn set_relational_database_config(
            mut self,
            input: std::option::Option<crate::model::RelationalDatabaseDataSourceConfig>,
        ) -> Self {
            self.inner = self.inner.set_relational_database_config(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateFunction<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_function_input::Builder,
    }
    impl<C> UpdateFunction<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateFunctionOutput,
            smithy_http::result::SdkError<crate::error::UpdateFunctionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The GraphQL API ID.</p>
        pub fn api_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.api_id(input);
            self
        }
        pub fn set_api_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_api_id(input);
            self
        }
        /// <p>The <code>Function</code> name.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The <code>Function</code> description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The function ID.</p>
        pub fn function_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.function_id(input);
            self
        }
        pub fn set_function_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_function_id(input);
            self
        }
        /// <p>The <code>Function</code>
        /// <code>DataSource</code> name.</p>
        pub fn data_source_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.data_source_name(input);
            self
        }
        pub fn set_data_source_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_data_source_name(input);
            self
        }
        /// <p>The <code>Function</code> request mapping template. Functions support only the
        /// 2018-05-29 version of the request mapping template.</p>
        pub fn request_mapping_template(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.request_mapping_template(input);
            self
        }
        pub fn set_request_mapping_template(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_request_mapping_template(input);
            self
        }
        /// <p>The <code>Function</code> request mapping template. </p>
        pub fn response_mapping_template(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.response_mapping_template(input);
            self
        }
        pub fn set_response_mapping_template(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_response_mapping_template(input);
            self
        }
        /// <p>The <code>version</code> of the request mapping template. Currently the supported value
        /// is 2018-05-29. </p>
        pub fn function_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.function_version(input);
            self
        }
        pub fn set_function_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_function_version(input);
            self
        }
        /// <p>Describes a Sync configuration for a resolver.</p>
        /// <p>Contains information on which Conflict Detection as well as Resolution strategy should
        /// be performed when the resolver is invoked.</p>
        pub fn sync_config(mut self, input: crate::model::SyncConfig) -> Self {
            self.inner = self.inner.sync_config(input);
            self
        }
        pub fn set_sync_config(
            mut self,
            input: std::option::Option<crate::model::SyncConfig>,
        ) -> Self {
            self.inner = self.inner.set_sync_config(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateGraphqlApi<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_graphql_api_input::Builder,
    }
    impl<C> UpdateGraphqlApi<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateGraphqlApiOutput,
            smithy_http::result::SdkError<crate::error::UpdateGraphqlApiError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The API ID.</p>
        pub fn api_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.api_id(input);
            self
        }
        pub fn set_api_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_api_id(input);
            self
        }
        /// <p>The new name for the <code>GraphqlApi</code> object.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The Amazon CloudWatch Logs configuration for the <code>GraphqlApi</code> object.</p>
        pub fn log_config(mut self, input: crate::model::LogConfig) -> Self {
            self.inner = self.inner.log_config(input);
            self
        }
        pub fn set_log_config(
            mut self,
            input: std::option::Option<crate::model::LogConfig>,
        ) -> Self {
            self.inner = self.inner.set_log_config(input);
            self
        }
        /// <p>The new authentication type for the <code>GraphqlApi</code> object.</p>
        pub fn authentication_type(mut self, input: crate::model::AuthenticationType) -> Self {
            self.inner = self.inner.authentication_type(input);
            self
        }
        pub fn set_authentication_type(
            mut self,
            input: std::option::Option<crate::model::AuthenticationType>,
        ) -> Self {
            self.inner = self.inner.set_authentication_type(input);
            self
        }
        /// <p>The new Amazon Cognito user pool configuration for the <code>GraphqlApi</code>
        /// object.</p>
        pub fn user_pool_config(mut self, input: crate::model::UserPoolConfig) -> Self {
            self.inner = self.inner.user_pool_config(input);
            self
        }
        pub fn set_user_pool_config(
            mut self,
            input: std::option::Option<crate::model::UserPoolConfig>,
        ) -> Self {
            self.inner = self.inner.set_user_pool_config(input);
            self
        }
        /// <p>The OpenID Connect configuration for the <code>GraphqlApi</code> object.</p>
        pub fn open_id_connect_config(mut self, input: crate::model::OpenIdConnectConfig) -> Self {
            self.inner = self.inner.open_id_connect_config(input);
            self
        }
        pub fn set_open_id_connect_config(
            mut self,
            input: std::option::Option<crate::model::OpenIdConnectConfig>,
        ) -> Self {
            self.inner = self.inner.set_open_id_connect_config(input);
            self
        }
        /// <p>A list of additional authentication providers for the <code>GraphqlApi</code>
        /// API.</p>
        pub fn additional_authentication_providers(
            mut self,
            inp: impl Into<crate::model::AdditionalAuthenticationProvider>,
        ) -> Self {
            self.inner = self.inner.additional_authentication_providers(inp);
            self
        }
        pub fn set_additional_authentication_providers(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::AdditionalAuthenticationProvider>,
            >,
        ) -> Self {
            self.inner = self.inner.set_additional_authentication_providers(input);
            self
        }
        /// <p>A flag indicating whether to enable X-Ray tracing for the
        /// <code>GraphqlApi</code>.</p>
        pub fn xray_enabled(mut self, input: bool) -> Self {
            self.inner = self.inner.xray_enabled(input);
            self
        }
        pub fn set_xray_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_xray_enabled(input);
            self
        }
        /// <p>Configuration for AWS Lambda function authorization.</p>
        pub fn lambda_authorizer_config(
            mut self,
            input: crate::model::LambdaAuthorizerConfig,
        ) -> Self {
            self.inner = self.inner.lambda_authorizer_config(input);
            self
        }
        pub fn set_lambda_authorizer_config(
            mut self,
            input: std::option::Option<crate::model::LambdaAuthorizerConfig>,
        ) -> Self {
            self.inner = self.inner.set_lambda_authorizer_config(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateResolver<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_resolver_input::Builder,
    }
    impl<C> UpdateResolver<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateResolverOutput,
            smithy_http::result::SdkError<crate::error::UpdateResolverError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The API ID.</p>
        pub fn api_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.api_id(input);
            self
        }
        pub fn set_api_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_api_id(input);
            self
        }
        /// <p>The new type name.</p>
        pub fn type_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.type_name(input);
            self
        }
        pub fn set_type_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_type_name(input);
            self
        }
        /// <p>The new field name.</p>
        pub fn field_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.field_name(input);
            self
        }
        pub fn set_field_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_field_name(input);
            self
        }
        /// <p>The new data source name.</p>
        pub fn data_source_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.data_source_name(input);
            self
        }
        pub fn set_data_source_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_data_source_name(input);
            self
        }
        /// <p>The new request mapping template.</p>
        /// <p>A resolver uses a request mapping template to convert a GraphQL expression into a format
        /// that a data source can understand. Mapping templates are written in Apache Velocity
        /// Template Language (VTL).</p>
        /// <p>VTL request mapping templates are optional when using a Lambda data source. For all
        /// other data sources, VTL request and response mapping templates are required.</p>
        pub fn request_mapping_template(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.request_mapping_template(input);
            self
        }
        pub fn set_request_mapping_template(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_request_mapping_template(input);
            self
        }
        /// <p>The new response mapping template.</p>
        pub fn response_mapping_template(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.response_mapping_template(input);
            self
        }
        pub fn set_response_mapping_template(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_response_mapping_template(input);
            self
        }
        /// <p>The resolver type.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>UNIT</b>: A UNIT resolver type. A UNIT resolver is
        /// the default resolver type. A UNIT resolver enables you to execute a GraphQL query
        /// against a single data source.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>PIPELINE</b>: A PIPELINE resolver type. A PIPELINE
        /// resolver enables you to execute a series of <code>Function</code> in a serial manner.
        /// You can use a pipeline resolver to execute a GraphQL query against multiple data
        /// sources.</p>
        /// </li>
        /// </ul>
        pub fn kind(mut self, input: crate::model::ResolverKind) -> Self {
            self.inner = self.inner.kind(input);
            self
        }
        pub fn set_kind(mut self, input: std::option::Option<crate::model::ResolverKind>) -> Self {
            self.inner = self.inner.set_kind(input);
            self
        }
        /// <p>The <code>PipelineConfig</code>.</p>
        pub fn pipeline_config(mut self, input: crate::model::PipelineConfig) -> Self {
            self.inner = self.inner.pipeline_config(input);
            self
        }
        pub fn set_pipeline_config(
            mut self,
            input: std::option::Option<crate::model::PipelineConfig>,
        ) -> Self {
            self.inner = self.inner.set_pipeline_config(input);
            self
        }
        /// <p>The <code>SyncConfig</code> for a resolver attached to a versioned datasource.</p>
        pub fn sync_config(mut self, input: crate::model::SyncConfig) -> Self {
            self.inner = self.inner.sync_config(input);
            self
        }
        pub fn set_sync_config(
            mut self,
            input: std::option::Option<crate::model::SyncConfig>,
        ) -> Self {
            self.inner = self.inner.set_sync_config(input);
            self
        }
        /// <p>The caching configuration for the resolver.</p>
        pub fn caching_config(mut self, input: crate::model::CachingConfig) -> Self {
            self.inner = self.inner.caching_config(input);
            self
        }
        pub fn set_caching_config(
            mut self,
            input: std::option::Option<crate::model::CachingConfig>,
        ) -> Self {
            self.inner = self.inner.set_caching_config(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateType<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_type_input::Builder,
    }
    impl<C> UpdateType<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateTypeOutput,
            smithy_http::result::SdkError<crate::error::UpdateTypeError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The API ID.</p>
        pub fn api_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.api_id(input);
            self
        }
        pub fn set_api_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_api_id(input);
            self
        }
        /// <p>The new type name.</p>
        pub fn type_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.type_name(input);
            self
        }
        pub fn set_type_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_type_name(input);
            self
        }
        /// <p>The new definition.</p>
        pub fn definition(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.definition(input);
            self
        }
        pub fn set_definition(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_definition(input);
            self
        }
        /// <p>The new type format: SDL or JSON.</p>
        pub fn format(mut self, input: crate::model::TypeDefinitionFormat) -> Self {
            self.inner = self.inner.format(input);
            self
        }
        pub fn set_format(
            mut self,
            input: std::option::Option<crate::model::TypeDefinitionFormat>,
        ) -> Self {
            self.inner = self.inner.set_format(input);
            self
        }
    }
}
