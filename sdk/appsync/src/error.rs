// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateApiCacheError {
    pub kind: CreateApiCacheErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateApiCacheErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    InternalFailureException(crate::error::InternalFailureException),
    NotFoundException(crate::error::NotFoundException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateApiCacheError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateApiCacheErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateApiCacheErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            CreateApiCacheErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateApiCacheErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateApiCacheErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            CreateApiCacheErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateApiCacheError {
    fn code(&self) -> Option<&str> {
        CreateApiCacheError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateApiCacheError {
    pub fn new(kind: CreateApiCacheErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateApiCacheErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateApiCacheErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, CreateApiCacheErrorKind::BadRequestException(_))
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateApiCacheErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateApiCacheErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, CreateApiCacheErrorKind::NotFoundException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateApiCacheErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for CreateApiCacheError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateApiCacheErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateApiCacheErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            CreateApiCacheErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateApiCacheErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateApiCacheErrorKind::UnauthorizedException(_inner) => Some(_inner),
            CreateApiCacheErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateApiKeyError {
    pub kind: CreateApiKeyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateApiKeyErrorKind {
    ApiKeyLimitExceededException(crate::error::ApiKeyLimitExceededException),
    ApiKeyValidityOutOfBoundsException(crate::error::ApiKeyValidityOutOfBoundsException),
    BadRequestException(crate::error::BadRequestException),
    InternalFailureException(crate::error::InternalFailureException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateApiKeyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateApiKeyErrorKind::ApiKeyLimitExceededException(_inner) => _inner.fmt(f),
            CreateApiKeyErrorKind::ApiKeyValidityOutOfBoundsException(_inner) => _inner.fmt(f),
            CreateApiKeyErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateApiKeyErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateApiKeyErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateApiKeyErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateApiKeyErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            CreateApiKeyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateApiKeyError {
    fn code(&self) -> Option<&str> {
        CreateApiKeyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateApiKeyError {
    pub fn new(kind: CreateApiKeyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateApiKeyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateApiKeyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_api_key_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateApiKeyErrorKind::ApiKeyLimitExceededException(_)
        )
    }
    pub fn is_api_key_validity_out_of_bounds_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateApiKeyErrorKind::ApiKeyValidityOutOfBoundsException(_)
        )
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, CreateApiKeyErrorKind::BadRequestException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateApiKeyErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, CreateApiKeyErrorKind::LimitExceededException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, CreateApiKeyErrorKind::NotFoundException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, CreateApiKeyErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for CreateApiKeyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateApiKeyErrorKind::ApiKeyLimitExceededException(_inner) => Some(_inner),
            CreateApiKeyErrorKind::ApiKeyValidityOutOfBoundsException(_inner) => Some(_inner),
            CreateApiKeyErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateApiKeyErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateApiKeyErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateApiKeyErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateApiKeyErrorKind::UnauthorizedException(_inner) => Some(_inner),
            CreateApiKeyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateDataSourceError {
    pub kind: CreateDataSourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDataSourceErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    InternalFailureException(crate::error::InternalFailureException),
    NotFoundException(crate::error::NotFoundException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateDataSourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateDataSourceErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateDataSourceErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            CreateDataSourceErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateDataSourceErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateDataSourceErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            CreateDataSourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateDataSourceError {
    fn code(&self) -> Option<&str> {
        CreateDataSourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDataSourceError {
    pub fn new(kind: CreateDataSourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateDataSourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateDataSourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDataSourceErrorKind::BadRequestException(_)
        )
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDataSourceErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDataSourceErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, CreateDataSourceErrorKind::NotFoundException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDataSourceErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for CreateDataSourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateDataSourceErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateDataSourceErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            CreateDataSourceErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateDataSourceErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateDataSourceErrorKind::UnauthorizedException(_inner) => Some(_inner),
            CreateDataSourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateFunctionError {
    pub kind: CreateFunctionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateFunctionErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    InternalFailureException(crate::error::InternalFailureException),
    NotFoundException(crate::error::NotFoundException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateFunctionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateFunctionErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            CreateFunctionErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateFunctionErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateFunctionErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            CreateFunctionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateFunctionError {
    fn code(&self) -> Option<&str> {
        CreateFunctionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateFunctionError {
    pub fn new(kind: CreateFunctionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateFunctionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateFunctionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateFunctionErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateFunctionErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, CreateFunctionErrorKind::NotFoundException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateFunctionErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for CreateFunctionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateFunctionErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            CreateFunctionErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateFunctionErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateFunctionErrorKind::UnauthorizedException(_inner) => Some(_inner),
            CreateFunctionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateGraphqlApiError {
    pub kind: CreateGraphqlApiErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateGraphqlApiErrorKind {
    ApiLimitExceededException(crate::error::ApiLimitExceededException),
    BadRequestException(crate::error::BadRequestException),
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    InternalFailureException(crate::error::InternalFailureException),
    LimitExceededException(crate::error::LimitExceededException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateGraphqlApiError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateGraphqlApiErrorKind::ApiLimitExceededException(_inner) => _inner.fmt(f),
            CreateGraphqlApiErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateGraphqlApiErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            CreateGraphqlApiErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateGraphqlApiErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateGraphqlApiErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            CreateGraphqlApiErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateGraphqlApiError {
    fn code(&self) -> Option<&str> {
        CreateGraphqlApiError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateGraphqlApiError {
    pub fn new(kind: CreateGraphqlApiErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateGraphqlApiErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateGraphqlApiErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_api_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateGraphqlApiErrorKind::ApiLimitExceededException(_)
        )
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateGraphqlApiErrorKind::BadRequestException(_)
        )
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateGraphqlApiErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateGraphqlApiErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateGraphqlApiErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateGraphqlApiErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for CreateGraphqlApiError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateGraphqlApiErrorKind::ApiLimitExceededException(_inner) => Some(_inner),
            CreateGraphqlApiErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateGraphqlApiErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            CreateGraphqlApiErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateGraphqlApiErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateGraphqlApiErrorKind::UnauthorizedException(_inner) => Some(_inner),
            CreateGraphqlApiErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateResolverError {
    pub kind: CreateResolverErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateResolverErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    InternalFailureException(crate::error::InternalFailureException),
    NotFoundException(crate::error::NotFoundException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateResolverError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateResolverErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            CreateResolverErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateResolverErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateResolverErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            CreateResolverErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateResolverError {
    fn code(&self) -> Option<&str> {
        CreateResolverError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateResolverError {
    pub fn new(kind: CreateResolverErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateResolverErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateResolverErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateResolverErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateResolverErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, CreateResolverErrorKind::NotFoundException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateResolverErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for CreateResolverError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateResolverErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            CreateResolverErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateResolverErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateResolverErrorKind::UnauthorizedException(_inner) => Some(_inner),
            CreateResolverErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateTypeError {
    pub kind: CreateTypeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateTypeErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    InternalFailureException(crate::error::InternalFailureException),
    NotFoundException(crate::error::NotFoundException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateTypeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateTypeErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateTypeErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            CreateTypeErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateTypeErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateTypeErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            CreateTypeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateTypeError {
    fn code(&self) -> Option<&str> {
        CreateTypeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateTypeError {
    pub fn new(kind: CreateTypeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateTypeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateTypeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, CreateTypeErrorKind::BadRequestException(_))
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTypeErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(&self.kind, CreateTypeErrorKind::InternalFailureException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, CreateTypeErrorKind::NotFoundException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, CreateTypeErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for CreateTypeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateTypeErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateTypeErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            CreateTypeErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateTypeErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateTypeErrorKind::UnauthorizedException(_inner) => Some(_inner),
            CreateTypeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteApiCacheError {
    pub kind: DeleteApiCacheErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteApiCacheErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    InternalFailureException(crate::error::InternalFailureException),
    NotFoundException(crate::error::NotFoundException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteApiCacheError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteApiCacheErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteApiCacheErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            DeleteApiCacheErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteApiCacheErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteApiCacheErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DeleteApiCacheErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteApiCacheError {
    fn code(&self) -> Option<&str> {
        DeleteApiCacheError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteApiCacheError {
    pub fn new(kind: DeleteApiCacheErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteApiCacheErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteApiCacheErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, DeleteApiCacheErrorKind::BadRequestException(_))
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteApiCacheErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteApiCacheErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteApiCacheErrorKind::NotFoundException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteApiCacheErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DeleteApiCacheError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteApiCacheErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteApiCacheErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            DeleteApiCacheErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteApiCacheErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteApiCacheErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DeleteApiCacheErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteApiKeyError {
    pub kind: DeleteApiKeyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteApiKeyErrorKind {
    BadRequestException(crate::error::BadRequestException),
    InternalFailureException(crate::error::InternalFailureException),
    NotFoundException(crate::error::NotFoundException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteApiKeyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteApiKeyErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteApiKeyErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteApiKeyErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteApiKeyErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DeleteApiKeyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteApiKeyError {
    fn code(&self) -> Option<&str> {
        DeleteApiKeyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteApiKeyError {
    pub fn new(kind: DeleteApiKeyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteApiKeyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteApiKeyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, DeleteApiKeyErrorKind::BadRequestException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteApiKeyErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteApiKeyErrorKind::NotFoundException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, DeleteApiKeyErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for DeleteApiKeyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteApiKeyErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteApiKeyErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteApiKeyErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteApiKeyErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DeleteApiKeyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteDataSourceError {
    pub kind: DeleteDataSourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDataSourceErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    InternalFailureException(crate::error::InternalFailureException),
    NotFoundException(crate::error::NotFoundException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteDataSourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteDataSourceErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteDataSourceErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            DeleteDataSourceErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteDataSourceErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteDataSourceErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DeleteDataSourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteDataSourceError {
    fn code(&self) -> Option<&str> {
        DeleteDataSourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteDataSourceError {
    pub fn new(kind: DeleteDataSourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteDataSourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteDataSourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDataSourceErrorKind::BadRequestException(_)
        )
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDataSourceErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDataSourceErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteDataSourceErrorKind::NotFoundException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDataSourceErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DeleteDataSourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteDataSourceErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteDataSourceErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            DeleteDataSourceErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteDataSourceErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteDataSourceErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DeleteDataSourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteFunctionError {
    pub kind: DeleteFunctionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteFunctionErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    InternalFailureException(crate::error::InternalFailureException),
    NotFoundException(crate::error::NotFoundException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteFunctionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteFunctionErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            DeleteFunctionErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteFunctionErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteFunctionErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DeleteFunctionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteFunctionError {
    fn code(&self) -> Option<&str> {
        DeleteFunctionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteFunctionError {
    pub fn new(kind: DeleteFunctionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteFunctionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteFunctionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFunctionErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFunctionErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteFunctionErrorKind::NotFoundException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFunctionErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DeleteFunctionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteFunctionErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            DeleteFunctionErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteFunctionErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteFunctionErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DeleteFunctionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteGraphqlApiError {
    pub kind: DeleteGraphqlApiErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteGraphqlApiErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    BadRequestException(crate::error::BadRequestException),
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    InternalFailureException(crate::error::InternalFailureException),
    NotFoundException(crate::error::NotFoundException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteGraphqlApiError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteGraphqlApiErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteGraphqlApiErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteGraphqlApiErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            DeleteGraphqlApiErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteGraphqlApiErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteGraphqlApiErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DeleteGraphqlApiErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteGraphqlApiError {
    fn code(&self) -> Option<&str> {
        DeleteGraphqlApiError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteGraphqlApiError {
    pub fn new(kind: DeleteGraphqlApiErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteGraphqlApiErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteGraphqlApiErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteGraphqlApiErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteGraphqlApiErrorKind::BadRequestException(_)
        )
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteGraphqlApiErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteGraphqlApiErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteGraphqlApiErrorKind::NotFoundException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteGraphqlApiErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DeleteGraphqlApiError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteGraphqlApiErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteGraphqlApiErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteGraphqlApiErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            DeleteGraphqlApiErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteGraphqlApiErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteGraphqlApiErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DeleteGraphqlApiErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteResolverError {
    pub kind: DeleteResolverErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteResolverErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    InternalFailureException(crate::error::InternalFailureException),
    NotFoundException(crate::error::NotFoundException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteResolverError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteResolverErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            DeleteResolverErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteResolverErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteResolverErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DeleteResolverErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteResolverError {
    fn code(&self) -> Option<&str> {
        DeleteResolverError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteResolverError {
    pub fn new(kind: DeleteResolverErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteResolverErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteResolverErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteResolverErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteResolverErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteResolverErrorKind::NotFoundException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteResolverErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for DeleteResolverError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteResolverErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            DeleteResolverErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteResolverErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteResolverErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DeleteResolverErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteTypeError {
    pub kind: DeleteTypeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteTypeErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    InternalFailureException(crate::error::InternalFailureException),
    NotFoundException(crate::error::NotFoundException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteTypeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteTypeErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteTypeErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            DeleteTypeErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteTypeErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteTypeErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            DeleteTypeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteTypeError {
    fn code(&self) -> Option<&str> {
        DeleteTypeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteTypeError {
    pub fn new(kind: DeleteTypeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteTypeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteTypeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, DeleteTypeErrorKind::BadRequestException(_))
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteTypeErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(&self.kind, DeleteTypeErrorKind::InternalFailureException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteTypeErrorKind::NotFoundException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, DeleteTypeErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for DeleteTypeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteTypeErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteTypeErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            DeleteTypeErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteTypeErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteTypeErrorKind::UnauthorizedException(_inner) => Some(_inner),
            DeleteTypeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct FlushApiCacheError {
    pub kind: FlushApiCacheErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum FlushApiCacheErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    InternalFailureException(crate::error::InternalFailureException),
    NotFoundException(crate::error::NotFoundException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for FlushApiCacheError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            FlushApiCacheErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            FlushApiCacheErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            FlushApiCacheErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            FlushApiCacheErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            FlushApiCacheErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            FlushApiCacheErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for FlushApiCacheError {
    fn code(&self) -> Option<&str> {
        FlushApiCacheError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl FlushApiCacheError {
    pub fn new(kind: FlushApiCacheErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: FlushApiCacheErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: FlushApiCacheErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, FlushApiCacheErrorKind::BadRequestException(_))
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            FlushApiCacheErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            FlushApiCacheErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, FlushApiCacheErrorKind::NotFoundException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, FlushApiCacheErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for FlushApiCacheError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            FlushApiCacheErrorKind::BadRequestException(_inner) => Some(_inner),
            FlushApiCacheErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            FlushApiCacheErrorKind::InternalFailureException(_inner) => Some(_inner),
            FlushApiCacheErrorKind::NotFoundException(_inner) => Some(_inner),
            FlushApiCacheErrorKind::UnauthorizedException(_inner) => Some(_inner),
            FlushApiCacheErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetApiCacheError {
    pub kind: GetApiCacheErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetApiCacheErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    InternalFailureException(crate::error::InternalFailureException),
    NotFoundException(crate::error::NotFoundException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetApiCacheError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetApiCacheErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetApiCacheErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            GetApiCacheErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            GetApiCacheErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetApiCacheErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetApiCacheErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetApiCacheError {
    fn code(&self) -> Option<&str> {
        GetApiCacheError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetApiCacheError {
    pub fn new(kind: GetApiCacheErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetApiCacheErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetApiCacheErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetApiCacheErrorKind::BadRequestException(_))
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetApiCacheErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetApiCacheErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetApiCacheErrorKind::NotFoundException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, GetApiCacheErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for GetApiCacheError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetApiCacheErrorKind::BadRequestException(_inner) => Some(_inner),
            GetApiCacheErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            GetApiCacheErrorKind::InternalFailureException(_inner) => Some(_inner),
            GetApiCacheErrorKind::NotFoundException(_inner) => Some(_inner),
            GetApiCacheErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetApiCacheErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetDataSourceError {
    pub kind: GetDataSourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetDataSourceErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    InternalFailureException(crate::error::InternalFailureException),
    NotFoundException(crate::error::NotFoundException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetDataSourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetDataSourceErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetDataSourceErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            GetDataSourceErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            GetDataSourceErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetDataSourceErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetDataSourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetDataSourceError {
    fn code(&self) -> Option<&str> {
        GetDataSourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetDataSourceError {
    pub fn new(kind: GetDataSourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetDataSourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetDataSourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetDataSourceErrorKind::BadRequestException(_))
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDataSourceErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDataSourceErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetDataSourceErrorKind::NotFoundException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, GetDataSourceErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for GetDataSourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetDataSourceErrorKind::BadRequestException(_inner) => Some(_inner),
            GetDataSourceErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            GetDataSourceErrorKind::InternalFailureException(_inner) => Some(_inner),
            GetDataSourceErrorKind::NotFoundException(_inner) => Some(_inner),
            GetDataSourceErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetDataSourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetFunctionError {
    pub kind: GetFunctionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetFunctionErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    NotFoundException(crate::error::NotFoundException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetFunctionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetFunctionErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            GetFunctionErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetFunctionErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetFunctionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetFunctionError {
    fn code(&self) -> Option<&str> {
        GetFunctionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetFunctionError {
    pub fn new(kind: GetFunctionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetFunctionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetFunctionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFunctionErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetFunctionErrorKind::NotFoundException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, GetFunctionErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for GetFunctionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetFunctionErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            GetFunctionErrorKind::NotFoundException(_inner) => Some(_inner),
            GetFunctionErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetFunctionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetGraphqlApiError {
    pub kind: GetGraphqlApiErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetGraphqlApiErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    BadRequestException(crate::error::BadRequestException),
    InternalFailureException(crate::error::InternalFailureException),
    NotFoundException(crate::error::NotFoundException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetGraphqlApiError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetGraphqlApiErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetGraphqlApiErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetGraphqlApiErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            GetGraphqlApiErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetGraphqlApiErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetGraphqlApiErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetGraphqlApiError {
    fn code(&self) -> Option<&str> {
        GetGraphqlApiError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetGraphqlApiError {
    pub fn new(kind: GetGraphqlApiErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetGraphqlApiErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetGraphqlApiErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, GetGraphqlApiErrorKind::AccessDeniedException(_))
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetGraphqlApiErrorKind::BadRequestException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetGraphqlApiErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetGraphqlApiErrorKind::NotFoundException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, GetGraphqlApiErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for GetGraphqlApiError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetGraphqlApiErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetGraphqlApiErrorKind::BadRequestException(_inner) => Some(_inner),
            GetGraphqlApiErrorKind::InternalFailureException(_inner) => Some(_inner),
            GetGraphqlApiErrorKind::NotFoundException(_inner) => Some(_inner),
            GetGraphqlApiErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetGraphqlApiErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetIntrospectionSchemaError {
    pub kind: GetIntrospectionSchemaErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetIntrospectionSchemaErrorKind {
    GraphQlSchemaException(crate::error::GraphQlSchemaException),
    InternalFailureException(crate::error::InternalFailureException),
    NotFoundException(crate::error::NotFoundException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetIntrospectionSchemaError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetIntrospectionSchemaErrorKind::GraphQlSchemaException(_inner) => _inner.fmt(f),
            GetIntrospectionSchemaErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            GetIntrospectionSchemaErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetIntrospectionSchemaErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetIntrospectionSchemaErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetIntrospectionSchemaError {
    fn code(&self) -> Option<&str> {
        GetIntrospectionSchemaError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetIntrospectionSchemaError {
    pub fn new(kind: GetIntrospectionSchemaErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetIntrospectionSchemaErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetIntrospectionSchemaErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_graph_ql_schema_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetIntrospectionSchemaErrorKind::GraphQlSchemaException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetIntrospectionSchemaErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetIntrospectionSchemaErrorKind::NotFoundException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetIntrospectionSchemaErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for GetIntrospectionSchemaError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetIntrospectionSchemaErrorKind::GraphQlSchemaException(_inner) => Some(_inner),
            GetIntrospectionSchemaErrorKind::InternalFailureException(_inner) => Some(_inner),
            GetIntrospectionSchemaErrorKind::NotFoundException(_inner) => Some(_inner),
            GetIntrospectionSchemaErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetIntrospectionSchemaErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetResolverError {
    pub kind: GetResolverErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetResolverErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    NotFoundException(crate::error::NotFoundException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetResolverError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetResolverErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            GetResolverErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetResolverErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetResolverErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetResolverError {
    fn code(&self) -> Option<&str> {
        GetResolverError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetResolverError {
    pub fn new(kind: GetResolverErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetResolverErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetResolverErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetResolverErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetResolverErrorKind::NotFoundException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, GetResolverErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for GetResolverError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetResolverErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            GetResolverErrorKind::NotFoundException(_inner) => Some(_inner),
            GetResolverErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetResolverErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetSchemaCreationStatusError {
    pub kind: GetSchemaCreationStatusErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetSchemaCreationStatusErrorKind {
    BadRequestException(crate::error::BadRequestException),
    InternalFailureException(crate::error::InternalFailureException),
    NotFoundException(crate::error::NotFoundException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetSchemaCreationStatusError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetSchemaCreationStatusErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetSchemaCreationStatusErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            GetSchemaCreationStatusErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetSchemaCreationStatusErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetSchemaCreationStatusErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetSchemaCreationStatusError {
    fn code(&self) -> Option<&str> {
        GetSchemaCreationStatusError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetSchemaCreationStatusError {
    pub fn new(kind: GetSchemaCreationStatusErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetSchemaCreationStatusErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetSchemaCreationStatusErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSchemaCreationStatusErrorKind::BadRequestException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSchemaCreationStatusErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSchemaCreationStatusErrorKind::NotFoundException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSchemaCreationStatusErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for GetSchemaCreationStatusError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetSchemaCreationStatusErrorKind::BadRequestException(_inner) => Some(_inner),
            GetSchemaCreationStatusErrorKind::InternalFailureException(_inner) => Some(_inner),
            GetSchemaCreationStatusErrorKind::NotFoundException(_inner) => Some(_inner),
            GetSchemaCreationStatusErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetSchemaCreationStatusErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetTypeError {
    pub kind: GetTypeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetTypeErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    InternalFailureException(crate::error::InternalFailureException),
    NotFoundException(crate::error::NotFoundException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetTypeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetTypeErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetTypeErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            GetTypeErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            GetTypeErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetTypeErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            GetTypeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetTypeError {
    fn code(&self) -> Option<&str> {
        GetTypeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetTypeError {
    pub fn new(kind: GetTypeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetTypeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetTypeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetTypeErrorKind::BadRequestException(_))
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetTypeErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(&self.kind, GetTypeErrorKind::InternalFailureException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetTypeErrorKind::NotFoundException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, GetTypeErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for GetTypeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetTypeErrorKind::BadRequestException(_inner) => Some(_inner),
            GetTypeErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            GetTypeErrorKind::InternalFailureException(_inner) => Some(_inner),
            GetTypeErrorKind::NotFoundException(_inner) => Some(_inner),
            GetTypeErrorKind::UnauthorizedException(_inner) => Some(_inner),
            GetTypeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListApiKeysError {
    pub kind: ListApiKeysErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListApiKeysErrorKind {
    BadRequestException(crate::error::BadRequestException),
    InternalFailureException(crate::error::InternalFailureException),
    NotFoundException(crate::error::NotFoundException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListApiKeysError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListApiKeysErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListApiKeysErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListApiKeysErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ListApiKeysErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ListApiKeysErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListApiKeysError {
    fn code(&self) -> Option<&str> {
        ListApiKeysError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListApiKeysError {
    pub fn new(kind: ListApiKeysErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListApiKeysErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListApiKeysErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, ListApiKeysErrorKind::BadRequestException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListApiKeysErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListApiKeysErrorKind::NotFoundException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, ListApiKeysErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for ListApiKeysError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListApiKeysErrorKind::BadRequestException(_inner) => Some(_inner),
            ListApiKeysErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListApiKeysErrorKind::NotFoundException(_inner) => Some(_inner),
            ListApiKeysErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ListApiKeysErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListDataSourcesError {
    pub kind: ListDataSourcesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListDataSourcesErrorKind {
    BadRequestException(crate::error::BadRequestException),
    InternalFailureException(crate::error::InternalFailureException),
    NotFoundException(crate::error::NotFoundException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListDataSourcesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListDataSourcesErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListDataSourcesErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListDataSourcesErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ListDataSourcesErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ListDataSourcesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListDataSourcesError {
    fn code(&self) -> Option<&str> {
        ListDataSourcesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListDataSourcesError {
    pub fn new(kind: ListDataSourcesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListDataSourcesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListDataSourcesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, ListDataSourcesErrorKind::BadRequestException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDataSourcesErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListDataSourcesErrorKind::NotFoundException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDataSourcesErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for ListDataSourcesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListDataSourcesErrorKind::BadRequestException(_inner) => Some(_inner),
            ListDataSourcesErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListDataSourcesErrorKind::NotFoundException(_inner) => Some(_inner),
            ListDataSourcesErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ListDataSourcesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListFunctionsError {
    pub kind: ListFunctionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListFunctionsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    InternalFailureException(crate::error::InternalFailureException),
    NotFoundException(crate::error::NotFoundException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListFunctionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListFunctionsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListFunctionsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListFunctionsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ListFunctionsErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ListFunctionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListFunctionsError {
    fn code(&self) -> Option<&str> {
        ListFunctionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListFunctionsError {
    pub fn new(kind: ListFunctionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListFunctionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListFunctionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, ListFunctionsErrorKind::BadRequestException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListFunctionsErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListFunctionsErrorKind::NotFoundException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, ListFunctionsErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for ListFunctionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListFunctionsErrorKind::BadRequestException(_inner) => Some(_inner),
            ListFunctionsErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListFunctionsErrorKind::NotFoundException(_inner) => Some(_inner),
            ListFunctionsErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ListFunctionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListGraphqlApisError {
    pub kind: ListGraphqlApisErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListGraphqlApisErrorKind {
    BadRequestException(crate::error::BadRequestException),
    InternalFailureException(crate::error::InternalFailureException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListGraphqlApisError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListGraphqlApisErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListGraphqlApisErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListGraphqlApisErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ListGraphqlApisErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListGraphqlApisError {
    fn code(&self) -> Option<&str> {
        ListGraphqlApisError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListGraphqlApisError {
    pub fn new(kind: ListGraphqlApisErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListGraphqlApisErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListGraphqlApisErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, ListGraphqlApisErrorKind::BadRequestException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListGraphqlApisErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListGraphqlApisErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for ListGraphqlApisError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListGraphqlApisErrorKind::BadRequestException(_inner) => Some(_inner),
            ListGraphqlApisErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListGraphqlApisErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ListGraphqlApisErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListResolversError {
    pub kind: ListResolversErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListResolversErrorKind {
    BadRequestException(crate::error::BadRequestException),
    InternalFailureException(crate::error::InternalFailureException),
    NotFoundException(crate::error::NotFoundException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListResolversError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListResolversErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListResolversErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListResolversErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ListResolversErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ListResolversErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListResolversError {
    fn code(&self) -> Option<&str> {
        ListResolversError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListResolversError {
    pub fn new(kind: ListResolversErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListResolversErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListResolversErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, ListResolversErrorKind::BadRequestException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListResolversErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListResolversErrorKind::NotFoundException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, ListResolversErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for ListResolversError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListResolversErrorKind::BadRequestException(_inner) => Some(_inner),
            ListResolversErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListResolversErrorKind::NotFoundException(_inner) => Some(_inner),
            ListResolversErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ListResolversErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListResolversByFunctionError {
    pub kind: ListResolversByFunctionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListResolversByFunctionErrorKind {
    BadRequestException(crate::error::BadRequestException),
    InternalFailureException(crate::error::InternalFailureException),
    NotFoundException(crate::error::NotFoundException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListResolversByFunctionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListResolversByFunctionErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListResolversByFunctionErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListResolversByFunctionErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ListResolversByFunctionErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ListResolversByFunctionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListResolversByFunctionError {
    fn code(&self) -> Option<&str> {
        ListResolversByFunctionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListResolversByFunctionError {
    pub fn new(kind: ListResolversByFunctionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListResolversByFunctionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListResolversByFunctionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListResolversByFunctionErrorKind::BadRequestException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListResolversByFunctionErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListResolversByFunctionErrorKind::NotFoundException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListResolversByFunctionErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for ListResolversByFunctionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListResolversByFunctionErrorKind::BadRequestException(_inner) => Some(_inner),
            ListResolversByFunctionErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListResolversByFunctionErrorKind::NotFoundException(_inner) => Some(_inner),
            ListResolversByFunctionErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ListResolversByFunctionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTagsForResourceError {
    pub kind: ListTagsForResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTagsForResourceErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    BadRequestException(crate::error::BadRequestException),
    InternalFailureException(crate::error::InternalFailureException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTagsForResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTagsForResourceErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTagsForResourceError {
    fn code(&self) -> Option<&str> {
        ListTagsForResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTagsForResourceError {
    pub fn new(kind: ListTagsForResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::BadRequestException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::NotFoundException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for ListTagsForResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTagsForResourceErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::BadRequestException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::LimitExceededException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::NotFoundException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTypesError {
    pub kind: ListTypesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTypesErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    InternalFailureException(crate::error::InternalFailureException),
    NotFoundException(crate::error::NotFoundException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTypesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTypesErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListTypesErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            ListTypesErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListTypesErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ListTypesErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            ListTypesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTypesError {
    fn code(&self) -> Option<&str> {
        ListTypesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTypesError {
    pub fn new(kind: ListTypesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTypesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTypesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, ListTypesErrorKind::BadRequestException(_))
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTypesErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(&self.kind, ListTypesErrorKind::InternalFailureException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListTypesErrorKind::NotFoundException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, ListTypesErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for ListTypesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTypesErrorKind::BadRequestException(_inner) => Some(_inner),
            ListTypesErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            ListTypesErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListTypesErrorKind::NotFoundException(_inner) => Some(_inner),
            ListTypesErrorKind::UnauthorizedException(_inner) => Some(_inner),
            ListTypesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartSchemaCreationError {
    pub kind: StartSchemaCreationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartSchemaCreationErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    InternalFailureException(crate::error::InternalFailureException),
    NotFoundException(crate::error::NotFoundException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartSchemaCreationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartSchemaCreationErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            StartSchemaCreationErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            StartSchemaCreationErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            StartSchemaCreationErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            StartSchemaCreationErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            StartSchemaCreationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartSchemaCreationError {
    fn code(&self) -> Option<&str> {
        StartSchemaCreationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartSchemaCreationError {
    pub fn new(kind: StartSchemaCreationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartSchemaCreationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartSchemaCreationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartSchemaCreationErrorKind::BadRequestException(_)
        )
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartSchemaCreationErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartSchemaCreationErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartSchemaCreationErrorKind::NotFoundException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartSchemaCreationErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for StartSchemaCreationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartSchemaCreationErrorKind::BadRequestException(_inner) => Some(_inner),
            StartSchemaCreationErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            StartSchemaCreationErrorKind::InternalFailureException(_inner) => Some(_inner),
            StartSchemaCreationErrorKind::NotFoundException(_inner) => Some(_inner),
            StartSchemaCreationErrorKind::UnauthorizedException(_inner) => Some(_inner),
            StartSchemaCreationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagResourceError {
    pub kind: TagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagResourceErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    BadRequestException(crate::error::BadRequestException),
    InternalFailureException(crate::error::InternalFailureException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagResourceErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TagResourceError {
    fn code(&self) -> Option<&str> {
        TagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagResourceError {
    pub fn new(kind: TagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::AccessDeniedException(_))
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::BadRequestException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::LimitExceededException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::NotFoundException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for TagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagResourceErrorKind::AccessDeniedException(_inner) => Some(_inner),
            TagResourceErrorKind::BadRequestException(_inner) => Some(_inner),
            TagResourceErrorKind::InternalFailureException(_inner) => Some(_inner),
            TagResourceErrorKind::LimitExceededException(_inner) => Some(_inner),
            TagResourceErrorKind::NotFoundException(_inner) => Some(_inner),
            TagResourceErrorKind::UnauthorizedException(_inner) => Some(_inner),
            TagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagResourceError {
    pub kind: UntagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagResourceErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    BadRequestException(crate::error::BadRequestException),
    InternalFailureException(crate::error::InternalFailureException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UntagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagResourceErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UntagResourceError {
    fn code(&self) -> Option<&str> {
        UntagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagResourceError {
    pub fn new(kind: UntagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UntagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UntagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::AccessDeniedException(_))
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::BadRequestException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::NotFoundException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for UntagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagResourceErrorKind::AccessDeniedException(_inner) => Some(_inner),
            UntagResourceErrorKind::BadRequestException(_inner) => Some(_inner),
            UntagResourceErrorKind::InternalFailureException(_inner) => Some(_inner),
            UntagResourceErrorKind::LimitExceededException(_inner) => Some(_inner),
            UntagResourceErrorKind::NotFoundException(_inner) => Some(_inner),
            UntagResourceErrorKind::UnauthorizedException(_inner) => Some(_inner),
            UntagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateApiCacheError {
    pub kind: UpdateApiCacheErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateApiCacheErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    InternalFailureException(crate::error::InternalFailureException),
    NotFoundException(crate::error::NotFoundException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateApiCacheError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateApiCacheErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateApiCacheErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            UpdateApiCacheErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateApiCacheErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateApiCacheErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            UpdateApiCacheErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateApiCacheError {
    fn code(&self) -> Option<&str> {
        UpdateApiCacheError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateApiCacheError {
    pub fn new(kind: UpdateApiCacheErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateApiCacheErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateApiCacheErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, UpdateApiCacheErrorKind::BadRequestException(_))
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateApiCacheErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateApiCacheErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateApiCacheErrorKind::NotFoundException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateApiCacheErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for UpdateApiCacheError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateApiCacheErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateApiCacheErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            UpdateApiCacheErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateApiCacheErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateApiCacheErrorKind::UnauthorizedException(_inner) => Some(_inner),
            UpdateApiCacheErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateApiKeyError {
    pub kind: UpdateApiKeyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateApiKeyErrorKind {
    ApiKeyValidityOutOfBoundsException(crate::error::ApiKeyValidityOutOfBoundsException),
    BadRequestException(crate::error::BadRequestException),
    InternalFailureException(crate::error::InternalFailureException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateApiKeyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateApiKeyErrorKind::ApiKeyValidityOutOfBoundsException(_inner) => _inner.fmt(f),
            UpdateApiKeyErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateApiKeyErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateApiKeyErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UpdateApiKeyErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateApiKeyErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            UpdateApiKeyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateApiKeyError {
    fn code(&self) -> Option<&str> {
        UpdateApiKeyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateApiKeyError {
    pub fn new(kind: UpdateApiKeyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateApiKeyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateApiKeyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_api_key_validity_out_of_bounds_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateApiKeyErrorKind::ApiKeyValidityOutOfBoundsException(_)
        )
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, UpdateApiKeyErrorKind::BadRequestException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateApiKeyErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, UpdateApiKeyErrorKind::LimitExceededException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateApiKeyErrorKind::NotFoundException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, UpdateApiKeyErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for UpdateApiKeyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateApiKeyErrorKind::ApiKeyValidityOutOfBoundsException(_inner) => Some(_inner),
            UpdateApiKeyErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateApiKeyErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateApiKeyErrorKind::LimitExceededException(_inner) => Some(_inner),
            UpdateApiKeyErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateApiKeyErrorKind::UnauthorizedException(_inner) => Some(_inner),
            UpdateApiKeyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateDataSourceError {
    pub kind: UpdateDataSourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateDataSourceErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    InternalFailureException(crate::error::InternalFailureException),
    NotFoundException(crate::error::NotFoundException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateDataSourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateDataSourceErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateDataSourceErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            UpdateDataSourceErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateDataSourceErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateDataSourceErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            UpdateDataSourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateDataSourceError {
    fn code(&self) -> Option<&str> {
        UpdateDataSourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateDataSourceError {
    pub fn new(kind: UpdateDataSourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateDataSourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateDataSourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDataSourceErrorKind::BadRequestException(_)
        )
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDataSourceErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDataSourceErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateDataSourceErrorKind::NotFoundException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDataSourceErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for UpdateDataSourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateDataSourceErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateDataSourceErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            UpdateDataSourceErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateDataSourceErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateDataSourceErrorKind::UnauthorizedException(_inner) => Some(_inner),
            UpdateDataSourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateFunctionError {
    pub kind: UpdateFunctionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateFunctionErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    InternalFailureException(crate::error::InternalFailureException),
    NotFoundException(crate::error::NotFoundException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateFunctionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateFunctionErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            UpdateFunctionErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateFunctionErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateFunctionErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            UpdateFunctionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateFunctionError {
    fn code(&self) -> Option<&str> {
        UpdateFunctionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateFunctionError {
    pub fn new(kind: UpdateFunctionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateFunctionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateFunctionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFunctionErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFunctionErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateFunctionErrorKind::NotFoundException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateFunctionErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for UpdateFunctionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateFunctionErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            UpdateFunctionErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateFunctionErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateFunctionErrorKind::UnauthorizedException(_inner) => Some(_inner),
            UpdateFunctionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateGraphqlApiError {
    pub kind: UpdateGraphqlApiErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateGraphqlApiErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    BadRequestException(crate::error::BadRequestException),
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    InternalFailureException(crate::error::InternalFailureException),
    NotFoundException(crate::error::NotFoundException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateGraphqlApiError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateGraphqlApiErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            UpdateGraphqlApiErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateGraphqlApiErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            UpdateGraphqlApiErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateGraphqlApiErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateGraphqlApiErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            UpdateGraphqlApiErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateGraphqlApiError {
    fn code(&self) -> Option<&str> {
        UpdateGraphqlApiError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateGraphqlApiError {
    pub fn new(kind: UpdateGraphqlApiErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateGraphqlApiErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateGraphqlApiErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateGraphqlApiErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateGraphqlApiErrorKind::BadRequestException(_)
        )
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateGraphqlApiErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateGraphqlApiErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateGraphqlApiErrorKind::NotFoundException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateGraphqlApiErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for UpdateGraphqlApiError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateGraphqlApiErrorKind::AccessDeniedException(_inner) => Some(_inner),
            UpdateGraphqlApiErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateGraphqlApiErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            UpdateGraphqlApiErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateGraphqlApiErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateGraphqlApiErrorKind::UnauthorizedException(_inner) => Some(_inner),
            UpdateGraphqlApiErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateResolverError {
    pub kind: UpdateResolverErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateResolverErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    InternalFailureException(crate::error::InternalFailureException),
    NotFoundException(crate::error::NotFoundException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateResolverError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateResolverErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            UpdateResolverErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateResolverErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateResolverErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            UpdateResolverErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateResolverError {
    fn code(&self) -> Option<&str> {
        UpdateResolverError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateResolverError {
    pub fn new(kind: UpdateResolverErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateResolverErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateResolverErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateResolverErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateResolverErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateResolverErrorKind::NotFoundException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateResolverErrorKind::UnauthorizedException(_)
        )
    }
}
impl std::error::Error for UpdateResolverError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateResolverErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            UpdateResolverErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateResolverErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateResolverErrorKind::UnauthorizedException(_inner) => Some(_inner),
            UpdateResolverErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateTypeError {
    pub kind: UpdateTypeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateTypeErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    InternalFailureException(crate::error::InternalFailureException),
    NotFoundException(crate::error::NotFoundException),
    UnauthorizedException(crate::error::UnauthorizedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateTypeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateTypeErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateTypeErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            UpdateTypeErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateTypeErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateTypeErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            UpdateTypeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateTypeError {
    fn code(&self) -> Option<&str> {
        UpdateTypeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateTypeError {
    pub fn new(kind: UpdateTypeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateTypeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateTypeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, UpdateTypeErrorKind::BadRequestException(_))
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTypeErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(&self.kind, UpdateTypeErrorKind::InternalFailureException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateTypeErrorKind::NotFoundException(_))
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, UpdateTypeErrorKind::UnauthorizedException(_))
    }
}
impl std::error::Error for UpdateTypeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateTypeErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateTypeErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            UpdateTypeErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateTypeErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateTypeErrorKind::UnauthorizedException(_inner) => Some(_inner),
            UpdateTypeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// <p>You are not authorized to perform this operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UnauthorizedException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UnauthorizedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UnauthorizedException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl UnauthorizedException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UnauthorizedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UnauthorizedException")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for UnauthorizedException {}
/// See [`UnauthorizedException`](crate::error::UnauthorizedException)
pub mod unauthorized_exception {
    /// A builder for [`UnauthorizedException`](crate::error::UnauthorizedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`UnauthorizedException`](crate::error::UnauthorizedException)
        pub fn build(self) -> crate::error::UnauthorizedException {
            crate::error::UnauthorizedException {
                message: self.message,
            }
        }
    }
}
impl UnauthorizedException {
    /// Creates a new builder-style object to manufacture [`UnauthorizedException`](crate::error::UnauthorizedException)
    pub fn builder() -> crate::error::unauthorized_exception::Builder {
        crate::error::unauthorized_exception::Builder::default()
    }
}

/// <p>The resource specified in the request was not found. Check the resource, and then try
/// again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NotFoundException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NotFoundException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl NotFoundException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NotFoundException")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for NotFoundException {}
/// See [`NotFoundException`](crate::error::NotFoundException)
pub mod not_found_exception {
    /// A builder for [`NotFoundException`](crate::error::NotFoundException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`NotFoundException`](crate::error::NotFoundException)
        pub fn build(self) -> crate::error::NotFoundException {
            crate::error::NotFoundException {
                message: self.message,
            }
        }
    }
}
impl NotFoundException {
    /// Creates a new builder-style object to manufacture [`NotFoundException`](crate::error::NotFoundException)
    pub fn builder() -> crate::error::not_found_exception::Builder {
        crate::error::not_found_exception::Builder::default()
    }
}

/// <p>An internal AWS AppSync error occurred. Try your request again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InternalFailureException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InternalFailureException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InternalFailureException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InternalFailureException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InternalFailureException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InternalFailureException")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for InternalFailureException {}
/// See [`InternalFailureException`](crate::error::InternalFailureException)
pub mod internal_failure_exception {
    /// A builder for [`InternalFailureException`](crate::error::InternalFailureException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InternalFailureException`](crate::error::InternalFailureException)
        pub fn build(self) -> crate::error::InternalFailureException {
            crate::error::InternalFailureException {
                message: self.message,
            }
        }
    }
}
impl InternalFailureException {
    /// Creates a new builder-style object to manufacture [`InternalFailureException`](crate::error::InternalFailureException)
    pub fn builder() -> crate::error::internal_failure_exception::Builder {
        crate::error::internal_failure_exception::Builder::default()
    }
}

/// <p>Another modification is in progress at this time and it must complete before you can
/// make your change. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ConcurrentModificationException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ConcurrentModificationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ConcurrentModificationException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ConcurrentModificationException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ConcurrentModificationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ConcurrentModificationException")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for ConcurrentModificationException {}
/// See [`ConcurrentModificationException`](crate::error::ConcurrentModificationException)
pub mod concurrent_modification_exception {
    /// A builder for [`ConcurrentModificationException`](crate::error::ConcurrentModificationException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ConcurrentModificationException`](crate::error::ConcurrentModificationException)
        pub fn build(self) -> crate::error::ConcurrentModificationException {
            crate::error::ConcurrentModificationException {
                message: self.message,
            }
        }
    }
}
impl ConcurrentModificationException {
    /// Creates a new builder-style object to manufacture [`ConcurrentModificationException`](crate::error::ConcurrentModificationException)
    pub fn builder() -> crate::error::concurrent_modification_exception::Builder {
        crate::error::concurrent_modification_exception::Builder::default()
    }
}

/// <p>The request is not well formed. For example, a value is invalid or a required field is
/// missing. Check the field values, and then try again. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BadRequestException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for BadRequestException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BadRequestException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl BadRequestException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for BadRequestException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "BadRequestException")?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for BadRequestException {}
/// See [`BadRequestException`](crate::error::BadRequestException)
pub mod bad_request_exception {
    /// A builder for [`BadRequestException`](crate::error::BadRequestException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`BadRequestException`](crate::error::BadRequestException)
        pub fn build(self) -> crate::error::BadRequestException {
            crate::error::BadRequestException {
                message: self.message,
            }
        }
    }
}
impl BadRequestException {
    /// Creates a new builder-style object to manufacture [`BadRequestException`](crate::error::BadRequestException)
    pub fn builder() -> crate::error::bad_request_exception::Builder {
        crate::error::bad_request_exception::Builder::default()
    }
}

/// <p>You do not have access to perform this operation on this resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AccessDeniedException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AccessDeniedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AccessDeniedException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl AccessDeniedException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AccessDeniedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AccessDeniedException")?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl std::error::Error for AccessDeniedException {}
/// See [`AccessDeniedException`](crate::error::AccessDeniedException)
pub mod access_denied_exception {
    /// A builder for [`AccessDeniedException`](crate::error::AccessDeniedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`AccessDeniedException`](crate::error::AccessDeniedException)
        pub fn build(self) -> crate::error::AccessDeniedException {
            crate::error::AccessDeniedException {
                message: self.message,
            }
        }
    }
}
impl AccessDeniedException {
    /// Creates a new builder-style object to manufacture [`AccessDeniedException`](crate::error::AccessDeniedException)
    pub fn builder() -> crate::error::access_denied_exception::Builder {
        crate::error::access_denied_exception::Builder::default()
    }
}

/// <p>The request exceeded a limit. Try your request again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LimitExceededException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LimitExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl LimitExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for LimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "LimitExceededException")?;
        if let Some(inner_7) = &self.message {
            write!(f, ": {}", inner_7)?;
        }
        Ok(())
    }
}
impl std::error::Error for LimitExceededException {}
/// See [`LimitExceededException`](crate::error::LimitExceededException)
pub mod limit_exceeded_exception {
    /// A builder for [`LimitExceededException`](crate::error::LimitExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`LimitExceededException`](crate::error::LimitExceededException)
        pub fn build(self) -> crate::error::LimitExceededException {
            crate::error::LimitExceededException {
                message: self.message,
            }
        }
    }
}
impl LimitExceededException {
    /// Creates a new builder-style object to manufacture [`LimitExceededException`](crate::error::LimitExceededException)
    pub fn builder() -> crate::error::limit_exceeded_exception::Builder {
        crate::error::limit_exceeded_exception::Builder::default()
    }
}

/// <p>The API key expiration must be set to a value between 1 and 365 days from creation (for
/// <code>CreateApiKey</code>) or from update (for <code>UpdateApiKey</code>).</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ApiKeyValidityOutOfBoundsException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ApiKeyValidityOutOfBoundsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ApiKeyValidityOutOfBoundsException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ApiKeyValidityOutOfBoundsException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ApiKeyValidityOutOfBoundsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ApiKeyValidityOutOfBoundsException")?;
        if let Some(inner_8) = &self.message {
            write!(f, ": {}", inner_8)?;
        }
        Ok(())
    }
}
impl std::error::Error for ApiKeyValidityOutOfBoundsException {}
/// See [`ApiKeyValidityOutOfBoundsException`](crate::error::ApiKeyValidityOutOfBoundsException)
pub mod api_key_validity_out_of_bounds_exception {
    /// A builder for [`ApiKeyValidityOutOfBoundsException`](crate::error::ApiKeyValidityOutOfBoundsException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ApiKeyValidityOutOfBoundsException`](crate::error::ApiKeyValidityOutOfBoundsException)
        pub fn build(self) -> crate::error::ApiKeyValidityOutOfBoundsException {
            crate::error::ApiKeyValidityOutOfBoundsException {
                message: self.message,
            }
        }
    }
}
impl ApiKeyValidityOutOfBoundsException {
    /// Creates a new builder-style object to manufacture [`ApiKeyValidityOutOfBoundsException`](crate::error::ApiKeyValidityOutOfBoundsException)
    pub fn builder() -> crate::error::api_key_validity_out_of_bounds_exception::Builder {
        crate::error::api_key_validity_out_of_bounds_exception::Builder::default()
    }
}

/// <p>The GraphQL schema is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GraphQlSchemaException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GraphQlSchemaException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GraphQlSchemaException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl GraphQlSchemaException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for GraphQlSchemaException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "GraphQlSchemaException [GraphQLSchemaException]")?;
        if let Some(inner_9) = &self.message {
            write!(f, ": {}", inner_9)?;
        }
        Ok(())
    }
}
impl std::error::Error for GraphQlSchemaException {}
/// See [`GraphQlSchemaException`](crate::error::GraphQlSchemaException)
pub mod graph_ql_schema_exception {
    /// A builder for [`GraphQlSchemaException`](crate::error::GraphQlSchemaException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`GraphQlSchemaException`](crate::error::GraphQlSchemaException)
        pub fn build(self) -> crate::error::GraphQlSchemaException {
            crate::error::GraphQlSchemaException {
                message: self.message,
            }
        }
    }
}
impl GraphQlSchemaException {
    /// Creates a new builder-style object to manufacture [`GraphQlSchemaException`](crate::error::GraphQlSchemaException)
    pub fn builder() -> crate::error::graph_ql_schema_exception::Builder {
        crate::error::graph_ql_schema_exception::Builder::default()
    }
}

/// <p>The GraphQL API exceeded a limit. Try your request again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ApiLimitExceededException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ApiLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ApiLimitExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ApiLimitExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ApiLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ApiLimitExceededException")?;
        if let Some(inner_10) = &self.message {
            write!(f, ": {}", inner_10)?;
        }
        Ok(())
    }
}
impl std::error::Error for ApiLimitExceededException {}
/// See [`ApiLimitExceededException`](crate::error::ApiLimitExceededException)
pub mod api_limit_exceeded_exception {
    /// A builder for [`ApiLimitExceededException`](crate::error::ApiLimitExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ApiLimitExceededException`](crate::error::ApiLimitExceededException)
        pub fn build(self) -> crate::error::ApiLimitExceededException {
            crate::error::ApiLimitExceededException {
                message: self.message,
            }
        }
    }
}
impl ApiLimitExceededException {
    /// Creates a new builder-style object to manufacture [`ApiLimitExceededException`](crate::error::ApiLimitExceededException)
    pub fn builder() -> crate::error::api_limit_exceeded_exception::Builder {
        crate::error::api_limit_exceeded_exception::Builder::default()
    }
}

/// <p>The API key exceeded a limit. Try your request again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ApiKeyLimitExceededException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ApiKeyLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ApiKeyLimitExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ApiKeyLimitExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ApiKeyLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ApiKeyLimitExceededException")?;
        if let Some(inner_11) = &self.message {
            write!(f, ": {}", inner_11)?;
        }
        Ok(())
    }
}
impl std::error::Error for ApiKeyLimitExceededException {}
/// See [`ApiKeyLimitExceededException`](crate::error::ApiKeyLimitExceededException)
pub mod api_key_limit_exceeded_exception {
    /// A builder for [`ApiKeyLimitExceededException`](crate::error::ApiKeyLimitExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ApiKeyLimitExceededException`](crate::error::ApiKeyLimitExceededException)
        pub fn build(self) -> crate::error::ApiKeyLimitExceededException {
            crate::error::ApiKeyLimitExceededException {
                message: self.message,
            }
        }
    }
}
impl ApiKeyLimitExceededException {
    /// Creates a new builder-style object to manufacture [`ApiKeyLimitExceededException`](crate::error::ApiKeyLimitExceededException)
    pub fn builder() -> crate::error::api_key_limit_exceeded_exception::Builder {
        crate::error::api_key_limit_exceeded_exception::Builder::default()
    }
}
