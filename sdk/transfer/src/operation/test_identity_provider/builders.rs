// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub use crate::operation::test_identity_provider::_test_identity_provider_output::TestIdentityProviderOutputBuilder;

pub use crate::operation::test_identity_provider::_test_identity_provider_input::TestIdentityProviderInputBuilder;

impl TestIdentityProviderInputBuilder {
    /// Sends a request with this input using the given client.
    pub async fn send_with(
        self,
        client: &crate::Client,
    ) -> ::std::result::Result<
        crate::operation::test_identity_provider::TestIdentityProviderOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::test_identity_provider::TestIdentityProviderError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let mut fluent_builder = client.test_identity_provider();
        fluent_builder.inner = self;
        fluent_builder.send().await
    }
}
/// Fluent builder constructing a request to `TestIdentityProvider`.
///
/// <p>If the <code>IdentityProviderType</code> of a file transfer protocol-enabled server is <code>AWS_DIRECTORY_SERVICE</code> or <code>API_Gateway</code>, tests whether your identity provider is set up successfully. We highly recommend that you call this operation to test your authentication method as soon as you create your server. By doing so, you can troubleshoot issues with the identity provider integration to ensure that your users can successfully use the service.</p>
/// <p>The <code>ServerId</code> and <code>UserName</code> parameters are required. The <code>ServerProtocol</code>, <code>SourceIp</code>, and <code>UserPassword</code> are all optional.</p>
/// <p>Note the following:</p>
/// <ul>
/// <li>
/// <p>You cannot use <code>TestIdentityProvider</code> if the <code>IdentityProviderType</code> of your server is <code>SERVICE_MANAGED</code>.</p></li>
/// <li>
/// <p><code>TestIdentityProvider</code> does not work with keys: it only accepts passwords.</p></li>
/// <li>
/// <p><code>TestIdentityProvider</code> can test the password operation for a custom Identity Provider that handles keys and passwords.</p></li>
/// <li>
/// <p>If you provide any incorrect values for any parameters, the <code>Response</code> field is empty.</p></li>
/// <li>
/// <p>If you provide a server ID for a server that uses service-managed users, you get an error:</p>
/// <p><code> An error occurred (InvalidRequestException) when calling the TestIdentityProvider operation: s-<i>server-ID</i> not configured for external auth </code></p></li>
/// <li>
/// <p>If you enter a Server ID for the <code>--server-id</code> parameter that does not identify an actual Transfer server, you receive the following error:</p>
/// <p><code>An error occurred (ResourceNotFoundException) when calling the TestIdentityProvider operation: Unknown server</code>.</p>
/// <p>It is possible your sever is in a different region. You can specify a region by adding the following: <code>--region region-code</code>, such as <code>--region us-east-2</code> to specify a server in <b>US East (Ohio)</b>.</p></li>
/// </ul>
#[derive(::std::clone::Clone, ::std::fmt::Debug)]
pub struct TestIdentityProviderFluentBuilder {
    handle: ::std::sync::Arc<crate::client::Handle>,
    inner: crate::operation::test_identity_provider::builders::TestIdentityProviderInputBuilder,
    config_override: ::std::option::Option<crate::config::Builder>,
}
impl
    crate::client::customize::internal::CustomizableSend<
        crate::operation::test_identity_provider::TestIdentityProviderOutput,
        crate::operation::test_identity_provider::TestIdentityProviderError,
    > for TestIdentityProviderFluentBuilder
{
    fn send(
        self,
        config_override: crate::config::Builder,
    ) -> crate::client::customize::internal::BoxFuture<
        crate::client::customize::internal::SendResult<
            crate::operation::test_identity_provider::TestIdentityProviderOutput,
            crate::operation::test_identity_provider::TestIdentityProviderError,
        >,
    > {
        ::std::boxed::Box::pin(async move { self.config_override(config_override).send().await })
    }
}
impl TestIdentityProviderFluentBuilder {
    /// Creates a new `TestIdentityProvider`.
    pub(crate) fn new(handle: ::std::sync::Arc<crate::client::Handle>) -> Self {
        Self {
            handle,
            inner: ::std::default::Default::default(),
            config_override: ::std::option::Option::None,
        }
    }
    /// Access the TestIdentityProvider as a reference.
    pub fn as_input(&self) -> &crate::operation::test_identity_provider::builders::TestIdentityProviderInputBuilder {
        &self.inner
    }
    /// Sends the request and returns the response.
    ///
    /// If an error occurs, an `SdkError` will be returned with additional details that
    /// can be matched against.
    ///
    /// By default, any retryable failures will be retried twice. Retry behavior
    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
    /// set when configuring the client.
    pub async fn send(
        self,
    ) -> ::std::result::Result<
        crate::operation::test_identity_provider::TestIdentityProviderOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::test_identity_provider::TestIdentityProviderError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let input = self
            .inner
            .build()
            .map_err(::aws_smithy_runtime_api::client::result::SdkError::construction_failure)?;
        let runtime_plugins = crate::operation::test_identity_provider::TestIdentityProvider::operation_runtime_plugins(
            self.handle.runtime_plugins.clone(),
            &self.handle.conf,
            self.config_override,
        );
        crate::operation::test_identity_provider::TestIdentityProvider::orchestrate(&runtime_plugins, input).await
    }

    /// Consumes this builder, creating a customizable operation that can be modified before being sent.
    pub fn customize(
        self,
    ) -> crate::client::customize::CustomizableOperation<
        crate::operation::test_identity_provider::TestIdentityProviderOutput,
        crate::operation::test_identity_provider::TestIdentityProviderError,
        Self,
    > {
        crate::client::customize::CustomizableOperation::new(self)
    }
    pub(crate) fn config_override(mut self, config_override: impl Into<crate::config::Builder>) -> Self {
        self.set_config_override(Some(config_override.into()));
        self
    }

    pub(crate) fn set_config_override(&mut self, config_override: Option<crate::config::Builder>) -> &mut Self {
        self.config_override = config_override;
        self
    }
    /// <p>A system-assigned identifier for a specific server. That server's user authentication method is tested with a user name and password.</p>
    pub fn server_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.server_id(input.into());
        self
    }
    /// <p>A system-assigned identifier for a specific server. That server's user authentication method is tested with a user name and password.</p>
    pub fn set_server_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_server_id(input);
        self
    }
    /// <p>A system-assigned identifier for a specific server. That server's user authentication method is tested with a user name and password.</p>
    pub fn get_server_id(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_server_id()
    }
    /// <p>The type of file transfer protocol to be tested.</p>
    /// <p>The available protocols are:</p>
    /// <ul>
    /// <li>
    /// <p>Secure Shell (SSH) File Transfer Protocol (SFTP)</p></li>
    /// <li>
    /// <p>File Transfer Protocol Secure (FTPS)</p></li>
    /// <li>
    /// <p>File Transfer Protocol (FTP)</p></li>
    /// <li>
    /// <p>Applicability Statement 2 (AS2)</p></li>
    /// </ul>
    pub fn server_protocol(mut self, input: crate::types::Protocol) -> Self {
        self.inner = self.inner.server_protocol(input);
        self
    }
    /// <p>The type of file transfer protocol to be tested.</p>
    /// <p>The available protocols are:</p>
    /// <ul>
    /// <li>
    /// <p>Secure Shell (SSH) File Transfer Protocol (SFTP)</p></li>
    /// <li>
    /// <p>File Transfer Protocol Secure (FTPS)</p></li>
    /// <li>
    /// <p>File Transfer Protocol (FTP)</p></li>
    /// <li>
    /// <p>Applicability Statement 2 (AS2)</p></li>
    /// </ul>
    pub fn set_server_protocol(mut self, input: ::std::option::Option<crate::types::Protocol>) -> Self {
        self.inner = self.inner.set_server_protocol(input);
        self
    }
    /// <p>The type of file transfer protocol to be tested.</p>
    /// <p>The available protocols are:</p>
    /// <ul>
    /// <li>
    /// <p>Secure Shell (SSH) File Transfer Protocol (SFTP)</p></li>
    /// <li>
    /// <p>File Transfer Protocol Secure (FTPS)</p></li>
    /// <li>
    /// <p>File Transfer Protocol (FTP)</p></li>
    /// <li>
    /// <p>Applicability Statement 2 (AS2)</p></li>
    /// </ul>
    pub fn get_server_protocol(&self) -> &::std::option::Option<crate::types::Protocol> {
        self.inner.get_server_protocol()
    }
    /// <p>The source IP address of the account to be tested.</p>
    pub fn source_ip(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.source_ip(input.into());
        self
    }
    /// <p>The source IP address of the account to be tested.</p>
    pub fn set_source_ip(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_source_ip(input);
        self
    }
    /// <p>The source IP address of the account to be tested.</p>
    pub fn get_source_ip(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_source_ip()
    }
    /// <p>The name of the account to be tested.</p>
    pub fn user_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.user_name(input.into());
        self
    }
    /// <p>The name of the account to be tested.</p>
    pub fn set_user_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_user_name(input);
        self
    }
    /// <p>The name of the account to be tested.</p>
    pub fn get_user_name(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_user_name()
    }
    /// <p>The password of the account to be tested.</p>
    pub fn user_password(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.user_password(input.into());
        self
    }
    /// <p>The password of the account to be tested.</p>
    pub fn set_user_password(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_user_password(input);
        self
    }
    /// <p>The password of the account to be tested.</p>
    pub fn get_user_password(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_user_password()
    }
}
