// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub use crate::operation::update_agreement::_update_agreement_output::UpdateAgreementOutputBuilder;

pub use crate::operation::update_agreement::_update_agreement_input::UpdateAgreementInputBuilder;

impl UpdateAgreementInputBuilder {
    /// Sends a request with this input using the given client.
    pub async fn send_with(
        self,
        client: &crate::Client,
    ) -> ::std::result::Result<
        crate::operation::update_agreement::UpdateAgreementOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::update_agreement::UpdateAgreementError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let mut fluent_builder = client.update_agreement();
        fluent_builder.inner = self;
        fluent_builder.send().await
    }
}
/// Fluent builder constructing a request to `UpdateAgreement`.
///
/// <p>Updates some of the parameters for an existing agreement. Provide the <code>AgreementId</code> and the <code>ServerId</code> for the agreement that you want to update, along with the new values for the parameters to update.</p>
#[derive(::std::clone::Clone, ::std::fmt::Debug)]
pub struct UpdateAgreementFluentBuilder {
    handle: ::std::sync::Arc<crate::client::Handle>,
    inner: crate::operation::update_agreement::builders::UpdateAgreementInputBuilder,
    config_override: ::std::option::Option<crate::config::Builder>,
}
impl
    crate::client::customize::internal::CustomizableSend<
        crate::operation::update_agreement::UpdateAgreementOutput,
        crate::operation::update_agreement::UpdateAgreementError,
    > for UpdateAgreementFluentBuilder
{
    fn send(
        self,
        config_override: crate::config::Builder,
    ) -> crate::client::customize::internal::BoxFuture<
        crate::client::customize::internal::SendResult<
            crate::operation::update_agreement::UpdateAgreementOutput,
            crate::operation::update_agreement::UpdateAgreementError,
        >,
    > {
        ::std::boxed::Box::pin(async move { self.config_override(config_override).send().await })
    }
}
impl UpdateAgreementFluentBuilder {
    /// Creates a new `UpdateAgreement`.
    pub(crate) fn new(handle: ::std::sync::Arc<crate::client::Handle>) -> Self {
        Self {
            handle,
            inner: ::std::default::Default::default(),
            config_override: ::std::option::Option::None,
        }
    }
    /// Access the UpdateAgreement as a reference.
    pub fn as_input(&self) -> &crate::operation::update_agreement::builders::UpdateAgreementInputBuilder {
        &self.inner
    }
    /// Sends the request and returns the response.
    ///
    /// If an error occurs, an `SdkError` will be returned with additional details that
    /// can be matched against.
    ///
    /// By default, any retryable failures will be retried twice. Retry behavior
    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
    /// set when configuring the client.
    pub async fn send(
        self,
    ) -> ::std::result::Result<
        crate::operation::update_agreement::UpdateAgreementOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::update_agreement::UpdateAgreementError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let input = self
            .inner
            .build()
            .map_err(::aws_smithy_runtime_api::client::result::SdkError::construction_failure)?;
        let runtime_plugins = crate::operation::update_agreement::UpdateAgreement::operation_runtime_plugins(
            self.handle.runtime_plugins.clone(),
            &self.handle.conf,
            self.config_override,
        );
        crate::operation::update_agreement::UpdateAgreement::orchestrate(&runtime_plugins, input).await
    }

    /// Consumes this builder, creating a customizable operation that can be modified before being sent.
    pub fn customize(
        self,
    ) -> crate::client::customize::CustomizableOperation<
        crate::operation::update_agreement::UpdateAgreementOutput,
        crate::operation::update_agreement::UpdateAgreementError,
        Self,
    > {
        crate::client::customize::CustomizableOperation::new(self)
    }
    pub(crate) fn config_override(mut self, config_override: impl Into<crate::config::Builder>) -> Self {
        self.set_config_override(Some(config_override.into()));
        self
    }

    pub(crate) fn set_config_override(&mut self, config_override: Option<crate::config::Builder>) -> &mut Self {
        self.config_override = config_override;
        self
    }
    /// <p>A unique identifier for the agreement. This identifier is returned when you create an agreement.</p>
    pub fn agreement_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.agreement_id(input.into());
        self
    }
    /// <p>A unique identifier for the agreement. This identifier is returned when you create an agreement.</p>
    pub fn set_agreement_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_agreement_id(input);
        self
    }
    /// <p>A unique identifier for the agreement. This identifier is returned when you create an agreement.</p>
    pub fn get_agreement_id(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_agreement_id()
    }
    /// <p>A system-assigned unique identifier for a server instance. This is the specific server that the agreement uses.</p>
    pub fn server_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.server_id(input.into());
        self
    }
    /// <p>A system-assigned unique identifier for a server instance. This is the specific server that the agreement uses.</p>
    pub fn set_server_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_server_id(input);
        self
    }
    /// <p>A system-assigned unique identifier for a server instance. This is the specific server that the agreement uses.</p>
    pub fn get_server_id(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_server_id()
    }
    /// <p>To replace the existing description, provide a short description for the agreement. </p>
    pub fn description(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.description(input.into());
        self
    }
    /// <p>To replace the existing description, provide a short description for the agreement. </p>
    pub fn set_description(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_description(input);
        self
    }
    /// <p>To replace the existing description, provide a short description for the agreement. </p>
    pub fn get_description(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_description()
    }
    /// <p>You can update the status for the agreement, either activating an inactive agreement or the reverse.</p>
    pub fn status(mut self, input: crate::types::AgreementStatusType) -> Self {
        self.inner = self.inner.status(input);
        self
    }
    /// <p>You can update the status for the agreement, either activating an inactive agreement or the reverse.</p>
    pub fn set_status(mut self, input: ::std::option::Option<crate::types::AgreementStatusType>) -> Self {
        self.inner = self.inner.set_status(input);
        self
    }
    /// <p>You can update the status for the agreement, either activating an inactive agreement or the reverse.</p>
    pub fn get_status(&self) -> &::std::option::Option<crate::types::AgreementStatusType> {
        self.inner.get_status()
    }
    /// <p>A unique identifier for the AS2 local profile.</p>
    /// <p>To change the local profile identifier, provide a new value here.</p>
    pub fn local_profile_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.local_profile_id(input.into());
        self
    }
    /// <p>A unique identifier for the AS2 local profile.</p>
    /// <p>To change the local profile identifier, provide a new value here.</p>
    pub fn set_local_profile_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_local_profile_id(input);
        self
    }
    /// <p>A unique identifier for the AS2 local profile.</p>
    /// <p>To change the local profile identifier, provide a new value here.</p>
    pub fn get_local_profile_id(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_local_profile_id()
    }
    /// <p>A unique identifier for the partner profile. To change the partner profile identifier, provide a new value here.</p>
    pub fn partner_profile_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.partner_profile_id(input.into());
        self
    }
    /// <p>A unique identifier for the partner profile. To change the partner profile identifier, provide a new value here.</p>
    pub fn set_partner_profile_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_partner_profile_id(input);
        self
    }
    /// <p>A unique identifier for the partner profile. To change the partner profile identifier, provide a new value here.</p>
    pub fn get_partner_profile_id(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_partner_profile_id()
    }
    /// <p>To change the landing directory (folder) for files that are transferred, provide the bucket folder that you want to use; for example, <code>/<i>DOC-EXAMPLE-BUCKET</i>/<i>home</i>/<i>mydirectory</i> </code>.</p>
    pub fn base_directory(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.base_directory(input.into());
        self
    }
    /// <p>To change the landing directory (folder) for files that are transferred, provide the bucket folder that you want to use; for example, <code>/<i>DOC-EXAMPLE-BUCKET</i>/<i>home</i>/<i>mydirectory</i> </code>.</p>
    pub fn set_base_directory(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_base_directory(input);
        self
    }
    /// <p>To change the landing directory (folder) for files that are transferred, provide the bucket folder that you want to use; for example, <code>/<i>DOC-EXAMPLE-BUCKET</i>/<i>home</i>/<i>mydirectory</i> </code>.</p>
    pub fn get_base_directory(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_base_directory()
    }
    /// <p>Connectors are used to send files using either the AS2 or SFTP protocol. For the access role, provide the Amazon Resource Name (ARN) of the Identity and Access Management role to use.</p>
    /// <p> <b>For AS2 connectors</b> </p>
    /// <p>With AS2, you can send files by calling <code>StartFileTransfer</code> and specifying the file paths in the request parameter, <code>SendFilePaths</code>. We use the file’s parent directory (for example, for <code>--send-file-paths /bucket/dir/file.txt</code>, parent directory is <code>/bucket/dir/</code>) to temporarily store a processed AS2 message file, store the MDN when we receive them from the partner, and write a final JSON file containing relevant metadata of the transmission. So, the <code>AccessRole</code> needs to provide read and write access to the parent directory of the file location used in the <code>StartFileTransfer</code> request. Additionally, you need to provide read and write access to the parent directory of the files that you intend to send with <code>StartFileTransfer</code>.</p>
    /// <p>If you are using Basic authentication for your AS2 connector, the access role requires the <code>secretsmanager:GetSecretValue</code> permission for the secret. If the secret is encrypted using a customer-managed key instead of the Amazon Web Services managed key in Secrets Manager, then the role also needs the <code>kms:Decrypt</code> permission for that key.</p>
    /// <p> <b>For SFTP connectors</b> </p>
    /// <p>Make sure that the access role provides read and write access to the parent directory of the file location that's used in the <code>StartFileTransfer</code> request. Additionally, make sure that the role provides <code>secretsmanager:GetSecretValue</code> permission to Secrets Manager.</p>
    pub fn access_role(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.access_role(input.into());
        self
    }
    /// <p>Connectors are used to send files using either the AS2 or SFTP protocol. For the access role, provide the Amazon Resource Name (ARN) of the Identity and Access Management role to use.</p>
    /// <p> <b>For AS2 connectors</b> </p>
    /// <p>With AS2, you can send files by calling <code>StartFileTransfer</code> and specifying the file paths in the request parameter, <code>SendFilePaths</code>. We use the file’s parent directory (for example, for <code>--send-file-paths /bucket/dir/file.txt</code>, parent directory is <code>/bucket/dir/</code>) to temporarily store a processed AS2 message file, store the MDN when we receive them from the partner, and write a final JSON file containing relevant metadata of the transmission. So, the <code>AccessRole</code> needs to provide read and write access to the parent directory of the file location used in the <code>StartFileTransfer</code> request. Additionally, you need to provide read and write access to the parent directory of the files that you intend to send with <code>StartFileTransfer</code>.</p>
    /// <p>If you are using Basic authentication for your AS2 connector, the access role requires the <code>secretsmanager:GetSecretValue</code> permission for the secret. If the secret is encrypted using a customer-managed key instead of the Amazon Web Services managed key in Secrets Manager, then the role also needs the <code>kms:Decrypt</code> permission for that key.</p>
    /// <p> <b>For SFTP connectors</b> </p>
    /// <p>Make sure that the access role provides read and write access to the parent directory of the file location that's used in the <code>StartFileTransfer</code> request. Additionally, make sure that the role provides <code>secretsmanager:GetSecretValue</code> permission to Secrets Manager.</p>
    pub fn set_access_role(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_access_role(input);
        self
    }
    /// <p>Connectors are used to send files using either the AS2 or SFTP protocol. For the access role, provide the Amazon Resource Name (ARN) of the Identity and Access Management role to use.</p>
    /// <p> <b>For AS2 connectors</b> </p>
    /// <p>With AS2, you can send files by calling <code>StartFileTransfer</code> and specifying the file paths in the request parameter, <code>SendFilePaths</code>. We use the file’s parent directory (for example, for <code>--send-file-paths /bucket/dir/file.txt</code>, parent directory is <code>/bucket/dir/</code>) to temporarily store a processed AS2 message file, store the MDN when we receive them from the partner, and write a final JSON file containing relevant metadata of the transmission. So, the <code>AccessRole</code> needs to provide read and write access to the parent directory of the file location used in the <code>StartFileTransfer</code> request. Additionally, you need to provide read and write access to the parent directory of the files that you intend to send with <code>StartFileTransfer</code>.</p>
    /// <p>If you are using Basic authentication for your AS2 connector, the access role requires the <code>secretsmanager:GetSecretValue</code> permission for the secret. If the secret is encrypted using a customer-managed key instead of the Amazon Web Services managed key in Secrets Manager, then the role also needs the <code>kms:Decrypt</code> permission for that key.</p>
    /// <p> <b>For SFTP connectors</b> </p>
    /// <p>Make sure that the access role provides read and write access to the parent directory of the file location that's used in the <code>StartFileTransfer</code> request. Additionally, make sure that the role provides <code>secretsmanager:GetSecretValue</code> permission to Secrets Manager.</p>
    pub fn get_access_role(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_access_role()
    }
}
