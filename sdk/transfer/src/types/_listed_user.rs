// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Returns properties of the user that you specify.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListedUser {
    /// <p>Provides the unique Amazon Resource Name (ARN) for the user that you want to learn about.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The landing directory (folder) for a user when they log in to the server using the client.</p>
    /// <p>A <code>HomeDirectory</code> example is <code>/bucket_name/home/mydirectory</code>.</p>
    #[doc(hidden)]
    pub home_directory: std::option::Option<std::string::String>,
    /// <p>The type of landing directory (folder) that you want your users' home directory to be when they log in to the server. If you set it to <code>PATH</code>, the user will see the absolute Amazon S3 bucket or EFS paths as is in their file transfer protocol clients. If you set it <code>LOGICAL</code>, you need to provide mappings in the <code>HomeDirectoryMappings</code> for how you want to make Amazon S3 or Amazon EFS paths visible to your users.</p>
    #[doc(hidden)]
    pub home_directory_type: std::option::Option<crate::types::HomeDirectoryType>,
    /// <p>The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role that controls your users' access to your Amazon S3 bucket or Amazon EFS file system. The policies attached to this role determine the level of access that you want to provide your users when transferring files into and out of your Amazon S3 bucket or Amazon EFS file system. The IAM role should also contain a trust relationship that allows the server to access your resources when servicing your users' transfer requests.</p> <note>
    /// <p>The IAM role that controls your users' access to your Amazon S3 bucket for servers with <code>Domain=S3</code>, or your EFS file system for servers with <code>Domain=EFS</code>. </p>
    /// <p>The policies attached to this role determine the level of access you want to provide your users when transferring files into and out of your S3 buckets or EFS file systems.</p>
    /// </note>
    #[doc(hidden)]
    pub role: std::option::Option<std::string::String>,
    /// <p>Specifies the number of SSH public keys stored for the user you specified.</p>
    #[doc(hidden)]
    pub ssh_public_key_count: std::option::Option<i32>,
    /// <p>Specifies the name of the user whose ARN was specified. User names are used for authentication purposes.</p>
    #[doc(hidden)]
    pub user_name: std::option::Option<std::string::String>,
}
impl ListedUser {
    /// <p>Provides the unique Amazon Resource Name (ARN) for the user that you want to learn about.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The landing directory (folder) for a user when they log in to the server using the client.</p>
    /// <p>A <code>HomeDirectory</code> example is <code>/bucket_name/home/mydirectory</code>.</p>
    pub fn home_directory(&self) -> std::option::Option<&str> {
        self.home_directory.as_deref()
    }
    /// <p>The type of landing directory (folder) that you want your users' home directory to be when they log in to the server. If you set it to <code>PATH</code>, the user will see the absolute Amazon S3 bucket or EFS paths as is in their file transfer protocol clients. If you set it <code>LOGICAL</code>, you need to provide mappings in the <code>HomeDirectoryMappings</code> for how you want to make Amazon S3 or Amazon EFS paths visible to your users.</p>
    pub fn home_directory_type(&self) -> std::option::Option<&crate::types::HomeDirectoryType> {
        self.home_directory_type.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role that controls your users' access to your Amazon S3 bucket or Amazon EFS file system. The policies attached to this role determine the level of access that you want to provide your users when transferring files into and out of your Amazon S3 bucket or Amazon EFS file system. The IAM role should also contain a trust relationship that allows the server to access your resources when servicing your users' transfer requests.</p> <note>
    /// <p>The IAM role that controls your users' access to your Amazon S3 bucket for servers with <code>Domain=S3</code>, or your EFS file system for servers with <code>Domain=EFS</code>. </p>
    /// <p>The policies attached to this role determine the level of access you want to provide your users when transferring files into and out of your S3 buckets or EFS file systems.</p>
    /// </note>
    pub fn role(&self) -> std::option::Option<&str> {
        self.role.as_deref()
    }
    /// <p>Specifies the number of SSH public keys stored for the user you specified.</p>
    pub fn ssh_public_key_count(&self) -> std::option::Option<i32> {
        self.ssh_public_key_count
    }
    /// <p>Specifies the name of the user whose ARN was specified. User names are used for authentication purposes.</p>
    pub fn user_name(&self) -> std::option::Option<&str> {
        self.user_name.as_deref()
    }
}
impl ListedUser {
    /// Creates a new builder-style object to manufacture [`ListedUser`](crate::types::ListedUser).
    pub fn builder() -> crate::types::builders::ListedUserBuilder {
        crate::types::builders::ListedUserBuilder::default()
    }
}

/// A builder for [`ListedUser`](crate::types::ListedUser).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct ListedUserBuilder {
    pub(crate) arn: std::option::Option<std::string::String>,
    pub(crate) home_directory: std::option::Option<std::string::String>,
    pub(crate) home_directory_type: std::option::Option<crate::types::HomeDirectoryType>,
    pub(crate) role: std::option::Option<std::string::String>,
    pub(crate) ssh_public_key_count: std::option::Option<i32>,
    pub(crate) user_name: std::option::Option<std::string::String>,
}
impl ListedUserBuilder {
    /// <p>Provides the unique Amazon Resource Name (ARN) for the user that you want to learn about.</p>
    pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
        self.arn = Some(input.into());
        self
    }
    /// <p>Provides the unique Amazon Resource Name (ARN) for the user that you want to learn about.</p>
    pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.arn = input;
        self
    }
    /// <p>The landing directory (folder) for a user when they log in to the server using the client.</p>
    /// <p>A <code>HomeDirectory</code> example is <code>/bucket_name/home/mydirectory</code>.</p>
    pub fn home_directory(mut self, input: impl Into<std::string::String>) -> Self {
        self.home_directory = Some(input.into());
        self
    }
    /// <p>The landing directory (folder) for a user when they log in to the server using the client.</p>
    /// <p>A <code>HomeDirectory</code> example is <code>/bucket_name/home/mydirectory</code>.</p>
    pub fn set_home_directory(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.home_directory = input;
        self
    }
    /// <p>The type of landing directory (folder) that you want your users' home directory to be when they log in to the server. If you set it to <code>PATH</code>, the user will see the absolute Amazon S3 bucket or EFS paths as is in their file transfer protocol clients. If you set it <code>LOGICAL</code>, you need to provide mappings in the <code>HomeDirectoryMappings</code> for how you want to make Amazon S3 or Amazon EFS paths visible to your users.</p>
    pub fn home_directory_type(mut self, input: crate::types::HomeDirectoryType) -> Self {
        self.home_directory_type = Some(input);
        self
    }
    /// <p>The type of landing directory (folder) that you want your users' home directory to be when they log in to the server. If you set it to <code>PATH</code>, the user will see the absolute Amazon S3 bucket or EFS paths as is in their file transfer protocol clients. If you set it <code>LOGICAL</code>, you need to provide mappings in the <code>HomeDirectoryMappings</code> for how you want to make Amazon S3 or Amazon EFS paths visible to your users.</p>
    pub fn set_home_directory_type(
        mut self,
        input: std::option::Option<crate::types::HomeDirectoryType>,
    ) -> Self {
        self.home_directory_type = input;
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role that controls your users' access to your Amazon S3 bucket or Amazon EFS file system. The policies attached to this role determine the level of access that you want to provide your users when transferring files into and out of your Amazon S3 bucket or Amazon EFS file system. The IAM role should also contain a trust relationship that allows the server to access your resources when servicing your users' transfer requests.</p> <note>
    /// <p>The IAM role that controls your users' access to your Amazon S3 bucket for servers with <code>Domain=S3</code>, or your EFS file system for servers with <code>Domain=EFS</code>. </p>
    /// <p>The policies attached to this role determine the level of access you want to provide your users when transferring files into and out of your S3 buckets or EFS file systems.</p>
    /// </note>
    pub fn role(mut self, input: impl Into<std::string::String>) -> Self {
        self.role = Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role that controls your users' access to your Amazon S3 bucket or Amazon EFS file system. The policies attached to this role determine the level of access that you want to provide your users when transferring files into and out of your Amazon S3 bucket or Amazon EFS file system. The IAM role should also contain a trust relationship that allows the server to access your resources when servicing your users' transfer requests.</p> <note>
    /// <p>The IAM role that controls your users' access to your Amazon S3 bucket for servers with <code>Domain=S3</code>, or your EFS file system for servers with <code>Domain=EFS</code>. </p>
    /// <p>The policies attached to this role determine the level of access you want to provide your users when transferring files into and out of your S3 buckets or EFS file systems.</p>
    /// </note>
    pub fn set_role(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.role = input;
        self
    }
    /// <p>Specifies the number of SSH public keys stored for the user you specified.</p>
    pub fn ssh_public_key_count(mut self, input: i32) -> Self {
        self.ssh_public_key_count = Some(input);
        self
    }
    /// <p>Specifies the number of SSH public keys stored for the user you specified.</p>
    pub fn set_ssh_public_key_count(mut self, input: std::option::Option<i32>) -> Self {
        self.ssh_public_key_count = input;
        self
    }
    /// <p>Specifies the name of the user whose ARN was specified. User names are used for authentication purposes.</p>
    pub fn user_name(mut self, input: impl Into<std::string::String>) -> Self {
        self.user_name = Some(input.into());
        self
    }
    /// <p>Specifies the name of the user whose ARN was specified. User names are used for authentication purposes.</p>
    pub fn set_user_name(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.user_name = input;
        self
    }
    /// Consumes the builder and constructs a [`ListedUser`](crate::types::ListedUser).
    pub fn build(self) -> crate::types::ListedUser {
        crate::types::ListedUser {
            arn: self.arn,
            home_directory: self.home_directory,
            home_directory_type: self.home_directory_type,
            role: self.role,
            ssh_public_key_count: self.ssh_public_key_count,
            user_name: self.user_name,
        }
    }
}
