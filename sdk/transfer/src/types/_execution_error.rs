// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Specifies the error message and type, for an error that occurs during the execution of the workflow.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ExecutionError  {
    /// <p>Specifies the error type.</p> 
    /// <ul> 
    /// <li> <p> <code>ALREADY_EXISTS</code>: occurs for a copy step, if the overwrite option is not selected and a file with the same name already exists in the target location.</p> </li> 
    /// <li> <p> <code>BAD_REQUEST</code>: a general bad request: for example, a step that attempts to tag an EFS file returns <code>BAD_REQUEST</code>, as only S3 files can be tagged.</p> </li> 
    /// <li> <p> <code>CUSTOM_STEP_FAILED</code>: occurs when the custom step provided a callback that indicates failure.</p> </li> 
    /// <li> <p> <code>INTERNAL_SERVER_ERROR</code>: a catch-all error that can occur for a variety of reasons.</p> </li> 
    /// <li> <p> <code>NOT_FOUND</code>: occurs when a requested entity, for example a source file for a copy step, does not exist.</p> </li> 
    /// <li> <p> <code>PERMISSION_DENIED</code>: occurs if your policy does not contain the correct permissions to complete one or more of the steps in the workflow.</p> </li> 
    /// <li> <p> <code>TIMEOUT</code>: occurs when the execution times out.</p> <note> 
    /// <p> You can set the <code>TimeoutSeconds</code> for a custom step, anywhere from 1 second to 1800 seconds (30 minutes). </p> 
    /// </note> </li> 
    /// <li> <p> <code>THROTTLED</code>: occurs if you exceed the new execution refill rate of one workflow per second.</p> </li> 
    /// </ul>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::types::ExecutionErrorType>,
    /// <p>Specifies the descriptive message that corresponds to the <code>ErrorType</code>.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl ExecutionError {
    /// <p>Specifies the error type.</p> 
    /// <ul> 
    /// <li> <p> <code>ALREADY_EXISTS</code>: occurs for a copy step, if the overwrite option is not selected and a file with the same name already exists in the target location.</p> </li> 
    /// <li> <p> <code>BAD_REQUEST</code>: a general bad request: for example, a step that attempts to tag an EFS file returns <code>BAD_REQUEST</code>, as only S3 files can be tagged.</p> </li> 
    /// <li> <p> <code>CUSTOM_STEP_FAILED</code>: occurs when the custom step provided a callback that indicates failure.</p> </li> 
    /// <li> <p> <code>INTERNAL_SERVER_ERROR</code>: a catch-all error that can occur for a variety of reasons.</p> </li> 
    /// <li> <p> <code>NOT_FOUND</code>: occurs when a requested entity, for example a source file for a copy step, does not exist.</p> </li> 
    /// <li> <p> <code>PERMISSION_DENIED</code>: occurs if your policy does not contain the correct permissions to complete one or more of the steps in the workflow.</p> </li> 
    /// <li> <p> <code>TIMEOUT</code>: occurs when the execution times out.</p> <note> 
    /// <p> You can set the <code>TimeoutSeconds</code> for a custom step, anywhere from 1 second to 1800 seconds (30 minutes). </p> 
    /// </note> </li> 
    /// <li> <p> <code>THROTTLED</code>: occurs if you exceed the new execution refill rate of one workflow per second.</p> </li> 
    /// </ul>
    pub fn r#type(&self) -> std::option::Option<& crate::types::ExecutionErrorType> {
        self.r#type.as_ref()
    }
    /// <p>Specifies the descriptive message that corresponds to the <code>ErrorType</code>.</p>
    pub fn message(&self) -> std::option::Option<& str> {
        self.message.as_deref()
    }
}
impl ExecutionError {
    /// Creates a new builder-style object to manufacture [`ExecutionError`](crate::types::ExecutionError).
    pub fn builder() -> crate::types::builders::ExecutionErrorBuilder {
        crate::types::builders::ExecutionErrorBuilder::default()
    }
}

/// A builder for [`ExecutionError`](crate::types::ExecutionError).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct ExecutionErrorBuilder {
    pub(crate) r#type: std::option::Option<crate::types::ExecutionErrorType>,
    pub(crate) message: std::option::Option<std::string::String>,
}
impl ExecutionErrorBuilder {
    /// <p>Specifies the error type.</p> 
    /// <ul> 
    /// <li> <p> <code>ALREADY_EXISTS</code>: occurs for a copy step, if the overwrite option is not selected and a file with the same name already exists in the target location.</p> </li> 
    /// <li> <p> <code>BAD_REQUEST</code>: a general bad request: for example, a step that attempts to tag an EFS file returns <code>BAD_REQUEST</code>, as only S3 files can be tagged.</p> </li> 
    /// <li> <p> <code>CUSTOM_STEP_FAILED</code>: occurs when the custom step provided a callback that indicates failure.</p> </li> 
    /// <li> <p> <code>INTERNAL_SERVER_ERROR</code>: a catch-all error that can occur for a variety of reasons.</p> </li> 
    /// <li> <p> <code>NOT_FOUND</code>: occurs when a requested entity, for example a source file for a copy step, does not exist.</p> </li> 
    /// <li> <p> <code>PERMISSION_DENIED</code>: occurs if your policy does not contain the correct permissions to complete one or more of the steps in the workflow.</p> </li> 
    /// <li> <p> <code>TIMEOUT</code>: occurs when the execution times out.</p> <note> 
    /// <p> You can set the <code>TimeoutSeconds</code> for a custom step, anywhere from 1 second to 1800 seconds (30 minutes). </p> 
    /// </note> </li> 
    /// <li> <p> <code>THROTTLED</code>: occurs if you exceed the new execution refill rate of one workflow per second.</p> </li> 
    /// </ul>
    pub fn r#type(mut self, input: crate::types::ExecutionErrorType) -> Self {
        self.r#type = Some(input);
        self
    }
    /// <p>Specifies the error type.</p> 
    /// <ul> 
    /// <li> <p> <code>ALREADY_EXISTS</code>: occurs for a copy step, if the overwrite option is not selected and a file with the same name already exists in the target location.</p> </li> 
    /// <li> <p> <code>BAD_REQUEST</code>: a general bad request: for example, a step that attempts to tag an EFS file returns <code>BAD_REQUEST</code>, as only S3 files can be tagged.</p> </li> 
    /// <li> <p> <code>CUSTOM_STEP_FAILED</code>: occurs when the custom step provided a callback that indicates failure.</p> </li> 
    /// <li> <p> <code>INTERNAL_SERVER_ERROR</code>: a catch-all error that can occur for a variety of reasons.</p> </li> 
    /// <li> <p> <code>NOT_FOUND</code>: occurs when a requested entity, for example a source file for a copy step, does not exist.</p> </li> 
    /// <li> <p> <code>PERMISSION_DENIED</code>: occurs if your policy does not contain the correct permissions to complete one or more of the steps in the workflow.</p> </li> 
    /// <li> <p> <code>TIMEOUT</code>: occurs when the execution times out.</p> <note> 
    /// <p> You can set the <code>TimeoutSeconds</code> for a custom step, anywhere from 1 second to 1800 seconds (30 minutes). </p> 
    /// </note> </li> 
    /// <li> <p> <code>THROTTLED</code>: occurs if you exceed the new execution refill rate of one workflow per second.</p> </li> 
    /// </ul>
    pub fn set_type(mut self, input: std::option::Option<crate::types::ExecutionErrorType>) -> Self {
        self.r#type = input; self
    }
    /// <p>Specifies the descriptive message that corresponds to the <code>ErrorType</code>.</p>
    pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
        self.message = Some(input.into());
        self
    }
    /// <p>Specifies the descriptive message that corresponds to the <code>ErrorType</code>.</p>
    pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.message = input; self
    }
    /// Consumes the builder and constructs a [`ExecutionError`](crate::types::ExecutionError).
    pub fn build(self) -> crate::types::ExecutionError {
        crate::types::ExecutionError {
            r#type: self.r#type
            ,
            message: self.message
            ,
        }
    }
}

