// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Describes the properties of a file transfer protocol-enabled server that was specified.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DescribedServer {
    /// <p>Specifies the unique Amazon Resource Name (ARN) of the server.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>Specifies the ARN of the Amazon Web ServicesCertificate Manager (ACM) certificate. Required when <code>Protocols</code> is set to <code>FTPS</code>.</p>
    #[doc(hidden)]
    pub certificate: std::option::Option<std::string::String>,
    /// <p>The protocol settings that are configured for your server.</p>
    /// <ul>
    /// <li> <p> To indicate passive mode (for FTP and FTPS protocols), use the <code>PassiveIp</code> parameter. Enter a single dotted-quad IPv4 address, such as the external IP address of a firewall, router, or load balancer. </p> </li>
    /// <li> <p>To ignore the error that is generated when the client attempts to use the <code>SETSTAT</code> command on a file that you are uploading to an Amazon S3 bucket, use the <code>SetStatOption</code> parameter. To have the Transfer Family server ignore the <code>SETSTAT</code> command and upload files without needing to make any changes to your SFTP client, set the value to <code>ENABLE_NO_OP</code>. If you set the <code>SetStatOption</code> parameter to <code>ENABLE_NO_OP</code>, Transfer Family generates a log entry to Amazon CloudWatch Logs, so that you can determine when the client is making a <code>SETSTAT</code> call.</p> </li>
    /// <li> <p>To determine whether your Transfer Family server resumes recent, negotiated sessions through a unique session ID, use the <code>TlsSessionResumptionMode</code> parameter.</p> </li>
    /// <li> <p> <code>As2Transports</code> indicates the transport method for the AS2 messages. Currently, only HTTP is supported.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub protocol_details: std::option::Option<crate::types::ProtocolDetails>,
    /// <p>Specifies the domain of the storage system that is used for file transfers.</p>
    #[doc(hidden)]
    pub domain: std::option::Option<crate::types::Domain>,
    /// <p>The virtual private cloud (VPC) endpoint settings that are configured for your server. When you host your endpoint within your VPC, you can make your endpoint accessible only to resources within your VPC, or you can attach Elastic IP addresses and make your endpoint accessible to clients over the internet. Your VPC's default security groups are automatically assigned to your endpoint.</p>
    #[doc(hidden)]
    pub endpoint_details: std::option::Option<crate::types::EndpointDetails>,
    /// <p>Defines the type of endpoint that your server is connected to. If your server is connected to a VPC endpoint, your server isn't accessible over the public internet.</p>
    #[doc(hidden)]
    pub endpoint_type: std::option::Option<crate::types::EndpointType>,
    /// <p>Specifies the Base64-encoded SHA256 fingerprint of the server's host key. This value is equivalent to the output of the <code>ssh-keygen -l -f my-new-server-key</code> command.</p>
    #[doc(hidden)]
    pub host_key_fingerprint: std::option::Option<std::string::String>,
    /// <p>Specifies information to call a customer-supplied authentication API. This field is not populated when the <code>IdentityProviderType</code> of a server is <code>AWS_DIRECTORY_SERVICE</code> or <code>SERVICE_MANAGED</code>.</p>
    #[doc(hidden)]
    pub identity_provider_details: std::option::Option<crate::types::IdentityProviderDetails>,
    /// <p>The mode of authentication for a server. The default value is <code>SERVICE_MANAGED</code>, which allows you to store and access user credentials within the Transfer Family service.</p>
    /// <p>Use <code>AWS_DIRECTORY_SERVICE</code> to provide access to Active Directory groups in Directory Service for Microsoft Active Directory or Microsoft Active Directory in your on-premises environment or in Amazon Web Services using AD Connector. This option also requires you to provide a Directory ID by using the <code>IdentityProviderDetails</code> parameter.</p>
    /// <p>Use the <code>API_GATEWAY</code> value to integrate with an identity provider of your choosing. The <code>API_GATEWAY</code> setting requires you to provide an Amazon API Gateway endpoint URL to call for authentication by using the <code>IdentityProviderDetails</code> parameter.</p>
    /// <p>Use the <code>AWS_LAMBDA</code> value to directly use an Lambda function as your identity provider. If you choose this value, you must specify the ARN for the Lambda function in the <code>Function</code> parameter or the <code>IdentityProviderDetails</code> data type.</p>
    #[doc(hidden)]
    pub identity_provider_type: std::option::Option<crate::types::IdentityProviderType>,
    /// <p>The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role that allows a server to turn on Amazon CloudWatch logging for Amazon S3 or Amazon EFSevents. When set, you can view user activity in your CloudWatch logs.</p>
    #[doc(hidden)]
    pub logging_role: std::option::Option<std::string::String>,
    /// <p>Specifies a string to display when users connect to a server. This string is displayed after the user authenticates.</p> <note>
    /// <p>The SFTP protocol does not support post-authentication display banners.</p>
    /// </note>
    #[doc(hidden)]
    pub post_authentication_login_banner: std::option::Option<std::string::String>,
    /// <p>Specifies a string to display when users connect to a server. This string is displayed before the user authenticates. For example, the following banner displays details about using the system:</p>
    /// <p> <code>This system is for the use of authorized users only. Individuals using this computer system without authority, or in excess of their authority, are subject to having all of their activities on this system monitored and recorded by system personnel.</code> </p>
    #[doc(hidden)]
    pub pre_authentication_login_banner: std::option::Option<std::string::String>,
    /// <p>Specifies the file transfer protocol or protocols over which your file transfer protocol client can connect to your server's endpoint. The available protocols are:</p>
    /// <ul>
    /// <li> <p> <code>SFTP</code> (Secure Shell (SSH) File Transfer Protocol): File transfer over SSH</p> </li>
    /// <li> <p> <code>FTPS</code> (File Transfer Protocol Secure): File transfer with TLS encryption</p> </li>
    /// <li> <p> <code>FTP</code> (File Transfer Protocol): Unencrypted file transfer</p> </li>
    /// <li> <p> <code>AS2</code> (Applicability Statement 2): used for transporting structured business-to-business data</p> </li>
    /// </ul> <note>
    /// <ul>
    /// <li> <p>If you select <code>FTPS</code>, you must choose a certificate stored in Certificate Manager (ACM) which is used to identify your server when clients connect to it over FTPS.</p> </li>
    /// <li> <p>If <code>Protocol</code> includes either <code>FTP</code> or <code>FTPS</code>, then the <code>EndpointType</code> must be <code>VPC</code> and the <code>IdentityProviderType</code> must be <code>AWS_DIRECTORY_SERVICE</code> or <code>API_GATEWAY</code>.</p> </li>
    /// <li> <p>If <code>Protocol</code> includes <code>FTP</code>, then <code>AddressAllocationIds</code> cannot be associated.</p> </li>
    /// <li> <p>If <code>Protocol</code> is set only to <code>SFTP</code>, the <code>EndpointType</code> can be set to <code>PUBLIC</code> and the <code>IdentityProviderType</code> can be set to <code>SERVICE_MANAGED</code>.</p> </li>
    /// <li> <p>If <code>Protocol</code> includes <code>AS2</code>, then the <code>EndpointType</code> must be <code>VPC</code>, and domain must be Amazon S3.</p> </li>
    /// </ul>
    /// </note>
    #[doc(hidden)]
    pub protocols: std::option::Option<std::vec::Vec<crate::types::Protocol>>,
    /// <p>Specifies the name of the security policy that is attached to the server.</p>
    #[doc(hidden)]
    pub security_policy_name: std::option::Option<std::string::String>,
    /// <p>Specifies the unique system-assigned identifier for a server that you instantiate.</p>
    #[doc(hidden)]
    pub server_id: std::option::Option<std::string::String>,
    /// <p>The condition of the server that was described. A value of <code>ONLINE</code> indicates that the server can accept jobs and transfer files. A <code>State</code> value of <code>OFFLINE</code> means that the server cannot perform file transfer operations.</p>
    /// <p>The states of <code>STARTING</code> and <code>STOPPING</code> indicate that the server is in an intermediate state, either not fully able to respond, or not fully offline. The values of <code>START_FAILED</code> or <code>STOP_FAILED</code> can indicate an error condition.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::types::State>,
    /// <p>Specifies the key-value pairs that you can use to search for and group servers that were assigned to the server that was described.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::vec::Vec<crate::types::Tag>>,
    /// <p>Specifies the number of users that are assigned to a server you specified with the <code>ServerId</code>.</p>
    #[doc(hidden)]
    pub user_count: std::option::Option<i32>,
    /// <p>Specifies the workflow ID for the workflow to assign and the execution role that's used for executing the workflow.</p>
    /// <p>In additon to a workflow to execute when a file is uploaded completely, <code>WorkflowDeatails</code> can also contain a workflow ID (and execution role) for a workflow to execute on partial upload. A partial upload occurs when a file is open when the session disconnects.</p>
    #[doc(hidden)]
    pub workflow_details: std::option::Option<crate::types::WorkflowDetails>,
}
impl DescribedServer {
    /// <p>Specifies the unique Amazon Resource Name (ARN) of the server.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>Specifies the ARN of the Amazon Web ServicesCertificate Manager (ACM) certificate. Required when <code>Protocols</code> is set to <code>FTPS</code>.</p>
    pub fn certificate(&self) -> std::option::Option<&str> {
        self.certificate.as_deref()
    }
    /// <p>The protocol settings that are configured for your server.</p>
    /// <ul>
    /// <li> <p> To indicate passive mode (for FTP and FTPS protocols), use the <code>PassiveIp</code> parameter. Enter a single dotted-quad IPv4 address, such as the external IP address of a firewall, router, or load balancer. </p> </li>
    /// <li> <p>To ignore the error that is generated when the client attempts to use the <code>SETSTAT</code> command on a file that you are uploading to an Amazon S3 bucket, use the <code>SetStatOption</code> parameter. To have the Transfer Family server ignore the <code>SETSTAT</code> command and upload files without needing to make any changes to your SFTP client, set the value to <code>ENABLE_NO_OP</code>. If you set the <code>SetStatOption</code> parameter to <code>ENABLE_NO_OP</code>, Transfer Family generates a log entry to Amazon CloudWatch Logs, so that you can determine when the client is making a <code>SETSTAT</code> call.</p> </li>
    /// <li> <p>To determine whether your Transfer Family server resumes recent, negotiated sessions through a unique session ID, use the <code>TlsSessionResumptionMode</code> parameter.</p> </li>
    /// <li> <p> <code>As2Transports</code> indicates the transport method for the AS2 messages. Currently, only HTTP is supported.</p> </li>
    /// </ul>
    pub fn protocol_details(&self) -> std::option::Option<&crate::types::ProtocolDetails> {
        self.protocol_details.as_ref()
    }
    /// <p>Specifies the domain of the storage system that is used for file transfers.</p>
    pub fn domain(&self) -> std::option::Option<&crate::types::Domain> {
        self.domain.as_ref()
    }
    /// <p>The virtual private cloud (VPC) endpoint settings that are configured for your server. When you host your endpoint within your VPC, you can make your endpoint accessible only to resources within your VPC, or you can attach Elastic IP addresses and make your endpoint accessible to clients over the internet. Your VPC's default security groups are automatically assigned to your endpoint.</p>
    pub fn endpoint_details(&self) -> std::option::Option<&crate::types::EndpointDetails> {
        self.endpoint_details.as_ref()
    }
    /// <p>Defines the type of endpoint that your server is connected to. If your server is connected to a VPC endpoint, your server isn't accessible over the public internet.</p>
    pub fn endpoint_type(&self) -> std::option::Option<&crate::types::EndpointType> {
        self.endpoint_type.as_ref()
    }
    /// <p>Specifies the Base64-encoded SHA256 fingerprint of the server's host key. This value is equivalent to the output of the <code>ssh-keygen -l -f my-new-server-key</code> command.</p>
    pub fn host_key_fingerprint(&self) -> std::option::Option<&str> {
        self.host_key_fingerprint.as_deref()
    }
    /// <p>Specifies information to call a customer-supplied authentication API. This field is not populated when the <code>IdentityProviderType</code> of a server is <code>AWS_DIRECTORY_SERVICE</code> or <code>SERVICE_MANAGED</code>.</p>
    pub fn identity_provider_details(
        &self,
    ) -> std::option::Option<&crate::types::IdentityProviderDetails> {
        self.identity_provider_details.as_ref()
    }
    /// <p>The mode of authentication for a server. The default value is <code>SERVICE_MANAGED</code>, which allows you to store and access user credentials within the Transfer Family service.</p>
    /// <p>Use <code>AWS_DIRECTORY_SERVICE</code> to provide access to Active Directory groups in Directory Service for Microsoft Active Directory or Microsoft Active Directory in your on-premises environment or in Amazon Web Services using AD Connector. This option also requires you to provide a Directory ID by using the <code>IdentityProviderDetails</code> parameter.</p>
    /// <p>Use the <code>API_GATEWAY</code> value to integrate with an identity provider of your choosing. The <code>API_GATEWAY</code> setting requires you to provide an Amazon API Gateway endpoint URL to call for authentication by using the <code>IdentityProviderDetails</code> parameter.</p>
    /// <p>Use the <code>AWS_LAMBDA</code> value to directly use an Lambda function as your identity provider. If you choose this value, you must specify the ARN for the Lambda function in the <code>Function</code> parameter or the <code>IdentityProviderDetails</code> data type.</p>
    pub fn identity_provider_type(
        &self,
    ) -> std::option::Option<&crate::types::IdentityProviderType> {
        self.identity_provider_type.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role that allows a server to turn on Amazon CloudWatch logging for Amazon S3 or Amazon EFSevents. When set, you can view user activity in your CloudWatch logs.</p>
    pub fn logging_role(&self) -> std::option::Option<&str> {
        self.logging_role.as_deref()
    }
    /// <p>Specifies a string to display when users connect to a server. This string is displayed after the user authenticates.</p> <note>
    /// <p>The SFTP protocol does not support post-authentication display banners.</p>
    /// </note>
    pub fn post_authentication_login_banner(&self) -> std::option::Option<&str> {
        self.post_authentication_login_banner.as_deref()
    }
    /// <p>Specifies a string to display when users connect to a server. This string is displayed before the user authenticates. For example, the following banner displays details about using the system:</p>
    /// <p> <code>This system is for the use of authorized users only. Individuals using this computer system without authority, or in excess of their authority, are subject to having all of their activities on this system monitored and recorded by system personnel.</code> </p>
    pub fn pre_authentication_login_banner(&self) -> std::option::Option<&str> {
        self.pre_authentication_login_banner.as_deref()
    }
    /// <p>Specifies the file transfer protocol or protocols over which your file transfer protocol client can connect to your server's endpoint. The available protocols are:</p>
    /// <ul>
    /// <li> <p> <code>SFTP</code> (Secure Shell (SSH) File Transfer Protocol): File transfer over SSH</p> </li>
    /// <li> <p> <code>FTPS</code> (File Transfer Protocol Secure): File transfer with TLS encryption</p> </li>
    /// <li> <p> <code>FTP</code> (File Transfer Protocol): Unencrypted file transfer</p> </li>
    /// <li> <p> <code>AS2</code> (Applicability Statement 2): used for transporting structured business-to-business data</p> </li>
    /// </ul> <note>
    /// <ul>
    /// <li> <p>If you select <code>FTPS</code>, you must choose a certificate stored in Certificate Manager (ACM) which is used to identify your server when clients connect to it over FTPS.</p> </li>
    /// <li> <p>If <code>Protocol</code> includes either <code>FTP</code> or <code>FTPS</code>, then the <code>EndpointType</code> must be <code>VPC</code> and the <code>IdentityProviderType</code> must be <code>AWS_DIRECTORY_SERVICE</code> or <code>API_GATEWAY</code>.</p> </li>
    /// <li> <p>If <code>Protocol</code> includes <code>FTP</code>, then <code>AddressAllocationIds</code> cannot be associated.</p> </li>
    /// <li> <p>If <code>Protocol</code> is set only to <code>SFTP</code>, the <code>EndpointType</code> can be set to <code>PUBLIC</code> and the <code>IdentityProviderType</code> can be set to <code>SERVICE_MANAGED</code>.</p> </li>
    /// <li> <p>If <code>Protocol</code> includes <code>AS2</code>, then the <code>EndpointType</code> must be <code>VPC</code>, and domain must be Amazon S3.</p> </li>
    /// </ul>
    /// </note>
    pub fn protocols(&self) -> std::option::Option<&[crate::types::Protocol]> {
        self.protocols.as_deref()
    }
    /// <p>Specifies the name of the security policy that is attached to the server.</p>
    pub fn security_policy_name(&self) -> std::option::Option<&str> {
        self.security_policy_name.as_deref()
    }
    /// <p>Specifies the unique system-assigned identifier for a server that you instantiate.</p>
    pub fn server_id(&self) -> std::option::Option<&str> {
        self.server_id.as_deref()
    }
    /// <p>The condition of the server that was described. A value of <code>ONLINE</code> indicates that the server can accept jobs and transfer files. A <code>State</code> value of <code>OFFLINE</code> means that the server cannot perform file transfer operations.</p>
    /// <p>The states of <code>STARTING</code> and <code>STOPPING</code> indicate that the server is in an intermediate state, either not fully able to respond, or not fully offline. The values of <code>START_FAILED</code> or <code>STOP_FAILED</code> can indicate an error condition.</p>
    pub fn state(&self) -> std::option::Option<&crate::types::State> {
        self.state.as_ref()
    }
    /// <p>Specifies the key-value pairs that you can use to search for and group servers that were assigned to the server that was described.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::types::Tag]> {
        self.tags.as_deref()
    }
    /// <p>Specifies the number of users that are assigned to a server you specified with the <code>ServerId</code>.</p>
    pub fn user_count(&self) -> std::option::Option<i32> {
        self.user_count
    }
    /// <p>Specifies the workflow ID for the workflow to assign and the execution role that's used for executing the workflow.</p>
    /// <p>In additon to a workflow to execute when a file is uploaded completely, <code>WorkflowDeatails</code> can also contain a workflow ID (and execution role) for a workflow to execute on partial upload. A partial upload occurs when a file is open when the session disconnects.</p>
    pub fn workflow_details(&self) -> std::option::Option<&crate::types::WorkflowDetails> {
        self.workflow_details.as_ref()
    }
}
impl DescribedServer {
    /// Creates a new builder-style object to manufacture [`DescribedServer`](crate::types::DescribedServer).
    pub fn builder() -> crate::types::builders::DescribedServerBuilder {
        crate::types::builders::DescribedServerBuilder::default()
    }
}

/// A builder for [`DescribedServer`](crate::types::DescribedServer).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct DescribedServerBuilder {
    pub(crate) arn: std::option::Option<std::string::String>,
    pub(crate) certificate: std::option::Option<std::string::String>,
    pub(crate) protocol_details: std::option::Option<crate::types::ProtocolDetails>,
    pub(crate) domain: std::option::Option<crate::types::Domain>,
    pub(crate) endpoint_details: std::option::Option<crate::types::EndpointDetails>,
    pub(crate) endpoint_type: std::option::Option<crate::types::EndpointType>,
    pub(crate) host_key_fingerprint: std::option::Option<std::string::String>,
    pub(crate) identity_provider_details:
        std::option::Option<crate::types::IdentityProviderDetails>,
    pub(crate) identity_provider_type: std::option::Option<crate::types::IdentityProviderType>,
    pub(crate) logging_role: std::option::Option<std::string::String>,
    pub(crate) post_authentication_login_banner: std::option::Option<std::string::String>,
    pub(crate) pre_authentication_login_banner: std::option::Option<std::string::String>,
    pub(crate) protocols: std::option::Option<std::vec::Vec<crate::types::Protocol>>,
    pub(crate) security_policy_name: std::option::Option<std::string::String>,
    pub(crate) server_id: std::option::Option<std::string::String>,
    pub(crate) state: std::option::Option<crate::types::State>,
    pub(crate) tags: std::option::Option<std::vec::Vec<crate::types::Tag>>,
    pub(crate) user_count: std::option::Option<i32>,
    pub(crate) workflow_details: std::option::Option<crate::types::WorkflowDetails>,
}
impl DescribedServerBuilder {
    /// <p>Specifies the unique Amazon Resource Name (ARN) of the server.</p>
    pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
        self.arn = Some(input.into());
        self
    }
    /// <p>Specifies the unique Amazon Resource Name (ARN) of the server.</p>
    pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.arn = input;
        self
    }
    /// <p>Specifies the ARN of the Amazon Web ServicesCertificate Manager (ACM) certificate. Required when <code>Protocols</code> is set to <code>FTPS</code>.</p>
    pub fn certificate(mut self, input: impl Into<std::string::String>) -> Self {
        self.certificate = Some(input.into());
        self
    }
    /// <p>Specifies the ARN of the Amazon Web ServicesCertificate Manager (ACM) certificate. Required when <code>Protocols</code> is set to <code>FTPS</code>.</p>
    pub fn set_certificate(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.certificate = input;
        self
    }
    /// <p>The protocol settings that are configured for your server.</p>
    /// <ul>
    /// <li> <p> To indicate passive mode (for FTP and FTPS protocols), use the <code>PassiveIp</code> parameter. Enter a single dotted-quad IPv4 address, such as the external IP address of a firewall, router, or load balancer. </p> </li>
    /// <li> <p>To ignore the error that is generated when the client attempts to use the <code>SETSTAT</code> command on a file that you are uploading to an Amazon S3 bucket, use the <code>SetStatOption</code> parameter. To have the Transfer Family server ignore the <code>SETSTAT</code> command and upload files without needing to make any changes to your SFTP client, set the value to <code>ENABLE_NO_OP</code>. If you set the <code>SetStatOption</code> parameter to <code>ENABLE_NO_OP</code>, Transfer Family generates a log entry to Amazon CloudWatch Logs, so that you can determine when the client is making a <code>SETSTAT</code> call.</p> </li>
    /// <li> <p>To determine whether your Transfer Family server resumes recent, negotiated sessions through a unique session ID, use the <code>TlsSessionResumptionMode</code> parameter.</p> </li>
    /// <li> <p> <code>As2Transports</code> indicates the transport method for the AS2 messages. Currently, only HTTP is supported.</p> </li>
    /// </ul>
    pub fn protocol_details(mut self, input: crate::types::ProtocolDetails) -> Self {
        self.protocol_details = Some(input);
        self
    }
    /// <p>The protocol settings that are configured for your server.</p>
    /// <ul>
    /// <li> <p> To indicate passive mode (for FTP and FTPS protocols), use the <code>PassiveIp</code> parameter. Enter a single dotted-quad IPv4 address, such as the external IP address of a firewall, router, or load balancer. </p> </li>
    /// <li> <p>To ignore the error that is generated when the client attempts to use the <code>SETSTAT</code> command on a file that you are uploading to an Amazon S3 bucket, use the <code>SetStatOption</code> parameter. To have the Transfer Family server ignore the <code>SETSTAT</code> command and upload files without needing to make any changes to your SFTP client, set the value to <code>ENABLE_NO_OP</code>. If you set the <code>SetStatOption</code> parameter to <code>ENABLE_NO_OP</code>, Transfer Family generates a log entry to Amazon CloudWatch Logs, so that you can determine when the client is making a <code>SETSTAT</code> call.</p> </li>
    /// <li> <p>To determine whether your Transfer Family server resumes recent, negotiated sessions through a unique session ID, use the <code>TlsSessionResumptionMode</code> parameter.</p> </li>
    /// <li> <p> <code>As2Transports</code> indicates the transport method for the AS2 messages. Currently, only HTTP is supported.</p> </li>
    /// </ul>
    pub fn set_protocol_details(
        mut self,
        input: std::option::Option<crate::types::ProtocolDetails>,
    ) -> Self {
        self.protocol_details = input;
        self
    }
    /// <p>Specifies the domain of the storage system that is used for file transfers.</p>
    pub fn domain(mut self, input: crate::types::Domain) -> Self {
        self.domain = Some(input);
        self
    }
    /// <p>Specifies the domain of the storage system that is used for file transfers.</p>
    pub fn set_domain(mut self, input: std::option::Option<crate::types::Domain>) -> Self {
        self.domain = input;
        self
    }
    /// <p>The virtual private cloud (VPC) endpoint settings that are configured for your server. When you host your endpoint within your VPC, you can make your endpoint accessible only to resources within your VPC, or you can attach Elastic IP addresses and make your endpoint accessible to clients over the internet. Your VPC's default security groups are automatically assigned to your endpoint.</p>
    pub fn endpoint_details(mut self, input: crate::types::EndpointDetails) -> Self {
        self.endpoint_details = Some(input);
        self
    }
    /// <p>The virtual private cloud (VPC) endpoint settings that are configured for your server. When you host your endpoint within your VPC, you can make your endpoint accessible only to resources within your VPC, or you can attach Elastic IP addresses and make your endpoint accessible to clients over the internet. Your VPC's default security groups are automatically assigned to your endpoint.</p>
    pub fn set_endpoint_details(
        mut self,
        input: std::option::Option<crate::types::EndpointDetails>,
    ) -> Self {
        self.endpoint_details = input;
        self
    }
    /// <p>Defines the type of endpoint that your server is connected to. If your server is connected to a VPC endpoint, your server isn't accessible over the public internet.</p>
    pub fn endpoint_type(mut self, input: crate::types::EndpointType) -> Self {
        self.endpoint_type = Some(input);
        self
    }
    /// <p>Defines the type of endpoint that your server is connected to. If your server is connected to a VPC endpoint, your server isn't accessible over the public internet.</p>
    pub fn set_endpoint_type(
        mut self,
        input: std::option::Option<crate::types::EndpointType>,
    ) -> Self {
        self.endpoint_type = input;
        self
    }
    /// <p>Specifies the Base64-encoded SHA256 fingerprint of the server's host key. This value is equivalent to the output of the <code>ssh-keygen -l -f my-new-server-key</code> command.</p>
    pub fn host_key_fingerprint(mut self, input: impl Into<std::string::String>) -> Self {
        self.host_key_fingerprint = Some(input.into());
        self
    }
    /// <p>Specifies the Base64-encoded SHA256 fingerprint of the server's host key. This value is equivalent to the output of the <code>ssh-keygen -l -f my-new-server-key</code> command.</p>
    pub fn set_host_key_fingerprint(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.host_key_fingerprint = input;
        self
    }
    /// <p>Specifies information to call a customer-supplied authentication API. This field is not populated when the <code>IdentityProviderType</code> of a server is <code>AWS_DIRECTORY_SERVICE</code> or <code>SERVICE_MANAGED</code>.</p>
    pub fn identity_provider_details(
        mut self,
        input: crate::types::IdentityProviderDetails,
    ) -> Self {
        self.identity_provider_details = Some(input);
        self
    }
    /// <p>Specifies information to call a customer-supplied authentication API. This field is not populated when the <code>IdentityProviderType</code> of a server is <code>AWS_DIRECTORY_SERVICE</code> or <code>SERVICE_MANAGED</code>.</p>
    pub fn set_identity_provider_details(
        mut self,
        input: std::option::Option<crate::types::IdentityProviderDetails>,
    ) -> Self {
        self.identity_provider_details = input;
        self
    }
    /// <p>The mode of authentication for a server. The default value is <code>SERVICE_MANAGED</code>, which allows you to store and access user credentials within the Transfer Family service.</p>
    /// <p>Use <code>AWS_DIRECTORY_SERVICE</code> to provide access to Active Directory groups in Directory Service for Microsoft Active Directory or Microsoft Active Directory in your on-premises environment or in Amazon Web Services using AD Connector. This option also requires you to provide a Directory ID by using the <code>IdentityProviderDetails</code> parameter.</p>
    /// <p>Use the <code>API_GATEWAY</code> value to integrate with an identity provider of your choosing. The <code>API_GATEWAY</code> setting requires you to provide an Amazon API Gateway endpoint URL to call for authentication by using the <code>IdentityProviderDetails</code> parameter.</p>
    /// <p>Use the <code>AWS_LAMBDA</code> value to directly use an Lambda function as your identity provider. If you choose this value, you must specify the ARN for the Lambda function in the <code>Function</code> parameter or the <code>IdentityProviderDetails</code> data type.</p>
    pub fn identity_provider_type(mut self, input: crate::types::IdentityProviderType) -> Self {
        self.identity_provider_type = Some(input);
        self
    }
    /// <p>The mode of authentication for a server. The default value is <code>SERVICE_MANAGED</code>, which allows you to store and access user credentials within the Transfer Family service.</p>
    /// <p>Use <code>AWS_DIRECTORY_SERVICE</code> to provide access to Active Directory groups in Directory Service for Microsoft Active Directory or Microsoft Active Directory in your on-premises environment or in Amazon Web Services using AD Connector. This option also requires you to provide a Directory ID by using the <code>IdentityProviderDetails</code> parameter.</p>
    /// <p>Use the <code>API_GATEWAY</code> value to integrate with an identity provider of your choosing. The <code>API_GATEWAY</code> setting requires you to provide an Amazon API Gateway endpoint URL to call for authentication by using the <code>IdentityProviderDetails</code> parameter.</p>
    /// <p>Use the <code>AWS_LAMBDA</code> value to directly use an Lambda function as your identity provider. If you choose this value, you must specify the ARN for the Lambda function in the <code>Function</code> parameter or the <code>IdentityProviderDetails</code> data type.</p>
    pub fn set_identity_provider_type(
        mut self,
        input: std::option::Option<crate::types::IdentityProviderType>,
    ) -> Self {
        self.identity_provider_type = input;
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role that allows a server to turn on Amazon CloudWatch logging for Amazon S3 or Amazon EFSevents. When set, you can view user activity in your CloudWatch logs.</p>
    pub fn logging_role(mut self, input: impl Into<std::string::String>) -> Self {
        self.logging_role = Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role that allows a server to turn on Amazon CloudWatch logging for Amazon S3 or Amazon EFSevents. When set, you can view user activity in your CloudWatch logs.</p>
    pub fn set_logging_role(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.logging_role = input;
        self
    }
    /// <p>Specifies a string to display when users connect to a server. This string is displayed after the user authenticates.</p> <note>
    /// <p>The SFTP protocol does not support post-authentication display banners.</p>
    /// </note>
    pub fn post_authentication_login_banner(
        mut self,
        input: impl Into<std::string::String>,
    ) -> Self {
        self.post_authentication_login_banner = Some(input.into());
        self
    }
    /// <p>Specifies a string to display when users connect to a server. This string is displayed after the user authenticates.</p> <note>
    /// <p>The SFTP protocol does not support post-authentication display banners.</p>
    /// </note>
    pub fn set_post_authentication_login_banner(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.post_authentication_login_banner = input;
        self
    }
    /// <p>Specifies a string to display when users connect to a server. This string is displayed before the user authenticates. For example, the following banner displays details about using the system:</p>
    /// <p> <code>This system is for the use of authorized users only. Individuals using this computer system without authority, or in excess of their authority, are subject to having all of their activities on this system monitored and recorded by system personnel.</code> </p>
    pub fn pre_authentication_login_banner(
        mut self,
        input: impl Into<std::string::String>,
    ) -> Self {
        self.pre_authentication_login_banner = Some(input.into());
        self
    }
    /// <p>Specifies a string to display when users connect to a server. This string is displayed before the user authenticates. For example, the following banner displays details about using the system:</p>
    /// <p> <code>This system is for the use of authorized users only. Individuals using this computer system without authority, or in excess of their authority, are subject to having all of their activities on this system monitored and recorded by system personnel.</code> </p>
    pub fn set_pre_authentication_login_banner(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.pre_authentication_login_banner = input;
        self
    }
    /// Appends an item to `protocols`.
    ///
    /// To override the contents of this collection use [`set_protocols`](Self::set_protocols).
    ///
    /// <p>Specifies the file transfer protocol or protocols over which your file transfer protocol client can connect to your server's endpoint. The available protocols are:</p>
    /// <ul>
    /// <li> <p> <code>SFTP</code> (Secure Shell (SSH) File Transfer Protocol): File transfer over SSH</p> </li>
    /// <li> <p> <code>FTPS</code> (File Transfer Protocol Secure): File transfer with TLS encryption</p> </li>
    /// <li> <p> <code>FTP</code> (File Transfer Protocol): Unencrypted file transfer</p> </li>
    /// <li> <p> <code>AS2</code> (Applicability Statement 2): used for transporting structured business-to-business data</p> </li>
    /// </ul> <note>
    /// <ul>
    /// <li> <p>If you select <code>FTPS</code>, you must choose a certificate stored in Certificate Manager (ACM) which is used to identify your server when clients connect to it over FTPS.</p> </li>
    /// <li> <p>If <code>Protocol</code> includes either <code>FTP</code> or <code>FTPS</code>, then the <code>EndpointType</code> must be <code>VPC</code> and the <code>IdentityProviderType</code> must be <code>AWS_DIRECTORY_SERVICE</code> or <code>API_GATEWAY</code>.</p> </li>
    /// <li> <p>If <code>Protocol</code> includes <code>FTP</code>, then <code>AddressAllocationIds</code> cannot be associated.</p> </li>
    /// <li> <p>If <code>Protocol</code> is set only to <code>SFTP</code>, the <code>EndpointType</code> can be set to <code>PUBLIC</code> and the <code>IdentityProviderType</code> can be set to <code>SERVICE_MANAGED</code>.</p> </li>
    /// <li> <p>If <code>Protocol</code> includes <code>AS2</code>, then the <code>EndpointType</code> must be <code>VPC</code>, and domain must be Amazon S3.</p> </li>
    /// </ul>
    /// </note>
    pub fn protocols(mut self, input: crate::types::Protocol) -> Self {
        let mut v = self.protocols.unwrap_or_default();
        v.push(input);
        self.protocols = Some(v);
        self
    }
    /// <p>Specifies the file transfer protocol or protocols over which your file transfer protocol client can connect to your server's endpoint. The available protocols are:</p>
    /// <ul>
    /// <li> <p> <code>SFTP</code> (Secure Shell (SSH) File Transfer Protocol): File transfer over SSH</p> </li>
    /// <li> <p> <code>FTPS</code> (File Transfer Protocol Secure): File transfer with TLS encryption</p> </li>
    /// <li> <p> <code>FTP</code> (File Transfer Protocol): Unencrypted file transfer</p> </li>
    /// <li> <p> <code>AS2</code> (Applicability Statement 2): used for transporting structured business-to-business data</p> </li>
    /// </ul> <note>
    /// <ul>
    /// <li> <p>If you select <code>FTPS</code>, you must choose a certificate stored in Certificate Manager (ACM) which is used to identify your server when clients connect to it over FTPS.</p> </li>
    /// <li> <p>If <code>Protocol</code> includes either <code>FTP</code> or <code>FTPS</code>, then the <code>EndpointType</code> must be <code>VPC</code> and the <code>IdentityProviderType</code> must be <code>AWS_DIRECTORY_SERVICE</code> or <code>API_GATEWAY</code>.</p> </li>
    /// <li> <p>If <code>Protocol</code> includes <code>FTP</code>, then <code>AddressAllocationIds</code> cannot be associated.</p> </li>
    /// <li> <p>If <code>Protocol</code> is set only to <code>SFTP</code>, the <code>EndpointType</code> can be set to <code>PUBLIC</code> and the <code>IdentityProviderType</code> can be set to <code>SERVICE_MANAGED</code>.</p> </li>
    /// <li> <p>If <code>Protocol</code> includes <code>AS2</code>, then the <code>EndpointType</code> must be <code>VPC</code>, and domain must be Amazon S3.</p> </li>
    /// </ul>
    /// </note>
    pub fn set_protocols(
        mut self,
        input: std::option::Option<std::vec::Vec<crate::types::Protocol>>,
    ) -> Self {
        self.protocols = input;
        self
    }
    /// <p>Specifies the name of the security policy that is attached to the server.</p>
    pub fn security_policy_name(mut self, input: impl Into<std::string::String>) -> Self {
        self.security_policy_name = Some(input.into());
        self
    }
    /// <p>Specifies the name of the security policy that is attached to the server.</p>
    pub fn set_security_policy_name(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.security_policy_name = input;
        self
    }
    /// <p>Specifies the unique system-assigned identifier for a server that you instantiate.</p>
    pub fn server_id(mut self, input: impl Into<std::string::String>) -> Self {
        self.server_id = Some(input.into());
        self
    }
    /// <p>Specifies the unique system-assigned identifier for a server that you instantiate.</p>
    pub fn set_server_id(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.server_id = input;
        self
    }
    /// <p>The condition of the server that was described. A value of <code>ONLINE</code> indicates that the server can accept jobs and transfer files. A <code>State</code> value of <code>OFFLINE</code> means that the server cannot perform file transfer operations.</p>
    /// <p>The states of <code>STARTING</code> and <code>STOPPING</code> indicate that the server is in an intermediate state, either not fully able to respond, or not fully offline. The values of <code>START_FAILED</code> or <code>STOP_FAILED</code> can indicate an error condition.</p>
    pub fn state(mut self, input: crate::types::State) -> Self {
        self.state = Some(input);
        self
    }
    /// <p>The condition of the server that was described. A value of <code>ONLINE</code> indicates that the server can accept jobs and transfer files. A <code>State</code> value of <code>OFFLINE</code> means that the server cannot perform file transfer operations.</p>
    /// <p>The states of <code>STARTING</code> and <code>STOPPING</code> indicate that the server is in an intermediate state, either not fully able to respond, or not fully offline. The values of <code>START_FAILED</code> or <code>STOP_FAILED</code> can indicate an error condition.</p>
    pub fn set_state(mut self, input: std::option::Option<crate::types::State>) -> Self {
        self.state = input;
        self
    }
    /// Appends an item to `tags`.
    ///
    /// To override the contents of this collection use [`set_tags`](Self::set_tags).
    ///
    /// <p>Specifies the key-value pairs that you can use to search for and group servers that were assigned to the server that was described.</p>
    pub fn tags(mut self, input: crate::types::Tag) -> Self {
        let mut v = self.tags.unwrap_or_default();
        v.push(input);
        self.tags = Some(v);
        self
    }
    /// <p>Specifies the key-value pairs that you can use to search for and group servers that were assigned to the server that was described.</p>
    pub fn set_tags(
        mut self,
        input: std::option::Option<std::vec::Vec<crate::types::Tag>>,
    ) -> Self {
        self.tags = input;
        self
    }
    /// <p>Specifies the number of users that are assigned to a server you specified with the <code>ServerId</code>.</p>
    pub fn user_count(mut self, input: i32) -> Self {
        self.user_count = Some(input);
        self
    }
    /// <p>Specifies the number of users that are assigned to a server you specified with the <code>ServerId</code>.</p>
    pub fn set_user_count(mut self, input: std::option::Option<i32>) -> Self {
        self.user_count = input;
        self
    }
    /// <p>Specifies the workflow ID for the workflow to assign and the execution role that's used for executing the workflow.</p>
    /// <p>In additon to a workflow to execute when a file is uploaded completely, <code>WorkflowDeatails</code> can also contain a workflow ID (and execution role) for a workflow to execute on partial upload. A partial upload occurs when a file is open when the session disconnects.</p>
    pub fn workflow_details(mut self, input: crate::types::WorkflowDetails) -> Self {
        self.workflow_details = Some(input);
        self
    }
    /// <p>Specifies the workflow ID for the workflow to assign and the execution role that's used for executing the workflow.</p>
    /// <p>In additon to a workflow to execute when a file is uploaded completely, <code>WorkflowDeatails</code> can also contain a workflow ID (and execution role) for a workflow to execute on partial upload. A partial upload occurs when a file is open when the session disconnects.</p>
    pub fn set_workflow_details(
        mut self,
        input: std::option::Option<crate::types::WorkflowDetails>,
    ) -> Self {
        self.workflow_details = input;
        self
    }
    /// Consumes the builder and constructs a [`DescribedServer`](crate::types::DescribedServer).
    pub fn build(self) -> crate::types::DescribedServer {
        crate::types::DescribedServer {
            arn: self.arn,
            certificate: self.certificate,
            protocol_details: self.protocol_details,
            domain: self.domain,
            endpoint_details: self.endpoint_details,
            endpoint_type: self.endpoint_type,
            host_key_fingerprint: self.host_key_fingerprint,
            identity_provider_details: self.identity_provider_details,
            identity_provider_type: self.identity_provider_type,
            logging_role: self.logging_role,
            post_authentication_login_banner: self.post_authentication_login_banner,
            pre_authentication_login_banner: self.pre_authentication_login_banner,
            protocols: self.protocols,
            security_policy_name: self.security_policy_name,
            server_id: self.server_id,
            state: self.state,
            tags: self.tags,
            user_count: self.user_count,
            workflow_details: self.workflow_details,
        }
    }
}
