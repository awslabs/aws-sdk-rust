// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(std::fmt::Debug)]
pub(crate) struct Handle<C = aws_hyper::DynConnector> {
    client: aws_hyper::Client<C>,
    conf: crate::Config,
}

#[derive(Clone, std::fmt::Debug)]
pub struct Client<C = aws_hyper::DynConnector> {
    handle: std::sync::Arc<Handle<C>>,
}
impl<C> Client<C> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl Client {
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_env() -> Self {
        Self::from_conf(crate::Config::builder().build())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let client = aws_hyper::Client::https();
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl<C> Client<C>
where
    C: aws_hyper::SmithyConnector,
{
    pub fn create_access(&self) -> fluent_builders::CreateAccess<C> {
        fluent_builders::CreateAccess::new(self.handle.clone())
    }
    pub fn create_server(&self) -> fluent_builders::CreateServer<C> {
        fluent_builders::CreateServer::new(self.handle.clone())
    }
    pub fn create_user(&self) -> fluent_builders::CreateUser<C> {
        fluent_builders::CreateUser::new(self.handle.clone())
    }
    pub fn delete_access(&self) -> fluent_builders::DeleteAccess<C> {
        fluent_builders::DeleteAccess::new(self.handle.clone())
    }
    pub fn delete_server(&self) -> fluent_builders::DeleteServer<C> {
        fluent_builders::DeleteServer::new(self.handle.clone())
    }
    pub fn delete_ssh_public_key(&self) -> fluent_builders::DeleteSshPublicKey<C> {
        fluent_builders::DeleteSshPublicKey::new(self.handle.clone())
    }
    pub fn delete_user(&self) -> fluent_builders::DeleteUser<C> {
        fluent_builders::DeleteUser::new(self.handle.clone())
    }
    pub fn describe_access(&self) -> fluent_builders::DescribeAccess<C> {
        fluent_builders::DescribeAccess::new(self.handle.clone())
    }
    pub fn describe_security_policy(&self) -> fluent_builders::DescribeSecurityPolicy<C> {
        fluent_builders::DescribeSecurityPolicy::new(self.handle.clone())
    }
    pub fn describe_server(&self) -> fluent_builders::DescribeServer<C> {
        fluent_builders::DescribeServer::new(self.handle.clone())
    }
    pub fn describe_user(&self) -> fluent_builders::DescribeUser<C> {
        fluent_builders::DescribeUser::new(self.handle.clone())
    }
    pub fn import_ssh_public_key(&self) -> fluent_builders::ImportSshPublicKey<C> {
        fluent_builders::ImportSshPublicKey::new(self.handle.clone())
    }
    pub fn list_accesses(&self) -> fluent_builders::ListAccesses<C> {
        fluent_builders::ListAccesses::new(self.handle.clone())
    }
    pub fn list_security_policies(&self) -> fluent_builders::ListSecurityPolicies<C> {
        fluent_builders::ListSecurityPolicies::new(self.handle.clone())
    }
    pub fn list_servers(&self) -> fluent_builders::ListServers<C> {
        fluent_builders::ListServers::new(self.handle.clone())
    }
    pub fn list_tags_for_resource(&self) -> fluent_builders::ListTagsForResource<C> {
        fluent_builders::ListTagsForResource::new(self.handle.clone())
    }
    pub fn list_users(&self) -> fluent_builders::ListUsers<C> {
        fluent_builders::ListUsers::new(self.handle.clone())
    }
    pub fn start_server(&self) -> fluent_builders::StartServer<C> {
        fluent_builders::StartServer::new(self.handle.clone())
    }
    pub fn stop_server(&self) -> fluent_builders::StopServer<C> {
        fluent_builders::StopServer::new(self.handle.clone())
    }
    pub fn tag_resource(&self) -> fluent_builders::TagResource<C> {
        fluent_builders::TagResource::new(self.handle.clone())
    }
    pub fn test_identity_provider(&self) -> fluent_builders::TestIdentityProvider<C> {
        fluent_builders::TestIdentityProvider::new(self.handle.clone())
    }
    pub fn untag_resource(&self) -> fluent_builders::UntagResource<C> {
        fluent_builders::UntagResource::new(self.handle.clone())
    }
    pub fn update_access(&self) -> fluent_builders::UpdateAccess<C> {
        fluent_builders::UpdateAccess::new(self.handle.clone())
    }
    pub fn update_server(&self) -> fluent_builders::UpdateServer<C> {
        fluent_builders::UpdateServer::new(self.handle.clone())
    }
    pub fn update_user(&self) -> fluent_builders::UpdateUser<C> {
        fluent_builders::UpdateUser::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct CreateAccess<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_access_input::Builder,
    }
    impl<C> CreateAccess<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateAccessOutput,
            smithy_http::result::SdkError<crate::error::CreateAccessError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The landing directory (folder) for a user when they log in to the server using the client.</p>
        /// <p>A <code>HomeDirectory</code> example is <code>/bucket_name/home/mydirectory</code>.</p>
        pub fn home_directory(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.home_directory(input);
            self
        }
        pub fn set_home_directory(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_home_directory(input);
            self
        }
        /// <p>The type of landing directory (folder) you want your users' home directory to be when they log into the server.
        /// If you set it to <code>PATH</code>, the user will see the absolute Amazon S3 bucket or EFS paths as is in their file transfer protocol clients.
        /// If you set it <code>LOGICAL</code>, you will need to provide mappings in the <code>HomeDirectoryMappings</code> for how you want to make Amazon
        /// S3 or EFS paths visible to your users.</p>
        pub fn home_directory_type(mut self, input: crate::model::HomeDirectoryType) -> Self {
            self.inner = self.inner.home_directory_type(input);
            self
        }
        pub fn set_home_directory_type(
            mut self,
            input: std::option::Option<crate::model::HomeDirectoryType>,
        ) -> Self {
            self.inner = self.inner.set_home_directory_type(input);
            self
        }
        /// <p>Logical directory mappings that specify what Amazon S3 or Amazon EFS paths and keys should
        /// be visible to your user and how you want to make them visible. You must specify the
        /// <code>Entry</code> and <code>Target</code> pair, where <code>Entry</code> shows how the path
        /// is made visible and <code>Target</code> is the actual Amazon S3 or Amazon EFS path. If you
        /// only specify a target, it is displayed as is. You also must ensure that your Amazon Web Services Identity
        /// and Access Management (IAM) role provides access to paths in <code>Target</code>. This value
        /// can only be set when <code>HomeDirectoryType</code> is set to
        /// <i>LOGICAL</i>.</p>
        /// <p>The following is an <code>Entry</code> and <code>Target</code> pair example.</p>
        /// <p>
        /// <code>[ { "Entry": "your-personal-report.pdf", "Target": "/bucket3/customized-reports/${transfer:UserName}.pdf" } ]</code>
        /// </p>
        /// <p>In most cases, you can use this value instead of the scope-down policy to lock down your
        /// user to the designated home directory ("<code>chroot</code>"). To do this, you can set
        /// <code>Entry</code> to <code>/</code> and set <code>Target</code> to the
        /// <code>HomeDirectory</code> parameter value.</p>
        /// <p>The following is an <code>Entry</code> and <code>Target</code> pair example for <code>chroot</code>.</p>
        /// <p>
        /// <code>[ { "Entry:": "/", "Target": "/bucket_name/home/mydirectory" } ]</code>
        /// </p>
        /// <note>
        /// <p>If the target of a logical directory entry does not exist in Amazon S3 or EFS, the entry is
        /// ignored. As a workaround, you can use the Amazon S3 API or EFS API to create 0 byte objects as place
        /// holders for your directory. If using the CLI, use the <code>s3api</code> or <code>efsapi</code> call instead of
        /// <code>s3</code> or <code>efs</code> so you can use the put-object operation. For example, you use the
        /// following: <code>aws s3api put-object --bucket bucketname --key path/to/folder/</code>. Make
        /// sure that the end of the key name ends in a <code>/</code> for it to be considered a folder.</p>
        /// </note>
        pub fn home_directory_mappings(
            mut self,
            inp: impl Into<crate::model::HomeDirectoryMapEntry>,
        ) -> Self {
            self.inner = self.inner.home_directory_mappings(inp);
            self
        }
        pub fn set_home_directory_mappings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::HomeDirectoryMapEntry>>,
        ) -> Self {
            self.inner = self.inner.set_home_directory_mappings(input);
            self
        }
        /// <p>A scope-down policy for your user so that you can use the same IAM role across multiple users. This policy scopes down user
        /// access to portions of their Amazon S3 bucket. Variables that you can use inside this policy include <code>${Transfer:UserName}</code>,
        /// <code>${Transfer:HomeDirectory}</code>, and <code>${Transfer:HomeBucket}</code>.</p>
        /// <note>
        /// <p>This only applies when domain of <code>ServerId</code> is S3.
        /// Amazon EFS does not use scope-down policies.</p>
        /// <p>For scope-down policies, Amazon Web Services Transfer Family stores the policy as a JSON blob, instead of the Amazon Resource Name (ARN) of the policy. You save the policy as a JSON blob and pass it in the <code>Policy</code> argument.</p>
        /// <p>For an example of a scope-down policy, see <a href="https://docs.aws.amazon.com/transfer/latest/userguide/scope-down-policy.html">Example
        /// scope-down policy</a>.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRole.html">AssumeRole</a> in the <i>Amazon Web Services Security Token Service API
        /// Reference</i>.</p>
        /// </note>
        pub fn policy(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy(input);
            self
        }
        pub fn set_policy(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy(input);
            self
        }
        /// <p>The full POSIX identity, including user ID (<code>Uid</code>), group ID
        /// (<code>Gid</code>), and any secondary groups IDs (<code>SecondaryGids</code>), that controls
        /// your users' access to your Amazon EFS file systems. The POSIX permissions that are set on
        /// files and directories in your file system determine the level of access your users get when
        /// transferring files into and out of your Amazon EFS file systems.</p>
        pub fn posix_profile(mut self, input: crate::model::PosixProfile) -> Self {
            self.inner = self.inner.posix_profile(input);
            self
        }
        pub fn set_posix_profile(
            mut self,
            input: std::option::Option<crate::model::PosixProfile>,
        ) -> Self {
            self.inner = self.inner.set_posix_profile(input);
            self
        }
        /// <p>Specifies the Amazon Resource Name (ARN) of the IAM role that controls your users' access to your Amazon S3 bucket or EFS
        /// file system. The policies attached to this role determine the level of access that you want to provide your users when transferring
        /// files into and out of your Amazon S3 bucket or EFS file system. The IAM role should also contain a trust relationship that allows the
        /// server to access your resources when servicing your users' transfer requests.</p>
        pub fn role(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role(input);
            self
        }
        pub fn set_role(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role(input);
            self
        }
        /// <p>A system-assigned unique identifier for a server instance. This is the specific server that you added your user to.</p>
        pub fn server_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.server_id(input);
            self
        }
        pub fn set_server_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_server_id(input);
            self
        }
        /// <p>A unique identifier that is required to identify specific groups within your directory.
        /// The users of the group that you associate have access to your Amazon S3 or Amazon EFS
        /// resources over the enabled protocols using Amazon Web Services Transfer Family. If you know the group name,
        /// you can view the SID values by running the following command using Windows PowerShell.</p>
        /// <p>
        /// <code>Get-ADGroup -Filter {samAccountName -like "<i>YourGroupName</i>*"} -Properties * | Select SamAccountName,ObjectSid</code>
        /// </p>
        /// <p>In that command, replace <i>YourGroupName</i> with the name of your Active Directory group.</p>
        /// <p>The regex used to validate this parameter is a string of characters consisting of uppercase and lowercase alphanumeric characters with no spaces.
        /// You can also include underscores or any of the following characters: =,.@:/-</p>
        pub fn external_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.external_id(input);
            self
        }
        pub fn set_external_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_external_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateServer<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_server_input::Builder,
    }
    impl<C> CreateServer<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateServerOutput,
            smithy_http::result::SdkError<crate::error::CreateServerError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the Amazon Web Services Certificate Manager (ACM) certificate. Required
        /// when <code>Protocols</code> is set to <code>FTPS</code>.</p>
        /// <p>To request a new public certificate, see <a href="https://docs.aws.amazon.com/acm/latest/userguide/gs-acm-request-public.html">Request a public certificate</a>
        /// in the <i> Amazon Web Services Certificate Manager User Guide</i>.</p>
        /// <p>To import an existing certificate into ACM, see <a href="https://docs.aws.amazon.com/acm/latest/userguide/import-certificate.html">Importing certificates into ACM</a>
        /// in the <i> Amazon Web Services Certificate Manager User Guide</i>.</p>
        /// <p>To request a private certificate to use FTPS through private IP addresses, see <a href="https://docs.aws.amazon.com/acm/latest/userguide/gs-acm-request-private.html">Request a
        /// private certificate</a> in the <i> Amazon Web Services Certificate Manager User
        /// Guide</i>.</p>
        /// <p>Certificates with the following cryptographic algorithms and key sizes are
        /// supported:</p>
        /// <ul>
        /// <li>
        /// <p>2048-bit RSA (RSA_2048)</p>
        /// </li>
        /// <li>
        /// <p>4096-bit RSA (RSA_4096)</p>
        /// </li>
        /// <li>
        /// <p>Elliptic Prime Curve 256 bit (EC_prime256v1)</p>
        /// </li>
        /// <li>
        /// <p>Elliptic Prime Curve 384 bit (EC_secp384r1)</p>
        /// </li>
        /// <li>
        /// <p>Elliptic Prime Curve 521 bit (EC_secp521r1)</p>
        /// </li>
        /// </ul>
        /// <note>
        /// <p>The certificate must be a valid SSL/TLS X.509 version 3 certificate with FQDN or IP
        /// address specified and information about the issuer.</p>
        /// </note>
        pub fn certificate(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.certificate(input);
            self
        }
        pub fn set_certificate(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_certificate(input);
            self
        }
        /// <p>The domain of the storage system that is used for file transfers. There are two domains
        /// available: Amazon Simple Storage Service (Amazon S3) and Amazon Elastic File System (Amazon EFS). The
        /// default value is S3.</p>
        /// <note>
        /// <p>After the server is created, the domain cannot be changed.</p>
        /// </note>
        pub fn domain(mut self, input: crate::model::Domain) -> Self {
            self.inner = self.inner.domain(input);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<crate::model::Domain>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>The virtual private cloud (VPC) endpoint settings that are configured for your server.
        /// When you host your endpoint within your VPC, you can make it accessible only to resources
        /// within your VPC, or you can attach Elastic IP addresses and make it accessible to clients over
        /// the internet. Your VPC's default security groups are automatically assigned to your
        /// endpoint.</p>
        pub fn endpoint_details(mut self, input: crate::model::EndpointDetails) -> Self {
            self.inner = self.inner.endpoint_details(input);
            self
        }
        pub fn set_endpoint_details(
            mut self,
            input: std::option::Option<crate::model::EndpointDetails>,
        ) -> Self {
            self.inner = self.inner.set_endpoint_details(input);
            self
        }
        /// <p>The type of endpoint that you want your server to use. You can choose to make your server's endpoint publicly accessible (PUBLIC)
        /// or host it inside your VPC. With an endpoint that is hosted in a VPC, you can restrict access to your server and
        /// resources only within your VPC or choose to make it internet facing by attaching Elastic IP addresses directly to it.</p>
        /// <note>
        /// <p> After May 19, 2021, you won't be able to create a server using
        /// <code>EndpointType=VPC_ENDPOINT</code> in your Amazon Web Services account if your account hasn't already
        /// done so before May 19, 2021. If you have already created servers with
        /// <code>EndpointType=VPC_ENDPOINT</code> in your Amazon Web Services account on or before May 19, 2021,
        /// you will not be affected. After this date, use
        /// <code>EndpointType</code>=<code>VPC</code>.</p>
        /// <p>For more information, see
        /// https://docs.aws.amazon.com/transfer/latest/userguide/create-server-in-vpc.html#deprecate-vpc-endpoint.</p>
        /// <p>It is recommended that you use <code>VPC</code> as the <code>EndpointType</code>. With
        /// this endpoint type, you have the option to directly associate up to three Elastic IPv4
        /// addresses (BYO IP included) with your server's endpoint and use VPC security groups to
        /// restrict traffic by the client's public IP address. This is not possible with
        /// <code>EndpointType</code> set to <code>VPC_ENDPOINT</code>.</p>
        /// </note>
        pub fn endpoint_type(mut self, input: crate::model::EndpointType) -> Self {
            self.inner = self.inner.endpoint_type(input);
            self
        }
        pub fn set_endpoint_type(
            mut self,
            input: std::option::Option<crate::model::EndpointType>,
        ) -> Self {
            self.inner = self.inner.set_endpoint_type(input);
            self
        }
        /// <p>The RSA private key as generated by the <code>ssh-keygen -N "" -m PEM -f
        /// my-new-server-key</code> command.</p>
        /// <important>
        /// <p>If you aren't planning to migrate existing users from an existing SFTP-enabled
        /// server to a new server, don't update the host key. Accidentally changing a
        /// server's host key can be disruptive.</p>
        /// </important>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/transfer/latest/userguide/edit-server-config.html#configuring-servers-change-host-key">Change the host key for your SFTP-enabled server</a> in the <i>Amazon Web Services Transfer
        /// Family User Guide</i>.</p>
        pub fn host_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.host_key(input);
            self
        }
        pub fn set_host_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_host_key(input);
            self
        }
        /// <p>Required when <code>IdentityProviderType</code> is set to
        /// <code>AWS_DIRECTORY_SERVICE</code> or <code>API_GATEWAY</code>. Accepts an array containing
        /// all of the information required to use a directory in <code>AWS_DIRECTORY_SERVICE</code> or
        /// invoke a customer-supplied authentication API, including the API Gateway URL. Not required
        /// when <code>IdentityProviderType</code> is set to <code>SERVICE_MANAGED</code>.</p>
        pub fn identity_provider_details(
            mut self,
            input: crate::model::IdentityProviderDetails,
        ) -> Self {
            self.inner = self.inner.identity_provider_details(input);
            self
        }
        pub fn set_identity_provider_details(
            mut self,
            input: std::option::Option<crate::model::IdentityProviderDetails>,
        ) -> Self {
            self.inner = self.inner.set_identity_provider_details(input);
            self
        }
        /// <p>Specifies the mode of authentication for a server. The default value is
        /// <code>SERVICE_MANAGED</code>, which allows you to store and access user credentials within
        /// the Amazon Web Services Transfer Family service.</p>
        /// <p>Use <code>AWS_DIRECTORY_SERVICE</code> to provide access to
        /// Active Directory groups in Amazon Web Services Managed Active Directory or Microsoft Active Directory in your
        /// on-premises environment or in Amazon Web Services using AD Connectors. This option also requires you to
        /// provide a Directory ID using the <code>IdentityProviderDetails</code> parameter.</p>
        /// <p>Use the <code>API_GATEWAY</code> value to integrate with an identity provider of your choosing. The
        /// <code>API_GATEWAY</code> setting requires you to provide an API Gateway endpoint URL to call
        /// for authentication using the <code>IdentityProviderDetails</code> parameter.</p>
        pub fn identity_provider_type(mut self, input: crate::model::IdentityProviderType) -> Self {
            self.inner = self.inner.identity_provider_type(input);
            self
        }
        pub fn set_identity_provider_type(
            mut self,
            input: std::option::Option<crate::model::IdentityProviderType>,
        ) -> Self {
            self.inner = self.inner.set_identity_provider_type(input);
            self
        }
        /// <p>Specifies the Amazon Resource Name (ARN) of the Amazon Web Services Identity and Access Management (IAM) role that allows a server to turn
        /// on Amazon CloudWatch logging for Amazon S3 or Amazon EFS events. When set, user activity can be viewed in
        /// your CloudWatch logs.</p>
        pub fn logging_role(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.logging_role(input);
            self
        }
        pub fn set_logging_role(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_logging_role(input);
            self
        }
        /// <p>Specifies the file transfer protocol or protocols over which your file transfer protocol
        /// client can connect to your server's endpoint. The available protocols are:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>SFTP</code> (Secure Shell (SSH) File Transfer Protocol): File transfer over
        /// SSH</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>FTPS</code> (File Transfer Protocol Secure): File transfer with TLS
        /// encryption</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>FTP</code> (File Transfer Protocol): Unencrypted file transfer</p>
        /// </li>
        /// </ul>
        /// <note>
        /// <p>If you select <code>FTPS</code>, you must choose a certificate stored in Amazon Web Services Certificate
        /// Manager (ACM) which is used to identify your server when clients connect to it over
        /// FTPS.</p>
        /// <p>If <code>Protocol</code> includes either <code>FTP</code> or <code>FTPS</code>, then the
        /// <code>EndpointType</code> must be <code>VPC</code> and the
        /// <code>IdentityProviderType</code> must be <code>AWS_DIRECTORY_SERVICE</code> or <code>API_GATEWAY</code>.</p>
        /// <p>If <code>Protocol</code> includes <code>FTP</code>, then
        /// <code>AddressAllocationIds</code> cannot be associated.</p>
        /// <p>If <code>Protocol</code> is set only to <code>SFTP</code>, the <code>EndpointType</code>
        /// can be set to <code>PUBLIC</code> and the <code>IdentityProviderType</code> can be set to
        /// <code>SERVICE_MANAGED</code>.</p>
        /// </note>
        pub fn protocols(mut self, inp: impl Into<crate::model::Protocol>) -> Self {
            self.inner = self.inner.protocols(inp);
            self
        }
        pub fn set_protocols(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Protocol>>,
        ) -> Self {
            self.inner = self.inner.set_protocols(input);
            self
        }
        /// <p>Specifies the name of the security policy that is attached to the server.</p>
        pub fn security_policy_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.security_policy_name(input);
            self
        }
        pub fn set_security_policy_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_security_policy_name(input);
            self
        }
        /// <p>Key-value pairs that can be used to group and search for servers.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateUser<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_user_input::Builder,
    }
    impl<C> CreateUser<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateUserOutput,
            smithy_http::result::SdkError<crate::error::CreateUserError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The landing directory (folder) for a user when they log in to the server using the client.</p>
        /// <p>A <code>HomeDirectory</code> example is <code>/bucket_name/home/mydirectory</code>.</p>
        pub fn home_directory(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.home_directory(input);
            self
        }
        pub fn set_home_directory(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_home_directory(input);
            self
        }
        /// <p>The type of landing directory (folder) you want your users' home directory to be when they log into the server.
        /// If you set it to <code>PATH</code>, the user will see the absolute Amazon S3 bucket or EFS paths as is in their file transfer protocol clients.
        /// If you set it <code>LOGICAL</code>, you will need to provide mappings in the <code>HomeDirectoryMappings</code> for how you want to make Amazon
        /// S3 or EFS paths visible to your users.</p>
        pub fn home_directory_type(mut self, input: crate::model::HomeDirectoryType) -> Self {
            self.inner = self.inner.home_directory_type(input);
            self
        }
        pub fn set_home_directory_type(
            mut self,
            input: std::option::Option<crate::model::HomeDirectoryType>,
        ) -> Self {
            self.inner = self.inner.set_home_directory_type(input);
            self
        }
        /// <p>Logical directory mappings that specify what Amazon S3 or Amazon EFS paths and keys should
        /// be visible to your user and how you want to make them visible. You must specify the
        /// <code>Entry</code> and <code>Target</code> pair, where <code>Entry</code> shows how the path
        /// is made visible and <code>Target</code> is the actual Amazon S3 or Amazon EFS path. If you
        /// only specify a target, it is displayed as is. You also must ensure that your Amazon Web Services Identity
        /// and Access Management (IAM) role provides access to paths in <code>Target</code>. This value
        /// can only be set when <code>HomeDirectoryType</code> is set to
        /// <i>LOGICAL</i>.</p>
        /// <p>The following is an <code>Entry</code> and <code>Target</code> pair example.</p>
        /// <p>
        /// <code>[ { "Entry": "your-personal-report.pdf", "Target":
        /// "/bucket3/customized-reports/${transfer:UserName}.pdf" } ]</code>
        /// </p>
        /// <p>In most cases, you can use this value instead of the scope-down policy to lock your user
        /// down to the designated home directory ("<code>chroot</code>"). To do this, you can set
        /// <code>Entry</code> to <code>/</code> and set <code>Target</code> to the HomeDirectory
        /// parameter value.</p>
        /// <p>The following is an <code>Entry</code> and <code>Target</code> pair example for <code>chroot</code>.</p>
        /// <p>
        /// <code>[ { "Entry:": "/", "Target": "/bucket_name/home/mydirectory" } ]</code>
        /// </p>
        /// <note>
        /// <p>If the target of a logical directory entry does not exist in Amazon S3 or EFS, the entry is
        /// ignored. As a workaround, you can use the Amazon S3 API or EFS API to create 0 byte objects as place
        /// holders for your directory. If using the CLI, use the <code>s3api</code> or <code>efsapi</code> call instead of
        /// <code>s3</code> or <code>efs</code> so you can use the put-object operation. For example, you use the
        /// following: <code>aws s3api put-object --bucket bucketname --key path/to/folder/</code>. Make
        /// sure that the end of the key name ends in a <code>/</code> for it to be considered a folder.</p>
        /// </note>
        pub fn home_directory_mappings(
            mut self,
            inp: impl Into<crate::model::HomeDirectoryMapEntry>,
        ) -> Self {
            self.inner = self.inner.home_directory_mappings(inp);
            self
        }
        pub fn set_home_directory_mappings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::HomeDirectoryMapEntry>>,
        ) -> Self {
            self.inner = self.inner.set_home_directory_mappings(input);
            self
        }
        /// <p>A scope-down policy for your user so that you can use the same IAM role across multiple users. This policy scopes down user
        /// access to portions of their Amazon S3 bucket. Variables that you can use inside this policy include <code>${Transfer:UserName}</code>,
        /// <code>${Transfer:HomeDirectory}</code>, and <code>${Transfer:HomeBucket}</code>.</p>
        /// <note>
        /// <p>This only applies when domain of ServerId is S3. EFS does not use scope down policy.</p>
        /// <p>For scope-down policies, Amazon Web Services Transfer Family stores the policy as a JSON blob, instead
        /// of the Amazon Resource Name (ARN) of the policy. You save the policy as a JSON blob and pass
        /// it in the <code>Policy</code> argument.</p>
        /// <p>For an example of a scope-down policy, see <a href="https://docs.aws.amazon.com/transfer/latest/userguide/scope-down-policy.html">Example scope-down
        /// policy</a>.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRole.html">AssumeRole</a> in the <i>Amazon Web Services
        /// Security Token Service API Reference</i>.</p>
        /// </note>
        pub fn policy(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy(input);
            self
        }
        pub fn set_policy(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy(input);
            self
        }
        /// <p>Specifies the full POSIX identity, including user ID (<code>Uid</code>), group ID
        /// (<code>Gid</code>), and any secondary groups IDs (<code>SecondaryGids</code>), that controls
        /// your users' access to your Amazon EFS file systems. The POSIX permissions that are set on
        /// files and directories in Amazon EFS determine the level of access your users get when
        /// transferring files into and out of your Amazon EFS file systems.</p>
        pub fn posix_profile(mut self, input: crate::model::PosixProfile) -> Self {
            self.inner = self.inner.posix_profile(input);
            self
        }
        pub fn set_posix_profile(
            mut self,
            input: std::option::Option<crate::model::PosixProfile>,
        ) -> Self {
            self.inner = self.inner.set_posix_profile(input);
            self
        }
        /// <p>Specifies the Amazon Resource Name (ARN) of the IAM role that controls your users' access to your Amazon S3 bucket or EFS
        /// file system. The policies attached to this role determine the level of access that you want to provide your users when transferring
        /// files into and out of your Amazon S3 bucket or EFS file system. The IAM role should also contain a trust relationship that allows the
        /// server to access your resources when servicing your users' transfer requests.</p>
        pub fn role(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role(input);
            self
        }
        pub fn set_role(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role(input);
            self
        }
        /// <p>A system-assigned unique identifier for a server instance. This is the specific server
        /// that you added your user to.</p>
        pub fn server_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.server_id(input);
            self
        }
        pub fn set_server_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_server_id(input);
            self
        }
        /// <p>The public portion of the Secure Shell (SSH) key used to authenticate the user to the
        /// server.</p>
        pub fn ssh_public_key_body(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ssh_public_key_body(input);
            self
        }
        pub fn set_ssh_public_key_body(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_ssh_public_key_body(input);
            self
        }
        /// <p>Key-value pairs that can be used to group and search for users. Tags are metadata attached
        /// to users for any purpose.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>A unique string that identifies a user and is associated with a as specified by the
        /// <code>ServerId</code>. This user name must be a minimum of 3 and a maximum of 100 characters
        /// long. The following are valid characters: a-z, A-Z, 0-9, underscore '_', hyphen
        /// '-', period '.', and at sign '@'. The user name can't start
        /// with a hyphen, period, or at sign.</p>
        pub fn user_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_name(input);
            self
        }
        pub fn set_user_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_user_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteAccess<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_access_input::Builder,
    }
    impl<C> DeleteAccess<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteAccessOutput,
            smithy_http::result::SdkError<crate::error::DeleteAccessError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A system-assigned unique identifier for a server that has this user assigned.</p>
        pub fn server_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.server_id(input);
            self
        }
        pub fn set_server_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_server_id(input);
            self
        }
        /// <p>A unique identifier that is required to identify specific groups within your directory.
        /// The users of the group that you associate have access to your Amazon S3 or Amazon EFS
        /// resources over the enabled protocols using Amazon Web Services Transfer Family. If you know the group name,
        /// you can view the SID values by running the following command using Windows PowerShell.</p>
        /// <p>
        /// <code>Get-ADGroup -Filter {samAccountName -like "<i>YourGroupName</i>*"} -Properties * | Select SamAccountName,ObjectSid</code>
        /// </p>
        /// <p>In that command, replace <i>YourGroupName</i> with the name of your Active Directory group.</p>
        /// <p>The regex used to validate this parameter is a string of characters consisting of uppercase and lowercase alphanumeric characters with no spaces.
        /// You can also include underscores or any of the following characters: =,.@:/-</p>
        pub fn external_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.external_id(input);
            self
        }
        pub fn set_external_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_external_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteServer<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_server_input::Builder,
    }
    impl<C> DeleteServer<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteServerOutput,
            smithy_http::result::SdkError<crate::error::DeleteServerError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A unique system-assigned identifier for a server instance.</p>
        pub fn server_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.server_id(input);
            self
        }
        pub fn set_server_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_server_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteSshPublicKey<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_ssh_public_key_input::Builder,
    }
    impl<C> DeleteSshPublicKey<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteSshPublicKeyOutput,
            smithy_http::result::SdkError<crate::error::DeleteSshPublicKeyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A system-assigned unique identifier for a file transfer protocol-enabled server instance
        /// that has the user assigned to it.</p>
        pub fn server_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.server_id(input);
            self
        }
        pub fn set_server_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_server_id(input);
            self
        }
        /// <p>A unique identifier used to reference your user's specific SSH key.</p>
        pub fn ssh_public_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ssh_public_key_id(input);
            self
        }
        pub fn set_ssh_public_key_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_ssh_public_key_id(input);
            self
        }
        /// <p>A unique string that identifies a user whose public key is being deleted.</p>
        pub fn user_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_name(input);
            self
        }
        pub fn set_user_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_user_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteUser<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_user_input::Builder,
    }
    impl<C> DeleteUser<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteUserOutput,
            smithy_http::result::SdkError<crate::error::DeleteUserError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A system-assigned unique identifier for a server instance that has the user assigned to
        /// it.</p>
        pub fn server_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.server_id(input);
            self
        }
        pub fn set_server_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_server_id(input);
            self
        }
        /// <p>A unique string that identifies a user that is being deleted from a server.</p>
        pub fn user_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_name(input);
            self
        }
        pub fn set_user_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_user_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeAccess<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_access_input::Builder,
    }
    impl<C> DescribeAccess<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeAccessOutput,
            smithy_http::result::SdkError<crate::error::DescribeAccessError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A system-assigned unique identifier for a server that has this access assigned.</p>
        pub fn server_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.server_id(input);
            self
        }
        pub fn set_server_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_server_id(input);
            self
        }
        /// <p>A unique identifier that is required to identify specific groups within your directory.
        /// The users of the group that you associate have access to your Amazon S3 or Amazon EFS
        /// resources over the enabled protocols using Amazon Web Services Transfer Family. If you know the group name,
        /// you can view the SID values by running the following command using Windows PowerShell.</p>
        /// <p>
        /// <code>Get-ADGroup -Filter {samAccountName -like "<i>YourGroupName</i>*"} -Properties * | Select SamAccountName,ObjectSid</code>
        /// </p>
        /// <p>In that command, replace <i>YourGroupName</i> with the name of your Active Directory group.</p>
        /// <p>The regex used to validate this parameter is a string of characters consisting of uppercase and lowercase alphanumeric characters with no spaces.
        /// You can also include underscores or any of the following characters: =,.@:/-</p>
        pub fn external_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.external_id(input);
            self
        }
        pub fn set_external_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_external_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeSecurityPolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_security_policy_input::Builder,
    }
    impl<C> DescribeSecurityPolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeSecurityPolicyOutput,
            smithy_http::result::SdkError<crate::error::DescribeSecurityPolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Specifies the name of the security policy that is attached to the server.</p>
        pub fn security_policy_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.security_policy_name(input);
            self
        }
        pub fn set_security_policy_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_security_policy_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeServer<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_server_input::Builder,
    }
    impl<C> DescribeServer<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeServerOutput,
            smithy_http::result::SdkError<crate::error::DescribeServerError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A system-assigned unique identifier for a server.</p>
        pub fn server_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.server_id(input);
            self
        }
        pub fn set_server_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_server_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeUser<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_user_input::Builder,
    }
    impl<C> DescribeUser<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeUserOutput,
            smithy_http::result::SdkError<crate::error::DescribeUserError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A system-assigned unique identifier for a server that has this user assigned.</p>
        pub fn server_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.server_id(input);
            self
        }
        pub fn set_server_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_server_id(input);
            self
        }
        /// <p>The name of the user assigned to one or more servers. User names are part of the sign-in
        /// credentials to use the Amazon Web Services Transfer Family service and perform file transfer tasks.</p>
        pub fn user_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_name(input);
            self
        }
        pub fn set_user_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_user_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ImportSshPublicKey<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::import_ssh_public_key_input::Builder,
    }
    impl<C> ImportSshPublicKey<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ImportSshPublicKeyOutput,
            smithy_http::result::SdkError<crate::error::ImportSshPublicKeyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A system-assigned unique identifier for a server.</p>
        pub fn server_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.server_id(input);
            self
        }
        pub fn set_server_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_server_id(input);
            self
        }
        /// <p>The public key portion of an SSH key pair.</p>
        pub fn ssh_public_key_body(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ssh_public_key_body(input);
            self
        }
        pub fn set_ssh_public_key_body(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_ssh_public_key_body(input);
            self
        }
        /// <p>The name of the user account that is assigned to one or more servers.</p>
        pub fn user_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_name(input);
            self
        }
        pub fn set_user_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_user_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListAccesses<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_accesses_input::Builder,
    }
    impl<C> ListAccesses<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListAccessesOutput,
            smithy_http::result::SdkError<crate::error::ListAccessesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Specifies the maximum number of access SIDs to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>When you can get additional results from the <code>ListAccesses</code> call, a
        /// <code>NextToken</code> parameter is returned in the output. You can then pass in a
        /// subsequent command to the <code>NextToken</code> parameter to continue listing additional
        /// accesses.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>A system-assigned unique identifier for a server that has users assigned to it.</p>
        pub fn server_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.server_id(input);
            self
        }
        pub fn set_server_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_server_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListSecurityPolicies<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_security_policies_input::Builder,
    }
    impl<C> ListSecurityPolicies<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListSecurityPoliciesOutput,
            smithy_http::result::SdkError<crate::error::ListSecurityPoliciesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Specifies the number of security policies to return as a response to the
        /// <code>ListSecurityPolicies</code> query.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>When additional results are obtained from the <code>ListSecurityPolicies</code> command, a
        /// <code>NextToken</code> parameter is returned in the output. You can then pass the
        /// <code>NextToken</code> parameter in a subsequent command to continue listing additional
        /// security policies.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListServers<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_servers_input::Builder,
    }
    impl<C> ListServers<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListServersOutput,
            smithy_http::result::SdkError<crate::error::ListServersError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Specifies the number of servers to return as a response to the <code>ListServers</code>
        /// query.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>When additional results are obtained from the <code>ListServers</code> command, a
        /// <code>NextToken</code> parameter is returned in the output. You can then pass the
        /// <code>NextToken</code> parameter in a subsequent command to continue listing additional
        /// servers.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTagsForResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_tags_for_resource_input::Builder,
    }
    impl<C> ListTagsForResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTagsForResourceOutput,
            smithy_http::result::SdkError<crate::error::ListTagsForResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Requests the tags associated with a particular Amazon Resource Name (ARN). An ARN is an
        /// identifier for a specific Amazon Web Services resource, such as a server, user, or role.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(input);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
        /// <p>Specifies the number of tags to return as a response to the
        /// <code>ListTagsForResource</code> request.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>When you request additional results from the <code>ListTagsForResource</code> operation, a
        /// <code>NextToken</code> parameter is returned in the input. You can then pass in a subsequent
        /// command to the <code>NextToken</code> parameter to continue listing additional tags.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListUsers<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_users_input::Builder,
    }
    impl<C> ListUsers<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListUsersOutput,
            smithy_http::result::SdkError<crate::error::ListUsersError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Specifies the number of users to return as a response to the <code>ListUsers</code>
        /// request.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>When you can get additional results from the <code>ListUsers</code> call, a
        /// <code>NextToken</code> parameter is returned in the output. You can then pass in a
        /// subsequent command to the <code>NextToken</code> parameter to continue listing additional
        /// users.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>A system-assigned unique identifier for a server that has users assigned to it.</p>
        pub fn server_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.server_id(input);
            self
        }
        pub fn set_server_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_server_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StartServer<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::start_server_input::Builder,
    }
    impl<C> StartServer<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StartServerOutput,
            smithy_http::result::SdkError<crate::error::StartServerError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A system-assigned unique identifier for a server that you start.</p>
        pub fn server_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.server_id(input);
            self
        }
        pub fn set_server_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_server_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StopServer<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::stop_server_input::Builder,
    }
    impl<C> StopServer<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StopServerOutput,
            smithy_http::result::SdkError<crate::error::StopServerError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A system-assigned unique identifier for a server that you stopped.</p>
        pub fn server_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.server_id(input);
            self
        }
        pub fn set_server_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_server_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TagResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::tag_resource_input::Builder,
    }
    impl<C> TagResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::TagResourceOutput,
            smithy_http::result::SdkError<crate::error::TagResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An Amazon Resource Name (ARN) for a specific Amazon Web Services resource, such as a server, user, or
        /// role.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(input);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
        /// <p>Key-value pairs assigned to ARNs that you can use to group and search for resources by
        /// type. You can attach this metadata to user accounts for any purpose.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TestIdentityProvider<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::test_identity_provider_input::Builder,
    }
    impl<C> TestIdentityProvider<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::TestIdentityProviderOutput,
            smithy_http::result::SdkError<crate::error::TestIdentityProviderError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A system-assigned identifier for a specific server. That server's user authentication
        /// method is tested with a user name and password.</p>
        pub fn server_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.server_id(input);
            self
        }
        pub fn set_server_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_server_id(input);
            self
        }
        /// <p>The type of file transfer protocol to be tested.</p>
        /// <p>The available protocols are:</p>
        /// <ul>
        /// <li>
        /// <p>Secure Shell (SSH) File Transfer Protocol (SFTP)</p>
        /// </li>
        /// <li>
        /// <p>File Transfer Protocol Secure (FTPS)</p>
        /// </li>
        /// <li>
        /// <p>File Transfer Protocol (FTP)</p>
        /// </li>
        /// </ul>
        pub fn server_protocol(mut self, input: crate::model::Protocol) -> Self {
            self.inner = self.inner.server_protocol(input);
            self
        }
        pub fn set_server_protocol(
            mut self,
            input: std::option::Option<crate::model::Protocol>,
        ) -> Self {
            self.inner = self.inner.set_server_protocol(input);
            self
        }
        /// <p>The source IP address of the user account to be tested.</p>
        pub fn source_ip(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source_ip(input);
            self
        }
        pub fn set_source_ip(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_source_ip(input);
            self
        }
        /// <p>The name of the user account to be tested.</p>
        pub fn user_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_name(input);
            self
        }
        pub fn set_user_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_user_name(input);
            self
        }
        /// <p>The password of the user account to be tested.</p>
        pub fn user_password(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_password(input);
            self
        }
        pub fn set_user_password(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_user_password(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UntagResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::untag_resource_input::Builder,
    }
    impl<C> UntagResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UntagResourceOutput,
            smithy_http::result::SdkError<crate::error::UntagResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The value of the resource that will have the tag removed. An Amazon Resource Name (ARN) is
        /// an identifier for a specific Amazon Web Services resource, such as a server, user, or role.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(input);
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
        /// <p>TagKeys are key-value pairs assigned to ARNs that can be used to group and search for
        /// resources by type. This metadata can be attached to resources for any purpose.</p>
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tag_keys(inp);
            self
        }
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tag_keys(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateAccess<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_access_input::Builder,
    }
    impl<C> UpdateAccess<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateAccessOutput,
            smithy_http::result::SdkError<crate::error::UpdateAccessError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The landing directory (folder) for a user when they log in to the server using the client.</p>
        /// <p>A <code>HomeDirectory</code> example is <code>/bucket_name/home/mydirectory</code>.</p>
        pub fn home_directory(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.home_directory(input);
            self
        }
        pub fn set_home_directory(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_home_directory(input);
            self
        }
        /// <p>The type of landing directory (folder) you want your users' home directory to be when they log into the server.
        /// If you set it to <code>PATH</code>, the user will see the absolute Amazon S3 bucket or EFS paths as is in their file transfer protocol clients.
        /// If you set it <code>LOGICAL</code>, you will need to provide mappings in the <code>HomeDirectoryMappings</code> for how you want to make Amazon
        /// S3 or EFS paths visible to your users.</p>
        pub fn home_directory_type(mut self, input: crate::model::HomeDirectoryType) -> Self {
            self.inner = self.inner.home_directory_type(input);
            self
        }
        pub fn set_home_directory_type(
            mut self,
            input: std::option::Option<crate::model::HomeDirectoryType>,
        ) -> Self {
            self.inner = self.inner.set_home_directory_type(input);
            self
        }
        /// <p>Logical directory mappings that specify what Amazon S3 or Amazon EFS paths and keys should
        /// be visible to your user and how you want to make them visible. You must specify the
        /// <code>Entry</code> and <code>Target</code> pair, where <code>Entry</code> shows how the path
        /// is made visible and <code>Target</code> is the actual Amazon S3 or Amazon EFS path. If you
        /// only specify a target, it is displayed as is. You also must ensure that your Amazon Web Services Identity
        /// and Access Management (IAM) role provides access to paths in <code>Target</code>. This value
        /// can only be set when <code>HomeDirectoryType</code> is set to
        /// <i>LOGICAL</i>.</p>
        /// <p>The following is an <code>Entry</code> and <code>Target</code> pair example.</p>
        /// <p>
        /// <code>[ { "Entry": "your-personal-report.pdf", "Target": "/bucket3/customized-reports/${transfer:UserName}.pdf" } ]</code>
        /// </p>
        /// <p>In most cases, you can use this value instead of the scope-down policy to lock down your
        /// user to the designated home directory ("<code>chroot</code>"). To do this, you can set
        /// <code>Entry</code> to <code>/</code> and set <code>Target</code> to the
        /// <code>HomeDirectory</code> parameter value.</p>
        /// <p>The following is an <code>Entry</code> and <code>Target</code> pair example for <code>chroot</code>.</p>
        /// <p>
        /// <code>[ { "Entry:": "/", "Target": "/bucket_name/home/mydirectory" } ]</code>
        /// </p>
        /// <note>
        /// <p>If the target of a logical directory entry does not exist in Amazon S3 or EFS, the entry is
        /// ignored. As a workaround, you can use the Amazon S3 API or EFS API to create 0 byte objects as place
        /// holders for your directory. If using the CLI, use the <code>s3api</code> or <code>efsapi</code> call instead of
        /// <code>s3</code> or <code>efs</code> so you can use the put-object operation. For example, you use the
        /// following: <code>aws s3api put-object --bucket bucketname --key path/to/folder/</code>. Make
        /// sure that the end of the key name ends in a <code>/</code> for it to be considered a folder.</p>
        /// </note>
        pub fn home_directory_mappings(
            mut self,
            inp: impl Into<crate::model::HomeDirectoryMapEntry>,
        ) -> Self {
            self.inner = self.inner.home_directory_mappings(inp);
            self
        }
        pub fn set_home_directory_mappings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::HomeDirectoryMapEntry>>,
        ) -> Self {
            self.inner = self.inner.set_home_directory_mappings(input);
            self
        }
        /// <p>A scope-down policy for your user so that you can use the same IAM role across multiple users. This policy scopes down user
        /// access to portions of their Amazon S3 bucket. Variables that you can use inside this policy include <code>${Transfer:UserName}</code>,
        /// <code>${Transfer:HomeDirectory}</code>, and <code>${Transfer:HomeBucket}</code>.</p>
        /// <note>
        /// <p>This only applies when domain of <code>ServerId</code> is S3. Amazon EFS does not use scope
        /// down policy.</p>
        /// <p>For scope-down policies, Amazon Web ServicesTransfer Family stores the policy as a JSON blob, instead of the Amazon Resource Name (ARN) of the policy. You save the policy as a JSON blob and pass it in the <code>Policy</code> argument.</p>
        /// <p>For an example of a scope-down policy, see <a href="https://docs.aws.amazon.com/transfer/latest/userguide/scope-down-policy.html">Example
        /// scope-down policy</a>.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRole.html">AssumeRole</a> in the <i>Amazon Web ServicesSecurity Token Service API
        /// Reference</i>.</p>
        /// </note>
        pub fn policy(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy(input);
            self
        }
        pub fn set_policy(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy(input);
            self
        }
        /// <p>The full POSIX identity, including user ID (<code>Uid</code>), group ID
        /// (<code>Gid</code>), and any secondary groups IDs (<code>SecondaryGids</code>), that controls
        /// your users' access to your Amazon EFS file systems. The POSIX permissions that are set on
        /// files and directories in your file system determine the level of access your users get when
        /// transferring files into and out of your Amazon EFS file systems.</p>
        pub fn posix_profile(mut self, input: crate::model::PosixProfile) -> Self {
            self.inner = self.inner.posix_profile(input);
            self
        }
        pub fn set_posix_profile(
            mut self,
            input: std::option::Option<crate::model::PosixProfile>,
        ) -> Self {
            self.inner = self.inner.set_posix_profile(input);
            self
        }
        /// <p>Specifies the Amazon Resource Name (ARN) of the IAM role that controls your users' access to your Amazon S3 bucket or EFS
        /// file system. The policies attached to this role determine the level of access that you want to provide your users when transferring
        /// files into and out of your Amazon S3 bucket or EFS file system. The IAM role should also contain a trust relationship that allows the
        /// server to access your resources when servicing your users' transfer requests.</p>
        pub fn role(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role(input);
            self
        }
        pub fn set_role(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role(input);
            self
        }
        /// <p>A system-assigned unique identifier for a server instance. This is the specific server that you added your user to.</p>
        pub fn server_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.server_id(input);
            self
        }
        pub fn set_server_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_server_id(input);
            self
        }
        /// <p>A unique identifier that is required to identify specific groups within your directory.
        /// The users of the group that you associate have access to your Amazon S3 or Amazon EFS
        /// resources over the enabled protocols using Amazon Web Services Transfer Family. If you know the group name,
        /// you can view the SID values by running the following command using Windows PowerShell.</p>
        /// <p>
        /// <code>Get-ADGroup -Filter {samAccountName -like "<i>YourGroupName</i>*"} -Properties * | Select SamAccountName,ObjectSid</code>
        /// </p>
        /// <p>In that command, replace <i>YourGroupName</i> with the name of your Active Directory group.</p>
        /// <p>The regex used to validate this parameter is a string of characters consisting of uppercase and lowercase alphanumeric characters with no spaces.
        /// You can also include underscores or any of the following characters: =,.@:/-</p>
        pub fn external_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.external_id(input);
            self
        }
        pub fn set_external_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_external_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateServer<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_server_input::Builder,
    }
    impl<C> UpdateServer<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateServerOutput,
            smithy_http::result::SdkError<crate::error::UpdateServerError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the Amazon Web ServicesCertificate Manager (ACM) certificate. Required
        /// when <code>Protocols</code> is set to <code>FTPS</code>.</p>
        /// <p>To request a new public certificate, see <a href="https://docs.aws.amazon.com/acm/latest/userguide/gs-acm-request-public.html">Request a public certificate</a>
        /// in the <i> Amazon Web ServicesCertificate Manager User Guide</i>.</p>
        /// <p>To import an existing certificate into ACM, see <a href="https://docs.aws.amazon.com/acm/latest/userguide/import-certificate.html">Importing certificates into ACM</a>
        /// in the <i> Amazon Web ServicesCertificate Manager User Guide</i>.</p>
        /// <p>To request a private certificate to use FTPS through private IP addresses, see <a href="https://docs.aws.amazon.com/acm/latest/userguide/gs-acm-request-private.html">Request a
        /// private certificate</a> in the <i> Amazon Web ServicesCertificate Manager User
        /// Guide</i>.</p>
        /// <p>Certificates with the following cryptographic algorithms and key sizes are
        /// supported:</p>
        /// <ul>
        /// <li>
        /// <p>2048-bit RSA (RSA_2048)</p>
        /// </li>
        /// <li>
        /// <p>4096-bit RSA (RSA_4096)</p>
        /// </li>
        /// <li>
        /// <p>Elliptic Prime Curve 256 bit (EC_prime256v1)</p>
        /// </li>
        /// <li>
        /// <p>Elliptic Prime Curve 384 bit (EC_secp384r1)</p>
        /// </li>
        /// <li>
        /// <p>Elliptic Prime Curve 521 bit (EC_secp521r1)</p>
        /// </li>
        /// </ul>
        /// <note>
        /// <p>The certificate must be a valid SSL/TLS X.509 version 3 certificate with FQDN or IP
        /// address specified and information about the issuer.</p>
        /// </note>
        pub fn certificate(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.certificate(input);
            self
        }
        pub fn set_certificate(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_certificate(input);
            self
        }
        /// <p>
        /// The protocol settings that are configured for your server.
        /// </p>
        /// <p>
        /// Use the <code>PassiveIp</code> parameter to indicate passive mode (for FTP and FTPS protocols).
        /// Enter a single dotted-quad IPv4 address, such as the external IP address of a firewall, router, or load balancer.
        /// </p>
        pub fn protocol_details(mut self, input: crate::model::ProtocolDetails) -> Self {
            self.inner = self.inner.protocol_details(input);
            self
        }
        pub fn set_protocol_details(
            mut self,
            input: std::option::Option<crate::model::ProtocolDetails>,
        ) -> Self {
            self.inner = self.inner.set_protocol_details(input);
            self
        }
        /// <p>The virtual private cloud (VPC) endpoint settings that are configured for your server.
        /// When you host your endpoint within your VPC, you can make it accessible only to resources
        /// within your VPC, or you can attach Elastic IP addresses and make it accessible to clients over
        /// the internet. Your VPC's default security groups are automatically assigned to your
        /// endpoint.</p>
        pub fn endpoint_details(mut self, input: crate::model::EndpointDetails) -> Self {
            self.inner = self.inner.endpoint_details(input);
            self
        }
        pub fn set_endpoint_details(
            mut self,
            input: std::option::Option<crate::model::EndpointDetails>,
        ) -> Self {
            self.inner = self.inner.set_endpoint_details(input);
            self
        }
        /// <p>The type of endpoint that you want your server to use. You can choose to make your server's endpoint publicly accessible (PUBLIC)
        /// or host it inside your VPC. With an endpoint that is hosted in a VPC, you can restrict access to your server and
        /// resources only within your VPC or choose to make it internet facing by attaching Elastic IP addresses directly to it.</p>
        /// <note>
        /// <p> After May 19, 2021, you won't be able to create a server using
        /// <code>EndpointType=VPC_ENDPOINT</code> in your Amazon Web Servicesaccount if your account hasn't already
        /// done so before May 19, 2021. If you have already created servers with
        /// <code>EndpointType=VPC_ENDPOINT</code> in your Amazon Web Servicesaccount on or before May 19, 2021,
        /// you will not be affected. After this date, use
        /// <code>EndpointType</code>=<code>VPC</code>.</p>
        /// <p>For more information, see
        /// https://docs.aws.amazon.com/transfer/latest/userguide/create-server-in-vpc.html#deprecate-vpc-endpoint.</p>
        /// <p>It is recommended that you use <code>VPC</code> as the <code>EndpointType</code>. With
        /// this endpoint type, you have the option to directly associate up to three Elastic IPv4
        /// addresses (BYO IP included) with your server's endpoint and use VPC security groups to
        /// restrict traffic by the client's public IP address. This is not possible with
        /// <code>EndpointType</code> set to <code>VPC_ENDPOINT</code>.</p>
        /// </note>
        pub fn endpoint_type(mut self, input: crate::model::EndpointType) -> Self {
            self.inner = self.inner.endpoint_type(input);
            self
        }
        pub fn set_endpoint_type(
            mut self,
            input: std::option::Option<crate::model::EndpointType>,
        ) -> Self {
            self.inner = self.inner.set_endpoint_type(input);
            self
        }
        /// <p>The RSA private key as generated by <code>ssh-keygen -N "" -m PEM -f
        /// my-new-server-key</code>.</p>
        /// <important>
        /// <p>If you aren't planning to migrate existing users from an existing server to a new
        /// server, don't update the host key. Accidentally changing a server's host key can
        /// be disruptive.</p>
        /// </important>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/transfer/latest/userguide/edit-server-config.html#configuring-servers-change-host-key">Change the host key for your SFTP-enabled server</a> in the <i>Amazon Web ServicesTransfer
        /// Family User Guide</i>.</p>
        pub fn host_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.host_key(input);
            self
        }
        pub fn set_host_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_host_key(input);
            self
        }
        /// <p>An array containing all of the information required to call a customer's
        /// authentication API method.</p>
        pub fn identity_provider_details(
            mut self,
            input: crate::model::IdentityProviderDetails,
        ) -> Self {
            self.inner = self.inner.identity_provider_details(input);
            self
        }
        pub fn set_identity_provider_details(
            mut self,
            input: std::option::Option<crate::model::IdentityProviderDetails>,
        ) -> Self {
            self.inner = self.inner.set_identity_provider_details(input);
            self
        }
        /// <p>Specifies the Amazon Resource Name (ARN) of the Amazon Web Services Identity and Access Management (IAM) role that allows a server to turn
        /// on Amazon CloudWatch logging for Amazon S3 or Amazon EFS events. When set, user activity can be viewed in
        /// your CloudWatch logs.</p>
        pub fn logging_role(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.logging_role(input);
            self
        }
        pub fn set_logging_role(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_logging_role(input);
            self
        }
        /// <p>Specifies the file transfer protocol or protocols over which your file transfer protocol
        /// client can connect to your server's endpoint. The available protocols are:</p>
        /// <ul>
        /// <li>
        /// <p>Secure Shell (SSH) File Transfer Protocol (SFTP): File transfer over SSH</p>
        /// </li>
        /// <li>
        /// <p>File Transfer Protocol Secure (FTPS): File transfer with TLS encryption</p>
        /// </li>
        /// <li>
        /// <p>File Transfer Protocol (FTP): Unencrypted file transfer</p>
        /// </li>
        /// </ul>
        /// <note>
        /// <p>If you select <code>FTPS</code>, you must choose a certificate stored in Amazon Web ServicesCertificate
        /// Manager (ACM) which will be used to identify your server when clients connect to it over
        /// FTPS.</p>
        /// <p>If <code>Protocol</code> includes either <code>FTP</code> or <code>FTPS</code>, then the
        /// <code>EndpointType</code> must be <code>VPC</code> and the
        /// <code>IdentityProviderType</code> must be <code>AWS_DIRECTORY_SERVICE</code> or <code>API_GATEWAY</code>.</p>
        /// <p>If <code>Protocol</code> includes <code>FTP</code>, then
        /// <code>AddressAllocationIds</code> cannot be associated.</p>
        /// <p>If <code>Protocol</code> is set only to <code>SFTP</code>, the <code>EndpointType</code>
        /// can be set to <code>PUBLIC</code> and the <code>IdentityProviderType</code> can be set to
        /// <code>SERVICE_MANAGED</code>.</p>
        /// </note>
        pub fn protocols(mut self, inp: impl Into<crate::model::Protocol>) -> Self {
            self.inner = self.inner.protocols(inp);
            self
        }
        pub fn set_protocols(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Protocol>>,
        ) -> Self {
            self.inner = self.inner.set_protocols(input);
            self
        }
        /// <p>Specifies the name of the security policy that is attached to the server.</p>
        pub fn security_policy_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.security_policy_name(input);
            self
        }
        pub fn set_security_policy_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_security_policy_name(input);
            self
        }
        /// <p>A system-assigned unique identifier for a server instance that the user account is
        /// assigned to.</p>
        pub fn server_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.server_id(input);
            self
        }
        pub fn set_server_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_server_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateUser<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_user_input::Builder,
    }
    impl<C> UpdateUser<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateUserOutput,
            smithy_http::result::SdkError<crate::error::UpdateUserError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The landing directory (folder) for a user when they log in to the server using the client.</p>
        /// <p>A <code>HomeDirectory</code> example is <code>/bucket_name/home/mydirectory</code>.</p>
        pub fn home_directory(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.home_directory(input);
            self
        }
        pub fn set_home_directory(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_home_directory(input);
            self
        }
        /// <p>The type of landing directory (folder) you want your users' home directory to be when they log into the server.
        /// If you set it to <code>PATH</code>, the user will see the absolute Amazon S3 bucket or EFS paths as is in their file transfer protocol clients.
        /// If you set it <code>LOGICAL</code>, you will need to provide mappings in the <code>HomeDirectoryMappings</code> for how you want to make Amazon
        /// S3 or EFS paths visible to your users.</p>
        pub fn home_directory_type(mut self, input: crate::model::HomeDirectoryType) -> Self {
            self.inner = self.inner.home_directory_type(input);
            self
        }
        pub fn set_home_directory_type(
            mut self,
            input: std::option::Option<crate::model::HomeDirectoryType>,
        ) -> Self {
            self.inner = self.inner.set_home_directory_type(input);
            self
        }
        /// <p>Logical directory mappings that specify what Amazon S3 or Amazon EFS paths and keys should
        /// be visible to your user and how you want to make them visible. You must specify the
        /// <code>Entry</code> and <code>Target</code> pair, where <code>Entry</code> shows how the path
        /// is made visible and <code>Target</code> is the actual Amazon S3 or Amazon EFS path. If you
        /// only specify a target, it is displayed as is. You also must ensure that your Amazon Web Services Identity
        /// and Access Management (IAM) role provides access to paths in <code>Target</code>. This value
        /// can only be set when <code>HomeDirectoryType</code> is set to
        /// <i>LOGICAL</i>.</p>
        /// <p>The following is an <code>Entry</code> and <code>Target</code> pair example.</p>
        /// <p>
        /// <code>[ { "Entry": "your-personal-report.pdf", "Target":
        /// "/bucket3/customized-reports/${transfer:UserName}.pdf" } ]</code>
        /// </p>
        /// <p>In most cases, you can use this value instead of the scope-down policy to lock down your
        /// user to the designated home directory ("<code>chroot</code>"). To do this, you can set
        /// <code>Entry</code> to '/' and set <code>Target</code> to the HomeDirectory
        /// parameter value.</p>
        /// <p>The following is an <code>Entry</code> and <code>Target</code> pair example for <code>chroot</code>.</p>
        /// <p>
        /// <code>[ { "Entry:": "/", "Target": "/bucket_name/home/mydirectory" } ]</code>
        /// </p>
        /// <note>
        /// <p>If the target of a logical directory entry does not exist in Amazon S3 or EFS, the entry is
        /// ignored. As a workaround, you can use the Amazon S3 API or EFS API to create 0 byte objects as place
        /// holders for your directory. If using the CLI, use the <code>s3api</code> or <code>efsapi</code> call instead of
        /// <code>s3</code> or <code>efs</code> so you can use the put-object operation. For example, you use the
        /// following: <code>aws s3api put-object --bucket bucketname --key path/to/folder/</code>. Make
        /// sure that the end of the key name ends in a <code>/</code> for it to be considered a folder.</p>
        /// </note>
        pub fn home_directory_mappings(
            mut self,
            inp: impl Into<crate::model::HomeDirectoryMapEntry>,
        ) -> Self {
            self.inner = self.inner.home_directory_mappings(inp);
            self
        }
        pub fn set_home_directory_mappings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::HomeDirectoryMapEntry>>,
        ) -> Self {
            self.inner = self.inner.set_home_directory_mappings(input);
            self
        }
        /// <p>A scope-down policy for your user so that you can use the same IAM role across multiple users. This policy scopes down user
        /// access to portions of their Amazon S3 bucket. Variables that you can use inside this policy include <code>${Transfer:UserName}</code>,
        /// <code>${Transfer:HomeDirectory}</code>, and <code>${Transfer:HomeBucket}</code>.</p>
        /// <note>
        /// <p>This only applies when domain of <code>ServerId</code> is S3.
        /// Amazon EFS does not use scope-down policies.</p>
        /// <p>For scope-down policies, Amazon Web ServicesTransfer Family stores the policy as a JSON blob, instead of the Amazon Resource Name (ARN) of the policy.
        /// You save the policy as a JSON blob and pass it in the <code>Policy</code> argument.</p>
        /// <p>For an example of a scope-down policy, see <a href="https://docs.aws.amazon.com/transfer/latest/userguide/users.html#users-policies-scope-down">Creating a scope-down
        /// policy</a>.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRole.html">AssumeRole</a> in the <i>Amazon Web Services
        /// Security Token Service API Reference</i>.</p>
        /// </note>
        pub fn policy(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy(input);
            self
        }
        pub fn set_policy(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy(input);
            self
        }
        /// <p>Specifies the full POSIX identity, including user ID (<code>Uid</code>), group ID
        /// (<code>Gid</code>), and any secondary groups IDs (<code>SecondaryGids</code>), that controls
        /// your users' access to your Amazon Elastic File Systems (Amazon EFS). The POSIX permissions
        /// that are set on files and directories in your file system determines the level of access your
        /// users get when transferring files into and out of your Amazon EFS file systems.</p>
        pub fn posix_profile(mut self, input: crate::model::PosixProfile) -> Self {
            self.inner = self.inner.posix_profile(input);
            self
        }
        pub fn set_posix_profile(
            mut self,
            input: std::option::Option<crate::model::PosixProfile>,
        ) -> Self {
            self.inner = self.inner.set_posix_profile(input);
            self
        }
        /// <p>Specifies the Amazon Resource Name (ARN) of the IAM role that controls your users' access to your Amazon S3 bucket or EFS
        /// file system. The policies attached to this role determine the level of access that you want to provide your users when transferring
        /// files into and out of your Amazon S3 bucket or EFS file system. The IAM role should also contain a trust relationship that allows the
        /// server to access your resources when servicing your users' transfer requests.</p>
        pub fn role(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role(input);
            self
        }
        pub fn set_role(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role(input);
            self
        }
        /// <p>A system-assigned unique identifier for a server instance that the user account is
        /// assigned to.</p>
        pub fn server_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.server_id(input);
            self
        }
        pub fn set_server_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_server_id(input);
            self
        }
        /// <p>A unique string that identifies a user and is associated with a server as specified by the
        /// <code>ServerId</code>. This user name must be a minimum of 3 and a maximum of 100 characters
        /// long. The following are valid characters: a-z, A-Z, 0-9, underscore '_', hyphen
        /// '-', period '.', and at sign '@'. The user name can't start
        /// with a hyphen, period, or at sign.</p>
        pub fn user_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_name(input);
            self
        }
        pub fn set_user_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_user_name(input);
            self
        }
    }
}
