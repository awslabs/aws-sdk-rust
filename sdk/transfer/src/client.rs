// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(Debug)]
pub(crate) struct Handle<
    C = aws_smithy_client::erase::DynConnector,
    M = aws_hyper::AwsMiddleware,
    R = aws_smithy_client::retry::Standard,
> {
    client: aws_smithy_client::Client<C, M, R>,
    conf: crate::Config,
}

/// An ergonomic service client for `TransferService`.
///
/// This client allows ergonomic access to a `TransferService`-shaped service.
/// Each method corresponds to an endpoint defined in the service's Smithy model,
/// and the request and response shapes are auto-generated from that same model.
///
/// # Using a Client
///
/// Once you have a client set up, you can access the service's endpoints
/// by calling the appropriate method on [`Client`]. Each such method
/// returns a request builder for that endpoint, with methods for setting
/// the various fields of the request. Once your request is complete, use
/// the `send` method to send the request. `send` returns a future, which
/// you then have to `.await` to get the service's response.
///
/// [builder pattern]: https://rust-lang.github.io/api-guidelines/type-safety.html#c-builder
/// [SigV4-signed requests]: https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html
#[derive(std::fmt::Debug)]
pub struct Client<
    C = aws_smithy_client::erase::DynConnector,
    M = aws_hyper::AwsMiddleware,
    R = aws_smithy_client::retry::Standard,
> {
    handle: std::sync::Arc<Handle<C, M, R>>,
}

impl<C, M, R> std::clone::Clone for Client<C, M, R> {
    fn clone(&self) -> Self {
        Self {
            handle: self.handle.clone(),
        }
    }
}

#[doc(inline)]
pub use aws_smithy_client::Builder;

impl<C, M, R> From<aws_smithy_client::Client<C, M, R>> for Client<C, M, R> {
    fn from(client: aws_smithy_client::Client<C, M, R>) -> Self {
        Self::with_config(client, crate::Config::builder().build())
    }
}

impl<C, M, R> Client<C, M, R> {
    /// Creates a client with the given service configuration.
    pub fn with_config(client: aws_smithy_client::Client<C, M, R>, conf: crate::Config) -> Self {
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    /// Returns the client's configuration.
    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl<C, M, R> Client<C, M, R>
where
    C: aws_smithy_client::bounds::SmithyConnector,
    M: aws_smithy_client::bounds::SmithyMiddleware<C>,
    R: aws_smithy_client::retry::NewRequestPolicy,
{
    /// Constructs a fluent builder for the `CreateAccess` operation.
    ///
    /// See [`CreateAccess`](crate::client::fluent_builders::CreateAccess) for more information about the
    /// operation and its arguments.
    pub fn create_access(&self) -> fluent_builders::CreateAccess<C, M, R> {
        fluent_builders::CreateAccess::new(self.handle.clone())
    }
    /// Constructs a fluent builder for the `CreateServer` operation.
    ///
    /// See [`CreateServer`](crate::client::fluent_builders::CreateServer) for more information about the
    /// operation and its arguments.
    pub fn create_server(&self) -> fluent_builders::CreateServer<C, M, R> {
        fluent_builders::CreateServer::new(self.handle.clone())
    }
    /// Constructs a fluent builder for the `CreateUser` operation.
    ///
    /// See [`CreateUser`](crate::client::fluent_builders::CreateUser) for more information about the
    /// operation and its arguments.
    pub fn create_user(&self) -> fluent_builders::CreateUser<C, M, R> {
        fluent_builders::CreateUser::new(self.handle.clone())
    }
    /// Constructs a fluent builder for the `CreateWorkflow` operation.
    ///
    /// See [`CreateWorkflow`](crate::client::fluent_builders::CreateWorkflow) for more information about the
    /// operation and its arguments.
    pub fn create_workflow(&self) -> fluent_builders::CreateWorkflow<C, M, R> {
        fluent_builders::CreateWorkflow::new(self.handle.clone())
    }
    /// Constructs a fluent builder for the `DeleteAccess` operation.
    ///
    /// See [`DeleteAccess`](crate::client::fluent_builders::DeleteAccess) for more information about the
    /// operation and its arguments.
    pub fn delete_access(&self) -> fluent_builders::DeleteAccess<C, M, R> {
        fluent_builders::DeleteAccess::new(self.handle.clone())
    }
    /// Constructs a fluent builder for the `DeleteServer` operation.
    ///
    /// See [`DeleteServer`](crate::client::fluent_builders::DeleteServer) for more information about the
    /// operation and its arguments.
    pub fn delete_server(&self) -> fluent_builders::DeleteServer<C, M, R> {
        fluent_builders::DeleteServer::new(self.handle.clone())
    }
    /// Constructs a fluent builder for the `DeleteSshPublicKey` operation.
    ///
    /// See [`DeleteSshPublicKey`](crate::client::fluent_builders::DeleteSshPublicKey) for more information about the
    /// operation and its arguments.
    pub fn delete_ssh_public_key(&self) -> fluent_builders::DeleteSshPublicKey<C, M, R> {
        fluent_builders::DeleteSshPublicKey::new(self.handle.clone())
    }
    /// Constructs a fluent builder for the `DeleteUser` operation.
    ///
    /// See [`DeleteUser`](crate::client::fluent_builders::DeleteUser) for more information about the
    /// operation and its arguments.
    pub fn delete_user(&self) -> fluent_builders::DeleteUser<C, M, R> {
        fluent_builders::DeleteUser::new(self.handle.clone())
    }
    /// Constructs a fluent builder for the `DeleteWorkflow` operation.
    ///
    /// See [`DeleteWorkflow`](crate::client::fluent_builders::DeleteWorkflow) for more information about the
    /// operation and its arguments.
    pub fn delete_workflow(&self) -> fluent_builders::DeleteWorkflow<C, M, R> {
        fluent_builders::DeleteWorkflow::new(self.handle.clone())
    }
    /// Constructs a fluent builder for the `DescribeAccess` operation.
    ///
    /// See [`DescribeAccess`](crate::client::fluent_builders::DescribeAccess) for more information about the
    /// operation and its arguments.
    pub fn describe_access(&self) -> fluent_builders::DescribeAccess<C, M, R> {
        fluent_builders::DescribeAccess::new(self.handle.clone())
    }
    /// Constructs a fluent builder for the `DescribeExecution` operation.
    ///
    /// See [`DescribeExecution`](crate::client::fluent_builders::DescribeExecution) for more information about the
    /// operation and its arguments.
    pub fn describe_execution(&self) -> fluent_builders::DescribeExecution<C, M, R> {
        fluent_builders::DescribeExecution::new(self.handle.clone())
    }
    /// Constructs a fluent builder for the `DescribeSecurityPolicy` operation.
    ///
    /// See [`DescribeSecurityPolicy`](crate::client::fluent_builders::DescribeSecurityPolicy) for more information about the
    /// operation and its arguments.
    pub fn describe_security_policy(&self) -> fluent_builders::DescribeSecurityPolicy<C, M, R> {
        fluent_builders::DescribeSecurityPolicy::new(self.handle.clone())
    }
    /// Constructs a fluent builder for the `DescribeServer` operation.
    ///
    /// See [`DescribeServer`](crate::client::fluent_builders::DescribeServer) for more information about the
    /// operation and its arguments.
    pub fn describe_server(&self) -> fluent_builders::DescribeServer<C, M, R> {
        fluent_builders::DescribeServer::new(self.handle.clone())
    }
    /// Constructs a fluent builder for the `DescribeUser` operation.
    ///
    /// See [`DescribeUser`](crate::client::fluent_builders::DescribeUser) for more information about the
    /// operation and its arguments.
    pub fn describe_user(&self) -> fluent_builders::DescribeUser<C, M, R> {
        fluent_builders::DescribeUser::new(self.handle.clone())
    }
    /// Constructs a fluent builder for the `DescribeWorkflow` operation.
    ///
    /// See [`DescribeWorkflow`](crate::client::fluent_builders::DescribeWorkflow) for more information about the
    /// operation and its arguments.
    pub fn describe_workflow(&self) -> fluent_builders::DescribeWorkflow<C, M, R> {
        fluent_builders::DescribeWorkflow::new(self.handle.clone())
    }
    /// Constructs a fluent builder for the `ImportSshPublicKey` operation.
    ///
    /// See [`ImportSshPublicKey`](crate::client::fluent_builders::ImportSshPublicKey) for more information about the
    /// operation and its arguments.
    pub fn import_ssh_public_key(&self) -> fluent_builders::ImportSshPublicKey<C, M, R> {
        fluent_builders::ImportSshPublicKey::new(self.handle.clone())
    }
    /// Constructs a fluent builder for the `ListAccesses` operation.
    ///
    /// See [`ListAccesses`](crate::client::fluent_builders::ListAccesses) for more information about the
    /// operation and its arguments.
    pub fn list_accesses(&self) -> fluent_builders::ListAccesses<C, M, R> {
        fluent_builders::ListAccesses::new(self.handle.clone())
    }
    /// Constructs a fluent builder for the `ListExecutions` operation.
    ///
    /// See [`ListExecutions`](crate::client::fluent_builders::ListExecutions) for more information about the
    /// operation and its arguments.
    pub fn list_executions(&self) -> fluent_builders::ListExecutions<C, M, R> {
        fluent_builders::ListExecutions::new(self.handle.clone())
    }
    /// Constructs a fluent builder for the `ListSecurityPolicies` operation.
    ///
    /// See [`ListSecurityPolicies`](crate::client::fluent_builders::ListSecurityPolicies) for more information about the
    /// operation and its arguments.
    pub fn list_security_policies(&self) -> fluent_builders::ListSecurityPolicies<C, M, R> {
        fluent_builders::ListSecurityPolicies::new(self.handle.clone())
    }
    /// Constructs a fluent builder for the `ListServers` operation.
    ///
    /// See [`ListServers`](crate::client::fluent_builders::ListServers) for more information about the
    /// operation and its arguments.
    pub fn list_servers(&self) -> fluent_builders::ListServers<C, M, R> {
        fluent_builders::ListServers::new(self.handle.clone())
    }
    /// Constructs a fluent builder for the `ListTagsForResource` operation.
    ///
    /// See [`ListTagsForResource`](crate::client::fluent_builders::ListTagsForResource) for more information about the
    /// operation and its arguments.
    pub fn list_tags_for_resource(&self) -> fluent_builders::ListTagsForResource<C, M, R> {
        fluent_builders::ListTagsForResource::new(self.handle.clone())
    }
    /// Constructs a fluent builder for the `ListUsers` operation.
    ///
    /// See [`ListUsers`](crate::client::fluent_builders::ListUsers) for more information about the
    /// operation and its arguments.
    pub fn list_users(&self) -> fluent_builders::ListUsers<C, M, R> {
        fluent_builders::ListUsers::new(self.handle.clone())
    }
    /// Constructs a fluent builder for the `ListWorkflows` operation.
    ///
    /// See [`ListWorkflows`](crate::client::fluent_builders::ListWorkflows) for more information about the
    /// operation and its arguments.
    pub fn list_workflows(&self) -> fluent_builders::ListWorkflows<C, M, R> {
        fluent_builders::ListWorkflows::new(self.handle.clone())
    }
    /// Constructs a fluent builder for the `SendWorkflowStepState` operation.
    ///
    /// See [`SendWorkflowStepState`](crate::client::fluent_builders::SendWorkflowStepState) for more information about the
    /// operation and its arguments.
    pub fn send_workflow_step_state(&self) -> fluent_builders::SendWorkflowStepState<C, M, R> {
        fluent_builders::SendWorkflowStepState::new(self.handle.clone())
    }
    /// Constructs a fluent builder for the `StartServer` operation.
    ///
    /// See [`StartServer`](crate::client::fluent_builders::StartServer) for more information about the
    /// operation and its arguments.
    pub fn start_server(&self) -> fluent_builders::StartServer<C, M, R> {
        fluent_builders::StartServer::new(self.handle.clone())
    }
    /// Constructs a fluent builder for the `StopServer` operation.
    ///
    /// See [`StopServer`](crate::client::fluent_builders::StopServer) for more information about the
    /// operation and its arguments.
    pub fn stop_server(&self) -> fluent_builders::StopServer<C, M, R> {
        fluent_builders::StopServer::new(self.handle.clone())
    }
    /// Constructs a fluent builder for the `TagResource` operation.
    ///
    /// See [`TagResource`](crate::client::fluent_builders::TagResource) for more information about the
    /// operation and its arguments.
    pub fn tag_resource(&self) -> fluent_builders::TagResource<C, M, R> {
        fluent_builders::TagResource::new(self.handle.clone())
    }
    /// Constructs a fluent builder for the `TestIdentityProvider` operation.
    ///
    /// See [`TestIdentityProvider`](crate::client::fluent_builders::TestIdentityProvider) for more information about the
    /// operation and its arguments.
    pub fn test_identity_provider(&self) -> fluent_builders::TestIdentityProvider<C, M, R> {
        fluent_builders::TestIdentityProvider::new(self.handle.clone())
    }
    /// Constructs a fluent builder for the `UntagResource` operation.
    ///
    /// See [`UntagResource`](crate::client::fluent_builders::UntagResource) for more information about the
    /// operation and its arguments.
    pub fn untag_resource(&self) -> fluent_builders::UntagResource<C, M, R> {
        fluent_builders::UntagResource::new(self.handle.clone())
    }
    /// Constructs a fluent builder for the `UpdateAccess` operation.
    ///
    /// See [`UpdateAccess`](crate::client::fluent_builders::UpdateAccess) for more information about the
    /// operation and its arguments.
    pub fn update_access(&self) -> fluent_builders::UpdateAccess<C, M, R> {
        fluent_builders::UpdateAccess::new(self.handle.clone())
    }
    /// Constructs a fluent builder for the `UpdateServer` operation.
    ///
    /// See [`UpdateServer`](crate::client::fluent_builders::UpdateServer) for more information about the
    /// operation and its arguments.
    pub fn update_server(&self) -> fluent_builders::UpdateServer<C, M, R> {
        fluent_builders::UpdateServer::new(self.handle.clone())
    }
    /// Constructs a fluent builder for the `UpdateUser` operation.
    ///
    /// See [`UpdateUser`](crate::client::fluent_builders::UpdateUser) for more information about the
    /// operation and its arguments.
    pub fn update_user(&self) -> fluent_builders::UpdateUser<C, M, R> {
        fluent_builders::UpdateUser::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    //!
    //! Utilities to ergonomically construct a request to the service.
    //!
    //! Fluent builders are created through the [`Client`](crate::client::Client) by calling
    //! one if its operation methods. After parameters are set using the builder methods,
    //! the `send` method can be called to initiate the request.
    //!
    /// Fluent builder constructing a request to `CreateAccess`.
    ///
    /// <p>Used by administrators to choose which groups in the directory should have access to
    /// upload and download files over the enabled protocols using Amazon Web Services Transfer Family. For example, a
    /// Microsoft Active Directory might contain 50,000 users, but only a small fraction might need
    /// the ability to transfer files to the server. An administrator can use
    /// <code>CreateAccess</code> to limit the access to the correct set of users who need this
    /// ability.</p>
    #[derive(std::fmt::Debug)]
    pub struct CreateAccess<
        C = aws_smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = aws_smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_access_input::Builder,
    }
    impl<C, M, R> CreateAccess<C, M, R>
    where
        C: aws_smithy_client::bounds::SmithyConnector,
        M: aws_smithy_client::bounds::SmithyMiddleware<C>,
        R: aws_smithy_client::retry::NewRequestPolicy,
    {
        /// Creates a new `CreateAccess`.
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        /// Sends the request and returns the response.
        ///
        /// If an error occurs, an `SdkError` will be returned with additional details that
        /// can be matched against.
        ///
        /// By default, any retryable failures will be retried twice. Retry behavior
        /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
        /// set when configuring the client.
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateAccessOutput,
            aws_smithy_http::result::SdkError<crate::error::CreateAccessError>,
        >
        where
            R::Policy: aws_smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateAccessInputOperationOutputAlias,
                crate::output::CreateAccessOutput,
                crate::error::CreateAccessError,
                crate::input::CreateAccessInputOperationRetryAlias,
            >,
        {
            let input = self.inner.build().map_err(|err| {
                aws_smithy_http::result::SdkError::ConstructionFailure(err.into())
            })?;
            let op = input
                .make_operation(&self.handle.conf)
                .await
                .map_err(|err| {
                    aws_smithy_http::result::SdkError::ConstructionFailure(err.into())
                })?;
            self.handle.client.call(op).await
        }
        /// <p>The landing directory (folder) for a user when they log in to the server using the client.</p>
        /// <p>A <code>HomeDirectory</code> example is <code>/bucket_name/home/mydirectory</code>.</p>
        pub fn home_directory(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.home_directory(inp);
            self
        }
        /// <p>The landing directory (folder) for a user when they log in to the server using the client.</p>
        /// <p>A <code>HomeDirectory</code> example is <code>/bucket_name/home/mydirectory</code>.</p>
        pub fn set_home_directory(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_home_directory(input);
            self
        }
        /// <p>The type of landing directory (folder) you want your users' home directory to be when they log into the server.
        /// If you set it to <code>PATH</code>, the user will see the absolute Amazon S3 bucket or EFS paths as is in their file transfer protocol clients.
        /// If you set it <code>LOGICAL</code>, you need to provide mappings in the <code>HomeDirectoryMappings</code> for how you want to make Amazon
        /// S3 or EFS paths visible to your users.</p>
        pub fn home_directory_type(mut self, inp: crate::model::HomeDirectoryType) -> Self {
            self.inner = self.inner.home_directory_type(inp);
            self
        }
        /// <p>The type of landing directory (folder) you want your users' home directory to be when they log into the server.
        /// If you set it to <code>PATH</code>, the user will see the absolute Amazon S3 bucket or EFS paths as is in their file transfer protocol clients.
        /// If you set it <code>LOGICAL</code>, you need to provide mappings in the <code>HomeDirectoryMappings</code> for how you want to make Amazon
        /// S3 or EFS paths visible to your users.</p>
        pub fn set_home_directory_type(
            mut self,
            input: std::option::Option<crate::model::HomeDirectoryType>,
        ) -> Self {
            self.inner = self.inner.set_home_directory_type(input);
            self
        }
        /// Appends an item to `HomeDirectoryMappings`.
        ///
        /// To override the contents of this collection use [`set_home_directory_mappings`](Self::set_home_directory_mappings).
        ///
        /// <p>Logical directory mappings that specify what Amazon S3 or Amazon EFS paths and keys should
        /// be visible to your user and how you want to make them visible. You must specify the
        /// <code>Entry</code> and <code>Target</code> pair, where <code>Entry</code> shows how the path
        /// is made visible and <code>Target</code> is the actual Amazon S3 or Amazon EFS path. If you
        /// only specify a target, it is displayed as is. You also must ensure that your Amazon Web Services Identity
        /// and Access Management (IAM) role provides access to paths in <code>Target</code>. This value
        /// can only be set when <code>HomeDirectoryType</code> is set to
        /// <i>LOGICAL</i>.</p>
        /// <p>The following is an <code>Entry</code> and <code>Target</code> pair example.</p>
        /// <p>
        /// <code>[ { "Entry": "/directory1", "Target": "/bucket_name/home/mydirectory" } ]</code>
        /// </p>
        /// <p>In most cases, you can use this value instead of the session policy to lock down your
        /// user to the designated home directory ("<code>chroot</code>"). To do this, you can set
        /// <code>Entry</code> to <code>/</code> and set <code>Target</code> to the
        /// <code>HomeDirectory</code> parameter value.</p>
        /// <p>The following is an <code>Entry</code> and <code>Target</code> pair example for <code>chroot</code>.</p>
        /// <p>
        /// <code>[ { "Entry:": "/", "Target": "/bucket_name/home/mydirectory" } ]</code>
        /// </p>
        ///
        /// <note>
        /// <p>If the target of a logical directory entry does not exist in Amazon S3 or EFS, the entry is
        /// ignored. As a workaround, you can use the Amazon S3 API or EFS API to create 0 byte objects as place
        /// holders for your directory. If using the CLI, use the <code>s3api</code> or <code>efsapi</code> call instead of
        /// <code>s3</code> or <code>efs</code> so you can use the put-object operation. For example, you use the
        /// following: <code>aws s3api put-object --bucket bucketname --key path/to/folder/</code>. Make
        /// sure that the end of the key name ends in a <code>/</code> for it to be considered a folder.</p>
        /// </note>
        pub fn home_directory_mappings(
            mut self,
            inp: impl Into<crate::model::HomeDirectoryMapEntry>,
        ) -> Self {
            self.inner = self.inner.home_directory_mappings(inp);
            self
        }
        /// <p>Logical directory mappings that specify what Amazon S3 or Amazon EFS paths and keys should
        /// be visible to your user and how you want to make them visible. You must specify the
        /// <code>Entry</code> and <code>Target</code> pair, where <code>Entry</code> shows how the path
        /// is made visible and <code>Target</code> is the actual Amazon S3 or Amazon EFS path. If you
        /// only specify a target, it is displayed as is. You also must ensure that your Amazon Web Services Identity
        /// and Access Management (IAM) role provides access to paths in <code>Target</code>. This value
        /// can only be set when <code>HomeDirectoryType</code> is set to
        /// <i>LOGICAL</i>.</p>
        /// <p>The following is an <code>Entry</code> and <code>Target</code> pair example.</p>
        /// <p>
        /// <code>[ { "Entry": "/directory1", "Target": "/bucket_name/home/mydirectory" } ]</code>
        /// </p>
        /// <p>In most cases, you can use this value instead of the session policy to lock down your
        /// user to the designated home directory ("<code>chroot</code>"). To do this, you can set
        /// <code>Entry</code> to <code>/</code> and set <code>Target</code> to the
        /// <code>HomeDirectory</code> parameter value.</p>
        /// <p>The following is an <code>Entry</code> and <code>Target</code> pair example for <code>chroot</code>.</p>
        /// <p>
        /// <code>[ { "Entry:": "/", "Target": "/bucket_name/home/mydirectory" } ]</code>
        /// </p>
        ///
        /// <note>
        /// <p>If the target of a logical directory entry does not exist in Amazon S3 or EFS, the entry is
        /// ignored. As a workaround, you can use the Amazon S3 API or EFS API to create 0 byte objects as place
        /// holders for your directory. If using the CLI, use the <code>s3api</code> or <code>efsapi</code> call instead of
        /// <code>s3</code> or <code>efs</code> so you can use the put-object operation. For example, you use the
        /// following: <code>aws s3api put-object --bucket bucketname --key path/to/folder/</code>. Make
        /// sure that the end of the key name ends in a <code>/</code> for it to be considered a folder.</p>
        /// </note>
        pub fn set_home_directory_mappings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::HomeDirectoryMapEntry>>,
        ) -> Self {
            self.inner = self.inner.set_home_directory_mappings(input);
            self
        }
        /// <p>A session policy for your user so that you can use the same IAM role across multiple users. This policy scopes down user
        /// access to portions of their Amazon S3 bucket. Variables that you can use inside this policy include <code>${Transfer:UserName}</code>,
        /// <code>${Transfer:HomeDirectory}</code>, and <code>${Transfer:HomeBucket}</code>.</p>
        ///
        /// <note>
        /// <p>This only applies when the domain of <code>ServerId</code> is S3. EFS does not use session policies.</p>
        /// <p>For session policies, Amazon Web Services Transfer Family stores the policy as a JSON blob, instead
        /// of the Amazon Resource Name (ARN) of the policy. You save the policy as a JSON blob and pass
        /// it in the <code>Policy</code> argument.</p>      
        /// <p>For an example of a session policy, see <a href="https://docs.aws.amazon.com/transfer/latest/userguide/session-policy.html">Example
        /// session policy</a>.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRole.html">AssumeRole</a> in the <i>Amazon Web Services Security Token Service API
        /// Reference</i>.</p>
        /// </note>
        pub fn policy(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy(inp);
            self
        }
        /// <p>A session policy for your user so that you can use the same IAM role across multiple users. This policy scopes down user
        /// access to portions of their Amazon S3 bucket. Variables that you can use inside this policy include <code>${Transfer:UserName}</code>,
        /// <code>${Transfer:HomeDirectory}</code>, and <code>${Transfer:HomeBucket}</code>.</p>
        ///
        /// <note>
        /// <p>This only applies when the domain of <code>ServerId</code> is S3. EFS does not use session policies.</p>
        /// <p>For session policies, Amazon Web Services Transfer Family stores the policy as a JSON blob, instead
        /// of the Amazon Resource Name (ARN) of the policy. You save the policy as a JSON blob and pass
        /// it in the <code>Policy</code> argument.</p>      
        /// <p>For an example of a session policy, see <a href="https://docs.aws.amazon.com/transfer/latest/userguide/session-policy.html">Example
        /// session policy</a>.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRole.html">AssumeRole</a> in the <i>Amazon Web Services Security Token Service API
        /// Reference</i>.</p>
        /// </note>
        pub fn set_policy(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy(input);
            self
        }
        /// <p>The full POSIX identity, including user ID (<code>Uid</code>), group ID
        /// (<code>Gid</code>), and any secondary groups IDs (<code>SecondaryGids</code>), that controls
        /// your users' access to your Amazon EFS file systems. The POSIX permissions that are set on
        /// files and directories in your file system determine the level of access your users get when
        /// transferring files into and out of your Amazon EFS file systems.</p>
        pub fn posix_profile(mut self, inp: crate::model::PosixProfile) -> Self {
            self.inner = self.inner.posix_profile(inp);
            self
        }
        /// <p>The full POSIX identity, including user ID (<code>Uid</code>), group ID
        /// (<code>Gid</code>), and any secondary groups IDs (<code>SecondaryGids</code>), that controls
        /// your users' access to your Amazon EFS file systems. The POSIX permissions that are set on
        /// files and directories in your file system determine the level of access your users get when
        /// transferring files into and out of your Amazon EFS file systems.</p>
        pub fn set_posix_profile(
            mut self,
            input: std::option::Option<crate::model::PosixProfile>,
        ) -> Self {
            self.inner = self.inner.set_posix_profile(input);
            self
        }
        /// <p>Specifies the Amazon Resource Name (ARN) of the IAM role that controls your users' access to your Amazon S3 bucket or EFS
        /// file system. The policies attached to this role determine the level of access that you want to provide your users when transferring
        /// files into and out of your Amazon S3 bucket or EFS file system. The IAM role should also contain a trust relationship that allows the
        /// server to access your resources when servicing your users' transfer requests.</p>
        pub fn role(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role(inp);
            self
        }
        /// <p>Specifies the Amazon Resource Name (ARN) of the IAM role that controls your users' access to your Amazon S3 bucket or EFS
        /// file system. The policies attached to this role determine the level of access that you want to provide your users when transferring
        /// files into and out of your Amazon S3 bucket or EFS file system. The IAM role should also contain a trust relationship that allows the
        /// server to access your resources when servicing your users' transfer requests.</p>
        pub fn set_role(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role(input);
            self
        }
        /// <p>A system-assigned unique identifier for a server instance. This is the specific server that you added your user to.</p>
        pub fn server_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.server_id(inp);
            self
        }
        /// <p>A system-assigned unique identifier for a server instance. This is the specific server that you added your user to.</p>
        pub fn set_server_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_server_id(input);
            self
        }
        /// <p>A unique identifier that is required to identify specific groups within your directory.
        /// The users of the group that you associate have access to your Amazon S3 or Amazon EFS
        /// resources over the enabled protocols using Amazon Web Services Transfer Family. If you know the group name,
        /// you can view the SID values by running the following command using Windows PowerShell.</p>
        ///
        /// <p>
        /// <code>Get-ADGroup -Filter {samAccountName -like "<i>YourGroupName</i>*"} -Properties * | Select SamAccountName,ObjectSid</code>
        /// </p>
        ///
        /// <p>In that command, replace <i>YourGroupName</i> with the name of your Active Directory group.</p>
        ///
        /// <p>The regex used to validate this parameter is a string of characters consisting of uppercase and lowercase alphanumeric characters with no spaces.
        /// You can also include underscores or any of the following characters: =,.@:/-</p>
        pub fn external_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.external_id(inp);
            self
        }
        /// <p>A unique identifier that is required to identify specific groups within your directory.
        /// The users of the group that you associate have access to your Amazon S3 or Amazon EFS
        /// resources over the enabled protocols using Amazon Web Services Transfer Family. If you know the group name,
        /// you can view the SID values by running the following command using Windows PowerShell.</p>
        ///
        /// <p>
        /// <code>Get-ADGroup -Filter {samAccountName -like "<i>YourGroupName</i>*"} -Properties * | Select SamAccountName,ObjectSid</code>
        /// </p>
        ///
        /// <p>In that command, replace <i>YourGroupName</i> with the name of your Active Directory group.</p>
        ///
        /// <p>The regex used to validate this parameter is a string of characters consisting of uppercase and lowercase alphanumeric characters with no spaces.
        /// You can also include underscores or any of the following characters: =,.@:/-</p>
        pub fn set_external_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_external_id(input);
            self
        }
    }
    /// Fluent builder constructing a request to `CreateServer`.
    ///
    /// <p>Instantiates an auto-scaling virtual server based on the selected file transfer protocol
    /// in Amazon Web Services. When you make updates to your file transfer protocol-enabled server or when you work
    /// with users, use the service-generated <code>ServerId</code> property that is assigned to the
    /// newly created server.</p>
    #[derive(std::fmt::Debug)]
    pub struct CreateServer<
        C = aws_smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = aws_smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_server_input::Builder,
    }
    impl<C, M, R> CreateServer<C, M, R>
    where
        C: aws_smithy_client::bounds::SmithyConnector,
        M: aws_smithy_client::bounds::SmithyMiddleware<C>,
        R: aws_smithy_client::retry::NewRequestPolicy,
    {
        /// Creates a new `CreateServer`.
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        /// Sends the request and returns the response.
        ///
        /// If an error occurs, an `SdkError` will be returned with additional details that
        /// can be matched against.
        ///
        /// By default, any retryable failures will be retried twice. Retry behavior
        /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
        /// set when configuring the client.
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateServerOutput,
            aws_smithy_http::result::SdkError<crate::error::CreateServerError>,
        >
        where
            R::Policy: aws_smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateServerInputOperationOutputAlias,
                crate::output::CreateServerOutput,
                crate::error::CreateServerError,
                crate::input::CreateServerInputOperationRetryAlias,
            >,
        {
            let input = self.inner.build().map_err(|err| {
                aws_smithy_http::result::SdkError::ConstructionFailure(err.into())
            })?;
            let op = input
                .make_operation(&self.handle.conf)
                .await
                .map_err(|err| {
                    aws_smithy_http::result::SdkError::ConstructionFailure(err.into())
                })?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the Amazon Web Services Certificate Manager (ACM) certificate. Required
        /// when <code>Protocols</code> is set to <code>FTPS</code>.</p>
        ///
        /// <p>To request a new public certificate, see <a href="https://docs.aws.amazon.com/acm/latest/userguide/gs-acm-request-public.html">Request a public certificate</a>
        /// in the <i> Amazon Web Services Certificate Manager User Guide</i>.</p>
        ///
        /// <p>To import an existing certificate into ACM, see <a href="https://docs.aws.amazon.com/acm/latest/userguide/import-certificate.html">Importing certificates into ACM</a>
        /// in the <i> Amazon Web Services Certificate Manager User Guide</i>.</p>
        ///
        /// <p>To request a private certificate to use FTPS through private IP addresses, see <a href="https://docs.aws.amazon.com/acm/latest/userguide/gs-acm-request-private.html">Request a
        /// private certificate</a> in the <i> Amazon Web Services Certificate Manager User
        /// Guide</i>.</p>
        ///
        /// <p>Certificates with the following cryptographic algorithms and key sizes are
        /// supported:</p>
        ///
        /// <ul>
        /// <li>
        /// <p>2048-bit RSA (RSA_2048)</p>
        /// </li>
        /// <li>
        /// <p>4096-bit RSA (RSA_4096)</p>
        /// </li>
        /// <li>
        /// <p>Elliptic Prime Curve 256 bit (EC_prime256v1)</p>
        /// </li>
        /// <li>
        /// <p>Elliptic Prime Curve 384 bit (EC_secp384r1)</p>
        /// </li>
        /// <li>
        /// <p>Elliptic Prime Curve 521 bit (EC_secp521r1)</p>
        /// </li>
        /// </ul>
        ///
        /// <note>
        /// <p>The certificate must be a valid SSL/TLS X.509 version 3 certificate with FQDN or IP
        /// address specified and information about the issuer.</p>
        /// </note>
        pub fn certificate(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.certificate(inp);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Amazon Web Services Certificate Manager (ACM) certificate. Required
        /// when <code>Protocols</code> is set to <code>FTPS</code>.</p>
        ///
        /// <p>To request a new public certificate, see <a href="https://docs.aws.amazon.com/acm/latest/userguide/gs-acm-request-public.html">Request a public certificate</a>
        /// in the <i> Amazon Web Services Certificate Manager User Guide</i>.</p>
        ///
        /// <p>To import an existing certificate into ACM, see <a href="https://docs.aws.amazon.com/acm/latest/userguide/import-certificate.html">Importing certificates into ACM</a>
        /// in the <i> Amazon Web Services Certificate Manager User Guide</i>.</p>
        ///
        /// <p>To request a private certificate to use FTPS through private IP addresses, see <a href="https://docs.aws.amazon.com/acm/latest/userguide/gs-acm-request-private.html">Request a
        /// private certificate</a> in the <i> Amazon Web Services Certificate Manager User
        /// Guide</i>.</p>
        ///
        /// <p>Certificates with the following cryptographic algorithms and key sizes are
        /// supported:</p>
        ///
        /// <ul>
        /// <li>
        /// <p>2048-bit RSA (RSA_2048)</p>
        /// </li>
        /// <li>
        /// <p>4096-bit RSA (RSA_4096)</p>
        /// </li>
        /// <li>
        /// <p>Elliptic Prime Curve 256 bit (EC_prime256v1)</p>
        /// </li>
        /// <li>
        /// <p>Elliptic Prime Curve 384 bit (EC_secp384r1)</p>
        /// </li>
        /// <li>
        /// <p>Elliptic Prime Curve 521 bit (EC_secp521r1)</p>
        /// </li>
        /// </ul>
        ///
        /// <note>
        /// <p>The certificate must be a valid SSL/TLS X.509 version 3 certificate with FQDN or IP
        /// address specified and information about the issuer.</p>
        /// </note>
        pub fn set_certificate(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_certificate(input);
            self
        }
        /// <p>The domain of the storage system that is used for file transfers. There are two domains
        /// available: Amazon Simple Storage Service (Amazon S3) and Amazon Elastic File System (Amazon EFS). The
        /// default value is S3.</p>
        ///
        /// <note>
        /// <p>After the server is created, the domain cannot be changed.</p>
        /// </note>
        pub fn domain(mut self, inp: crate::model::Domain) -> Self {
            self.inner = self.inner.domain(inp);
            self
        }
        /// <p>The domain of the storage system that is used for file transfers. There are two domains
        /// available: Amazon Simple Storage Service (Amazon S3) and Amazon Elastic File System (Amazon EFS). The
        /// default value is S3.</p>
        ///
        /// <note>
        /// <p>After the server is created, the domain cannot be changed.</p>
        /// </note>
        pub fn set_domain(mut self, input: std::option::Option<crate::model::Domain>) -> Self {
            self.inner = self.inner.set_domain(input);
            self
        }
        /// <p>The virtual private cloud (VPC) endpoint settings that are configured for your server.
        /// When you host your endpoint within your VPC, you can make it accessible only to resources
        /// within your VPC, or you can attach Elastic IP addresses and make it accessible to clients over
        /// the internet. Your VPC's default security groups are automatically assigned to your
        /// endpoint.</p>
        pub fn endpoint_details(mut self, inp: crate::model::EndpointDetails) -> Self {
            self.inner = self.inner.endpoint_details(inp);
            self
        }
        /// <p>The virtual private cloud (VPC) endpoint settings that are configured for your server.
        /// When you host your endpoint within your VPC, you can make it accessible only to resources
        /// within your VPC, or you can attach Elastic IP addresses and make it accessible to clients over
        /// the internet. Your VPC's default security groups are automatically assigned to your
        /// endpoint.</p>
        pub fn set_endpoint_details(
            mut self,
            input: std::option::Option<crate::model::EndpointDetails>,
        ) -> Self {
            self.inner = self.inner.set_endpoint_details(input);
            self
        }
        /// <p>The type of endpoint that you want your server to use. You can choose to make your server's endpoint publicly accessible (PUBLIC)
        /// or host it inside your VPC. With an endpoint that is hosted in a VPC, you can restrict access to your server and
        /// resources only within your VPC or choose to make it internet facing by attaching Elastic IP addresses directly to it.</p>
        /// <note>
        /// <p> After May 19, 2021, you won't be able to create a server using
        /// <code>EndpointType=VPC_ENDPOINT</code> in your Amazon Web Services account if your account hasn't already
        /// done so before May 19, 2021. If you have already created servers with
        /// <code>EndpointType=VPC_ENDPOINT</code> in your Amazon Web Services account on or before May 19, 2021,
        /// you will not be affected. After this date, use
        /// <code>EndpointType</code>=<code>VPC</code>.</p>
        ///
        /// <p>For more information, see
        /// https://docs.aws.amazon.com/transfer/latest/userguide/create-server-in-vpc.html#deprecate-vpc-endpoint.</p>
        /// <p>It is recommended that you use <code>VPC</code> as the <code>EndpointType</code>. With
        /// this endpoint type, you have the option to directly associate up to three Elastic IPv4
        /// addresses (BYO IP included) with your server's endpoint and use VPC security groups to
        /// restrict traffic by the client's public IP address. This is not possible with
        /// <code>EndpointType</code> set to <code>VPC_ENDPOINT</code>.</p>
        /// </note>
        pub fn endpoint_type(mut self, inp: crate::model::EndpointType) -> Self {
            self.inner = self.inner.endpoint_type(inp);
            self
        }
        /// <p>The type of endpoint that you want your server to use. You can choose to make your server's endpoint publicly accessible (PUBLIC)
        /// or host it inside your VPC. With an endpoint that is hosted in a VPC, you can restrict access to your server and
        /// resources only within your VPC or choose to make it internet facing by attaching Elastic IP addresses directly to it.</p>
        /// <note>
        /// <p> After May 19, 2021, you won't be able to create a server using
        /// <code>EndpointType=VPC_ENDPOINT</code> in your Amazon Web Services account if your account hasn't already
        /// done so before May 19, 2021. If you have already created servers with
        /// <code>EndpointType=VPC_ENDPOINT</code> in your Amazon Web Services account on or before May 19, 2021,
        /// you will not be affected. After this date, use
        /// <code>EndpointType</code>=<code>VPC</code>.</p>
        ///
        /// <p>For more information, see
        /// https://docs.aws.amazon.com/transfer/latest/userguide/create-server-in-vpc.html#deprecate-vpc-endpoint.</p>
        /// <p>It is recommended that you use <code>VPC</code> as the <code>EndpointType</code>. With
        /// this endpoint type, you have the option to directly associate up to three Elastic IPv4
        /// addresses (BYO IP included) with your server's endpoint and use VPC security groups to
        /// restrict traffic by the client's public IP address. This is not possible with
        /// <code>EndpointType</code> set to <code>VPC_ENDPOINT</code>.</p>
        /// </note>
        pub fn set_endpoint_type(
            mut self,
            input: std::option::Option<crate::model::EndpointType>,
        ) -> Self {
            self.inner = self.inner.set_endpoint_type(input);
            self
        }
        /// <p>The RSA private key as generated by the <code>ssh-keygen -N "" -m PEM -f
        /// my-new-server-key</code> command.</p>
        ///
        /// <important>
        /// <p>If you aren't planning to migrate existing users from an existing SFTP-enabled
        /// server to a new server, don't update the host key. Accidentally changing a
        /// server's host key can be disruptive.</p>
        /// </important>
        ///
        ///
        ///
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/transfer/latest/userguide/edit-server-config.html#configuring-servers-change-host-key">Change the host key for your SFTP-enabled server</a> in the <i>Amazon Web Services Transfer
        /// Family User Guide</i>.</p>
        pub fn host_key(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.host_key(inp);
            self
        }
        /// <p>The RSA private key as generated by the <code>ssh-keygen -N "" -m PEM -f
        /// my-new-server-key</code> command.</p>
        ///
        /// <important>
        /// <p>If you aren't planning to migrate existing users from an existing SFTP-enabled
        /// server to a new server, don't update the host key. Accidentally changing a
        /// server's host key can be disruptive.</p>
        /// </important>
        ///
        ///
        ///
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/transfer/latest/userguide/edit-server-config.html#configuring-servers-change-host-key">Change the host key for your SFTP-enabled server</a> in the <i>Amazon Web Services Transfer
        /// Family User Guide</i>.</p>
        pub fn set_host_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_host_key(input);
            self
        }
        /// <p>Required when <code>IdentityProviderType</code> is set to
        /// <code>AWS_DIRECTORY_SERVICE</code> or <code>API_GATEWAY</code>. Accepts an array containing
        /// all of the information required to use a directory in <code>AWS_DIRECTORY_SERVICE</code> or
        /// invoke a customer-supplied authentication API, including the API Gateway URL. Not required
        /// when <code>IdentityProviderType</code> is set to <code>SERVICE_MANAGED</code>.</p>
        pub fn identity_provider_details(
            mut self,
            inp: crate::model::IdentityProviderDetails,
        ) -> Self {
            self.inner = self.inner.identity_provider_details(inp);
            self
        }
        /// <p>Required when <code>IdentityProviderType</code> is set to
        /// <code>AWS_DIRECTORY_SERVICE</code> or <code>API_GATEWAY</code>. Accepts an array containing
        /// all of the information required to use a directory in <code>AWS_DIRECTORY_SERVICE</code> or
        /// invoke a customer-supplied authentication API, including the API Gateway URL. Not required
        /// when <code>IdentityProviderType</code> is set to <code>SERVICE_MANAGED</code>.</p>
        pub fn set_identity_provider_details(
            mut self,
            input: std::option::Option<crate::model::IdentityProviderDetails>,
        ) -> Self {
            self.inner = self.inner.set_identity_provider_details(input);
            self
        }
        /// <p>Specifies the mode of authentication for a server. The default value is
        /// <code>SERVICE_MANAGED</code>, which allows you to store and access user credentials within
        /// the Amazon Web Services Transfer Family service.</p>
        /// <p>Use <code>AWS_DIRECTORY_SERVICE</code> to provide access to
        /// Active Directory groups in Amazon Web Services Managed Active Directory or Microsoft Active Directory in your
        /// on-premises environment or in Amazon Web Services using AD Connectors. This option also requires you to
        /// provide a Directory ID using the <code>IdentityProviderDetails</code> parameter.</p>
        /// <p>Use the <code>API_GATEWAY</code> value to integrate with an identity provider of your choosing. The
        /// <code>API_GATEWAY</code> setting requires you to provide an API Gateway endpoint URL to call
        /// for authentication using the <code>IdentityProviderDetails</code> parameter.</p>
        pub fn identity_provider_type(mut self, inp: crate::model::IdentityProviderType) -> Self {
            self.inner = self.inner.identity_provider_type(inp);
            self
        }
        /// <p>Specifies the mode of authentication for a server. The default value is
        /// <code>SERVICE_MANAGED</code>, which allows you to store and access user credentials within
        /// the Amazon Web Services Transfer Family service.</p>
        /// <p>Use <code>AWS_DIRECTORY_SERVICE</code> to provide access to
        /// Active Directory groups in Amazon Web Services Managed Active Directory or Microsoft Active Directory in your
        /// on-premises environment or in Amazon Web Services using AD Connectors. This option also requires you to
        /// provide a Directory ID using the <code>IdentityProviderDetails</code> parameter.</p>
        /// <p>Use the <code>API_GATEWAY</code> value to integrate with an identity provider of your choosing. The
        /// <code>API_GATEWAY</code> setting requires you to provide an API Gateway endpoint URL to call
        /// for authentication using the <code>IdentityProviderDetails</code> parameter.</p>
        pub fn set_identity_provider_type(
            mut self,
            input: std::option::Option<crate::model::IdentityProviderType>,
        ) -> Self {
            self.inner = self.inner.set_identity_provider_type(input);
            self
        }
        /// <p>Specifies the Amazon Resource Name (ARN) of the Amazon Web Services Identity and Access Management (IAM) role that allows a server to turn
        /// on Amazon CloudWatch logging for Amazon S3 or Amazon EFS events. When set, user activity can be viewed in
        /// your CloudWatch logs.</p>
        pub fn logging_role(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.logging_role(inp);
            self
        }
        /// <p>Specifies the Amazon Resource Name (ARN) of the Amazon Web Services Identity and Access Management (IAM) role that allows a server to turn
        /// on Amazon CloudWatch logging for Amazon S3 or Amazon EFS events. When set, user activity can be viewed in
        /// your CloudWatch logs.</p>
        pub fn set_logging_role(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_logging_role(input);
            self
        }
        /// Appends an item to `Protocols`.
        ///
        /// To override the contents of this collection use [`set_protocols`](Self::set_protocols).
        ///
        /// <p>Specifies the file transfer protocol or protocols over which your file transfer protocol
        /// client can connect to your server's endpoint. The available protocols are:</p>
        ///
        /// <ul>
        /// <li>
        /// <p>
        /// <code>SFTP</code> (Secure Shell (SSH) File Transfer Protocol): File transfer over
        /// SSH</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>FTPS</code> (File Transfer Protocol Secure): File transfer with TLS
        /// encryption</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>FTP</code> (File Transfer Protocol): Unencrypted file transfer</p>
        /// </li>
        /// </ul>
        ///
        /// <note>
        /// <p>If you select <code>FTPS</code>, you must choose a certificate stored in Amazon Web Services Certificate
        /// Manager (ACM) which is used to identify your server when clients connect to it over
        /// FTPS.</p>
        ///
        /// <p>If <code>Protocol</code> includes either <code>FTP</code> or <code>FTPS</code>, then the
        /// <code>EndpointType</code> must be <code>VPC</code> and the
        /// <code>IdentityProviderType</code> must be <code>AWS_DIRECTORY_SERVICE</code> or <code>API_GATEWAY</code>.</p>
        ///
        /// <p>If <code>Protocol</code> includes <code>FTP</code>, then
        /// <code>AddressAllocationIds</code> cannot be associated.</p>
        ///
        /// <p>If <code>Protocol</code> is set only to <code>SFTP</code>, the <code>EndpointType</code>
        /// can be set to <code>PUBLIC</code> and the <code>IdentityProviderType</code> can be set to
        /// <code>SERVICE_MANAGED</code>.</p>
        /// </note>
        pub fn protocols(mut self, inp: impl Into<crate::model::Protocol>) -> Self {
            self.inner = self.inner.protocols(inp);
            self
        }
        /// <p>Specifies the file transfer protocol or protocols over which your file transfer protocol
        /// client can connect to your server's endpoint. The available protocols are:</p>
        ///
        /// <ul>
        /// <li>
        /// <p>
        /// <code>SFTP</code> (Secure Shell (SSH) File Transfer Protocol): File transfer over
        /// SSH</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>FTPS</code> (File Transfer Protocol Secure): File transfer with TLS
        /// encryption</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>FTP</code> (File Transfer Protocol): Unencrypted file transfer</p>
        /// </li>
        /// </ul>
        ///
        /// <note>
        /// <p>If you select <code>FTPS</code>, you must choose a certificate stored in Amazon Web Services Certificate
        /// Manager (ACM) which is used to identify your server when clients connect to it over
        /// FTPS.</p>
        ///
        /// <p>If <code>Protocol</code> includes either <code>FTP</code> or <code>FTPS</code>, then the
        /// <code>EndpointType</code> must be <code>VPC</code> and the
        /// <code>IdentityProviderType</code> must be <code>AWS_DIRECTORY_SERVICE</code> or <code>API_GATEWAY</code>.</p>
        ///
        /// <p>If <code>Protocol</code> includes <code>FTP</code>, then
        /// <code>AddressAllocationIds</code> cannot be associated.</p>
        ///
        /// <p>If <code>Protocol</code> is set only to <code>SFTP</code>, the <code>EndpointType</code>
        /// can be set to <code>PUBLIC</code> and the <code>IdentityProviderType</code> can be set to
        /// <code>SERVICE_MANAGED</code>.</p>
        /// </note>
        pub fn set_protocols(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Protocol>>,
        ) -> Self {
            self.inner = self.inner.set_protocols(input);
            self
        }
        /// <p>Specifies the name of the security policy that is attached to the server.</p>
        pub fn security_policy_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.security_policy_name(inp);
            self
        }
        /// <p>Specifies the name of the security policy that is attached to the server.</p>
        pub fn set_security_policy_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_security_policy_name(input);
            self
        }
        /// Appends an item to `Tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Key-value pairs that can be used to group and search for servers.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        /// <p>Key-value pairs that can be used to group and search for servers.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>Specifies the workflow ID for the workflow to assign and the execution role used for executing the workflow.</p>
        pub fn workflow_details(mut self, inp: crate::model::WorkflowDetails) -> Self {
            self.inner = self.inner.workflow_details(inp);
            self
        }
        /// <p>Specifies the workflow ID for the workflow to assign and the execution role used for executing the workflow.</p>
        pub fn set_workflow_details(
            mut self,
            input: std::option::Option<crate::model::WorkflowDetails>,
        ) -> Self {
            self.inner = self.inner.set_workflow_details(input);
            self
        }
    }
    /// Fluent builder constructing a request to `CreateUser`.
    ///
    /// <p>Creates a user and associates them with an existing file transfer protocol-enabled server.
    /// You can only create and associate users with servers that have the
    /// <code>IdentityProviderType</code> set to <code>SERVICE_MANAGED</code>. Using parameters for
    /// <code>CreateUser</code>, you can specify the user name, set the home directory, store the
    /// user's public key, and assign the user's Amazon Web Services Identity and Access Management (IAM)
    /// role. You can also optionally add a session policy, and assign metadata with tags that can
    /// be used to group and search for users.</p>
    #[derive(std::fmt::Debug)]
    pub struct CreateUser<
        C = aws_smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = aws_smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_user_input::Builder,
    }
    impl<C, M, R> CreateUser<C, M, R>
    where
        C: aws_smithy_client::bounds::SmithyConnector,
        M: aws_smithy_client::bounds::SmithyMiddleware<C>,
        R: aws_smithy_client::retry::NewRequestPolicy,
    {
        /// Creates a new `CreateUser`.
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        /// Sends the request and returns the response.
        ///
        /// If an error occurs, an `SdkError` will be returned with additional details that
        /// can be matched against.
        ///
        /// By default, any retryable failures will be retried twice. Retry behavior
        /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
        /// set when configuring the client.
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateUserOutput,
            aws_smithy_http::result::SdkError<crate::error::CreateUserError>,
        >
        where
            R::Policy: aws_smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateUserInputOperationOutputAlias,
                crate::output::CreateUserOutput,
                crate::error::CreateUserError,
                crate::input::CreateUserInputOperationRetryAlias,
            >,
        {
            let input = self.inner.build().map_err(|err| {
                aws_smithy_http::result::SdkError::ConstructionFailure(err.into())
            })?;
            let op = input
                .make_operation(&self.handle.conf)
                .await
                .map_err(|err| {
                    aws_smithy_http::result::SdkError::ConstructionFailure(err.into())
                })?;
            self.handle.client.call(op).await
        }
        /// <p>The landing directory (folder) for a user when they log in to the server using the client.</p>
        /// <p>A <code>HomeDirectory</code> example is <code>/bucket_name/home/mydirectory</code>.</p>
        pub fn home_directory(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.home_directory(inp);
            self
        }
        /// <p>The landing directory (folder) for a user when they log in to the server using the client.</p>
        /// <p>A <code>HomeDirectory</code> example is <code>/bucket_name/home/mydirectory</code>.</p>
        pub fn set_home_directory(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_home_directory(input);
            self
        }
        /// <p>The type of landing directory (folder) you want your users' home directory to be when they log into the server.
        /// If you set it to <code>PATH</code>, the user will see the absolute Amazon S3 bucket or EFS paths as is in their file transfer protocol clients.
        /// If you set it <code>LOGICAL</code>, you need to provide mappings in the <code>HomeDirectoryMappings</code> for how you want to make Amazon
        /// S3 or EFS paths visible to your users.</p>
        pub fn home_directory_type(mut self, inp: crate::model::HomeDirectoryType) -> Self {
            self.inner = self.inner.home_directory_type(inp);
            self
        }
        /// <p>The type of landing directory (folder) you want your users' home directory to be when they log into the server.
        /// If you set it to <code>PATH</code>, the user will see the absolute Amazon S3 bucket or EFS paths as is in their file transfer protocol clients.
        /// If you set it <code>LOGICAL</code>, you need to provide mappings in the <code>HomeDirectoryMappings</code> for how you want to make Amazon
        /// S3 or EFS paths visible to your users.</p>
        pub fn set_home_directory_type(
            mut self,
            input: std::option::Option<crate::model::HomeDirectoryType>,
        ) -> Self {
            self.inner = self.inner.set_home_directory_type(input);
            self
        }
        /// Appends an item to `HomeDirectoryMappings`.
        ///
        /// To override the contents of this collection use [`set_home_directory_mappings`](Self::set_home_directory_mappings).
        ///
        /// <p>Logical directory mappings that specify what Amazon S3 or Amazon EFS paths and keys should
        /// be visible to your user and how you want to make them visible. You must specify the
        /// <code>Entry</code> and <code>Target</code> pair, where <code>Entry</code> shows how the path
        /// is made visible and <code>Target</code> is the actual Amazon S3 or Amazon EFS path. If you
        /// only specify a target, it is displayed as is. You also must ensure that your Amazon Web Services Identity
        /// and Access Management (IAM) role provides access to paths in <code>Target</code>. This value
        /// can only be set when <code>HomeDirectoryType</code> is set to
        /// <i>LOGICAL</i>.</p>
        ///
        /// <p>The following is an <code>Entry</code> and <code>Target</code> pair example.</p>
        ///
        /// <p>
        /// <code>[ { "Entry": "/directory1", "Target":
        /// "/bucket_name/home/mydirectory" } ]</code>
        /// </p>
        ///
        /// <p>In most cases, you can use this value instead of the session policy to lock your user
        /// down to the designated home directory ("<code>chroot</code>"). To do this, you can set
        /// <code>Entry</code> to <code>/</code> and set <code>Target</code> to the HomeDirectory
        /// parameter value.</p>
        /// <p>The following is an <code>Entry</code> and <code>Target</code> pair example for <code>chroot</code>.</p>
        /// <p>
        /// <code>[ { "Entry:": "/", "Target": "/bucket_name/home/mydirectory" } ]</code>
        /// </p>
        ///
        /// <note>
        /// <p>If the target of a logical directory entry does not exist in Amazon S3 or EFS, the entry is
        /// ignored. As a workaround, you can use the Amazon S3 API or EFS API to create 0 byte objects as place
        /// holders for your directory. If using the CLI, use the <code>s3api</code> or <code>efsapi</code> call instead of
        /// <code>s3</code> or <code>efs</code> so you can use the put-object operation. For example, you use the
        /// following: <code>aws s3api put-object --bucket bucketname --key path/to/folder/</code>. Make
        /// sure that the end of the key name ends in a <code>/</code> for it to be considered a folder.</p>
        /// </note>
        pub fn home_directory_mappings(
            mut self,
            inp: impl Into<crate::model::HomeDirectoryMapEntry>,
        ) -> Self {
            self.inner = self.inner.home_directory_mappings(inp);
            self
        }
        /// <p>Logical directory mappings that specify what Amazon S3 or Amazon EFS paths and keys should
        /// be visible to your user and how you want to make them visible. You must specify the
        /// <code>Entry</code> and <code>Target</code> pair, where <code>Entry</code> shows how the path
        /// is made visible and <code>Target</code> is the actual Amazon S3 or Amazon EFS path. If you
        /// only specify a target, it is displayed as is. You also must ensure that your Amazon Web Services Identity
        /// and Access Management (IAM) role provides access to paths in <code>Target</code>. This value
        /// can only be set when <code>HomeDirectoryType</code> is set to
        /// <i>LOGICAL</i>.</p>
        ///
        /// <p>The following is an <code>Entry</code> and <code>Target</code> pair example.</p>
        ///
        /// <p>
        /// <code>[ { "Entry": "/directory1", "Target":
        /// "/bucket_name/home/mydirectory" } ]</code>
        /// </p>
        ///
        /// <p>In most cases, you can use this value instead of the session policy to lock your user
        /// down to the designated home directory ("<code>chroot</code>"). To do this, you can set
        /// <code>Entry</code> to <code>/</code> and set <code>Target</code> to the HomeDirectory
        /// parameter value.</p>
        /// <p>The following is an <code>Entry</code> and <code>Target</code> pair example for <code>chroot</code>.</p>
        /// <p>
        /// <code>[ { "Entry:": "/", "Target": "/bucket_name/home/mydirectory" } ]</code>
        /// </p>
        ///
        /// <note>
        /// <p>If the target of a logical directory entry does not exist in Amazon S3 or EFS, the entry is
        /// ignored. As a workaround, you can use the Amazon S3 API or EFS API to create 0 byte objects as place
        /// holders for your directory. If using the CLI, use the <code>s3api</code> or <code>efsapi</code> call instead of
        /// <code>s3</code> or <code>efs</code> so you can use the put-object operation. For example, you use the
        /// following: <code>aws s3api put-object --bucket bucketname --key path/to/folder/</code>. Make
        /// sure that the end of the key name ends in a <code>/</code> for it to be considered a folder.</p>
        /// </note>
        pub fn set_home_directory_mappings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::HomeDirectoryMapEntry>>,
        ) -> Self {
            self.inner = self.inner.set_home_directory_mappings(input);
            self
        }
        /// <p>A session policy for your user so that you can use the same IAM role across multiple users. This policy scopes down user
        /// access to portions of their Amazon S3 bucket. Variables that you can use inside this policy include <code>${Transfer:UserName}</code>,
        /// <code>${Transfer:HomeDirectory}</code>, and <code>${Transfer:HomeBucket}</code>.</p>
        ///
        /// <note>
        /// <p>This only applies when the domain of <code>ServerId</code> is S3. EFS does not use session policies.</p>
        /// <p>For session policies, Amazon Web Services Transfer Family stores the policy as a JSON blob, instead
        /// of the Amazon Resource Name (ARN) of the policy. You save the policy as a JSON blob and pass
        /// it in the <code>Policy</code> argument.</p>
        ///
        ///
        ///
        /// <p>For an example of a session policy, see <a href="https://docs.aws.amazon.com/transfer/latest/userguide/session-policy.html">Example session
        /// policy</a>.</p>
        ///
        ///
        ///
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRole.html">AssumeRole</a> in the <i>Amazon Web Services
        /// Security Token Service API Reference</i>.</p>
        /// </note>
        pub fn policy(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy(inp);
            self
        }
        /// <p>A session policy for your user so that you can use the same IAM role across multiple users. This policy scopes down user
        /// access to portions of their Amazon S3 bucket. Variables that you can use inside this policy include <code>${Transfer:UserName}</code>,
        /// <code>${Transfer:HomeDirectory}</code>, and <code>${Transfer:HomeBucket}</code>.</p>
        ///
        /// <note>
        /// <p>This only applies when the domain of <code>ServerId</code> is S3. EFS does not use session policies.</p>
        /// <p>For session policies, Amazon Web Services Transfer Family stores the policy as a JSON blob, instead
        /// of the Amazon Resource Name (ARN) of the policy. You save the policy as a JSON blob and pass
        /// it in the <code>Policy</code> argument.</p>
        ///
        ///
        ///
        /// <p>For an example of a session policy, see <a href="https://docs.aws.amazon.com/transfer/latest/userguide/session-policy.html">Example session
        /// policy</a>.</p>
        ///
        ///
        ///
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRole.html">AssumeRole</a> in the <i>Amazon Web Services
        /// Security Token Service API Reference</i>.</p>
        /// </note>
        pub fn set_policy(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy(input);
            self
        }
        /// <p>Specifies the full POSIX identity, including user ID (<code>Uid</code>), group ID
        /// (<code>Gid</code>), and any secondary groups IDs (<code>SecondaryGids</code>), that controls
        /// your users' access to your Amazon EFS file systems. The POSIX permissions that are set on
        /// files and directories in Amazon EFS determine the level of access your users get when
        /// transferring files into and out of your Amazon EFS file systems.</p>
        pub fn posix_profile(mut self, inp: crate::model::PosixProfile) -> Self {
            self.inner = self.inner.posix_profile(inp);
            self
        }
        /// <p>Specifies the full POSIX identity, including user ID (<code>Uid</code>), group ID
        /// (<code>Gid</code>), and any secondary groups IDs (<code>SecondaryGids</code>), that controls
        /// your users' access to your Amazon EFS file systems. The POSIX permissions that are set on
        /// files and directories in Amazon EFS determine the level of access your users get when
        /// transferring files into and out of your Amazon EFS file systems.</p>
        pub fn set_posix_profile(
            mut self,
            input: std::option::Option<crate::model::PosixProfile>,
        ) -> Self {
            self.inner = self.inner.set_posix_profile(input);
            self
        }
        /// <p>Specifies the Amazon Resource Name (ARN) of the IAM role that controls your users' access to your Amazon S3 bucket or EFS
        /// file system. The policies attached to this role determine the level of access that you want to provide your users when transferring
        /// files into and out of your Amazon S3 bucket or EFS file system. The IAM role should also contain a trust relationship that allows the
        /// server to access your resources when servicing your users' transfer requests.</p>
        pub fn role(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role(inp);
            self
        }
        /// <p>Specifies the Amazon Resource Name (ARN) of the IAM role that controls your users' access to your Amazon S3 bucket or EFS
        /// file system. The policies attached to this role determine the level of access that you want to provide your users when transferring
        /// files into and out of your Amazon S3 bucket or EFS file system. The IAM role should also contain a trust relationship that allows the
        /// server to access your resources when servicing your users' transfer requests.</p>
        pub fn set_role(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role(input);
            self
        }
        /// <p>A system-assigned unique identifier for a server instance. This is the specific server
        /// that you added your user to.</p>
        pub fn server_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.server_id(inp);
            self
        }
        /// <p>A system-assigned unique identifier for a server instance. This is the specific server
        /// that you added your user to.</p>
        pub fn set_server_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_server_id(input);
            self
        }
        /// <p>The public portion of the Secure Shell (SSH) key used to authenticate the user to the
        /// server.</p>
        pub fn ssh_public_key_body(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ssh_public_key_body(inp);
            self
        }
        /// <p>The public portion of the Secure Shell (SSH) key used to authenticate the user to the
        /// server.</p>
        pub fn set_ssh_public_key_body(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_ssh_public_key_body(input);
            self
        }
        /// Appends an item to `Tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Key-value pairs that can be used to group and search for users. Tags are metadata attached
        /// to users for any purpose.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        /// <p>Key-value pairs that can be used to group and search for users. Tags are metadata attached
        /// to users for any purpose.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>A unique string that identifies a user and is associated with a <code>ServerId</code>. This user name must be a minimum of 3 and a maximum of 100 characters
        /// long. The following are valid characters: a-z, A-Z, 0-9, underscore '_', hyphen
        /// '-', period '.', and at sign '@'. The user name can't start
        /// with a hyphen, period, or at sign.</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_name(inp);
            self
        }
        /// <p>A unique string that identifies a user and is associated with a <code>ServerId</code>. This user name must be a minimum of 3 and a maximum of 100 characters
        /// long. The following are valid characters: a-z, A-Z, 0-9, underscore '_', hyphen
        /// '-', period '.', and at sign '@'. The user name can't start
        /// with a hyphen, period, or at sign.</p>
        pub fn set_user_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_user_name(input);
            self
        }
    }
    /// Fluent builder constructing a request to `CreateWorkflow`.
    ///
    /// <p>
    /// Allows you to create a workflow with specified steps and step details the workflow invokes after file transfer completes.
    /// After creating a workflow, you can associate the workflow created with any transfer servers by specifying the <code>workflow-details</code> field in <code>CreateServer</code> and <code>UpdateServer</code> operations.
    /// </p>
    #[derive(std::fmt::Debug)]
    pub struct CreateWorkflow<
        C = aws_smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = aws_smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_workflow_input::Builder,
    }
    impl<C, M, R> CreateWorkflow<C, M, R>
    where
        C: aws_smithy_client::bounds::SmithyConnector,
        M: aws_smithy_client::bounds::SmithyMiddleware<C>,
        R: aws_smithy_client::retry::NewRequestPolicy,
    {
        /// Creates a new `CreateWorkflow`.
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        /// Sends the request and returns the response.
        ///
        /// If an error occurs, an `SdkError` will be returned with additional details that
        /// can be matched against.
        ///
        /// By default, any retryable failures will be retried twice. Retry behavior
        /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
        /// set when configuring the client.
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateWorkflowOutput,
            aws_smithy_http::result::SdkError<crate::error::CreateWorkflowError>,
        >
        where
            R::Policy: aws_smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateWorkflowInputOperationOutputAlias,
                crate::output::CreateWorkflowOutput,
                crate::error::CreateWorkflowError,
                crate::input::CreateWorkflowInputOperationRetryAlias,
            >,
        {
            let input = self.inner.build().map_err(|err| {
                aws_smithy_http::result::SdkError::ConstructionFailure(err.into())
            })?;
            let op = input
                .make_operation(&self.handle.conf)
                .await
                .map_err(|err| {
                    aws_smithy_http::result::SdkError::ConstructionFailure(err.into())
                })?;
            self.handle.client.call(op).await
        }
        /// <p>A textual description for the workflow.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(inp);
            self
        }
        /// <p>A textual description for the workflow.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// Appends an item to `Steps`.
        ///
        /// To override the contents of this collection use [`set_steps`](Self::set_steps).
        ///
        /// <p>Specifies the details for the steps that are in the specified workflow.</p>
        /// <p>
        /// The <code>TYPE</code> specifies which of the following actions is being taken for this step.
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <i>Copy</i>: copy the file to another location</p>
        /// </li>
        /// <li>
        /// <p>
        /// <i>Custom</i>: custom step with a lambda target</p>
        /// </li>
        /// <li>
        /// <p>
        /// <i>Delete</i>: delete the file</p>
        /// </li>
        /// <li>
        /// <p>
        /// <i>Tag</i>: add a tag to the file</p>
        /// </li>
        /// </ul>
        /// <note>
        /// <p>
        /// Currently, copying and tagging are supported only on S3.
        /// </p>
        /// </note>
        /// <p>
        /// For file location, you specify either the S3 bucket and key, or the EFS filesystem ID and path.
        /// </p>
        pub fn steps(mut self, inp: impl Into<crate::model::WorkflowStep>) -> Self {
            self.inner = self.inner.steps(inp);
            self
        }
        /// <p>Specifies the details for the steps that are in the specified workflow.</p>
        /// <p>
        /// The <code>TYPE</code> specifies which of the following actions is being taken for this step.
        /// </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <i>Copy</i>: copy the file to another location</p>
        /// </li>
        /// <li>
        /// <p>
        /// <i>Custom</i>: custom step with a lambda target</p>
        /// </li>
        /// <li>
        /// <p>
        /// <i>Delete</i>: delete the file</p>
        /// </li>
        /// <li>
        /// <p>
        /// <i>Tag</i>: add a tag to the file</p>
        /// </li>
        /// </ul>
        /// <note>
        /// <p>
        /// Currently, copying and tagging are supported only on S3.
        /// </p>
        /// </note>
        /// <p>
        /// For file location, you specify either the S3 bucket and key, or the EFS filesystem ID and path.
        /// </p>
        pub fn set_steps(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::WorkflowStep>>,
        ) -> Self {
            self.inner = self.inner.set_steps(input);
            self
        }
        /// Appends an item to `OnExceptionSteps`.
        ///
        /// To override the contents of this collection use [`set_on_exception_steps`](Self::set_on_exception_steps).
        ///
        /// <p>Specifies the steps (actions) to take if errors are encountered during execution of the workflow.</p>
        /// <note>
        /// <p>For custom steps, the lambda function needs to send <code>FAILURE</code> to the call
        /// back API to kick off the exception steps. Additionally, if the lambda does not send
        /// <code>SUCCESS</code> before it times out, the exception steps are executed.</p>
        /// </note>
        pub fn on_exception_steps(mut self, inp: impl Into<crate::model::WorkflowStep>) -> Self {
            self.inner = self.inner.on_exception_steps(inp);
            self
        }
        /// <p>Specifies the steps (actions) to take if errors are encountered during execution of the workflow.</p>
        /// <note>
        /// <p>For custom steps, the lambda function needs to send <code>FAILURE</code> to the call
        /// back API to kick off the exception steps. Additionally, if the lambda does not send
        /// <code>SUCCESS</code> before it times out, the exception steps are executed.</p>
        /// </note>
        pub fn set_on_exception_steps(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::WorkflowStep>>,
        ) -> Self {
            self.inner = self.inner.set_on_exception_steps(input);
            self
        }
        /// Appends an item to `Tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Key-value pairs that can be used to group and search for workflows. Tags are metadata attached
        /// to workflows for any purpose.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        /// <p>Key-value pairs that can be used to group and search for workflows. Tags are metadata attached
        /// to workflows for any purpose.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    /// Fluent builder constructing a request to `DeleteAccess`.
    ///
    /// <p>Allows you to delete the access specified in the <code>ServerID</code> and
    /// <code>ExternalID</code> parameters.</p>
    #[derive(std::fmt::Debug)]
    pub struct DeleteAccess<
        C = aws_smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = aws_smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_access_input::Builder,
    }
    impl<C, M, R> DeleteAccess<C, M, R>
    where
        C: aws_smithy_client::bounds::SmithyConnector,
        M: aws_smithy_client::bounds::SmithyMiddleware<C>,
        R: aws_smithy_client::retry::NewRequestPolicy,
    {
        /// Creates a new `DeleteAccess`.
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        /// Sends the request and returns the response.
        ///
        /// If an error occurs, an `SdkError` will be returned with additional details that
        /// can be matched against.
        ///
        /// By default, any retryable failures will be retried twice. Retry behavior
        /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
        /// set when configuring the client.
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteAccessOutput,
            aws_smithy_http::result::SdkError<crate::error::DeleteAccessError>,
        >
        where
            R::Policy: aws_smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteAccessInputOperationOutputAlias,
                crate::output::DeleteAccessOutput,
                crate::error::DeleteAccessError,
                crate::input::DeleteAccessInputOperationRetryAlias,
            >,
        {
            let input = self.inner.build().map_err(|err| {
                aws_smithy_http::result::SdkError::ConstructionFailure(err.into())
            })?;
            let op = input
                .make_operation(&self.handle.conf)
                .await
                .map_err(|err| {
                    aws_smithy_http::result::SdkError::ConstructionFailure(err.into())
                })?;
            self.handle.client.call(op).await
        }
        /// <p>A system-assigned unique identifier for a server that has this user assigned.</p>
        pub fn server_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.server_id(inp);
            self
        }
        /// <p>A system-assigned unique identifier for a server that has this user assigned.</p>
        pub fn set_server_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_server_id(input);
            self
        }
        /// <p>A unique identifier that is required to identify specific groups within your directory.
        /// The users of the group that you associate have access to your Amazon S3 or Amazon EFS
        /// resources over the enabled protocols using Amazon Web Services Transfer Family. If you know the group name,
        /// you can view the SID values by running the following command using Windows PowerShell.</p>
        ///
        /// <p>
        /// <code>Get-ADGroup -Filter {samAccountName -like "<i>YourGroupName</i>*"} -Properties * | Select SamAccountName,ObjectSid</code>
        /// </p>
        ///
        /// <p>In that command, replace <i>YourGroupName</i> with the name of your Active Directory group.</p>
        ///
        /// <p>The regex used to validate this parameter is a string of characters consisting of uppercase and lowercase alphanumeric characters with no spaces.
        /// You can also include underscores or any of the following characters: =,.@:/-</p>
        pub fn external_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.external_id(inp);
            self
        }
        /// <p>A unique identifier that is required to identify specific groups within your directory.
        /// The users of the group that you associate have access to your Amazon S3 or Amazon EFS
        /// resources over the enabled protocols using Amazon Web Services Transfer Family. If you know the group name,
        /// you can view the SID values by running the following command using Windows PowerShell.</p>
        ///
        /// <p>
        /// <code>Get-ADGroup -Filter {samAccountName -like "<i>YourGroupName</i>*"} -Properties * | Select SamAccountName,ObjectSid</code>
        /// </p>
        ///
        /// <p>In that command, replace <i>YourGroupName</i> with the name of your Active Directory group.</p>
        ///
        /// <p>The regex used to validate this parameter is a string of characters consisting of uppercase and lowercase alphanumeric characters with no spaces.
        /// You can also include underscores or any of the following characters: =,.@:/-</p>
        pub fn set_external_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_external_id(input);
            self
        }
    }
    /// Fluent builder constructing a request to `DeleteServer`.
    ///
    /// <p>Deletes the file transfer protocol-enabled server that you specify.</p>
    ///
    /// <p>No response returns from this operation.</p>
    #[derive(std::fmt::Debug)]
    pub struct DeleteServer<
        C = aws_smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = aws_smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_server_input::Builder,
    }
    impl<C, M, R> DeleteServer<C, M, R>
    where
        C: aws_smithy_client::bounds::SmithyConnector,
        M: aws_smithy_client::bounds::SmithyMiddleware<C>,
        R: aws_smithy_client::retry::NewRequestPolicy,
    {
        /// Creates a new `DeleteServer`.
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        /// Sends the request and returns the response.
        ///
        /// If an error occurs, an `SdkError` will be returned with additional details that
        /// can be matched against.
        ///
        /// By default, any retryable failures will be retried twice. Retry behavior
        /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
        /// set when configuring the client.
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteServerOutput,
            aws_smithy_http::result::SdkError<crate::error::DeleteServerError>,
        >
        where
            R::Policy: aws_smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteServerInputOperationOutputAlias,
                crate::output::DeleteServerOutput,
                crate::error::DeleteServerError,
                crate::input::DeleteServerInputOperationRetryAlias,
            >,
        {
            let input = self.inner.build().map_err(|err| {
                aws_smithy_http::result::SdkError::ConstructionFailure(err.into())
            })?;
            let op = input
                .make_operation(&self.handle.conf)
                .await
                .map_err(|err| {
                    aws_smithy_http::result::SdkError::ConstructionFailure(err.into())
                })?;
            self.handle.client.call(op).await
        }
        /// <p>A unique system-assigned identifier for a server instance.</p>
        pub fn server_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.server_id(inp);
            self
        }
        /// <p>A unique system-assigned identifier for a server instance.</p>
        pub fn set_server_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_server_id(input);
            self
        }
    }
    /// Fluent builder constructing a request to `DeleteSshPublicKey`.
    ///
    /// <p>Deletes a user's Secure Shell (SSH) public key.</p>
    #[derive(std::fmt::Debug)]
    pub struct DeleteSshPublicKey<
        C = aws_smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = aws_smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_ssh_public_key_input::Builder,
    }
    impl<C, M, R> DeleteSshPublicKey<C, M, R>
    where
        C: aws_smithy_client::bounds::SmithyConnector,
        M: aws_smithy_client::bounds::SmithyMiddleware<C>,
        R: aws_smithy_client::retry::NewRequestPolicy,
    {
        /// Creates a new `DeleteSshPublicKey`.
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        /// Sends the request and returns the response.
        ///
        /// If an error occurs, an `SdkError` will be returned with additional details that
        /// can be matched against.
        ///
        /// By default, any retryable failures will be retried twice. Retry behavior
        /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
        /// set when configuring the client.
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteSshPublicKeyOutput,
            aws_smithy_http::result::SdkError<crate::error::DeleteSshPublicKeyError>,
        >
        where
            R::Policy: aws_smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteSshPublicKeyInputOperationOutputAlias,
                crate::output::DeleteSshPublicKeyOutput,
                crate::error::DeleteSshPublicKeyError,
                crate::input::DeleteSshPublicKeyInputOperationRetryAlias,
            >,
        {
            let input = self.inner.build().map_err(|err| {
                aws_smithy_http::result::SdkError::ConstructionFailure(err.into())
            })?;
            let op = input
                .make_operation(&self.handle.conf)
                .await
                .map_err(|err| {
                    aws_smithy_http::result::SdkError::ConstructionFailure(err.into())
                })?;
            self.handle.client.call(op).await
        }
        /// <p>A system-assigned unique identifier for a file transfer protocol-enabled server instance
        /// that has the user assigned to it.</p>
        pub fn server_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.server_id(inp);
            self
        }
        /// <p>A system-assigned unique identifier for a file transfer protocol-enabled server instance
        /// that has the user assigned to it.</p>
        pub fn set_server_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_server_id(input);
            self
        }
        /// <p>A unique identifier used to reference your user's specific SSH key.</p>
        pub fn ssh_public_key_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ssh_public_key_id(inp);
            self
        }
        /// <p>A unique identifier used to reference your user's specific SSH key.</p>
        pub fn set_ssh_public_key_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_ssh_public_key_id(input);
            self
        }
        /// <p>A unique string that identifies a user whose public key is being deleted.</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_name(inp);
            self
        }
        /// <p>A unique string that identifies a user whose public key is being deleted.</p>
        pub fn set_user_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_user_name(input);
            self
        }
    }
    /// Fluent builder constructing a request to `DeleteUser`.
    ///
    /// <p>Deletes the user belonging to a file transfer protocol-enabled server you specify.</p>
    ///
    /// <p>No response returns from this operation.</p>
    ///
    /// <note>
    /// <p>When you delete a user from a server, the user's information is lost.</p>
    /// </note>
    #[derive(std::fmt::Debug)]
    pub struct DeleteUser<
        C = aws_smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = aws_smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_user_input::Builder,
    }
    impl<C, M, R> DeleteUser<C, M, R>
    where
        C: aws_smithy_client::bounds::SmithyConnector,
        M: aws_smithy_client::bounds::SmithyMiddleware<C>,
        R: aws_smithy_client::retry::NewRequestPolicy,
    {
        /// Creates a new `DeleteUser`.
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        /// Sends the request and returns the response.
        ///
        /// If an error occurs, an `SdkError` will be returned with additional details that
        /// can be matched against.
        ///
        /// By default, any retryable failures will be retried twice. Retry behavior
        /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
        /// set when configuring the client.
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteUserOutput,
            aws_smithy_http::result::SdkError<crate::error::DeleteUserError>,
        >
        where
            R::Policy: aws_smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteUserInputOperationOutputAlias,
                crate::output::DeleteUserOutput,
                crate::error::DeleteUserError,
                crate::input::DeleteUserInputOperationRetryAlias,
            >,
        {
            let input = self.inner.build().map_err(|err| {
                aws_smithy_http::result::SdkError::ConstructionFailure(err.into())
            })?;
            let op = input
                .make_operation(&self.handle.conf)
                .await
                .map_err(|err| {
                    aws_smithy_http::result::SdkError::ConstructionFailure(err.into())
                })?;
            self.handle.client.call(op).await
        }
        /// <p>A system-assigned unique identifier for a server instance that has the user assigned to
        /// it.</p>
        pub fn server_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.server_id(inp);
            self
        }
        /// <p>A system-assigned unique identifier for a server instance that has the user assigned to
        /// it.</p>
        pub fn set_server_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_server_id(input);
            self
        }
        /// <p>A unique string that identifies a user that is being deleted from a server.</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_name(inp);
            self
        }
        /// <p>A unique string that identifies a user that is being deleted from a server.</p>
        pub fn set_user_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_user_name(input);
            self
        }
    }
    /// Fluent builder constructing a request to `DeleteWorkflow`.
    ///
    /// <p>Deletes the specified workflow.</p>
    #[derive(std::fmt::Debug)]
    pub struct DeleteWorkflow<
        C = aws_smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = aws_smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_workflow_input::Builder,
    }
    impl<C, M, R> DeleteWorkflow<C, M, R>
    where
        C: aws_smithy_client::bounds::SmithyConnector,
        M: aws_smithy_client::bounds::SmithyMiddleware<C>,
        R: aws_smithy_client::retry::NewRequestPolicy,
    {
        /// Creates a new `DeleteWorkflow`.
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        /// Sends the request and returns the response.
        ///
        /// If an error occurs, an `SdkError` will be returned with additional details that
        /// can be matched against.
        ///
        /// By default, any retryable failures will be retried twice. Retry behavior
        /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
        /// set when configuring the client.
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteWorkflowOutput,
            aws_smithy_http::result::SdkError<crate::error::DeleteWorkflowError>,
        >
        where
            R::Policy: aws_smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteWorkflowInputOperationOutputAlias,
                crate::output::DeleteWorkflowOutput,
                crate::error::DeleteWorkflowError,
                crate::input::DeleteWorkflowInputOperationRetryAlias,
            >,
        {
            let input = self.inner.build().map_err(|err| {
                aws_smithy_http::result::SdkError::ConstructionFailure(err.into())
            })?;
            let op = input
                .make_operation(&self.handle.conf)
                .await
                .map_err(|err| {
                    aws_smithy_http::result::SdkError::ConstructionFailure(err.into())
                })?;
            self.handle.client.call(op).await
        }
        /// <p>A unique identifier for the workflow.</p>
        pub fn workflow_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.workflow_id(inp);
            self
        }
        /// <p>A unique identifier for the workflow.</p>
        pub fn set_workflow_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_workflow_id(input);
            self
        }
    }
    /// Fluent builder constructing a request to `DescribeAccess`.
    ///
    /// <p>Describes the access that is assigned to the specific file transfer protocol-enabled
    /// server, as identified by its <code>ServerId</code> property and its
    /// <code>ExternalID</code>.</p>
    ///
    /// <p>The response from this call returns the properties of the access that is associated with
    /// the <code>ServerId</code> value that was specified.</p>
    #[derive(std::fmt::Debug)]
    pub struct DescribeAccess<
        C = aws_smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = aws_smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_access_input::Builder,
    }
    impl<C, M, R> DescribeAccess<C, M, R>
    where
        C: aws_smithy_client::bounds::SmithyConnector,
        M: aws_smithy_client::bounds::SmithyMiddleware<C>,
        R: aws_smithy_client::retry::NewRequestPolicy,
    {
        /// Creates a new `DescribeAccess`.
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        /// Sends the request and returns the response.
        ///
        /// If an error occurs, an `SdkError` will be returned with additional details that
        /// can be matched against.
        ///
        /// By default, any retryable failures will be retried twice. Retry behavior
        /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
        /// set when configuring the client.
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeAccessOutput,
            aws_smithy_http::result::SdkError<crate::error::DescribeAccessError>,
        >
        where
            R::Policy: aws_smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeAccessInputOperationOutputAlias,
                crate::output::DescribeAccessOutput,
                crate::error::DescribeAccessError,
                crate::input::DescribeAccessInputOperationRetryAlias,
            >,
        {
            let input = self.inner.build().map_err(|err| {
                aws_smithy_http::result::SdkError::ConstructionFailure(err.into())
            })?;
            let op = input
                .make_operation(&self.handle.conf)
                .await
                .map_err(|err| {
                    aws_smithy_http::result::SdkError::ConstructionFailure(err.into())
                })?;
            self.handle.client.call(op).await
        }
        /// <p>A system-assigned unique identifier for a server that has this access assigned.</p>
        pub fn server_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.server_id(inp);
            self
        }
        /// <p>A system-assigned unique identifier for a server that has this access assigned.</p>
        pub fn set_server_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_server_id(input);
            self
        }
        /// <p>A unique identifier that is required to identify specific groups within your directory.
        /// The users of the group that you associate have access to your Amazon S3 or Amazon EFS
        /// resources over the enabled protocols using Amazon Web Services Transfer Family. If you know the group name,
        /// you can view the SID values by running the following command using Windows PowerShell.</p>
        ///
        /// <p>
        /// <code>Get-ADGroup -Filter {samAccountName -like "<i>YourGroupName</i>*"} -Properties * | Select SamAccountName,ObjectSid</code>
        /// </p>
        ///
        /// <p>In that command, replace <i>YourGroupName</i> with the name of your Active Directory group.</p>
        ///
        /// <p>The regex used to validate this parameter is a string of characters consisting of uppercase and lowercase alphanumeric characters with no spaces.
        /// You can also include underscores or any of the following characters: =,.@:/-</p>
        pub fn external_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.external_id(inp);
            self
        }
        /// <p>A unique identifier that is required to identify specific groups within your directory.
        /// The users of the group that you associate have access to your Amazon S3 or Amazon EFS
        /// resources over the enabled protocols using Amazon Web Services Transfer Family. If you know the group name,
        /// you can view the SID values by running the following command using Windows PowerShell.</p>
        ///
        /// <p>
        /// <code>Get-ADGroup -Filter {samAccountName -like "<i>YourGroupName</i>*"} -Properties * | Select SamAccountName,ObjectSid</code>
        /// </p>
        ///
        /// <p>In that command, replace <i>YourGroupName</i> with the name of your Active Directory group.</p>
        ///
        /// <p>The regex used to validate this parameter is a string of characters consisting of uppercase and lowercase alphanumeric characters with no spaces.
        /// You can also include underscores or any of the following characters: =,.@:/-</p>
        pub fn set_external_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_external_id(input);
            self
        }
    }
    /// Fluent builder constructing a request to `DescribeExecution`.
    ///
    /// <p>You can use <code>DescribeExecution</code> to check the details of the execution of the specified workflow.</p>
    #[derive(std::fmt::Debug)]
    pub struct DescribeExecution<
        C = aws_smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = aws_smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_execution_input::Builder,
    }
    impl<C, M, R> DescribeExecution<C, M, R>
    where
        C: aws_smithy_client::bounds::SmithyConnector,
        M: aws_smithy_client::bounds::SmithyMiddleware<C>,
        R: aws_smithy_client::retry::NewRequestPolicy,
    {
        /// Creates a new `DescribeExecution`.
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        /// Sends the request and returns the response.
        ///
        /// If an error occurs, an `SdkError` will be returned with additional details that
        /// can be matched against.
        ///
        /// By default, any retryable failures will be retried twice. Retry behavior
        /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
        /// set when configuring the client.
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeExecutionOutput,
            aws_smithy_http::result::SdkError<crate::error::DescribeExecutionError>,
        >
        where
            R::Policy: aws_smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeExecutionInputOperationOutputAlias,
                crate::output::DescribeExecutionOutput,
                crate::error::DescribeExecutionError,
                crate::input::DescribeExecutionInputOperationRetryAlias,
            >,
        {
            let input = self.inner.build().map_err(|err| {
                aws_smithy_http::result::SdkError::ConstructionFailure(err.into())
            })?;
            let op = input
                .make_operation(&self.handle.conf)
                .await
                .map_err(|err| {
                    aws_smithy_http::result::SdkError::ConstructionFailure(err.into())
                })?;
            self.handle.client.call(op).await
        }
        /// <p>A unique identifier for the execution of a workflow.</p>
        pub fn execution_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.execution_id(inp);
            self
        }
        /// <p>A unique identifier for the execution of a workflow.</p>
        pub fn set_execution_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_execution_id(input);
            self
        }
        /// <p>A unique identifier for the workflow.</p>
        pub fn workflow_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.workflow_id(inp);
            self
        }
        /// <p>A unique identifier for the workflow.</p>
        pub fn set_workflow_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_workflow_id(input);
            self
        }
    }
    /// Fluent builder constructing a request to `DescribeSecurityPolicy`.
    ///
    /// <p>Describes the security policy that is attached to your file transfer protocol-enabled
    /// server. The response contains a description of the security policy's properties. For more
    /// information about security policies, see <a href="https://docs.aws.amazon.com/transfer/latest/userguide/security-policies.html">Working with security
    /// policies</a>.</p>
    #[derive(std::fmt::Debug)]
    pub struct DescribeSecurityPolicy<
        C = aws_smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = aws_smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_security_policy_input::Builder,
    }
    impl<C, M, R> DescribeSecurityPolicy<C, M, R>
    where
        C: aws_smithy_client::bounds::SmithyConnector,
        M: aws_smithy_client::bounds::SmithyMiddleware<C>,
        R: aws_smithy_client::retry::NewRequestPolicy,
    {
        /// Creates a new `DescribeSecurityPolicy`.
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        /// Sends the request and returns the response.
        ///
        /// If an error occurs, an `SdkError` will be returned with additional details that
        /// can be matched against.
        ///
        /// By default, any retryable failures will be retried twice. Retry behavior
        /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
        /// set when configuring the client.
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeSecurityPolicyOutput,
            aws_smithy_http::result::SdkError<crate::error::DescribeSecurityPolicyError>,
        >
        where
            R::Policy: aws_smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeSecurityPolicyInputOperationOutputAlias,
                crate::output::DescribeSecurityPolicyOutput,
                crate::error::DescribeSecurityPolicyError,
                crate::input::DescribeSecurityPolicyInputOperationRetryAlias,
            >,
        {
            let input = self.inner.build().map_err(|err| {
                aws_smithy_http::result::SdkError::ConstructionFailure(err.into())
            })?;
            let op = input
                .make_operation(&self.handle.conf)
                .await
                .map_err(|err| {
                    aws_smithy_http::result::SdkError::ConstructionFailure(err.into())
                })?;
            self.handle.client.call(op).await
        }
        /// <p>Specifies the name of the security policy that is attached to the server.</p>
        pub fn security_policy_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.security_policy_name(inp);
            self
        }
        /// <p>Specifies the name of the security policy that is attached to the server.</p>
        pub fn set_security_policy_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_security_policy_name(input);
            self
        }
    }
    /// Fluent builder constructing a request to `DescribeServer`.
    ///
    /// <p>Describes a file transfer protocol-enabled server that you specify by passing the
    /// <code>ServerId</code> parameter.</p>
    ///
    /// <p>The response contains a description of a server's properties. When you set
    /// <code>EndpointType</code> to VPC, the response will contain the
    /// <code>EndpointDetails</code>.</p>
    #[derive(std::fmt::Debug)]
    pub struct DescribeServer<
        C = aws_smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = aws_smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_server_input::Builder,
    }
    impl<C, M, R> DescribeServer<C, M, R>
    where
        C: aws_smithy_client::bounds::SmithyConnector,
        M: aws_smithy_client::bounds::SmithyMiddleware<C>,
        R: aws_smithy_client::retry::NewRequestPolicy,
    {
        /// Creates a new `DescribeServer`.
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        /// Sends the request and returns the response.
        ///
        /// If an error occurs, an `SdkError` will be returned with additional details that
        /// can be matched against.
        ///
        /// By default, any retryable failures will be retried twice. Retry behavior
        /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
        /// set when configuring the client.
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeServerOutput,
            aws_smithy_http::result::SdkError<crate::error::DescribeServerError>,
        >
        where
            R::Policy: aws_smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeServerInputOperationOutputAlias,
                crate::output::DescribeServerOutput,
                crate::error::DescribeServerError,
                crate::input::DescribeServerInputOperationRetryAlias,
            >,
        {
            let input = self.inner.build().map_err(|err| {
                aws_smithy_http::result::SdkError::ConstructionFailure(err.into())
            })?;
            let op = input
                .make_operation(&self.handle.conf)
                .await
                .map_err(|err| {
                    aws_smithy_http::result::SdkError::ConstructionFailure(err.into())
                })?;
            self.handle.client.call(op).await
        }
        /// <p>A system-assigned unique identifier for a server.</p>
        pub fn server_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.server_id(inp);
            self
        }
        /// <p>A system-assigned unique identifier for a server.</p>
        pub fn set_server_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_server_id(input);
            self
        }
    }
    /// Fluent builder constructing a request to `DescribeUser`.
    ///
    /// <p>Describes the user assigned to the specific file transfer protocol-enabled server, as
    /// identified by its <code>ServerId</code> property.</p>
    ///
    /// <p>The response from this call returns the properties of the user associated with the
    /// <code>ServerId</code> value that was specified.</p>
    #[derive(std::fmt::Debug)]
    pub struct DescribeUser<
        C = aws_smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = aws_smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_user_input::Builder,
    }
    impl<C, M, R> DescribeUser<C, M, R>
    where
        C: aws_smithy_client::bounds::SmithyConnector,
        M: aws_smithy_client::bounds::SmithyMiddleware<C>,
        R: aws_smithy_client::retry::NewRequestPolicy,
    {
        /// Creates a new `DescribeUser`.
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        /// Sends the request and returns the response.
        ///
        /// If an error occurs, an `SdkError` will be returned with additional details that
        /// can be matched against.
        ///
        /// By default, any retryable failures will be retried twice. Retry behavior
        /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
        /// set when configuring the client.
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeUserOutput,
            aws_smithy_http::result::SdkError<crate::error::DescribeUserError>,
        >
        where
            R::Policy: aws_smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeUserInputOperationOutputAlias,
                crate::output::DescribeUserOutput,
                crate::error::DescribeUserError,
                crate::input::DescribeUserInputOperationRetryAlias,
            >,
        {
            let input = self.inner.build().map_err(|err| {
                aws_smithy_http::result::SdkError::ConstructionFailure(err.into())
            })?;
            let op = input
                .make_operation(&self.handle.conf)
                .await
                .map_err(|err| {
                    aws_smithy_http::result::SdkError::ConstructionFailure(err.into())
                })?;
            self.handle.client.call(op).await
        }
        /// <p>A system-assigned unique identifier for a server that has this user assigned.</p>
        pub fn server_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.server_id(inp);
            self
        }
        /// <p>A system-assigned unique identifier for a server that has this user assigned.</p>
        pub fn set_server_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_server_id(input);
            self
        }
        /// <p>The name of the user assigned to one or more servers. User names are part of the sign-in
        /// credentials to use the Amazon Web Services Transfer Family service and perform file transfer tasks.</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_name(inp);
            self
        }
        /// <p>The name of the user assigned to one or more servers. User names are part of the sign-in
        /// credentials to use the Amazon Web Services Transfer Family service and perform file transfer tasks.</p>
        pub fn set_user_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_user_name(input);
            self
        }
    }
    /// Fluent builder constructing a request to `DescribeWorkflow`.
    ///
    /// <p>Describes the specified workflow.</p>
    #[derive(std::fmt::Debug)]
    pub struct DescribeWorkflow<
        C = aws_smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = aws_smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_workflow_input::Builder,
    }
    impl<C, M, R> DescribeWorkflow<C, M, R>
    where
        C: aws_smithy_client::bounds::SmithyConnector,
        M: aws_smithy_client::bounds::SmithyMiddleware<C>,
        R: aws_smithy_client::retry::NewRequestPolicy,
    {
        /// Creates a new `DescribeWorkflow`.
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        /// Sends the request and returns the response.
        ///
        /// If an error occurs, an `SdkError` will be returned with additional details that
        /// can be matched against.
        ///
        /// By default, any retryable failures will be retried twice. Retry behavior
        /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
        /// set when configuring the client.
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeWorkflowOutput,
            aws_smithy_http::result::SdkError<crate::error::DescribeWorkflowError>,
        >
        where
            R::Policy: aws_smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeWorkflowInputOperationOutputAlias,
                crate::output::DescribeWorkflowOutput,
                crate::error::DescribeWorkflowError,
                crate::input::DescribeWorkflowInputOperationRetryAlias,
            >,
        {
            let input = self.inner.build().map_err(|err| {
                aws_smithy_http::result::SdkError::ConstructionFailure(err.into())
            })?;
            let op = input
                .make_operation(&self.handle.conf)
                .await
                .map_err(|err| {
                    aws_smithy_http::result::SdkError::ConstructionFailure(err.into())
                })?;
            self.handle.client.call(op).await
        }
        /// <p>A unique identifier for the workflow.</p>
        pub fn workflow_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.workflow_id(inp);
            self
        }
        /// <p>A unique identifier for the workflow.</p>
        pub fn set_workflow_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_workflow_id(input);
            self
        }
    }
    /// Fluent builder constructing a request to `ImportSshPublicKey`.
    ///
    /// <p>Adds a Secure Shell (SSH) public key to a user account identified by a
    /// <code>UserName</code> value assigned to the specific file transfer protocol-enabled server,
    /// identified by <code>ServerId</code>.</p>
    ///
    /// <p>The response returns the <code>UserName</code> value, the <code>ServerId</code> value, and
    /// the name of the <code>SshPublicKeyId</code>.</p>
    #[derive(std::fmt::Debug)]
    pub struct ImportSshPublicKey<
        C = aws_smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = aws_smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::import_ssh_public_key_input::Builder,
    }
    impl<C, M, R> ImportSshPublicKey<C, M, R>
    where
        C: aws_smithy_client::bounds::SmithyConnector,
        M: aws_smithy_client::bounds::SmithyMiddleware<C>,
        R: aws_smithy_client::retry::NewRequestPolicy,
    {
        /// Creates a new `ImportSshPublicKey`.
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        /// Sends the request and returns the response.
        ///
        /// If an error occurs, an `SdkError` will be returned with additional details that
        /// can be matched against.
        ///
        /// By default, any retryable failures will be retried twice. Retry behavior
        /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
        /// set when configuring the client.
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ImportSshPublicKeyOutput,
            aws_smithy_http::result::SdkError<crate::error::ImportSshPublicKeyError>,
        >
        where
            R::Policy: aws_smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ImportSshPublicKeyInputOperationOutputAlias,
                crate::output::ImportSshPublicKeyOutput,
                crate::error::ImportSshPublicKeyError,
                crate::input::ImportSshPublicKeyInputOperationRetryAlias,
            >,
        {
            let input = self.inner.build().map_err(|err| {
                aws_smithy_http::result::SdkError::ConstructionFailure(err.into())
            })?;
            let op = input
                .make_operation(&self.handle.conf)
                .await
                .map_err(|err| {
                    aws_smithy_http::result::SdkError::ConstructionFailure(err.into())
                })?;
            self.handle.client.call(op).await
        }
        /// <p>A system-assigned unique identifier for a server.</p>
        pub fn server_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.server_id(inp);
            self
        }
        /// <p>A system-assigned unique identifier for a server.</p>
        pub fn set_server_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_server_id(input);
            self
        }
        /// <p>The public key portion of an SSH key pair.</p>
        pub fn ssh_public_key_body(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ssh_public_key_body(inp);
            self
        }
        /// <p>The public key portion of an SSH key pair.</p>
        pub fn set_ssh_public_key_body(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_ssh_public_key_body(input);
            self
        }
        /// <p>The name of the user account that is assigned to one or more servers.</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_name(inp);
            self
        }
        /// <p>The name of the user account that is assigned to one or more servers.</p>
        pub fn set_user_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_user_name(input);
            self
        }
    }
    /// Fluent builder constructing a request to `ListAccesses`.
    ///
    /// <p>Lists the details for all the accesses you have on your server.</p>
    #[derive(std::fmt::Debug)]
    pub struct ListAccesses<
        C = aws_smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = aws_smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_accesses_input::Builder,
    }
    impl<C, M, R> ListAccesses<C, M, R>
    where
        C: aws_smithy_client::bounds::SmithyConnector,
        M: aws_smithy_client::bounds::SmithyMiddleware<C>,
        R: aws_smithy_client::retry::NewRequestPolicy,
    {
        /// Creates a new `ListAccesses`.
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        /// Sends the request and returns the response.
        ///
        /// If an error occurs, an `SdkError` will be returned with additional details that
        /// can be matched against.
        ///
        /// By default, any retryable failures will be retried twice. Retry behavior
        /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
        /// set when configuring the client.
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListAccessesOutput,
            aws_smithy_http::result::SdkError<crate::error::ListAccessesError>,
        >
        where
            R::Policy: aws_smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListAccessesInputOperationOutputAlias,
                crate::output::ListAccessesOutput,
                crate::error::ListAccessesError,
                crate::input::ListAccessesInputOperationRetryAlias,
            >,
        {
            let input = self.inner.build().map_err(|err| {
                aws_smithy_http::result::SdkError::ConstructionFailure(err.into())
            })?;
            let op = input
                .make_operation(&self.handle.conf)
                .await
                .map_err(|err| {
                    aws_smithy_http::result::SdkError::ConstructionFailure(err.into())
                })?;
            self.handle.client.call(op).await
        }
        /// <p>Specifies the maximum number of access SIDs to return.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        /// <p>Specifies the maximum number of access SIDs to return.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>When you can get additional results from the <code>ListAccesses</code> call, a
        /// <code>NextToken</code> parameter is returned in the output. You can then pass in a
        /// subsequent command to the <code>NextToken</code> parameter to continue listing additional
        /// accesses.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        /// <p>When you can get additional results from the <code>ListAccesses</code> call, a
        /// <code>NextToken</code> parameter is returned in the output. You can then pass in a
        /// subsequent command to the <code>NextToken</code> parameter to continue listing additional
        /// accesses.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>A system-assigned unique identifier for a server that has users assigned to it.</p>
        pub fn server_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.server_id(inp);
            self
        }
        /// <p>A system-assigned unique identifier for a server that has users assigned to it.</p>
        pub fn set_server_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_server_id(input);
            self
        }
    }
    /// Fluent builder constructing a request to `ListExecutions`.
    ///
    /// <p>Lists all executions for the specified workflow.</p>
    #[derive(std::fmt::Debug)]
    pub struct ListExecutions<
        C = aws_smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = aws_smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_executions_input::Builder,
    }
    impl<C, M, R> ListExecutions<C, M, R>
    where
        C: aws_smithy_client::bounds::SmithyConnector,
        M: aws_smithy_client::bounds::SmithyMiddleware<C>,
        R: aws_smithy_client::retry::NewRequestPolicy,
    {
        /// Creates a new `ListExecutions`.
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        /// Sends the request and returns the response.
        ///
        /// If an error occurs, an `SdkError` will be returned with additional details that
        /// can be matched against.
        ///
        /// By default, any retryable failures will be retried twice. Retry behavior
        /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
        /// set when configuring the client.
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListExecutionsOutput,
            aws_smithy_http::result::SdkError<crate::error::ListExecutionsError>,
        >
        where
            R::Policy: aws_smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListExecutionsInputOperationOutputAlias,
                crate::output::ListExecutionsOutput,
                crate::error::ListExecutionsError,
                crate::input::ListExecutionsInputOperationRetryAlias,
            >,
        {
            let input = self.inner.build().map_err(|err| {
                aws_smithy_http::result::SdkError::ConstructionFailure(err.into())
            })?;
            let op = input
                .make_operation(&self.handle.conf)
                .await
                .map_err(|err| {
                    aws_smithy_http::result::SdkError::ConstructionFailure(err.into())
                })?;
            self.handle.client.call(op).await
        }
        /// <p>Specifies the aximum number of executions to return.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        /// <p>Specifies the aximum number of executions to return.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>
        /// <code>ListExecutions</code> returns the <code>NextToken</code> parameter in the output.
        /// You can then pass the <code>NextToken</code> parameter in a subsequent command to
        /// continue listing additional executions.</p>
        /// <p>
        /// This is useful for pagination, for instance.
        /// If you have 100 executions for a workflow, you might only want to list first 10. If so, callthe API by specifing the <code>max-results</code>:
        /// </p>
        /// <p>
        /// <code>aws transfer list-executions --max-results 10</code>
        /// </p>
        /// <p>
        /// This returns details for the first 10 executions, as well as the pointer (<code>NextToken</code>) to the eleventh execution.
        /// You can now call the API again, suppling the <code>NextToken</code> value you received:
        /// </p>
        /// <p>
        /// <code>aws transfer list-executions --max-results 10 --next-token $somePointerReturnedFromPreviousListResult</code>
        /// </p>
        /// <p>
        /// This call returns the next 10 executions, the 11th through the 20th. You can then repeat the call until the details
        /// for all 100 executions have been returned.
        /// </p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        /// <p>
        /// <code>ListExecutions</code> returns the <code>NextToken</code> parameter in the output.
        /// You can then pass the <code>NextToken</code> parameter in a subsequent command to
        /// continue listing additional executions.</p>
        /// <p>
        /// This is useful for pagination, for instance.
        /// If you have 100 executions for a workflow, you might only want to list first 10. If so, callthe API by specifing the <code>max-results</code>:
        /// </p>
        /// <p>
        /// <code>aws transfer list-executions --max-results 10</code>
        /// </p>
        /// <p>
        /// This returns details for the first 10 executions, as well as the pointer (<code>NextToken</code>) to the eleventh execution.
        /// You can now call the API again, suppling the <code>NextToken</code> value you received:
        /// </p>
        /// <p>
        /// <code>aws transfer list-executions --max-results 10 --next-token $somePointerReturnedFromPreviousListResult</code>
        /// </p>
        /// <p>
        /// This call returns the next 10 executions, the 11th through the 20th. You can then repeat the call until the details
        /// for all 100 executions have been returned.
        /// </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>A unique identifier for the workflow.</p>
        pub fn workflow_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.workflow_id(inp);
            self
        }
        /// <p>A unique identifier for the workflow.</p>
        pub fn set_workflow_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_workflow_id(input);
            self
        }
    }
    /// Fluent builder constructing a request to `ListSecurityPolicies`.
    ///
    /// <p>Lists the security policies that are attached to your file transfer protocol-enabled
    /// servers.</p>
    #[derive(std::fmt::Debug)]
    pub struct ListSecurityPolicies<
        C = aws_smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = aws_smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_security_policies_input::Builder,
    }
    impl<C, M, R> ListSecurityPolicies<C, M, R>
    where
        C: aws_smithy_client::bounds::SmithyConnector,
        M: aws_smithy_client::bounds::SmithyMiddleware<C>,
        R: aws_smithy_client::retry::NewRequestPolicy,
    {
        /// Creates a new `ListSecurityPolicies`.
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        /// Sends the request and returns the response.
        ///
        /// If an error occurs, an `SdkError` will be returned with additional details that
        /// can be matched against.
        ///
        /// By default, any retryable failures will be retried twice. Retry behavior
        /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
        /// set when configuring the client.
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListSecurityPoliciesOutput,
            aws_smithy_http::result::SdkError<crate::error::ListSecurityPoliciesError>,
        >
        where
            R::Policy: aws_smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListSecurityPoliciesInputOperationOutputAlias,
                crate::output::ListSecurityPoliciesOutput,
                crate::error::ListSecurityPoliciesError,
                crate::input::ListSecurityPoliciesInputOperationRetryAlias,
            >,
        {
            let input = self.inner.build().map_err(|err| {
                aws_smithy_http::result::SdkError::ConstructionFailure(err.into())
            })?;
            let op = input
                .make_operation(&self.handle.conf)
                .await
                .map_err(|err| {
                    aws_smithy_http::result::SdkError::ConstructionFailure(err.into())
                })?;
            self.handle.client.call(op).await
        }
        /// <p>Specifies the number of security policies to return as a response to the
        /// <code>ListSecurityPolicies</code> query.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        /// <p>Specifies the number of security policies to return as a response to the
        /// <code>ListSecurityPolicies</code> query.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>When additional results are obtained from the <code>ListSecurityPolicies</code> command, a
        /// <code>NextToken</code> parameter is returned in the output. You can then pass the
        /// <code>NextToken</code> parameter in a subsequent command to continue listing additional
        /// security policies.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        /// <p>When additional results are obtained from the <code>ListSecurityPolicies</code> command, a
        /// <code>NextToken</code> parameter is returned in the output. You can then pass the
        /// <code>NextToken</code> parameter in a subsequent command to continue listing additional
        /// security policies.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    /// Fluent builder constructing a request to `ListServers`.
    ///
    /// <p>Lists the file transfer protocol-enabled servers that are associated with your Amazon Web Services
    /// account.</p>
    #[derive(std::fmt::Debug)]
    pub struct ListServers<
        C = aws_smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = aws_smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_servers_input::Builder,
    }
    impl<C, M, R> ListServers<C, M, R>
    where
        C: aws_smithy_client::bounds::SmithyConnector,
        M: aws_smithy_client::bounds::SmithyMiddleware<C>,
        R: aws_smithy_client::retry::NewRequestPolicy,
    {
        /// Creates a new `ListServers`.
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        /// Sends the request and returns the response.
        ///
        /// If an error occurs, an `SdkError` will be returned with additional details that
        /// can be matched against.
        ///
        /// By default, any retryable failures will be retried twice. Retry behavior
        /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
        /// set when configuring the client.
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListServersOutput,
            aws_smithy_http::result::SdkError<crate::error::ListServersError>,
        >
        where
            R::Policy: aws_smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListServersInputOperationOutputAlias,
                crate::output::ListServersOutput,
                crate::error::ListServersError,
                crate::input::ListServersInputOperationRetryAlias,
            >,
        {
            let input = self.inner.build().map_err(|err| {
                aws_smithy_http::result::SdkError::ConstructionFailure(err.into())
            })?;
            let op = input
                .make_operation(&self.handle.conf)
                .await
                .map_err(|err| {
                    aws_smithy_http::result::SdkError::ConstructionFailure(err.into())
                })?;
            self.handle.client.call(op).await
        }
        /// <p>Specifies the number of servers to return as a response to the <code>ListServers</code>
        /// query.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        /// <p>Specifies the number of servers to return as a response to the <code>ListServers</code>
        /// query.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>When additional results are obtained from the <code>ListServers</code> command, a
        /// <code>NextToken</code> parameter is returned in the output. You can then pass the
        /// <code>NextToken</code> parameter in a subsequent command to continue listing additional
        /// servers.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        /// <p>When additional results are obtained from the <code>ListServers</code> command, a
        /// <code>NextToken</code> parameter is returned in the output. You can then pass the
        /// <code>NextToken</code> parameter in a subsequent command to continue listing additional
        /// servers.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    /// Fluent builder constructing a request to `ListTagsForResource`.
    ///
    /// <p>Lists all of the tags associated with the Amazon Resource Name (ARN) that you specify. The
    /// resource can be a user, server, or role.</p>
    #[derive(std::fmt::Debug)]
    pub struct ListTagsForResource<
        C = aws_smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = aws_smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_tags_for_resource_input::Builder,
    }
    impl<C, M, R> ListTagsForResource<C, M, R>
    where
        C: aws_smithy_client::bounds::SmithyConnector,
        M: aws_smithy_client::bounds::SmithyMiddleware<C>,
        R: aws_smithy_client::retry::NewRequestPolicy,
    {
        /// Creates a new `ListTagsForResource`.
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        /// Sends the request and returns the response.
        ///
        /// If an error occurs, an `SdkError` will be returned with additional details that
        /// can be matched against.
        ///
        /// By default, any retryable failures will be retried twice. Retry behavior
        /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
        /// set when configuring the client.
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTagsForResourceOutput,
            aws_smithy_http::result::SdkError<crate::error::ListTagsForResourceError>,
        >
        where
            R::Policy: aws_smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListTagsForResourceInputOperationOutputAlias,
                crate::output::ListTagsForResourceOutput,
                crate::error::ListTagsForResourceError,
                crate::input::ListTagsForResourceInputOperationRetryAlias,
            >,
        {
            let input = self.inner.build().map_err(|err| {
                aws_smithy_http::result::SdkError::ConstructionFailure(err.into())
            })?;
            let op = input
                .make_operation(&self.handle.conf)
                .await
                .map_err(|err| {
                    aws_smithy_http::result::SdkError::ConstructionFailure(err.into())
                })?;
            self.handle.client.call(op).await
        }
        /// <p>Requests the tags associated with a particular Amazon Resource Name (ARN). An ARN is an
        /// identifier for a specific Amazon Web Services resource, such as a server, user, or role.</p>
        pub fn arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(inp);
            self
        }
        /// <p>Requests the tags associated with a particular Amazon Resource Name (ARN). An ARN is an
        /// identifier for a specific Amazon Web Services resource, such as a server, user, or role.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
        /// <p>Specifies the number of tags to return as a response to the
        /// <code>ListTagsForResource</code> request.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        /// <p>Specifies the number of tags to return as a response to the
        /// <code>ListTagsForResource</code> request.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>When you request additional results from the <code>ListTagsForResource</code> operation, a
        /// <code>NextToken</code> parameter is returned in the input. You can then pass in a subsequent
        /// command to the <code>NextToken</code> parameter to continue listing additional tags.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        /// <p>When you request additional results from the <code>ListTagsForResource</code> operation, a
        /// <code>NextToken</code> parameter is returned in the input. You can then pass in a subsequent
        /// command to the <code>NextToken</code> parameter to continue listing additional tags.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    /// Fluent builder constructing a request to `ListUsers`.
    ///
    /// <p>Lists the users for a file transfer protocol-enabled server that you specify by passing
    /// the <code>ServerId</code> parameter.</p>
    #[derive(std::fmt::Debug)]
    pub struct ListUsers<
        C = aws_smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = aws_smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_users_input::Builder,
    }
    impl<C, M, R> ListUsers<C, M, R>
    where
        C: aws_smithy_client::bounds::SmithyConnector,
        M: aws_smithy_client::bounds::SmithyMiddleware<C>,
        R: aws_smithy_client::retry::NewRequestPolicy,
    {
        /// Creates a new `ListUsers`.
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        /// Sends the request and returns the response.
        ///
        /// If an error occurs, an `SdkError` will be returned with additional details that
        /// can be matched against.
        ///
        /// By default, any retryable failures will be retried twice. Retry behavior
        /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
        /// set when configuring the client.
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListUsersOutput,
            aws_smithy_http::result::SdkError<crate::error::ListUsersError>,
        >
        where
            R::Policy: aws_smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListUsersInputOperationOutputAlias,
                crate::output::ListUsersOutput,
                crate::error::ListUsersError,
                crate::input::ListUsersInputOperationRetryAlias,
            >,
        {
            let input = self.inner.build().map_err(|err| {
                aws_smithy_http::result::SdkError::ConstructionFailure(err.into())
            })?;
            let op = input
                .make_operation(&self.handle.conf)
                .await
                .map_err(|err| {
                    aws_smithy_http::result::SdkError::ConstructionFailure(err.into())
                })?;
            self.handle.client.call(op).await
        }
        /// <p>Specifies the number of users to return as a response to the <code>ListUsers</code>
        /// request.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        /// <p>Specifies the number of users to return as a response to the <code>ListUsers</code>
        /// request.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>When you can get additional results from the <code>ListUsers</code> call, a
        /// <code>NextToken</code> parameter is returned in the output. You can then pass in a
        /// subsequent command to the <code>NextToken</code> parameter to continue listing additional
        /// users.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        /// <p>When you can get additional results from the <code>ListUsers</code> call, a
        /// <code>NextToken</code> parameter is returned in the output. You can then pass in a
        /// subsequent command to the <code>NextToken</code> parameter to continue listing additional
        /// users.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>A system-assigned unique identifier for a server that has users assigned to it.</p>
        pub fn server_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.server_id(inp);
            self
        }
        /// <p>A system-assigned unique identifier for a server that has users assigned to it.</p>
        pub fn set_server_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_server_id(input);
            self
        }
    }
    /// Fluent builder constructing a request to `ListWorkflows`.
    ///
    /// <p>Lists all of your workflows.</p>
    #[derive(std::fmt::Debug)]
    pub struct ListWorkflows<
        C = aws_smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = aws_smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_workflows_input::Builder,
    }
    impl<C, M, R> ListWorkflows<C, M, R>
    where
        C: aws_smithy_client::bounds::SmithyConnector,
        M: aws_smithy_client::bounds::SmithyMiddleware<C>,
        R: aws_smithy_client::retry::NewRequestPolicy,
    {
        /// Creates a new `ListWorkflows`.
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        /// Sends the request and returns the response.
        ///
        /// If an error occurs, an `SdkError` will be returned with additional details that
        /// can be matched against.
        ///
        /// By default, any retryable failures will be retried twice. Retry behavior
        /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
        /// set when configuring the client.
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListWorkflowsOutput,
            aws_smithy_http::result::SdkError<crate::error::ListWorkflowsError>,
        >
        where
            R::Policy: aws_smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListWorkflowsInputOperationOutputAlias,
                crate::output::ListWorkflowsOutput,
                crate::error::ListWorkflowsError,
                crate::input::ListWorkflowsInputOperationRetryAlias,
            >,
        {
            let input = self.inner.build().map_err(|err| {
                aws_smithy_http::result::SdkError::ConstructionFailure(err.into())
            })?;
            let op = input
                .make_operation(&self.handle.conf)
                .await
                .map_err(|err| {
                    aws_smithy_http::result::SdkError::ConstructionFailure(err.into())
                })?;
            self.handle.client.call(op).await
        }
        /// <p>Specifies the maximum number of workflows to return.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        /// <p>Specifies the maximum number of workflows to return.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>
        /// <code>ListWorkflows</code> returns the <code>NextToken</code> parameter in the output.
        /// You can then pass the <code>NextToken</code> parameter in a subsequent command to
        /// continue listing additional workflows.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        /// <p>
        /// <code>ListWorkflows</code> returns the <code>NextToken</code> parameter in the output.
        /// You can then pass the <code>NextToken</code> parameter in a subsequent command to
        /// continue listing additional workflows.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    /// Fluent builder constructing a request to `SendWorkflowStepState`.
    ///
    /// <p>Sends a callback for asynchronous custom steps.</p>
    /// <p>
    /// The <code>ExecutionId</code>, <code>WorkflowId</code>, and <code>Token</code> are passed to the target resource during execution of a custom step of a workflow.
    /// You must include those with their callback as well as providing a status.
    /// </p>
    #[derive(std::fmt::Debug)]
    pub struct SendWorkflowStepState<
        C = aws_smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = aws_smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::send_workflow_step_state_input::Builder,
    }
    impl<C, M, R> SendWorkflowStepState<C, M, R>
    where
        C: aws_smithy_client::bounds::SmithyConnector,
        M: aws_smithy_client::bounds::SmithyMiddleware<C>,
        R: aws_smithy_client::retry::NewRequestPolicy,
    {
        /// Creates a new `SendWorkflowStepState`.
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        /// Sends the request and returns the response.
        ///
        /// If an error occurs, an `SdkError` will be returned with additional details that
        /// can be matched against.
        ///
        /// By default, any retryable failures will be retried twice. Retry behavior
        /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
        /// set when configuring the client.
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::SendWorkflowStepStateOutput,
            aws_smithy_http::result::SdkError<crate::error::SendWorkflowStepStateError>,
        >
        where
            R::Policy: aws_smithy_client::bounds::SmithyRetryPolicy<
                crate::input::SendWorkflowStepStateInputOperationOutputAlias,
                crate::output::SendWorkflowStepStateOutput,
                crate::error::SendWorkflowStepStateError,
                crate::input::SendWorkflowStepStateInputOperationRetryAlias,
            >,
        {
            let input = self.inner.build().map_err(|err| {
                aws_smithy_http::result::SdkError::ConstructionFailure(err.into())
            })?;
            let op = input
                .make_operation(&self.handle.conf)
                .await
                .map_err(|err| {
                    aws_smithy_http::result::SdkError::ConstructionFailure(err.into())
                })?;
            self.handle.client.call(op).await
        }
        /// <p>A unique identifier for the workflow.</p>
        pub fn workflow_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.workflow_id(inp);
            self
        }
        /// <p>A unique identifier for the workflow.</p>
        pub fn set_workflow_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_workflow_id(input);
            self
        }
        /// <p>A unique identifier for the execution of a workflow.</p>
        pub fn execution_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.execution_id(inp);
            self
        }
        /// <p>A unique identifier for the execution of a workflow.</p>
        pub fn set_execution_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_execution_id(input);
            self
        }
        /// <p>Used to distinguish between multiple callbacks for multiple Lambda steps within the same execution.</p>
        pub fn token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.token(inp);
            self
        }
        /// <p>Used to distinguish between multiple callbacks for multiple Lambda steps within the same execution.</p>
        pub fn set_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_token(input);
            self
        }
        /// <p>Indicates whether the specified step succeeded or failed.</p>
        pub fn status(mut self, inp: crate::model::CustomStepStatus) -> Self {
            self.inner = self.inner.status(inp);
            self
        }
        /// <p>Indicates whether the specified step succeeded or failed.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::CustomStepStatus>,
        ) -> Self {
            self.inner = self.inner.set_status(input);
            self
        }
    }
    /// Fluent builder constructing a request to `StartServer`.
    ///
    /// <p>Changes the state of a file transfer protocol-enabled server from <code>OFFLINE</code> to
    /// <code>ONLINE</code>. It has no impact on a server that is already <code>ONLINE</code>. An
    /// <code>ONLINE</code> server can accept and process file transfer jobs.</p>
    ///
    /// <p>The state of <code>STARTING</code> indicates that the server is in an intermediate state,
    /// either not fully able to respond, or not fully online. The values of <code>START_FAILED</code>
    /// can indicate an error condition.</p>
    ///
    /// <p>No response is returned from this call.</p>
    #[derive(std::fmt::Debug)]
    pub struct StartServer<
        C = aws_smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = aws_smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::start_server_input::Builder,
    }
    impl<C, M, R> StartServer<C, M, R>
    where
        C: aws_smithy_client::bounds::SmithyConnector,
        M: aws_smithy_client::bounds::SmithyMiddleware<C>,
        R: aws_smithy_client::retry::NewRequestPolicy,
    {
        /// Creates a new `StartServer`.
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        /// Sends the request and returns the response.
        ///
        /// If an error occurs, an `SdkError` will be returned with additional details that
        /// can be matched against.
        ///
        /// By default, any retryable failures will be retried twice. Retry behavior
        /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
        /// set when configuring the client.
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StartServerOutput,
            aws_smithy_http::result::SdkError<crate::error::StartServerError>,
        >
        where
            R::Policy: aws_smithy_client::bounds::SmithyRetryPolicy<
                crate::input::StartServerInputOperationOutputAlias,
                crate::output::StartServerOutput,
                crate::error::StartServerError,
                crate::input::StartServerInputOperationRetryAlias,
            >,
        {
            let input = self.inner.build().map_err(|err| {
                aws_smithy_http::result::SdkError::ConstructionFailure(err.into())
            })?;
            let op = input
                .make_operation(&self.handle.conf)
                .await
                .map_err(|err| {
                    aws_smithy_http::result::SdkError::ConstructionFailure(err.into())
                })?;
            self.handle.client.call(op).await
        }
        /// <p>A system-assigned unique identifier for a server that you start.</p>
        pub fn server_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.server_id(inp);
            self
        }
        /// <p>A system-assigned unique identifier for a server that you start.</p>
        pub fn set_server_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_server_id(input);
            self
        }
    }
    /// Fluent builder constructing a request to `StopServer`.
    ///
    /// <p>Changes the state of a file transfer protocol-enabled server from <code>ONLINE</code> to
    /// <code>OFFLINE</code>. An <code>OFFLINE</code> server cannot accept and process file transfer
    /// jobs. Information tied to your server, such as server and user properties, are not affected by
    /// stopping your server.</p>
    ///
    /// <note>
    /// <p>Stopping the server will not reduce or impact your file transfer protocol endpoint
    /// billing; you must delete the server to stop being billed.</p>
    /// </note>
    ///
    /// <p>The state of <code>STOPPING</code> indicates that the server is in an intermediate state,
    /// either not fully able to respond, or not fully offline. The values of <code>STOP_FAILED</code>
    /// can indicate an error condition.</p>
    ///
    /// <p>No response is returned from this call.</p>
    #[derive(std::fmt::Debug)]
    pub struct StopServer<
        C = aws_smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = aws_smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::stop_server_input::Builder,
    }
    impl<C, M, R> StopServer<C, M, R>
    where
        C: aws_smithy_client::bounds::SmithyConnector,
        M: aws_smithy_client::bounds::SmithyMiddleware<C>,
        R: aws_smithy_client::retry::NewRequestPolicy,
    {
        /// Creates a new `StopServer`.
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        /// Sends the request and returns the response.
        ///
        /// If an error occurs, an `SdkError` will be returned with additional details that
        /// can be matched against.
        ///
        /// By default, any retryable failures will be retried twice. Retry behavior
        /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
        /// set when configuring the client.
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StopServerOutput,
            aws_smithy_http::result::SdkError<crate::error::StopServerError>,
        >
        where
            R::Policy: aws_smithy_client::bounds::SmithyRetryPolicy<
                crate::input::StopServerInputOperationOutputAlias,
                crate::output::StopServerOutput,
                crate::error::StopServerError,
                crate::input::StopServerInputOperationRetryAlias,
            >,
        {
            let input = self.inner.build().map_err(|err| {
                aws_smithy_http::result::SdkError::ConstructionFailure(err.into())
            })?;
            let op = input
                .make_operation(&self.handle.conf)
                .await
                .map_err(|err| {
                    aws_smithy_http::result::SdkError::ConstructionFailure(err.into())
                })?;
            self.handle.client.call(op).await
        }
        /// <p>A system-assigned unique identifier for a server that you stopped.</p>
        pub fn server_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.server_id(inp);
            self
        }
        /// <p>A system-assigned unique identifier for a server that you stopped.</p>
        pub fn set_server_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_server_id(input);
            self
        }
    }
    /// Fluent builder constructing a request to `TagResource`.
    ///
    /// <p>Attaches a key-value pair to a resource, as identified by its Amazon Resource Name (ARN).
    /// Resources are users, servers, roles, and other entities.</p>
    ///
    /// <p>There is no response returned from this call.</p>
    #[derive(std::fmt::Debug)]
    pub struct TagResource<
        C = aws_smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = aws_smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::tag_resource_input::Builder,
    }
    impl<C, M, R> TagResource<C, M, R>
    where
        C: aws_smithy_client::bounds::SmithyConnector,
        M: aws_smithy_client::bounds::SmithyMiddleware<C>,
        R: aws_smithy_client::retry::NewRequestPolicy,
    {
        /// Creates a new `TagResource`.
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        /// Sends the request and returns the response.
        ///
        /// If an error occurs, an `SdkError` will be returned with additional details that
        /// can be matched against.
        ///
        /// By default, any retryable failures will be retried twice. Retry behavior
        /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
        /// set when configuring the client.
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::TagResourceOutput,
            aws_smithy_http::result::SdkError<crate::error::TagResourceError>,
        >
        where
            R::Policy: aws_smithy_client::bounds::SmithyRetryPolicy<
                crate::input::TagResourceInputOperationOutputAlias,
                crate::output::TagResourceOutput,
                crate::error::TagResourceError,
                crate::input::TagResourceInputOperationRetryAlias,
            >,
        {
            let input = self.inner.build().map_err(|err| {
                aws_smithy_http::result::SdkError::ConstructionFailure(err.into())
            })?;
            let op = input
                .make_operation(&self.handle.conf)
                .await
                .map_err(|err| {
                    aws_smithy_http::result::SdkError::ConstructionFailure(err.into())
                })?;
            self.handle.client.call(op).await
        }
        /// <p>An Amazon Resource Name (ARN) for a specific Amazon Web Services resource, such as a server, user, or
        /// role.</p>
        pub fn arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(inp);
            self
        }
        /// <p>An Amazon Resource Name (ARN) for a specific Amazon Web Services resource, such as a server, user, or
        /// role.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
        /// Appends an item to `Tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Key-value pairs assigned to ARNs that you can use to group and search for resources by
        /// type. You can attach this metadata to user accounts for any purpose.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        /// <p>Key-value pairs assigned to ARNs that you can use to group and search for resources by
        /// type. You can attach this metadata to user accounts for any purpose.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    /// Fluent builder constructing a request to `TestIdentityProvider`.
    ///
    /// <p>If the <code>IdentityProviderType</code> of a file transfer protocol-enabled server is
    /// <code>AWS_DIRECTORY_SERVICE</code> or <code>API_Gateway</code>, tests whether your identity
    /// provider is set up successfully. We highly recommend that you call this operation to test your
    /// authentication method as soon as you create your server. By doing so, you can troubleshoot
    /// issues with the identity provider integration to ensure that your users can successfully use
    /// the service.</p>
    /// <p>
    /// The <code>ServerId</code> and <code>UserName</code> parameters are required. The <code>ServerProtocol</code>, <code>SourceIp</code>, and <code>UserPassword</code> are all optional.
    /// </p>
    /// <note>
    /// <p>
    /// You cannot use <code>TestIdentityProvider</code> if the <code>IdentityProviderType</code> of your server is <code>SERVICE_MANAGED</code>.
    /// </p>
    /// </note>
    /// <ul>
    /// <li>
    /// <p>
    /// If you provide any incorrect values for any parameters, the <code>Response</code> field is empty.
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// If you provide a server ID for a server that uses service-managed users, you get an error:
    /// </p>
    /// <p>
    /// <code>
    /// An error occurred (InvalidRequestException) when calling the TestIdentityProvider operation: s-<i>server-ID</i> not configured for external auth
    /// </code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// If you enter a Server ID for the <code>--server-id</code> parameter that does not identify an actual Transfer server, you receive the following error:
    /// </p>
    /// <p>
    /// <code>An error occurred (ResourceNotFoundException) when calling the TestIdentityProvider operation: Unknown server</code>
    /// </p>
    /// </li>
    /// </ul>
    #[derive(std::fmt::Debug)]
    pub struct TestIdentityProvider<
        C = aws_smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = aws_smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::test_identity_provider_input::Builder,
    }
    impl<C, M, R> TestIdentityProvider<C, M, R>
    where
        C: aws_smithy_client::bounds::SmithyConnector,
        M: aws_smithy_client::bounds::SmithyMiddleware<C>,
        R: aws_smithy_client::retry::NewRequestPolicy,
    {
        /// Creates a new `TestIdentityProvider`.
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        /// Sends the request and returns the response.
        ///
        /// If an error occurs, an `SdkError` will be returned with additional details that
        /// can be matched against.
        ///
        /// By default, any retryable failures will be retried twice. Retry behavior
        /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
        /// set when configuring the client.
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::TestIdentityProviderOutput,
            aws_smithy_http::result::SdkError<crate::error::TestIdentityProviderError>,
        >
        where
            R::Policy: aws_smithy_client::bounds::SmithyRetryPolicy<
                crate::input::TestIdentityProviderInputOperationOutputAlias,
                crate::output::TestIdentityProviderOutput,
                crate::error::TestIdentityProviderError,
                crate::input::TestIdentityProviderInputOperationRetryAlias,
            >,
        {
            let input = self.inner.build().map_err(|err| {
                aws_smithy_http::result::SdkError::ConstructionFailure(err.into())
            })?;
            let op = input
                .make_operation(&self.handle.conf)
                .await
                .map_err(|err| {
                    aws_smithy_http::result::SdkError::ConstructionFailure(err.into())
                })?;
            self.handle.client.call(op).await
        }
        /// <p>A system-assigned identifier for a specific server. That server's user authentication
        /// method is tested with a user name and password.</p>
        pub fn server_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.server_id(inp);
            self
        }
        /// <p>A system-assigned identifier for a specific server. That server's user authentication
        /// method is tested with a user name and password.</p>
        pub fn set_server_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_server_id(input);
            self
        }
        /// <p>The type of file transfer protocol to be tested.</p>
        ///
        /// <p>The available protocols are:</p>
        ///
        /// <ul>
        /// <li>
        /// <p>Secure Shell (SSH) File Transfer Protocol (SFTP)</p>
        /// </li>
        /// <li>
        /// <p>File Transfer Protocol Secure (FTPS)</p>
        /// </li>
        /// <li>
        /// <p>File Transfer Protocol (FTP)</p>
        /// </li>
        /// </ul>
        pub fn server_protocol(mut self, inp: crate::model::Protocol) -> Self {
            self.inner = self.inner.server_protocol(inp);
            self
        }
        /// <p>The type of file transfer protocol to be tested.</p>
        ///
        /// <p>The available protocols are:</p>
        ///
        /// <ul>
        /// <li>
        /// <p>Secure Shell (SSH) File Transfer Protocol (SFTP)</p>
        /// </li>
        /// <li>
        /// <p>File Transfer Protocol Secure (FTPS)</p>
        /// </li>
        /// <li>
        /// <p>File Transfer Protocol (FTP)</p>
        /// </li>
        /// </ul>
        pub fn set_server_protocol(
            mut self,
            input: std::option::Option<crate::model::Protocol>,
        ) -> Self {
            self.inner = self.inner.set_server_protocol(input);
            self
        }
        /// <p>The source IP address of the user account to be tested.</p>
        pub fn source_ip(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source_ip(inp);
            self
        }
        /// <p>The source IP address of the user account to be tested.</p>
        pub fn set_source_ip(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_source_ip(input);
            self
        }
        /// <p>The name of the user account to be tested.</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_name(inp);
            self
        }
        /// <p>The name of the user account to be tested.</p>
        pub fn set_user_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_user_name(input);
            self
        }
        /// <p>The password of the user account to be tested.</p>
        pub fn user_password(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_password(inp);
            self
        }
        /// <p>The password of the user account to be tested.</p>
        pub fn set_user_password(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_user_password(input);
            self
        }
    }
    /// Fluent builder constructing a request to `UntagResource`.
    ///
    /// <p>Detaches a key-value pair from a resource, as identified by its Amazon Resource Name
    /// (ARN). Resources are users, servers, roles, and other entities.</p>
    ///
    /// <p>No response is returned from this call.</p>
    #[derive(std::fmt::Debug)]
    pub struct UntagResource<
        C = aws_smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = aws_smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::untag_resource_input::Builder,
    }
    impl<C, M, R> UntagResource<C, M, R>
    where
        C: aws_smithy_client::bounds::SmithyConnector,
        M: aws_smithy_client::bounds::SmithyMiddleware<C>,
        R: aws_smithy_client::retry::NewRequestPolicy,
    {
        /// Creates a new `UntagResource`.
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        /// Sends the request and returns the response.
        ///
        /// If an error occurs, an `SdkError` will be returned with additional details that
        /// can be matched against.
        ///
        /// By default, any retryable failures will be retried twice. Retry behavior
        /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
        /// set when configuring the client.
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UntagResourceOutput,
            aws_smithy_http::result::SdkError<crate::error::UntagResourceError>,
        >
        where
            R::Policy: aws_smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UntagResourceInputOperationOutputAlias,
                crate::output::UntagResourceOutput,
                crate::error::UntagResourceError,
                crate::input::UntagResourceInputOperationRetryAlias,
            >,
        {
            let input = self.inner.build().map_err(|err| {
                aws_smithy_http::result::SdkError::ConstructionFailure(err.into())
            })?;
            let op = input
                .make_operation(&self.handle.conf)
                .await
                .map_err(|err| {
                    aws_smithy_http::result::SdkError::ConstructionFailure(err.into())
                })?;
            self.handle.client.call(op).await
        }
        /// <p>The value of the resource that will have the tag removed. An Amazon Resource Name (ARN) is
        /// an identifier for a specific Amazon Web Services resource, such as a server, user, or role.</p>
        pub fn arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.arn(inp);
            self
        }
        /// <p>The value of the resource that will have the tag removed. An Amazon Resource Name (ARN) is
        /// an identifier for a specific Amazon Web Services resource, such as a server, user, or role.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_arn(input);
            self
        }
        /// Appends an item to `TagKeys`.
        ///
        /// To override the contents of this collection use [`set_tag_keys`](Self::set_tag_keys).
        ///
        /// <p>TagKeys are key-value pairs assigned to ARNs that can be used to group and search for
        /// resources by type. This metadata can be attached to resources for any purpose.</p>
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tag_keys(inp);
            self
        }
        /// <p>TagKeys are key-value pairs assigned to ARNs that can be used to group and search for
        /// resources by type. This metadata can be attached to resources for any purpose.</p>
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tag_keys(input);
            self
        }
    }
    /// Fluent builder constructing a request to `UpdateAccess`.
    ///
    /// <p>Allows you to update parameters for the access specified in the <code>ServerID</code> and
    /// <code>ExternalID</code> parameters.</p>
    #[derive(std::fmt::Debug)]
    pub struct UpdateAccess<
        C = aws_smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = aws_smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::update_access_input::Builder,
    }
    impl<C, M, R> UpdateAccess<C, M, R>
    where
        C: aws_smithy_client::bounds::SmithyConnector,
        M: aws_smithy_client::bounds::SmithyMiddleware<C>,
        R: aws_smithy_client::retry::NewRequestPolicy,
    {
        /// Creates a new `UpdateAccess`.
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        /// Sends the request and returns the response.
        ///
        /// If an error occurs, an `SdkError` will be returned with additional details that
        /// can be matched against.
        ///
        /// By default, any retryable failures will be retried twice. Retry behavior
        /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
        /// set when configuring the client.
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateAccessOutput,
            aws_smithy_http::result::SdkError<crate::error::UpdateAccessError>,
        >
        where
            R::Policy: aws_smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UpdateAccessInputOperationOutputAlias,
                crate::output::UpdateAccessOutput,
                crate::error::UpdateAccessError,
                crate::input::UpdateAccessInputOperationRetryAlias,
            >,
        {
            let input = self.inner.build().map_err(|err| {
                aws_smithy_http::result::SdkError::ConstructionFailure(err.into())
            })?;
            let op = input
                .make_operation(&self.handle.conf)
                .await
                .map_err(|err| {
                    aws_smithy_http::result::SdkError::ConstructionFailure(err.into())
                })?;
            self.handle.client.call(op).await
        }
        /// <p>The landing directory (folder) for a user when they log in to the server using the client.</p>
        /// <p>A <code>HomeDirectory</code> example is <code>/bucket_name/home/mydirectory</code>.</p>
        pub fn home_directory(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.home_directory(inp);
            self
        }
        /// <p>The landing directory (folder) for a user when they log in to the server using the client.</p>
        /// <p>A <code>HomeDirectory</code> example is <code>/bucket_name/home/mydirectory</code>.</p>
        pub fn set_home_directory(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_home_directory(input);
            self
        }
        /// <p>The type of landing directory (folder) you want your users' home directory to be when they log into the server.
        /// If you set it to <code>PATH</code>, the user will see the absolute Amazon S3 bucket or EFS paths as is in their file transfer protocol clients.
        /// If you set it <code>LOGICAL</code>, you need to provide mappings in the <code>HomeDirectoryMappings</code> for how you want to make Amazon
        /// S3 or EFS paths visible to your users.</p>
        pub fn home_directory_type(mut self, inp: crate::model::HomeDirectoryType) -> Self {
            self.inner = self.inner.home_directory_type(inp);
            self
        }
        /// <p>The type of landing directory (folder) you want your users' home directory to be when they log into the server.
        /// If you set it to <code>PATH</code>, the user will see the absolute Amazon S3 bucket or EFS paths as is in their file transfer protocol clients.
        /// If you set it <code>LOGICAL</code>, you need to provide mappings in the <code>HomeDirectoryMappings</code> for how you want to make Amazon
        /// S3 or EFS paths visible to your users.</p>
        pub fn set_home_directory_type(
            mut self,
            input: std::option::Option<crate::model::HomeDirectoryType>,
        ) -> Self {
            self.inner = self.inner.set_home_directory_type(input);
            self
        }
        /// Appends an item to `HomeDirectoryMappings`.
        ///
        /// To override the contents of this collection use [`set_home_directory_mappings`](Self::set_home_directory_mappings).
        ///
        /// <p>Logical directory mappings that specify what Amazon S3 or Amazon EFS paths and keys should
        /// be visible to your user and how you want to make them visible. You must specify the
        /// <code>Entry</code> and <code>Target</code> pair, where <code>Entry</code> shows how the path
        /// is made visible and <code>Target</code> is the actual Amazon S3 or Amazon EFS path. If you
        /// only specify a target, it is displayed as is. You also must ensure that your Amazon Web Services Identity
        /// and Access Management (IAM) role provides access to paths in <code>Target</code>. This value
        /// can only be set when <code>HomeDirectoryType</code> is set to
        /// <i>LOGICAL</i>.</p>
        /// <p>The following is an <code>Entry</code> and <code>Target</code> pair example.</p>
        /// <p>
        /// <code>[ { "Entry": "/directory1", "Target": "/bucket_name/home/mydirectory" } ]</code>
        /// </p>
        /// <p>In most cases, you can use this value instead of the session policy to lock down your
        /// user to the designated home directory ("<code>chroot</code>"). To do this, you can set
        /// <code>Entry</code> to <code>/</code> and set <code>Target</code> to the
        /// <code>HomeDirectory</code> parameter value.</p>
        /// <p>The following is an <code>Entry</code> and <code>Target</code> pair example for <code>chroot</code>.</p>
        /// <p>
        /// <code>[ { "Entry:": "/", "Target": "/bucket_name/home/mydirectory" } ]</code>
        /// </p>
        ///
        /// <note>
        /// <p>If the target of a logical directory entry does not exist in Amazon S3 or EFS, the entry is
        /// ignored. As a workaround, you can use the Amazon S3 API or EFS API to create 0 byte objects as place
        /// holders for your directory. If using the CLI, use the <code>s3api</code> or <code>efsapi</code> call instead of
        /// <code>s3</code> or <code>efs</code> so you can use the put-object operation. For example, you use the
        /// following: <code>aws s3api put-object --bucket bucketname --key path/to/folder/</code>. Make
        /// sure that the end of the key name ends in a <code>/</code> for it to be considered a folder.</p>
        /// </note>
        pub fn home_directory_mappings(
            mut self,
            inp: impl Into<crate::model::HomeDirectoryMapEntry>,
        ) -> Self {
            self.inner = self.inner.home_directory_mappings(inp);
            self
        }
        /// <p>Logical directory mappings that specify what Amazon S3 or Amazon EFS paths and keys should
        /// be visible to your user and how you want to make them visible. You must specify the
        /// <code>Entry</code> and <code>Target</code> pair, where <code>Entry</code> shows how the path
        /// is made visible and <code>Target</code> is the actual Amazon S3 or Amazon EFS path. If you
        /// only specify a target, it is displayed as is. You also must ensure that your Amazon Web Services Identity
        /// and Access Management (IAM) role provides access to paths in <code>Target</code>. This value
        /// can only be set when <code>HomeDirectoryType</code> is set to
        /// <i>LOGICAL</i>.</p>
        /// <p>The following is an <code>Entry</code> and <code>Target</code> pair example.</p>
        /// <p>
        /// <code>[ { "Entry": "/directory1", "Target": "/bucket_name/home/mydirectory" } ]</code>
        /// </p>
        /// <p>In most cases, you can use this value instead of the session policy to lock down your
        /// user to the designated home directory ("<code>chroot</code>"). To do this, you can set
        /// <code>Entry</code> to <code>/</code> and set <code>Target</code> to the
        /// <code>HomeDirectory</code> parameter value.</p>
        /// <p>The following is an <code>Entry</code> and <code>Target</code> pair example for <code>chroot</code>.</p>
        /// <p>
        /// <code>[ { "Entry:": "/", "Target": "/bucket_name/home/mydirectory" } ]</code>
        /// </p>
        ///
        /// <note>
        /// <p>If the target of a logical directory entry does not exist in Amazon S3 or EFS, the entry is
        /// ignored. As a workaround, you can use the Amazon S3 API or EFS API to create 0 byte objects as place
        /// holders for your directory. If using the CLI, use the <code>s3api</code> or <code>efsapi</code> call instead of
        /// <code>s3</code> or <code>efs</code> so you can use the put-object operation. For example, you use the
        /// following: <code>aws s3api put-object --bucket bucketname --key path/to/folder/</code>. Make
        /// sure that the end of the key name ends in a <code>/</code> for it to be considered a folder.</p>
        /// </note>
        pub fn set_home_directory_mappings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::HomeDirectoryMapEntry>>,
        ) -> Self {
            self.inner = self.inner.set_home_directory_mappings(input);
            self
        }
        /// <p>A session policy for your user so that you can use the same IAM role across multiple users. This policy scopes down user
        /// access to portions of their Amazon S3 bucket. Variables that you can use inside this policy include <code>${Transfer:UserName}</code>,
        /// <code>${Transfer:HomeDirectory}</code>, and <code>${Transfer:HomeBucket}</code>.</p>
        ///
        ///
        /// <note>
        /// <p>This only applies when the domain of <code>ServerId</code> is S3. EFS does not use session policies.</p>
        /// <p>For session policies, Amazon Web Services Transfer Family stores the policy as a JSON blob, instead
        /// of the Amazon Resource Name (ARN) of the policy. You save the policy as a JSON blob and pass
        /// it in the <code>Policy</code> argument.</p>
        /// <p>For an example of a session policy, see <a href="https://docs.aws.amazon.com/transfer/latest/userguide/session-policy.html">Example
        /// session policy</a>.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRole.html">AssumeRole</a> in the <i>Amazon Web ServicesSecurity Token Service API
        /// Reference</i>.</p>
        /// </note>
        pub fn policy(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy(inp);
            self
        }
        /// <p>A session policy for your user so that you can use the same IAM role across multiple users. This policy scopes down user
        /// access to portions of their Amazon S3 bucket. Variables that you can use inside this policy include <code>${Transfer:UserName}</code>,
        /// <code>${Transfer:HomeDirectory}</code>, and <code>${Transfer:HomeBucket}</code>.</p>
        ///
        ///
        /// <note>
        /// <p>This only applies when the domain of <code>ServerId</code> is S3. EFS does not use session policies.</p>
        /// <p>For session policies, Amazon Web Services Transfer Family stores the policy as a JSON blob, instead
        /// of the Amazon Resource Name (ARN) of the policy. You save the policy as a JSON blob and pass
        /// it in the <code>Policy</code> argument.</p>
        /// <p>For an example of a session policy, see <a href="https://docs.aws.amazon.com/transfer/latest/userguide/session-policy.html">Example
        /// session policy</a>.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRole.html">AssumeRole</a> in the <i>Amazon Web ServicesSecurity Token Service API
        /// Reference</i>.</p>
        /// </note>
        pub fn set_policy(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy(input);
            self
        }
        /// <p>The full POSIX identity, including user ID (<code>Uid</code>), group ID
        /// (<code>Gid</code>), and any secondary groups IDs (<code>SecondaryGids</code>), that controls
        /// your users' access to your Amazon EFS file systems. The POSIX permissions that are set on
        /// files and directories in your file system determine the level of access your users get when
        /// transferring files into and out of your Amazon EFS file systems.</p>
        pub fn posix_profile(mut self, inp: crate::model::PosixProfile) -> Self {
            self.inner = self.inner.posix_profile(inp);
            self
        }
        /// <p>The full POSIX identity, including user ID (<code>Uid</code>), group ID
        /// (<code>Gid</code>), and any secondary groups IDs (<code>SecondaryGids</code>), that controls
        /// your users' access to your Amazon EFS file systems. The POSIX permissions that are set on
        /// files and directories in your file system determine the level of access your users get when
        /// transferring files into and out of your Amazon EFS file systems.</p>
        pub fn set_posix_profile(
            mut self,
            input: std::option::Option<crate::model::PosixProfile>,
        ) -> Self {
            self.inner = self.inner.set_posix_profile(input);
            self
        }
        /// <p>Specifies the Amazon Resource Name (ARN) of the IAM role that controls your users' access to your Amazon S3 bucket or EFS
        /// file system. The policies attached to this role determine the level of access that you want to provide your users when transferring
        /// files into and out of your Amazon S3 bucket or EFS file system. The IAM role should also contain a trust relationship that allows the
        /// server to access your resources when servicing your users' transfer requests.</p>
        pub fn role(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role(inp);
            self
        }
        /// <p>Specifies the Amazon Resource Name (ARN) of the IAM role that controls your users' access to your Amazon S3 bucket or EFS
        /// file system. The policies attached to this role determine the level of access that you want to provide your users when transferring
        /// files into and out of your Amazon S3 bucket or EFS file system. The IAM role should also contain a trust relationship that allows the
        /// server to access your resources when servicing your users' transfer requests.</p>
        pub fn set_role(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role(input);
            self
        }
        /// <p>A system-assigned unique identifier for a server instance. This is the specific server that you added your user to.</p>
        pub fn server_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.server_id(inp);
            self
        }
        /// <p>A system-assigned unique identifier for a server instance. This is the specific server that you added your user to.</p>
        pub fn set_server_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_server_id(input);
            self
        }
        /// <p>A unique identifier that is required to identify specific groups within your directory.
        /// The users of the group that you associate have access to your Amazon S3 or Amazon EFS
        /// resources over the enabled protocols using Amazon Web Services Transfer Family. If you know the group name,
        /// you can view the SID values by running the following command using Windows PowerShell.</p>
        ///
        /// <p>
        /// <code>Get-ADGroup -Filter {samAccountName -like "<i>YourGroupName</i>*"} -Properties * | Select SamAccountName,ObjectSid</code>
        /// </p>
        ///
        /// <p>In that command, replace <i>YourGroupName</i> with the name of your Active Directory group.</p>
        ///
        /// <p>The regex used to validate this parameter is a string of characters consisting of uppercase and lowercase alphanumeric characters with no spaces.
        /// You can also include underscores or any of the following characters: =,.@:/-</p>
        pub fn external_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.external_id(inp);
            self
        }
        /// <p>A unique identifier that is required to identify specific groups within your directory.
        /// The users of the group that you associate have access to your Amazon S3 or Amazon EFS
        /// resources over the enabled protocols using Amazon Web Services Transfer Family. If you know the group name,
        /// you can view the SID values by running the following command using Windows PowerShell.</p>
        ///
        /// <p>
        /// <code>Get-ADGroup -Filter {samAccountName -like "<i>YourGroupName</i>*"} -Properties * | Select SamAccountName,ObjectSid</code>
        /// </p>
        ///
        /// <p>In that command, replace <i>YourGroupName</i> with the name of your Active Directory group.</p>
        ///
        /// <p>The regex used to validate this parameter is a string of characters consisting of uppercase and lowercase alphanumeric characters with no spaces.
        /// You can also include underscores or any of the following characters: =,.@:/-</p>
        pub fn set_external_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_external_id(input);
            self
        }
    }
    /// Fluent builder constructing a request to `UpdateServer`.
    ///
    /// <p>Updates the file transfer protocol-enabled server's properties after that server has
    /// been created.</p>
    ///
    /// <p>The <code>UpdateServer</code> call returns the <code>ServerId</code> of the server you
    /// updated.</p>
    #[derive(std::fmt::Debug)]
    pub struct UpdateServer<
        C = aws_smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = aws_smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::update_server_input::Builder,
    }
    impl<C, M, R> UpdateServer<C, M, R>
    where
        C: aws_smithy_client::bounds::SmithyConnector,
        M: aws_smithy_client::bounds::SmithyMiddleware<C>,
        R: aws_smithy_client::retry::NewRequestPolicy,
    {
        /// Creates a new `UpdateServer`.
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        /// Sends the request and returns the response.
        ///
        /// If an error occurs, an `SdkError` will be returned with additional details that
        /// can be matched against.
        ///
        /// By default, any retryable failures will be retried twice. Retry behavior
        /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
        /// set when configuring the client.
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateServerOutput,
            aws_smithy_http::result::SdkError<crate::error::UpdateServerError>,
        >
        where
            R::Policy: aws_smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UpdateServerInputOperationOutputAlias,
                crate::output::UpdateServerOutput,
                crate::error::UpdateServerError,
                crate::input::UpdateServerInputOperationRetryAlias,
            >,
        {
            let input = self.inner.build().map_err(|err| {
                aws_smithy_http::result::SdkError::ConstructionFailure(err.into())
            })?;
            let op = input
                .make_operation(&self.handle.conf)
                .await
                .map_err(|err| {
                    aws_smithy_http::result::SdkError::ConstructionFailure(err.into())
                })?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the Amazon Web ServicesCertificate Manager (ACM) certificate. Required
        /// when <code>Protocols</code> is set to <code>FTPS</code>.</p>
        ///
        /// <p>To request a new public certificate, see <a href="https://docs.aws.amazon.com/acm/latest/userguide/gs-acm-request-public.html">Request a public certificate</a>
        /// in the <i> Amazon Web ServicesCertificate Manager User Guide</i>.</p>
        ///
        /// <p>To import an existing certificate into ACM, see <a href="https://docs.aws.amazon.com/acm/latest/userguide/import-certificate.html">Importing certificates into ACM</a>
        /// in the <i> Amazon Web ServicesCertificate Manager User Guide</i>.</p>
        ///
        /// <p>To request a private certificate to use FTPS through private IP addresses, see <a href="https://docs.aws.amazon.com/acm/latest/userguide/gs-acm-request-private.html">Request a
        /// private certificate</a> in the <i> Amazon Web ServicesCertificate Manager User
        /// Guide</i>.</p>
        ///
        /// <p>Certificates with the following cryptographic algorithms and key sizes are
        /// supported:</p>
        ///
        /// <ul>
        /// <li>
        /// <p>2048-bit RSA (RSA_2048)</p>
        /// </li>
        /// <li>
        /// <p>4096-bit RSA (RSA_4096)</p>
        /// </li>
        /// <li>
        /// <p>Elliptic Prime Curve 256 bit (EC_prime256v1)</p>
        /// </li>
        /// <li>
        /// <p>Elliptic Prime Curve 384 bit (EC_secp384r1)</p>
        /// </li>
        /// <li>
        /// <p>Elliptic Prime Curve 521 bit (EC_secp521r1)</p>
        /// </li>
        /// </ul>
        ///
        /// <note>
        /// <p>The certificate must be a valid SSL/TLS X.509 version 3 certificate with FQDN or IP
        /// address specified and information about the issuer.</p>
        /// </note>
        pub fn certificate(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.certificate(inp);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Amazon Web ServicesCertificate Manager (ACM) certificate. Required
        /// when <code>Protocols</code> is set to <code>FTPS</code>.</p>
        ///
        /// <p>To request a new public certificate, see <a href="https://docs.aws.amazon.com/acm/latest/userguide/gs-acm-request-public.html">Request a public certificate</a>
        /// in the <i> Amazon Web ServicesCertificate Manager User Guide</i>.</p>
        ///
        /// <p>To import an existing certificate into ACM, see <a href="https://docs.aws.amazon.com/acm/latest/userguide/import-certificate.html">Importing certificates into ACM</a>
        /// in the <i> Amazon Web ServicesCertificate Manager User Guide</i>.</p>
        ///
        /// <p>To request a private certificate to use FTPS through private IP addresses, see <a href="https://docs.aws.amazon.com/acm/latest/userguide/gs-acm-request-private.html">Request a
        /// private certificate</a> in the <i> Amazon Web ServicesCertificate Manager User
        /// Guide</i>.</p>
        ///
        /// <p>Certificates with the following cryptographic algorithms and key sizes are
        /// supported:</p>
        ///
        /// <ul>
        /// <li>
        /// <p>2048-bit RSA (RSA_2048)</p>
        /// </li>
        /// <li>
        /// <p>4096-bit RSA (RSA_4096)</p>
        /// </li>
        /// <li>
        /// <p>Elliptic Prime Curve 256 bit (EC_prime256v1)</p>
        /// </li>
        /// <li>
        /// <p>Elliptic Prime Curve 384 bit (EC_secp384r1)</p>
        /// </li>
        /// <li>
        /// <p>Elliptic Prime Curve 521 bit (EC_secp521r1)</p>
        /// </li>
        /// </ul>
        ///
        /// <note>
        /// <p>The certificate must be a valid SSL/TLS X.509 version 3 certificate with FQDN or IP
        /// address specified and information about the issuer.</p>
        /// </note>
        pub fn set_certificate(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_certificate(input);
            self
        }
        /// <p>
        /// The protocol settings that are configured for your server.
        /// </p>
        /// <p>
        /// Use the <code>PassiveIp</code> parameter to indicate passive mode (for FTP and FTPS protocols).
        /// Enter a single dotted-quad IPv4 address, such as the external IP address of a firewall, router, or load balancer.
        /// </p>
        pub fn protocol_details(mut self, inp: crate::model::ProtocolDetails) -> Self {
            self.inner = self.inner.protocol_details(inp);
            self
        }
        /// <p>
        /// The protocol settings that are configured for your server.
        /// </p>
        /// <p>
        /// Use the <code>PassiveIp</code> parameter to indicate passive mode (for FTP and FTPS protocols).
        /// Enter a single dotted-quad IPv4 address, such as the external IP address of a firewall, router, or load balancer.
        /// </p>
        pub fn set_protocol_details(
            mut self,
            input: std::option::Option<crate::model::ProtocolDetails>,
        ) -> Self {
            self.inner = self.inner.set_protocol_details(input);
            self
        }
        /// <p>The virtual private cloud (VPC) endpoint settings that are configured for your server.
        /// When you host your endpoint within your VPC, you can make it accessible only to resources
        /// within your VPC, or you can attach Elastic IP addresses and make it accessible to clients over
        /// the internet. Your VPC's default security groups are automatically assigned to your
        /// endpoint.</p>
        pub fn endpoint_details(mut self, inp: crate::model::EndpointDetails) -> Self {
            self.inner = self.inner.endpoint_details(inp);
            self
        }
        /// <p>The virtual private cloud (VPC) endpoint settings that are configured for your server.
        /// When you host your endpoint within your VPC, you can make it accessible only to resources
        /// within your VPC, or you can attach Elastic IP addresses and make it accessible to clients over
        /// the internet. Your VPC's default security groups are automatically assigned to your
        /// endpoint.</p>
        pub fn set_endpoint_details(
            mut self,
            input: std::option::Option<crate::model::EndpointDetails>,
        ) -> Self {
            self.inner = self.inner.set_endpoint_details(input);
            self
        }
        /// <p>The type of endpoint that you want your server to use. You can choose to make your server's endpoint publicly accessible (PUBLIC)
        /// or host it inside your VPC. With an endpoint that is hosted in a VPC, you can restrict access to your server and
        /// resources only within your VPC or choose to make it internet facing by attaching Elastic IP addresses directly to it.</p>
        /// <note>
        /// <p> After May 19, 2021, you won't be able to create a server using
        /// <code>EndpointType=VPC_ENDPOINT</code> in your Amazon Web Servicesaccount if your account hasn't already
        /// done so before May 19, 2021. If you have already created servers with
        /// <code>EndpointType=VPC_ENDPOINT</code> in your Amazon Web Servicesaccount on or before May 19, 2021,
        /// you will not be affected. After this date, use
        /// <code>EndpointType</code>=<code>VPC</code>.</p>
        ///
        /// <p>For more information, see
        /// https://docs.aws.amazon.com/transfer/latest/userguide/create-server-in-vpc.html#deprecate-vpc-endpoint.</p>
        /// <p>It is recommended that you use <code>VPC</code> as the <code>EndpointType</code>. With
        /// this endpoint type, you have the option to directly associate up to three Elastic IPv4
        /// addresses (BYO IP included) with your server's endpoint and use VPC security groups to
        /// restrict traffic by the client's public IP address. This is not possible with
        /// <code>EndpointType</code> set to <code>VPC_ENDPOINT</code>.</p>
        /// </note>
        pub fn endpoint_type(mut self, inp: crate::model::EndpointType) -> Self {
            self.inner = self.inner.endpoint_type(inp);
            self
        }
        /// <p>The type of endpoint that you want your server to use. You can choose to make your server's endpoint publicly accessible (PUBLIC)
        /// or host it inside your VPC. With an endpoint that is hosted in a VPC, you can restrict access to your server and
        /// resources only within your VPC or choose to make it internet facing by attaching Elastic IP addresses directly to it.</p>
        /// <note>
        /// <p> After May 19, 2021, you won't be able to create a server using
        /// <code>EndpointType=VPC_ENDPOINT</code> in your Amazon Web Servicesaccount if your account hasn't already
        /// done so before May 19, 2021. If you have already created servers with
        /// <code>EndpointType=VPC_ENDPOINT</code> in your Amazon Web Servicesaccount on or before May 19, 2021,
        /// you will not be affected. After this date, use
        /// <code>EndpointType</code>=<code>VPC</code>.</p>
        ///
        /// <p>For more information, see
        /// https://docs.aws.amazon.com/transfer/latest/userguide/create-server-in-vpc.html#deprecate-vpc-endpoint.</p>
        /// <p>It is recommended that you use <code>VPC</code> as the <code>EndpointType</code>. With
        /// this endpoint type, you have the option to directly associate up to three Elastic IPv4
        /// addresses (BYO IP included) with your server's endpoint and use VPC security groups to
        /// restrict traffic by the client's public IP address. This is not possible with
        /// <code>EndpointType</code> set to <code>VPC_ENDPOINT</code>.</p>
        /// </note>
        pub fn set_endpoint_type(
            mut self,
            input: std::option::Option<crate::model::EndpointType>,
        ) -> Self {
            self.inner = self.inner.set_endpoint_type(input);
            self
        }
        /// <p>The RSA private key as generated by <code>ssh-keygen -N "" -m PEM -f
        /// my-new-server-key</code>.</p>
        ///
        /// <important>
        /// <p>If you aren't planning to migrate existing users from an existing server to a new
        /// server, don't update the host key. Accidentally changing a server's host key can
        /// be disruptive.</p>
        /// </important>
        ///
        ///
        ///
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/transfer/latest/userguide/edit-server-config.html#configuring-servers-change-host-key">Change the host key for your SFTP-enabled server</a> in the <i>Amazon Web ServicesTransfer
        /// Family User Guide</i>.</p>
        pub fn host_key(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.host_key(inp);
            self
        }
        /// <p>The RSA private key as generated by <code>ssh-keygen -N "" -m PEM -f
        /// my-new-server-key</code>.</p>
        ///
        /// <important>
        /// <p>If you aren't planning to migrate existing users from an existing server to a new
        /// server, don't update the host key. Accidentally changing a server's host key can
        /// be disruptive.</p>
        /// </important>
        ///
        ///
        ///
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/transfer/latest/userguide/edit-server-config.html#configuring-servers-change-host-key">Change the host key for your SFTP-enabled server</a> in the <i>Amazon Web ServicesTransfer
        /// Family User Guide</i>.</p>
        pub fn set_host_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_host_key(input);
            self
        }
        /// <p>An array containing all of the information required to call a customer's
        /// authentication API method.</p>
        pub fn identity_provider_details(
            mut self,
            inp: crate::model::IdentityProviderDetails,
        ) -> Self {
            self.inner = self.inner.identity_provider_details(inp);
            self
        }
        /// <p>An array containing all of the information required to call a customer's
        /// authentication API method.</p>
        pub fn set_identity_provider_details(
            mut self,
            input: std::option::Option<crate::model::IdentityProviderDetails>,
        ) -> Self {
            self.inner = self.inner.set_identity_provider_details(input);
            self
        }
        /// <p>Specifies the Amazon Resource Name (ARN) of the Amazon Web Services Identity and Access Management (IAM) role that allows a server to turn
        /// on Amazon CloudWatch logging for Amazon S3 or Amazon EFS events. When set, user activity can be viewed in
        /// your CloudWatch logs.</p>
        pub fn logging_role(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.logging_role(inp);
            self
        }
        /// <p>Specifies the Amazon Resource Name (ARN) of the Amazon Web Services Identity and Access Management (IAM) role that allows a server to turn
        /// on Amazon CloudWatch logging for Amazon S3 or Amazon EFS events. When set, user activity can be viewed in
        /// your CloudWatch logs.</p>
        pub fn set_logging_role(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_logging_role(input);
            self
        }
        /// Appends an item to `Protocols`.
        ///
        /// To override the contents of this collection use [`set_protocols`](Self::set_protocols).
        ///
        /// <p>Specifies the file transfer protocol or protocols over which your file transfer protocol
        /// client can connect to your server's endpoint. The available protocols are:</p>
        ///
        /// <ul>
        /// <li>
        /// <p>Secure Shell (SSH) File Transfer Protocol (SFTP): File transfer over SSH</p>
        /// </li>
        /// <li>
        /// <p>File Transfer Protocol Secure (FTPS): File transfer with TLS encryption</p>
        /// </li>
        /// <li>
        /// <p>File Transfer Protocol (FTP): Unencrypted file transfer</p>
        /// </li>
        /// </ul>
        ///
        /// <note>
        /// <p>If you select <code>FTPS</code>, you must choose a certificate stored in Amazon Web ServicesCertificate
        /// Manager (ACM) which will be used to identify your server when clients connect to it over
        /// FTPS.</p>
        ///
        ///
        /// <p>If <code>Protocol</code> includes either <code>FTP</code> or <code>FTPS</code>, then the
        /// <code>EndpointType</code> must be <code>VPC</code> and the
        /// <code>IdentityProviderType</code> must be <code>AWS_DIRECTORY_SERVICE</code> or <code>API_GATEWAY</code>.</p>
        ///
        /// <p>If <code>Protocol</code> includes <code>FTP</code>, then
        /// <code>AddressAllocationIds</code> cannot be associated.</p>
        ///
        /// <p>If <code>Protocol</code> is set only to <code>SFTP</code>, the <code>EndpointType</code>
        /// can be set to <code>PUBLIC</code> and the <code>IdentityProviderType</code> can be set to
        /// <code>SERVICE_MANAGED</code>.</p>
        /// </note>
        pub fn protocols(mut self, inp: impl Into<crate::model::Protocol>) -> Self {
            self.inner = self.inner.protocols(inp);
            self
        }
        /// <p>Specifies the file transfer protocol or protocols over which your file transfer protocol
        /// client can connect to your server's endpoint. The available protocols are:</p>
        ///
        /// <ul>
        /// <li>
        /// <p>Secure Shell (SSH) File Transfer Protocol (SFTP): File transfer over SSH</p>
        /// </li>
        /// <li>
        /// <p>File Transfer Protocol Secure (FTPS): File transfer with TLS encryption</p>
        /// </li>
        /// <li>
        /// <p>File Transfer Protocol (FTP): Unencrypted file transfer</p>
        /// </li>
        /// </ul>
        ///
        /// <note>
        /// <p>If you select <code>FTPS</code>, you must choose a certificate stored in Amazon Web ServicesCertificate
        /// Manager (ACM) which will be used to identify your server when clients connect to it over
        /// FTPS.</p>
        ///
        ///
        /// <p>If <code>Protocol</code> includes either <code>FTP</code> or <code>FTPS</code>, then the
        /// <code>EndpointType</code> must be <code>VPC</code> and the
        /// <code>IdentityProviderType</code> must be <code>AWS_DIRECTORY_SERVICE</code> or <code>API_GATEWAY</code>.</p>
        ///
        /// <p>If <code>Protocol</code> includes <code>FTP</code>, then
        /// <code>AddressAllocationIds</code> cannot be associated.</p>
        ///
        /// <p>If <code>Protocol</code> is set only to <code>SFTP</code>, the <code>EndpointType</code>
        /// can be set to <code>PUBLIC</code> and the <code>IdentityProviderType</code> can be set to
        /// <code>SERVICE_MANAGED</code>.</p>
        /// </note>
        pub fn set_protocols(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Protocol>>,
        ) -> Self {
            self.inner = self.inner.set_protocols(input);
            self
        }
        /// <p>Specifies the name of the security policy that is attached to the server.</p>
        pub fn security_policy_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.security_policy_name(inp);
            self
        }
        /// <p>Specifies the name of the security policy that is attached to the server.</p>
        pub fn set_security_policy_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_security_policy_name(input);
            self
        }
        /// <p>A system-assigned unique identifier for a server instance that the user account is
        /// assigned to.</p>
        pub fn server_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.server_id(inp);
            self
        }
        /// <p>A system-assigned unique identifier for a server instance that the user account is
        /// assigned to.</p>
        pub fn set_server_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_server_id(input);
            self
        }
        /// <p>Specifies the workflow ID for the workflow to assign and the execution role used for executing the workflow.</p>
        pub fn workflow_details(mut self, inp: crate::model::WorkflowDetails) -> Self {
            self.inner = self.inner.workflow_details(inp);
            self
        }
        /// <p>Specifies the workflow ID for the workflow to assign and the execution role used for executing the workflow.</p>
        pub fn set_workflow_details(
            mut self,
            input: std::option::Option<crate::model::WorkflowDetails>,
        ) -> Self {
            self.inner = self.inner.set_workflow_details(input);
            self
        }
    }
    /// Fluent builder constructing a request to `UpdateUser`.
    ///
    /// <p>Assigns new properties to a user. Parameters you pass modify any or all of the following:
    /// the home directory, role, and policy for the <code>UserName</code> and <code>ServerId</code>
    /// you specify.</p>
    ///
    /// <p>The response returns the <code>ServerId</code> and the <code>UserName</code> for the
    /// updated user.</p>
    #[derive(std::fmt::Debug)]
    pub struct UpdateUser<
        C = aws_smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = aws_smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::update_user_input::Builder,
    }
    impl<C, M, R> UpdateUser<C, M, R>
    where
        C: aws_smithy_client::bounds::SmithyConnector,
        M: aws_smithy_client::bounds::SmithyMiddleware<C>,
        R: aws_smithy_client::retry::NewRequestPolicy,
    {
        /// Creates a new `UpdateUser`.
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        /// Sends the request and returns the response.
        ///
        /// If an error occurs, an `SdkError` will be returned with additional details that
        /// can be matched against.
        ///
        /// By default, any retryable failures will be retried twice. Retry behavior
        /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
        /// set when configuring the client.
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateUserOutput,
            aws_smithy_http::result::SdkError<crate::error::UpdateUserError>,
        >
        where
            R::Policy: aws_smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UpdateUserInputOperationOutputAlias,
                crate::output::UpdateUserOutput,
                crate::error::UpdateUserError,
                crate::input::UpdateUserInputOperationRetryAlias,
            >,
        {
            let input = self.inner.build().map_err(|err| {
                aws_smithy_http::result::SdkError::ConstructionFailure(err.into())
            })?;
            let op = input
                .make_operation(&self.handle.conf)
                .await
                .map_err(|err| {
                    aws_smithy_http::result::SdkError::ConstructionFailure(err.into())
                })?;
            self.handle.client.call(op).await
        }
        /// <p>The landing directory (folder) for a user when they log in to the server using the client.</p>
        /// <p>A <code>HomeDirectory</code> example is <code>/bucket_name/home/mydirectory</code>.</p>
        pub fn home_directory(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.home_directory(inp);
            self
        }
        /// <p>The landing directory (folder) for a user when they log in to the server using the client.</p>
        /// <p>A <code>HomeDirectory</code> example is <code>/bucket_name/home/mydirectory</code>.</p>
        pub fn set_home_directory(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_home_directory(input);
            self
        }
        /// <p>The type of landing directory (folder) you want your users' home directory to be when they log into the server.
        /// If you set it to <code>PATH</code>, the user will see the absolute Amazon S3 bucket or EFS paths as is in their file transfer protocol clients.
        /// If you set it <code>LOGICAL</code>, you need to provide mappings in the <code>HomeDirectoryMappings</code> for how you want to make Amazon
        /// S3 or EFS paths visible to your users.</p>
        pub fn home_directory_type(mut self, inp: crate::model::HomeDirectoryType) -> Self {
            self.inner = self.inner.home_directory_type(inp);
            self
        }
        /// <p>The type of landing directory (folder) you want your users' home directory to be when they log into the server.
        /// If you set it to <code>PATH</code>, the user will see the absolute Amazon S3 bucket or EFS paths as is in their file transfer protocol clients.
        /// If you set it <code>LOGICAL</code>, you need to provide mappings in the <code>HomeDirectoryMappings</code> for how you want to make Amazon
        /// S3 or EFS paths visible to your users.</p>
        pub fn set_home_directory_type(
            mut self,
            input: std::option::Option<crate::model::HomeDirectoryType>,
        ) -> Self {
            self.inner = self.inner.set_home_directory_type(input);
            self
        }
        /// Appends an item to `HomeDirectoryMappings`.
        ///
        /// To override the contents of this collection use [`set_home_directory_mappings`](Self::set_home_directory_mappings).
        ///
        /// <p>Logical directory mappings that specify what Amazon S3 or Amazon EFS paths and keys should
        /// be visible to your user and how you want to make them visible. You must specify the
        /// <code>Entry</code> and <code>Target</code> pair, where <code>Entry</code> shows how the path
        /// is made visible and <code>Target</code> is the actual Amazon S3 or Amazon EFS path. If you
        /// only specify a target, it is displayed as is. You also must ensure that your Amazon Web Services Identity
        /// and Access Management (IAM) role provides access to paths in <code>Target</code>. This value
        /// can only be set when <code>HomeDirectoryType</code> is set to
        /// <i>LOGICAL</i>.</p>
        ///
        /// <p>The following is an <code>Entry</code> and <code>Target</code> pair example.</p>
        /// <p>
        /// <code>[ { "Entry": "/directory1", "Target":
        /// "/bucket_name/home/mydirectory" } ]</code>
        /// </p>
        ///
        /// <p>In most cases, you can use this value instead of the session policy to lock down your
        /// user to the designated home directory ("<code>chroot</code>"). To do this, you can set
        /// <code>Entry</code> to '/' and set <code>Target</code> to the HomeDirectory
        /// parameter value.</p>
        ///
        /// <p>The following is an <code>Entry</code> and <code>Target</code> pair example for <code>chroot</code>.</p>
        /// <p>
        /// <code>[ { "Entry:": "/", "Target": "/bucket_name/home/mydirectory" } ]</code>
        /// </p>
        ///
        /// <note>
        /// <p>If the target of a logical directory entry does not exist in Amazon S3 or EFS, the entry is
        /// ignored. As a workaround, you can use the Amazon S3 API or EFS API to create 0 byte objects as place
        /// holders for your directory. If using the CLI, use the <code>s3api</code> or <code>efsapi</code> call instead of
        /// <code>s3</code> or <code>efs</code> so you can use the put-object operation. For example, you use the
        /// following: <code>aws s3api put-object --bucket bucketname --key path/to/folder/</code>. Make
        /// sure that the end of the key name ends in a <code>/</code> for it to be considered a folder.</p>
        /// </note>
        pub fn home_directory_mappings(
            mut self,
            inp: impl Into<crate::model::HomeDirectoryMapEntry>,
        ) -> Self {
            self.inner = self.inner.home_directory_mappings(inp);
            self
        }
        /// <p>Logical directory mappings that specify what Amazon S3 or Amazon EFS paths and keys should
        /// be visible to your user and how you want to make them visible. You must specify the
        /// <code>Entry</code> and <code>Target</code> pair, where <code>Entry</code> shows how the path
        /// is made visible and <code>Target</code> is the actual Amazon S3 or Amazon EFS path. If you
        /// only specify a target, it is displayed as is. You also must ensure that your Amazon Web Services Identity
        /// and Access Management (IAM) role provides access to paths in <code>Target</code>. This value
        /// can only be set when <code>HomeDirectoryType</code> is set to
        /// <i>LOGICAL</i>.</p>
        ///
        /// <p>The following is an <code>Entry</code> and <code>Target</code> pair example.</p>
        /// <p>
        /// <code>[ { "Entry": "/directory1", "Target":
        /// "/bucket_name/home/mydirectory" } ]</code>
        /// </p>
        ///
        /// <p>In most cases, you can use this value instead of the session policy to lock down your
        /// user to the designated home directory ("<code>chroot</code>"). To do this, you can set
        /// <code>Entry</code> to '/' and set <code>Target</code> to the HomeDirectory
        /// parameter value.</p>
        ///
        /// <p>The following is an <code>Entry</code> and <code>Target</code> pair example for <code>chroot</code>.</p>
        /// <p>
        /// <code>[ { "Entry:": "/", "Target": "/bucket_name/home/mydirectory" } ]</code>
        /// </p>
        ///
        /// <note>
        /// <p>If the target of a logical directory entry does not exist in Amazon S3 or EFS, the entry is
        /// ignored. As a workaround, you can use the Amazon S3 API or EFS API to create 0 byte objects as place
        /// holders for your directory. If using the CLI, use the <code>s3api</code> or <code>efsapi</code> call instead of
        /// <code>s3</code> or <code>efs</code> so you can use the put-object operation. For example, you use the
        /// following: <code>aws s3api put-object --bucket bucketname --key path/to/folder/</code>. Make
        /// sure that the end of the key name ends in a <code>/</code> for it to be considered a folder.</p>
        /// </note>
        pub fn set_home_directory_mappings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::HomeDirectoryMapEntry>>,
        ) -> Self {
            self.inner = self.inner.set_home_directory_mappings(input);
            self
        }
        /// <p>A session policy for your user so that you can use the same IAM role across multiple users. This policy scopes down user
        /// access to portions of their Amazon S3 bucket. Variables that you can use inside this policy include <code>${Transfer:UserName}</code>,
        /// <code>${Transfer:HomeDirectory}</code>, and <code>${Transfer:HomeBucket}</code>.</p>
        ///
        /// <note>
        /// <p>This only applies when the domain of <code>ServerId</code> is S3. EFS does not use session policies.</p>
        /// <p>For session policies, Amazon Web Services Transfer Family stores the policy as a JSON blob, instead
        /// of the Amazon Resource Name (ARN) of the policy. You save the policy as a JSON blob and pass
        /// it in the <code>Policy</code> argument.</p>
        ///
        ///
        ///
        /// <p>For an example of a session policy, see <a href="https://docs.aws.amazon.com/transfer/latest/userguide/session-policy">Creating a session
        /// policy</a>.</p>
        ///
        ///
        ///
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRole.html">AssumeRole</a> in the <i>Amazon Web Services
        /// Security Token Service API Reference</i>.</p>
        /// </note>
        pub fn policy(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy(inp);
            self
        }
        /// <p>A session policy for your user so that you can use the same IAM role across multiple users. This policy scopes down user
        /// access to portions of their Amazon S3 bucket. Variables that you can use inside this policy include <code>${Transfer:UserName}</code>,
        /// <code>${Transfer:HomeDirectory}</code>, and <code>${Transfer:HomeBucket}</code>.</p>
        ///
        /// <note>
        /// <p>This only applies when the domain of <code>ServerId</code> is S3. EFS does not use session policies.</p>
        /// <p>For session policies, Amazon Web Services Transfer Family stores the policy as a JSON blob, instead
        /// of the Amazon Resource Name (ARN) of the policy. You save the policy as a JSON blob and pass
        /// it in the <code>Policy</code> argument.</p>
        ///
        ///
        ///
        /// <p>For an example of a session policy, see <a href="https://docs.aws.amazon.com/transfer/latest/userguide/session-policy">Creating a session
        /// policy</a>.</p>
        ///
        ///
        ///
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRole.html">AssumeRole</a> in the <i>Amazon Web Services
        /// Security Token Service API Reference</i>.</p>
        /// </note>
        pub fn set_policy(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy(input);
            self
        }
        /// <p>Specifies the full POSIX identity, including user ID (<code>Uid</code>), group ID
        /// (<code>Gid</code>), and any secondary groups IDs (<code>SecondaryGids</code>), that controls
        /// your users' access to your Amazon Elastic File Systems (Amazon EFS). The POSIX permissions
        /// that are set on files and directories in your file system determines the level of access your
        /// users get when transferring files into and out of your Amazon EFS file systems.</p>
        pub fn posix_profile(mut self, inp: crate::model::PosixProfile) -> Self {
            self.inner = self.inner.posix_profile(inp);
            self
        }
        /// <p>Specifies the full POSIX identity, including user ID (<code>Uid</code>), group ID
        /// (<code>Gid</code>), and any secondary groups IDs (<code>SecondaryGids</code>), that controls
        /// your users' access to your Amazon Elastic File Systems (Amazon EFS). The POSIX permissions
        /// that are set on files and directories in your file system determines the level of access your
        /// users get when transferring files into and out of your Amazon EFS file systems.</p>
        pub fn set_posix_profile(
            mut self,
            input: std::option::Option<crate::model::PosixProfile>,
        ) -> Self {
            self.inner = self.inner.set_posix_profile(input);
            self
        }
        /// <p>Specifies the Amazon Resource Name (ARN) of the IAM role that controls your users' access to your Amazon S3 bucket or EFS
        /// file system. The policies attached to this role determine the level of access that you want to provide your users when transferring
        /// files into and out of your Amazon S3 bucket or EFS file system. The IAM role should also contain a trust relationship that allows the
        /// server to access your resources when servicing your users' transfer requests.</p>
        pub fn role(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role(inp);
            self
        }
        /// <p>Specifies the Amazon Resource Name (ARN) of the IAM role that controls your users' access to your Amazon S3 bucket or EFS
        /// file system. The policies attached to this role determine the level of access that you want to provide your users when transferring
        /// files into and out of your Amazon S3 bucket or EFS file system. The IAM role should also contain a trust relationship that allows the
        /// server to access your resources when servicing your users' transfer requests.</p>
        pub fn set_role(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role(input);
            self
        }
        /// <p>A system-assigned unique identifier for a server instance that the user account is
        /// assigned to.</p>
        pub fn server_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.server_id(inp);
            self
        }
        /// <p>A system-assigned unique identifier for a server instance that the user account is
        /// assigned to.</p>
        pub fn set_server_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_server_id(input);
            self
        }
        /// <p>A unique string that identifies a user and is associated with a server as specified by the
        /// <code>ServerId</code>. This user name must be a minimum of 3 and a maximum of 100 characters
        /// long. The following are valid characters: a-z, A-Z, 0-9, underscore '_', hyphen
        /// '-', period '.', and at sign '@'. The user name can't start
        /// with a hyphen, period, or at sign.</p>
        pub fn user_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_name(inp);
            self
        }
        /// <p>A unique string that identifies a user and is associated with a server as specified by the
        /// <code>ServerId</code>. This user name must be a minimum of 3 and a maximum of 100 characters
        /// long. The following are valid characters: a-z, A-Z, 0-9, underscore '_', hyphen
        /// '-', period '.', and at sign '@'. The user name can't start
        /// with a hyphen, period, or at sign.</p>
        pub fn set_user_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_user_name(input);
            self
        }
    }
}
impl<C> Client<C, aws_hyper::AwsMiddleware, aws_smithy_client::retry::Standard> {
    /// Creates a client with the given service config and connector override.
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let retry_config = conf.retry_config.as_ref().cloned().unwrap_or_default();
        let client = aws_hyper::Client::new(conn).with_retry_config(retry_config.into());
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl
    Client<
        aws_smithy_client::erase::DynConnector,
        aws_hyper::AwsMiddleware,
        aws_smithy_client::retry::Standard,
    >
{
    /// Creates a new client from a shared config.
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn new(config: &aws_types::config::Config) -> Self {
        Self::from_conf(config.into())
    }

    /// Creates a new client from the service [`Config`](crate::Config).
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let retry_config = conf.retry_config.as_ref().cloned().unwrap_or_default();
        let client = aws_hyper::Client::https().with_retry_config(retry_config.into());
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
