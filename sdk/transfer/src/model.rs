// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>The full POSIX identity, including user ID (<code>Uid</code>), group ID
/// (<code>Gid</code>), and any secondary groups IDs (<code>SecondaryGids</code>), that controls
/// your users' access to your Amazon EFS file systems. The POSIX permissions that are set on
/// files and directories in your file system determine the level of access your users get when
/// transferring files into and out of your Amazon EFS file systems.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PosixProfile {
    /// <p>The POSIX user ID used for all EFS operations by this user.</p>
    pub uid: std::option::Option<i64>,
    /// <p>The POSIX group ID used for all EFS operations by this user.</p>
    pub gid: std::option::Option<i64>,
    /// <p>The secondary POSIX group IDs used for all EFS operations by this user.</p>
    pub secondary_gids: std::option::Option<std::vec::Vec<i64>>,
}
impl std::fmt::Debug for PosixProfile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PosixProfile");
        formatter.field("uid", &self.uid);
        formatter.field("gid", &self.gid);
        formatter.field("secondary_gids", &self.secondary_gids);
        formatter.finish()
    }
}
/// See [`PosixProfile`](crate::model::PosixProfile)
pub mod posix_profile {
    /// A builder for [`PosixProfile`](crate::model::PosixProfile)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) uid: std::option::Option<i64>,
        pub(crate) gid: std::option::Option<i64>,
        pub(crate) secondary_gids: std::option::Option<std::vec::Vec<i64>>,
    }
    impl Builder {
        /// <p>The POSIX user ID used for all EFS operations by this user.</p>
        pub fn uid(mut self, input: i64) -> Self {
            self.uid = Some(input);
            self
        }
        pub fn set_uid(mut self, input: std::option::Option<i64>) -> Self {
            self.uid = input;
            self
        }
        /// <p>The POSIX group ID used for all EFS operations by this user.</p>
        pub fn gid(mut self, input: i64) -> Self {
            self.gid = Some(input);
            self
        }
        pub fn set_gid(mut self, input: std::option::Option<i64>) -> Self {
            self.gid = input;
            self
        }
        pub fn secondary_gids(mut self, input: impl Into<i64>) -> Self {
            let mut v = self.secondary_gids.unwrap_or_default();
            v.push(input.into());
            self.secondary_gids = Some(v);
            self
        }
        pub fn set_secondary_gids(
            mut self,
            input: std::option::Option<std::vec::Vec<i64>>,
        ) -> Self {
            self.secondary_gids = input;
            self
        }
        /// Consumes the builder and constructs a [`PosixProfile`](crate::model::PosixProfile)
        pub fn build(self) -> crate::model::PosixProfile {
            crate::model::PosixProfile {
                uid: self.uid,
                gid: self.gid,
                secondary_gids: self.secondary_gids,
            }
        }
    }
}
impl PosixProfile {
    /// Creates a new builder-style object to manufacture [`PosixProfile`](crate::model::PosixProfile)
    pub fn builder() -> crate::model::posix_profile::Builder {
        crate::model::posix_profile::Builder::default()
    }
}

/// <p>Represents an object that contains entries and targets for
/// <code>HomeDirectoryMappings</code>.</p>
/// <p>The following is an <code>Entry</code> and <code>Target</code> pair example for <code>chroot</code>.</p>
/// <p>
/// <code>[ { "Entry:": "/", "Target": "/bucket_name/home/mydirectory" } ]</code>
/// </p>
/// <note>
/// <p>If the target of a logical directory entry does not exist in Amazon S3 or EFS, the entry is
/// ignored. As a workaround, you can use the Amazon S3 API or EFS API to create 0 byte objects as place
/// holders for your directory. If using the CLI, use the <code>s3api</code> or <code>efsapi</code> call instead of
/// <code>s3</code> or <code>efs</code> so you can use the put-object operation. For example, you use the
/// following: <code>aws s3api put-object --bucket bucketname --key path/to/folder/</code>. Make
/// sure that the end of the key name ends in a <code>/</code> for it to be considered a folder.</p>
/// </note>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct HomeDirectoryMapEntry {
    /// <p>Represents an entry for <code>HomeDirectoryMappings</code>.</p>
    pub entry: std::option::Option<std::string::String>,
    /// <p>Represents the map target that is used in a <code>HomeDirectorymapEntry</code>.</p>
    pub target: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for HomeDirectoryMapEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("HomeDirectoryMapEntry");
        formatter.field("entry", &self.entry);
        formatter.field("target", &self.target);
        formatter.finish()
    }
}
/// See [`HomeDirectoryMapEntry`](crate::model::HomeDirectoryMapEntry)
pub mod home_directory_map_entry {
    /// A builder for [`HomeDirectoryMapEntry`](crate::model::HomeDirectoryMapEntry)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) entry: std::option::Option<std::string::String>,
        pub(crate) target: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Represents an entry for <code>HomeDirectoryMappings</code>.</p>
        pub fn entry(mut self, input: impl Into<std::string::String>) -> Self {
            self.entry = Some(input.into());
            self
        }
        pub fn set_entry(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.entry = input;
            self
        }
        /// <p>Represents the map target that is used in a <code>HomeDirectorymapEntry</code>.</p>
        pub fn target(mut self, input: impl Into<std::string::String>) -> Self {
            self.target = Some(input.into());
            self
        }
        pub fn set_target(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.target = input;
            self
        }
        /// Consumes the builder and constructs a [`HomeDirectoryMapEntry`](crate::model::HomeDirectoryMapEntry)
        pub fn build(self) -> crate::model::HomeDirectoryMapEntry {
            crate::model::HomeDirectoryMapEntry {
                entry: self.entry,
                target: self.target,
            }
        }
    }
}
impl HomeDirectoryMapEntry {
    /// Creates a new builder-style object to manufacture [`HomeDirectoryMapEntry`](crate::model::HomeDirectoryMapEntry)
    pub fn builder() -> crate::model::home_directory_map_entry::Builder {
        crate::model::home_directory_map_entry::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum HomeDirectoryType {
    Logical,
    Path,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for HomeDirectoryType {
    fn from(s: &str) -> Self {
        match s {
            "LOGICAL" => HomeDirectoryType::Logical,
            "PATH" => HomeDirectoryType::Path,
            other => HomeDirectoryType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for HomeDirectoryType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(HomeDirectoryType::from(s))
    }
}
impl HomeDirectoryType {
    pub fn as_str(&self) -> &str {
        match self {
            HomeDirectoryType::Logical => "LOGICAL",
            HomeDirectoryType::Path => "PATH",
            HomeDirectoryType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["LOGICAL", "PATH"]
    }
}
impl AsRef<str> for HomeDirectoryType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Protocol {
    Ftp,
    Ftps,
    Sftp,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for Protocol {
    fn from(s: &str) -> Self {
        match s {
            "FTP" => Protocol::Ftp,
            "FTPS" => Protocol::Ftps,
            "SFTP" => Protocol::Sftp,
            other => Protocol::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for Protocol {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Protocol::from(s))
    }
}
impl Protocol {
    pub fn as_str(&self) -> &str {
        match self {
            Protocol::Ftp => "FTP",
            Protocol::Ftps => "FTPS",
            Protocol::Sftp => "SFTP",
            Protocol::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["FTP", "FTPS", "SFTP"]
    }
}
impl AsRef<str> for Protocol {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Returns information related to the type of user authentication that is in use for a file
/// transfer protocol-enabled server's users. A server can have only one method of
/// authentication.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct IdentityProviderDetails {
    /// <p>Provides the location of the service endpoint used to authenticate users.</p>
    pub url: std::option::Option<std::string::String>,
    /// <p>Provides the type of <code>InvocationRole</code> used to authenticate the user
    /// account.</p>
    pub invocation_role: std::option::Option<std::string::String>,
    /// <p>The identifier of the Amazon Web ServicesDirectory Service directory that you want to stop sharing.</p>
    pub directory_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for IdentityProviderDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("IdentityProviderDetails");
        formatter.field("url", &self.url);
        formatter.field("invocation_role", &self.invocation_role);
        formatter.field("directory_id", &self.directory_id);
        formatter.finish()
    }
}
/// See [`IdentityProviderDetails`](crate::model::IdentityProviderDetails)
pub mod identity_provider_details {
    /// A builder for [`IdentityProviderDetails`](crate::model::IdentityProviderDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) url: std::option::Option<std::string::String>,
        pub(crate) invocation_role: std::option::Option<std::string::String>,
        pub(crate) directory_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Provides the location of the service endpoint used to authenticate users.</p>
        pub fn url(mut self, input: impl Into<std::string::String>) -> Self {
            self.url = Some(input.into());
            self
        }
        pub fn set_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.url = input;
            self
        }
        /// <p>Provides the type of <code>InvocationRole</code> used to authenticate the user
        /// account.</p>
        pub fn invocation_role(mut self, input: impl Into<std::string::String>) -> Self {
            self.invocation_role = Some(input.into());
            self
        }
        pub fn set_invocation_role(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.invocation_role = input;
            self
        }
        /// <p>The identifier of the Amazon Web ServicesDirectory Service directory that you want to stop sharing.</p>
        pub fn directory_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.directory_id = Some(input.into());
            self
        }
        pub fn set_directory_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.directory_id = input;
            self
        }
        /// Consumes the builder and constructs a [`IdentityProviderDetails`](crate::model::IdentityProviderDetails)
        pub fn build(self) -> crate::model::IdentityProviderDetails {
            crate::model::IdentityProviderDetails {
                url: self.url,
                invocation_role: self.invocation_role,
                directory_id: self.directory_id,
            }
        }
    }
}
impl IdentityProviderDetails {
    /// Creates a new builder-style object to manufacture [`IdentityProviderDetails`](crate::model::IdentityProviderDetails)
    pub fn builder() -> crate::model::identity_provider_details::Builder {
        crate::model::identity_provider_details::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum EndpointType {
    Public,
    Vpc,
    VpcEndpoint,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for EndpointType {
    fn from(s: &str) -> Self {
        match s {
            "PUBLIC" => EndpointType::Public,
            "VPC" => EndpointType::Vpc,
            "VPC_ENDPOINT" => EndpointType::VpcEndpoint,
            other => EndpointType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for EndpointType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(EndpointType::from(s))
    }
}
impl EndpointType {
    pub fn as_str(&self) -> &str {
        match self {
            EndpointType::Public => "PUBLIC",
            EndpointType::Vpc => "VPC",
            EndpointType::VpcEndpoint => "VPC_ENDPOINT",
            EndpointType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["PUBLIC", "VPC", "VPC_ENDPOINT"]
    }
}
impl AsRef<str> for EndpointType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The virtual private cloud (VPC) endpoint settings that are configured for your file
/// transfer protocol-enabled server. With a VPC endpoint, you can restrict access to your server
/// and resources only within your VPC. To control incoming internet traffic, invoke the
/// <code>UpdateServer</code> API and attach an Elastic IP address to your server's
/// endpoint.</p>
/// <note>
/// <p> After May 19, 2021, you won't be able to create a server using
/// <code>EndpointType=VPC_ENDPOINT</code> in your Amazon Web Servicesaccount if your account hasn't already
/// done so before May 19, 2021. If you have already created servers with
/// <code>EndpointType=VPC_ENDPOINT</code> in your Amazon Web Servicesaccount on or before May 19, 2021,
/// you will not be affected. After this date, use
/// <code>EndpointType</code>=<code>VPC</code>.</p>
/// <p>For more information, see
/// https://docs.aws.amazon.com/transfer/latest/userguide/create-server-in-vpc.html#deprecate-vpc-endpoint.</p>
/// </note>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EndpointDetails {
    /// <p>A list of address allocation IDs that are required to attach an Elastic IP address to your
    /// server's endpoint.</p>
    /// <note>
    /// <p>This property can only be set when <code>EndpointType</code> is set to <code>VPC</code>
    /// and it is only valid in the <code>UpdateServer</code> API.</p>
    /// </note>
    pub address_allocation_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of subnet IDs that are required to host your server endpoint in your VPC.</p>
    /// <note>
    /// <p>This property can only be set when <code>EndpointType</code> is set to
    /// <code>VPC</code>.</p>
    /// </note>
    pub subnet_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The ID of the VPC endpoint.</p>
    /// <note>
    /// <p>This property can only be set when <code>EndpointType</code> is set to
    /// <code>VPC_ENDPOINT</code>.</p>
    /// <p>For more information, see
    /// https://docs.aws.amazon.com/transfer/latest/userguide/create-server-in-vpc.html#deprecate-vpc-endpoint.</p>
    /// </note>
    pub vpc_endpoint_id: std::option::Option<std::string::String>,
    /// <p>The VPC ID of the VPC in which a server's endpoint will be hosted.</p>
    /// <note>
    /// <p>This property can only be set when <code>EndpointType</code> is set to
    /// <code>VPC</code>.</p>
    /// </note>
    pub vpc_id: std::option::Option<std::string::String>,
    /// <p>A list of security groups IDs that are available to attach to your server's
    /// endpoint.</p>
    /// <note>
    /// <p>This property can only be set when <code>EndpointType</code> is set to
    /// <code>VPC</code>.</p>
    /// <p>You can edit the <code>SecurityGroupIds</code> property in the <a href="https://docs.aws.amazon.com/transfer/latest/userguide/API_UpdateServer.html">UpdateServer</a> API only if you are changing the <code>EndpointType</code> from
    /// <code>PUBLIC</code> or <code>VPC_ENDPOINT</code> to <code>VPC</code>. To change security
    /// groups associated with your server's VPC endpoint after creation, use the Amazon EC2
    /// <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyVpcEndpoint.html">ModifyVpcEndpoint</a> API.</p>
    /// </note>
    pub security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for EndpointDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EndpointDetails");
        formatter.field("address_allocation_ids", &self.address_allocation_ids);
        formatter.field("subnet_ids", &self.subnet_ids);
        formatter.field("vpc_endpoint_id", &self.vpc_endpoint_id);
        formatter.field("vpc_id", &self.vpc_id);
        formatter.field("security_group_ids", &self.security_group_ids);
        formatter.finish()
    }
}
/// See [`EndpointDetails`](crate::model::EndpointDetails)
pub mod endpoint_details {
    /// A builder for [`EndpointDetails`](crate::model::EndpointDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) address_allocation_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) subnet_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) vpc_endpoint_id: std::option::Option<std::string::String>,
        pub(crate) vpc_id: std::option::Option<std::string::String>,
        pub(crate) security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        pub fn address_allocation_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.address_allocation_ids.unwrap_or_default();
            v.push(input.into());
            self.address_allocation_ids = Some(v);
            self
        }
        pub fn set_address_allocation_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.address_allocation_ids = input;
            self
        }
        pub fn subnet_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.subnet_ids.unwrap_or_default();
            v.push(input.into());
            self.subnet_ids = Some(v);
            self
        }
        pub fn set_subnet_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.subnet_ids = input;
            self
        }
        /// <p>The ID of the VPC endpoint.</p>
        /// <note>
        /// <p>This property can only be set when <code>EndpointType</code> is set to
        /// <code>VPC_ENDPOINT</code>.</p>
        /// <p>For more information, see
        /// https://docs.aws.amazon.com/transfer/latest/userguide/create-server-in-vpc.html#deprecate-vpc-endpoint.</p>
        /// </note>
        pub fn vpc_endpoint_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_endpoint_id = Some(input.into());
            self
        }
        pub fn set_vpc_endpoint_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vpc_endpoint_id = input;
            self
        }
        /// <p>The VPC ID of the VPC in which a server's endpoint will be hosted.</p>
        /// <note>
        /// <p>This property can only be set when <code>EndpointType</code> is set to
        /// <code>VPC</code>.</p>
        /// </note>
        pub fn vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_id = Some(input.into());
            self
        }
        pub fn set_vpc_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vpc_id = input;
            self
        }
        pub fn security_group_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.security_group_ids.unwrap_or_default();
            v.push(input.into());
            self.security_group_ids = Some(v);
            self
        }
        pub fn set_security_group_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.security_group_ids = input;
            self
        }
        /// Consumes the builder and constructs a [`EndpointDetails`](crate::model::EndpointDetails)
        pub fn build(self) -> crate::model::EndpointDetails {
            crate::model::EndpointDetails {
                address_allocation_ids: self.address_allocation_ids,
                subnet_ids: self.subnet_ids,
                vpc_endpoint_id: self.vpc_endpoint_id,
                vpc_id: self.vpc_id,
                security_group_ids: self.security_group_ids,
            }
        }
    }
}
impl EndpointDetails {
    /// Creates a new builder-style object to manufacture [`EndpointDetails`](crate::model::EndpointDetails)
    pub fn builder() -> crate::model::endpoint_details::Builder {
        crate::model::endpoint_details::Builder::default()
    }
}

/// <p>
/// The protocol settings that are configured for your server.
/// </p>
/// <note>
/// <p>
/// This type is only valid in the <code>UpdateServer</code> API.
/// </p>
/// </note>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ProtocolDetails {
    /// <p>
    /// Indicates passive mode, for FTP and FTPS protocols.
    /// Enter a single dotted-quad IPv4 address, such as the external IP address of a firewall, router, or load balancer.
    /// For example:
    /// </p>
    /// <p>
    /// <code>
    /// aws transfer update-server --protocol-details PassiveIp=<i>0.0.0.0</i>
    /// </code>
    /// </p>
    /// <p>Replace <code>
    /// <i>0.0.0.0</i>
    /// </code> in the example above with the actual IP address you want to use.</p>
    pub passive_ip: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ProtocolDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ProtocolDetails");
        formatter.field("passive_ip", &self.passive_ip);
        formatter.finish()
    }
}
/// See [`ProtocolDetails`](crate::model::ProtocolDetails)
pub mod protocol_details {
    /// A builder for [`ProtocolDetails`](crate::model::ProtocolDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) passive_ip: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>
        /// Indicates passive mode, for FTP and FTPS protocols.
        /// Enter a single dotted-quad IPv4 address, such as the external IP address of a firewall, router, or load balancer.
        /// For example:
        /// </p>
        /// <p>
        /// <code>
        /// aws transfer update-server --protocol-details PassiveIp=<i>0.0.0.0</i>
        /// </code>
        /// </p>
        /// <p>Replace <code>
        /// <i>0.0.0.0</i>
        /// </code> in the example above with the actual IP address you want to use.</p>
        pub fn passive_ip(mut self, input: impl Into<std::string::String>) -> Self {
            self.passive_ip = Some(input.into());
            self
        }
        pub fn set_passive_ip(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.passive_ip = input;
            self
        }
        /// Consumes the builder and constructs a [`ProtocolDetails`](crate::model::ProtocolDetails)
        pub fn build(self) -> crate::model::ProtocolDetails {
            crate::model::ProtocolDetails {
                passive_ip: self.passive_ip,
            }
        }
    }
}
impl ProtocolDetails {
    /// Creates a new builder-style object to manufacture [`ProtocolDetails`](crate::model::ProtocolDetails)
    pub fn builder() -> crate::model::protocol_details::Builder {
        crate::model::protocol_details::Builder::default()
    }
}

/// <p>Creates a key-value pair for a specific resource. Tags are metadata that you can use to
/// search for and group a resource for various purposes. You can apply tags to servers, users,
/// and roles. A tag key can take more than one value. For example, to group servers for
/// accounting purposes, you might create a tag called <code>Group</code> and assign the values
/// <code>Research</code> and <code>Accounting</code> to that group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Tag {
    /// <p>The name assigned to the tag that you create.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>Contains one or more values that you assigned to the key name you create.</p>
    pub value: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Tag {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Tag");
        formatter.field("key", &self.key);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`Tag`](crate::model::Tag)
pub mod tag {
    /// A builder for [`Tag`](crate::model::Tag)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name assigned to the tag that you create.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>Contains one or more values that you assigned to the key name you create.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`Tag`](crate::model::Tag)
        pub fn build(self) -> crate::model::Tag {
            crate::model::Tag {
                key: self.key,
                value: self.value,
            }
        }
    }
}
impl Tag {
    /// Creates a new builder-style object to manufacture [`Tag`](crate::model::Tag)
    pub fn builder() -> crate::model::tag::Builder {
        crate::model::tag::Builder::default()
    }
}

/// <p>Returns properties of the user that you specify.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListedUser {
    /// <p>Provides the unique Amazon Resource Name (ARN) for the user that you want to learn
    /// about.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The landing directory (folder) for a user when they log in to the server using the client.</p>
    /// <p>A <code>HomeDirectory</code> example is <code>/bucket_name/home/mydirectory</code>.</p>
    pub home_directory: std::option::Option<std::string::String>,
    /// <p>The type of landing directory (folder) you want your users' home directory to be when they log into the server.
    /// If you set it to <code>PATH</code>, the user will see the absolute Amazon S3 bucket or EFS paths as is in their file transfer protocol clients.
    /// If you set it <code>LOGICAL</code>, you will need to provide mappings in the <code>HomeDirectoryMappings</code> for how you want to make Amazon
    /// S3 or EFS paths visible to your users.</p>
    pub home_directory_type: std::option::Option<crate::model::HomeDirectoryType>,
    /// <p>Specifies the Amazon Resource Name (ARN) of the IAM role that controls your users' access to your Amazon S3 bucket or EFS
    /// file system. The policies attached to this role determine the level of access that you want to provide your users when transferring
    /// files into and out of your Amazon S3 bucket or EFS file system. The IAM role should also contain a trust relationship that allows the
    /// server to access your resources when servicing your users' transfer requests.</p>
    /// <note>
    /// <p>The IAM role that controls your users' access to your Amazon S3 bucket for servers with <code>Domain=S3</code>, or your EFS file system for servers with <code>Domain=EFS</code>.
    /// </p>
    /// <p>The policies attached to this role determine the level of access you want to provide your users when
    /// transferring files into and out of your S3 buckets or EFS file systems.</p>
    /// </note>
    pub role: std::option::Option<std::string::String>,
    /// <p>Specifies the number of SSH public keys stored for the user you specified.</p>
    pub ssh_public_key_count: std::option::Option<i32>,
    /// <p>Specifies the name of the user whose ARN was specified. User names are used for
    /// authentication purposes.</p>
    pub user_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListedUser {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListedUser");
        formatter.field("arn", &self.arn);
        formatter.field("home_directory", &self.home_directory);
        formatter.field("home_directory_type", &self.home_directory_type);
        formatter.field("role", &self.role);
        formatter.field("ssh_public_key_count", &self.ssh_public_key_count);
        formatter.field("user_name", &self.user_name);
        formatter.finish()
    }
}
/// See [`ListedUser`](crate::model::ListedUser)
pub mod listed_user {
    /// A builder for [`ListedUser`](crate::model::ListedUser)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) home_directory: std::option::Option<std::string::String>,
        pub(crate) home_directory_type: std::option::Option<crate::model::HomeDirectoryType>,
        pub(crate) role: std::option::Option<std::string::String>,
        pub(crate) ssh_public_key_count: std::option::Option<i32>,
        pub(crate) user_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Provides the unique Amazon Resource Name (ARN) for the user that you want to learn
        /// about.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The landing directory (folder) for a user when they log in to the server using the client.</p>
        /// <p>A <code>HomeDirectory</code> example is <code>/bucket_name/home/mydirectory</code>.</p>
        pub fn home_directory(mut self, input: impl Into<std::string::String>) -> Self {
            self.home_directory = Some(input.into());
            self
        }
        pub fn set_home_directory(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.home_directory = input;
            self
        }
        /// <p>The type of landing directory (folder) you want your users' home directory to be when they log into the server.
        /// If you set it to <code>PATH</code>, the user will see the absolute Amazon S3 bucket or EFS paths as is in their file transfer protocol clients.
        /// If you set it <code>LOGICAL</code>, you will need to provide mappings in the <code>HomeDirectoryMappings</code> for how you want to make Amazon
        /// S3 or EFS paths visible to your users.</p>
        pub fn home_directory_type(mut self, input: crate::model::HomeDirectoryType) -> Self {
            self.home_directory_type = Some(input);
            self
        }
        pub fn set_home_directory_type(
            mut self,
            input: std::option::Option<crate::model::HomeDirectoryType>,
        ) -> Self {
            self.home_directory_type = input;
            self
        }
        /// <p>Specifies the Amazon Resource Name (ARN) of the IAM role that controls your users' access to your Amazon S3 bucket or EFS
        /// file system. The policies attached to this role determine the level of access that you want to provide your users when transferring
        /// files into and out of your Amazon S3 bucket or EFS file system. The IAM role should also contain a trust relationship that allows the
        /// server to access your resources when servicing your users' transfer requests.</p>
        /// <note>
        /// <p>The IAM role that controls your users' access to your Amazon S3 bucket for servers with <code>Domain=S3</code>, or your EFS file system for servers with <code>Domain=EFS</code>.
        /// </p>
        /// <p>The policies attached to this role determine the level of access you want to provide your users when
        /// transferring files into and out of your S3 buckets or EFS file systems.</p>
        /// </note>
        pub fn role(mut self, input: impl Into<std::string::String>) -> Self {
            self.role = Some(input.into());
            self
        }
        pub fn set_role(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role = input;
            self
        }
        /// <p>Specifies the number of SSH public keys stored for the user you specified.</p>
        pub fn ssh_public_key_count(mut self, input: i32) -> Self {
            self.ssh_public_key_count = Some(input);
            self
        }
        pub fn set_ssh_public_key_count(mut self, input: std::option::Option<i32>) -> Self {
            self.ssh_public_key_count = input;
            self
        }
        /// <p>Specifies the name of the user whose ARN was specified. User names are used for
        /// authentication purposes.</p>
        pub fn user_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_name = Some(input.into());
            self
        }
        pub fn set_user_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.user_name = input;
            self
        }
        /// Consumes the builder and constructs a [`ListedUser`](crate::model::ListedUser)
        pub fn build(self) -> crate::model::ListedUser {
            crate::model::ListedUser {
                arn: self.arn,
                home_directory: self.home_directory,
                home_directory_type: self.home_directory_type,
                role: self.role,
                ssh_public_key_count: self.ssh_public_key_count,
                user_name: self.user_name,
            }
        }
    }
}
impl ListedUser {
    /// Creates a new builder-style object to manufacture [`ListedUser`](crate::model::ListedUser)
    pub fn builder() -> crate::model::listed_user::Builder {
        crate::model::listed_user::Builder::default()
    }
}

/// <p>Returns properties of a file transfer protocol-enabled server that was specified.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListedServer {
    /// <p>Specifies the unique Amazon Resource Name (ARN) for a server to be listed.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>Specifies the domain of the storage system that is used for file transfers.</p>
    pub domain: std::option::Option<crate::model::Domain>,
    /// <p>Specifies the mode of authentication for a server. The default value is
    /// <code>SERVICE_MANAGED</code>, which allows you to store and access user credentials within
    /// the Amazon Web Services Transfer Family service.</p>
    /// <p>Use <code>AWS_DIRECTORY_SERVICE</code> to provide access to
    /// Active Directory groups in Amazon Web Services Managed Active Directory or Microsoft Active Directory in your
    /// on-premises environment or in Amazon Web Services using AD Connectors. This option also requires you to
    /// provide a Directory ID using the <code>IdentityProviderDetails</code> parameter.</p>
    /// <p>Use the <code>API_GATEWAY</code> value to integrate with an identity provider of your choosing. The
    /// <code>API_GATEWAY</code> setting requires you to provide an API Gateway endpoint URL to call
    /// for authentication using the <code>IdentityProviderDetails</code> parameter.</p>
    pub identity_provider_type: std::option::Option<crate::model::IdentityProviderType>,
    /// <p>Specifies the type of VPC endpoint that your server is connected to. If your server is
    /// connected to a VPC endpoint, your server isn't accessible over the public internet.</p>
    pub endpoint_type: std::option::Option<crate::model::EndpointType>,
    /// <p>Specifies the Amazon Resource Name (ARN) of the Amazon Web Services Identity and Access Management (IAM) role that allows a server to turn
    /// on Amazon CloudWatch logging for Amazon S3 or Amazon EFS events. When set, user activity can be viewed in
    /// your CloudWatch logs.</p>
    pub logging_role: std::option::Option<std::string::String>,
    /// <p>Specifies the unique system assigned identifier for the servers that were listed.</p>
    pub server_id: std::option::Option<std::string::String>,
    /// <p>Specifies the condition of a server for the server that was described. A value of
    /// <code>ONLINE</code> indicates that the server can accept jobs and transfer files. A
    /// <code>State</code> value of <code>OFFLINE</code> means that the server cannot perform file
    /// transfer operations.</p>
    /// <p>The states of <code>STARTING</code> and <code>STOPPING</code> indicate that the server is
    /// in an intermediate state, either not fully able to respond, or not fully offline. The values
    /// of <code>START_FAILED</code> or <code>STOP_FAILED</code> can indicate an error
    /// condition.</p>
    pub state: std::option::Option<crate::model::State>,
    /// <p>Specifies the number of users that are assigned to a server you specified with the
    /// <code>ServerId</code>.</p>
    pub user_count: std::option::Option<i32>,
}
impl std::fmt::Debug for ListedServer {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListedServer");
        formatter.field("arn", &self.arn);
        formatter.field("domain", &self.domain);
        formatter.field("identity_provider_type", &self.identity_provider_type);
        formatter.field("endpoint_type", &self.endpoint_type);
        formatter.field("logging_role", &self.logging_role);
        formatter.field("server_id", &self.server_id);
        formatter.field("state", &self.state);
        formatter.field("user_count", &self.user_count);
        formatter.finish()
    }
}
/// See [`ListedServer`](crate::model::ListedServer)
pub mod listed_server {
    /// A builder for [`ListedServer`](crate::model::ListedServer)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) domain: std::option::Option<crate::model::Domain>,
        pub(crate) identity_provider_type: std::option::Option<crate::model::IdentityProviderType>,
        pub(crate) endpoint_type: std::option::Option<crate::model::EndpointType>,
        pub(crate) logging_role: std::option::Option<std::string::String>,
        pub(crate) server_id: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::State>,
        pub(crate) user_count: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>Specifies the unique Amazon Resource Name (ARN) for a server to be listed.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>Specifies the domain of the storage system that is used for file transfers.</p>
        pub fn domain(mut self, input: crate::model::Domain) -> Self {
            self.domain = Some(input);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<crate::model::Domain>) -> Self {
            self.domain = input;
            self
        }
        /// <p>Specifies the mode of authentication for a server. The default value is
        /// <code>SERVICE_MANAGED</code>, which allows you to store and access user credentials within
        /// the Amazon Web Services Transfer Family service.</p>
        /// <p>Use <code>AWS_DIRECTORY_SERVICE</code> to provide access to
        /// Active Directory groups in Amazon Web Services Managed Active Directory or Microsoft Active Directory in your
        /// on-premises environment or in Amazon Web Services using AD Connectors. This option also requires you to
        /// provide a Directory ID using the <code>IdentityProviderDetails</code> parameter.</p>
        /// <p>Use the <code>API_GATEWAY</code> value to integrate with an identity provider of your choosing. The
        /// <code>API_GATEWAY</code> setting requires you to provide an API Gateway endpoint URL to call
        /// for authentication using the <code>IdentityProviderDetails</code> parameter.</p>
        pub fn identity_provider_type(mut self, input: crate::model::IdentityProviderType) -> Self {
            self.identity_provider_type = Some(input);
            self
        }
        pub fn set_identity_provider_type(
            mut self,
            input: std::option::Option<crate::model::IdentityProviderType>,
        ) -> Self {
            self.identity_provider_type = input;
            self
        }
        /// <p>Specifies the type of VPC endpoint that your server is connected to. If your server is
        /// connected to a VPC endpoint, your server isn't accessible over the public internet.</p>
        pub fn endpoint_type(mut self, input: crate::model::EndpointType) -> Self {
            self.endpoint_type = Some(input);
            self
        }
        pub fn set_endpoint_type(
            mut self,
            input: std::option::Option<crate::model::EndpointType>,
        ) -> Self {
            self.endpoint_type = input;
            self
        }
        /// <p>Specifies the Amazon Resource Name (ARN) of the Amazon Web Services Identity and Access Management (IAM) role that allows a server to turn
        /// on Amazon CloudWatch logging for Amazon S3 or Amazon EFS events. When set, user activity can be viewed in
        /// your CloudWatch logs.</p>
        pub fn logging_role(mut self, input: impl Into<std::string::String>) -> Self {
            self.logging_role = Some(input.into());
            self
        }
        pub fn set_logging_role(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.logging_role = input;
            self
        }
        /// <p>Specifies the unique system assigned identifier for the servers that were listed.</p>
        pub fn server_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.server_id = Some(input.into());
            self
        }
        pub fn set_server_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.server_id = input;
            self
        }
        /// <p>Specifies the condition of a server for the server that was described. A value of
        /// <code>ONLINE</code> indicates that the server can accept jobs and transfer files. A
        /// <code>State</code> value of <code>OFFLINE</code> means that the server cannot perform file
        /// transfer operations.</p>
        /// <p>The states of <code>STARTING</code> and <code>STOPPING</code> indicate that the server is
        /// in an intermediate state, either not fully able to respond, or not fully offline. The values
        /// of <code>START_FAILED</code> or <code>STOP_FAILED</code> can indicate an error
        /// condition.</p>
        pub fn state(mut self, input: crate::model::State) -> Self {
            self.state = Some(input);
            self
        }
        pub fn set_state(mut self, input: std::option::Option<crate::model::State>) -> Self {
            self.state = input;
            self
        }
        /// <p>Specifies the number of users that are assigned to a server you specified with the
        /// <code>ServerId</code>.</p>
        pub fn user_count(mut self, input: i32) -> Self {
            self.user_count = Some(input);
            self
        }
        pub fn set_user_count(mut self, input: std::option::Option<i32>) -> Self {
            self.user_count = input;
            self
        }
        /// Consumes the builder and constructs a [`ListedServer`](crate::model::ListedServer)
        pub fn build(self) -> crate::model::ListedServer {
            crate::model::ListedServer {
                arn: self.arn,
                domain: self.domain,
                identity_provider_type: self.identity_provider_type,
                endpoint_type: self.endpoint_type,
                logging_role: self.logging_role,
                server_id: self.server_id,
                state: self.state,
                user_count: self.user_count,
            }
        }
    }
}
impl ListedServer {
    /// Creates a new builder-style object to manufacture [`ListedServer`](crate::model::ListedServer)
    pub fn builder() -> crate::model::listed_server::Builder {
        crate::model::listed_server::Builder::default()
    }
}

/// <p>Describes the condition of a file transfer protocol-enabled server with respect to its
/// ability to perform file operations. There are six possible states: <code>OFFLINE</code>,
/// <code>ONLINE</code>, <code>STARTING</code>, <code>STOPPING</code>,
/// <code>START_FAILED</code>, and <code>STOP_FAILED</code>.</p>
/// <p>
/// <code>OFFLINE</code> indicates that the server exists, but that it is not available for
/// file operations. <code>ONLINE</code> indicates that the server is available to perform file
/// operations. <code>STARTING</code> indicates that the server's was instantiated, but the
/// server is not yet available to perform file operations. Under normal conditions, it can take a
/// couple of minutes for the server to be completely operational. Both <code>START_FAILED</code>
/// and <code>STOP_FAILED</code> are error conditions.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum State {
    Offline,
    Online,
    Starting,
    StartFailed,
    Stopping,
    StopFailed,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for State {
    fn from(s: &str) -> Self {
        match s {
            "OFFLINE" => State::Offline,
            "ONLINE" => State::Online,
            "STARTING" => State::Starting,
            "START_FAILED" => State::StartFailed,
            "STOPPING" => State::Stopping,
            "STOP_FAILED" => State::StopFailed,
            other => State::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for State {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(State::from(s))
    }
}
impl State {
    pub fn as_str(&self) -> &str {
        match self {
            State::Offline => "OFFLINE",
            State::Online => "ONLINE",
            State::Starting => "STARTING",
            State::StartFailed => "START_FAILED",
            State::Stopping => "STOPPING",
            State::StopFailed => "STOP_FAILED",
            State::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "OFFLINE",
            "ONLINE",
            "STARTING",
            "START_FAILED",
            "STOPPING",
            "STOP_FAILED",
        ]
    }
}
impl AsRef<str> for State {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Returns information related to the type of user authentication that is in use for a file
/// transfer protocol-enabled server's users. For <code>AWS_DIRECTORY_SERVICE</code> or <code>SERVICE_MANAGED</code>
/// authentication, the Secure Shell (SSH) public keys are stored with a user on the server
/// instance. For <code>API_GATEWAY</code> authentication, your custom authentication method is
/// implemented by using an API call. The server can have only one method of
/// authentication.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum IdentityProviderType {
    ApiGateway,
    AwsDirectoryService,
    ServiceManaged,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for IdentityProviderType {
    fn from(s: &str) -> Self {
        match s {
            "API_GATEWAY" => IdentityProviderType::ApiGateway,
            "AWS_DIRECTORY_SERVICE" => IdentityProviderType::AwsDirectoryService,
            "SERVICE_MANAGED" => IdentityProviderType::ServiceManaged,
            other => IdentityProviderType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for IdentityProviderType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(IdentityProviderType::from(s))
    }
}
impl IdentityProviderType {
    pub fn as_str(&self) -> &str {
        match self {
            IdentityProviderType::ApiGateway => "API_GATEWAY",
            IdentityProviderType::AwsDirectoryService => "AWS_DIRECTORY_SERVICE",
            IdentityProviderType::ServiceManaged => "SERVICE_MANAGED",
            IdentityProviderType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["API_GATEWAY", "AWS_DIRECTORY_SERVICE", "SERVICE_MANAGED"]
    }
}
impl AsRef<str> for IdentityProviderType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Domain {
    Efs,
    S3,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for Domain {
    fn from(s: &str) -> Self {
        match s {
            "EFS" => Domain::Efs,
            "S3" => Domain::S3,
            other => Domain::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for Domain {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Domain::from(s))
    }
}
impl Domain {
    pub fn as_str(&self) -> &str {
        match self {
            Domain::Efs => "EFS",
            Domain::S3 => "S3",
            Domain::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["EFS", "S3"]
    }
}
impl AsRef<str> for Domain {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Lists the properties for one or more specified associated accesses.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListedAccess {
    /// <p>The landing directory (folder) for a user when they log in to the server using the client.</p>
    /// <p>A <code>HomeDirectory</code> example is <code>/bucket_name/home/mydirectory</code>.</p>
    pub home_directory: std::option::Option<std::string::String>,
    /// <p>The type of landing directory (folder) you want your users' home directory to be when they log into the server.
    /// If you set it to <code>PATH</code>, the user will see the absolute Amazon S3 bucket or EFS paths as is in their file transfer protocol clients.
    /// If you set it <code>LOGICAL</code>, you will need to provide mappings in the <code>HomeDirectoryMappings</code> for how you want to make Amazon
    /// S3 or EFS paths visible to your users.</p>
    pub home_directory_type: std::option::Option<crate::model::HomeDirectoryType>,
    /// <p>Specifies the Amazon Resource Name (ARN) of the IAM role that controls your users' access to your Amazon S3 bucket or EFS
    /// file system. The policies attached to this role determine the level of access that you want to provide your users when transferring
    /// files into and out of your Amazon S3 bucket or EFS file system. The IAM role should also contain a trust relationship that allows the
    /// server to access your resources when servicing your users' transfer requests.</p>
    pub role: std::option::Option<std::string::String>,
    /// <p>A unique identifier that is required to identify specific groups within your directory.
    /// The users of the group that you associate have access to your Amazon S3 or Amazon EFS
    /// resources over the enabled protocols using Amazon Web Services Transfer Family. If you know the group name,
    /// you can view the SID values by running the following command using Windows PowerShell.</p>
    /// <p>
    /// <code>Get-ADGroup -Filter {samAccountName -like "<i>YourGroupName</i>*"} -Properties * | Select SamAccountName,ObjectSid</code>
    /// </p>
    /// <p>In that command, replace <i>YourGroupName</i> with the name of your Active Directory group.</p>
    /// <p>The regex used to validate this parameter is a string of characters consisting of uppercase and lowercase alphanumeric characters with no spaces.
    /// You can also include underscores or any of the following characters: =,.@:/-</p>
    pub external_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListedAccess {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListedAccess");
        formatter.field("home_directory", &self.home_directory);
        formatter.field("home_directory_type", &self.home_directory_type);
        formatter.field("role", &self.role);
        formatter.field("external_id", &self.external_id);
        formatter.finish()
    }
}
/// See [`ListedAccess`](crate::model::ListedAccess)
pub mod listed_access {
    /// A builder for [`ListedAccess`](crate::model::ListedAccess)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) home_directory: std::option::Option<std::string::String>,
        pub(crate) home_directory_type: std::option::Option<crate::model::HomeDirectoryType>,
        pub(crate) role: std::option::Option<std::string::String>,
        pub(crate) external_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The landing directory (folder) for a user when they log in to the server using the client.</p>
        /// <p>A <code>HomeDirectory</code> example is <code>/bucket_name/home/mydirectory</code>.</p>
        pub fn home_directory(mut self, input: impl Into<std::string::String>) -> Self {
            self.home_directory = Some(input.into());
            self
        }
        pub fn set_home_directory(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.home_directory = input;
            self
        }
        /// <p>The type of landing directory (folder) you want your users' home directory to be when they log into the server.
        /// If you set it to <code>PATH</code>, the user will see the absolute Amazon S3 bucket or EFS paths as is in their file transfer protocol clients.
        /// If you set it <code>LOGICAL</code>, you will need to provide mappings in the <code>HomeDirectoryMappings</code> for how you want to make Amazon
        /// S3 or EFS paths visible to your users.</p>
        pub fn home_directory_type(mut self, input: crate::model::HomeDirectoryType) -> Self {
            self.home_directory_type = Some(input);
            self
        }
        pub fn set_home_directory_type(
            mut self,
            input: std::option::Option<crate::model::HomeDirectoryType>,
        ) -> Self {
            self.home_directory_type = input;
            self
        }
        /// <p>Specifies the Amazon Resource Name (ARN) of the IAM role that controls your users' access to your Amazon S3 bucket or EFS
        /// file system. The policies attached to this role determine the level of access that you want to provide your users when transferring
        /// files into and out of your Amazon S3 bucket or EFS file system. The IAM role should also contain a trust relationship that allows the
        /// server to access your resources when servicing your users' transfer requests.</p>
        pub fn role(mut self, input: impl Into<std::string::String>) -> Self {
            self.role = Some(input.into());
            self
        }
        pub fn set_role(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role = input;
            self
        }
        /// <p>A unique identifier that is required to identify specific groups within your directory.
        /// The users of the group that you associate have access to your Amazon S3 or Amazon EFS
        /// resources over the enabled protocols using Amazon Web Services Transfer Family. If you know the group name,
        /// you can view the SID values by running the following command using Windows PowerShell.</p>
        /// <p>
        /// <code>Get-ADGroup -Filter {samAccountName -like "<i>YourGroupName</i>*"} -Properties * | Select SamAccountName,ObjectSid</code>
        /// </p>
        /// <p>In that command, replace <i>YourGroupName</i> with the name of your Active Directory group.</p>
        /// <p>The regex used to validate this parameter is a string of characters consisting of uppercase and lowercase alphanumeric characters with no spaces.
        /// You can also include underscores or any of the following characters: =,.@:/-</p>
        pub fn external_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.external_id = Some(input.into());
            self
        }
        pub fn set_external_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.external_id = input;
            self
        }
        /// Consumes the builder and constructs a [`ListedAccess`](crate::model::ListedAccess)
        pub fn build(self) -> crate::model::ListedAccess {
            crate::model::ListedAccess {
                home_directory: self.home_directory,
                home_directory_type: self.home_directory_type,
                role: self.role,
                external_id: self.external_id,
            }
        }
    }
}
impl ListedAccess {
    /// Creates a new builder-style object to manufacture [`ListedAccess`](crate::model::ListedAccess)
    pub fn builder() -> crate::model::listed_access::Builder {
        crate::model::listed_access::Builder::default()
    }
}

/// <p>Describes the properties of a user that was specified.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribedUser {
    /// <p>Specifies the unique Amazon Resource Name (ARN) for the user that was requested to be
    /// described.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The landing directory (folder) for a user when they log in to the server using the client.</p>
    /// <p>A <code>HomeDirectory</code> example is <code>/bucket_name/home/mydirectory</code>.</p>
    pub home_directory: std::option::Option<std::string::String>,
    /// <p>Logical directory mappings that specify what Amazon S3 or Amazon EFS paths and keys should
    /// be visible to your user and how you want to make them visible. You must specify the
    /// <code>Entry</code> and <code>Target</code> pair, where <code>Entry</code> shows how the path
    /// is made visible and <code>Target</code> is the actual Amazon S3 or Amazon EFS path. If you
    /// only specify a target, it is displayed as is. You also must ensure that your Amazon Web Services Identity
    /// and Access Management (IAM) role provides access to paths in <code>Target</code>. This value
    /// can only be set when <code>HomeDirectoryType</code> is set to
    /// <i>LOGICAL</i>.</p>
    /// <p>In most cases, you can use this value instead of the scope-down policy to lock your user
    /// down to the designated home directory ("<code>chroot</code>"). To do this, you can set
    /// <code>Entry</code> to '/' and set <code>Target</code> to the HomeDirectory
    /// parameter value.</p>
    pub home_directory_mappings:
        std::option::Option<std::vec::Vec<crate::model::HomeDirectoryMapEntry>>,
    /// <p>The type of landing directory (folder) you want your users' home directory to be when they log into the server.
    /// If you set it to <code>PATH</code>, the user will see the absolute Amazon S3 bucket or EFS paths as is in their file transfer protocol clients.
    /// If you set it <code>LOGICAL</code>, you will need to provide mappings in the <code>HomeDirectoryMappings</code> for how you want to make Amazon
    /// S3 or EFS paths visible to your users.</p>
    pub home_directory_type: std::option::Option<crate::model::HomeDirectoryType>,
    /// <p>A scope-down policy for your user so that you can use the same IAM role across multiple users. This policy scopes down user
    /// access to portions of their Amazon S3 bucket. Variables that you can use inside this policy include <code>${Transfer:UserName}</code>,
    /// <code>${Transfer:HomeDirectory}</code>, and <code>${Transfer:HomeBucket}</code>.</p>
    pub policy: std::option::Option<std::string::String>,
    /// <p>Specifies the full POSIX identity, including user ID (<code>Uid</code>), group ID
    /// (<code>Gid</code>), and any secondary groups IDs (<code>SecondaryGids</code>), that controls
    /// your users' access to your Amazon Elastic File System (Amazon EFS) file systems. The POSIX
    /// permissions that are set on files and directories in your file system determine the level of
    /// access your users get when transferring files into and out of your Amazon EFS file
    /// systems.</p>
    pub posix_profile: std::option::Option<crate::model::PosixProfile>,
    /// <p>Specifies the Amazon Resource Name (ARN) of the IAM role that controls your users' access to your Amazon S3 bucket or EFS
    /// file system. The policies attached to this role determine the level of access that you want to provide your users when transferring
    /// files into and out of your Amazon S3 bucket or EFS file system. The IAM role should also contain a trust relationship that allows the
    /// server to access your resources when servicing your users' transfer requests.</p>
    pub role: std::option::Option<std::string::String>,
    /// <p>Specifies the public key portion of the Secure Shell (SSH) keys stored for the described
    /// user.</p>
    pub ssh_public_keys: std::option::Option<std::vec::Vec<crate::model::SshPublicKey>>,
    /// <p>Specifies the key-value pairs for the user requested. Tag can be used to search for and
    /// group users for a variety of purposes.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>Specifies the name of the user that was requested to be described. User names are used for
    /// authentication purposes. This is the string that will be used by your user when they log in to
    /// your server.</p>
    pub user_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribedUser {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribedUser");
        formatter.field("arn", &self.arn);
        formatter.field("home_directory", &self.home_directory);
        formatter.field("home_directory_mappings", &self.home_directory_mappings);
        formatter.field("home_directory_type", &self.home_directory_type);
        formatter.field("policy", &self.policy);
        formatter.field("posix_profile", &self.posix_profile);
        formatter.field("role", &self.role);
        formatter.field("ssh_public_keys", &self.ssh_public_keys);
        formatter.field("tags", &self.tags);
        formatter.field("user_name", &self.user_name);
        formatter.finish()
    }
}
/// See [`DescribedUser`](crate::model::DescribedUser)
pub mod described_user {
    /// A builder for [`DescribedUser`](crate::model::DescribedUser)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) home_directory: std::option::Option<std::string::String>,
        pub(crate) home_directory_mappings:
            std::option::Option<std::vec::Vec<crate::model::HomeDirectoryMapEntry>>,
        pub(crate) home_directory_type: std::option::Option<crate::model::HomeDirectoryType>,
        pub(crate) policy: std::option::Option<std::string::String>,
        pub(crate) posix_profile: std::option::Option<crate::model::PosixProfile>,
        pub(crate) role: std::option::Option<std::string::String>,
        pub(crate) ssh_public_keys: std::option::Option<std::vec::Vec<crate::model::SshPublicKey>>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) user_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Specifies the unique Amazon Resource Name (ARN) for the user that was requested to be
        /// described.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The landing directory (folder) for a user when they log in to the server using the client.</p>
        /// <p>A <code>HomeDirectory</code> example is <code>/bucket_name/home/mydirectory</code>.</p>
        pub fn home_directory(mut self, input: impl Into<std::string::String>) -> Self {
            self.home_directory = Some(input.into());
            self
        }
        pub fn set_home_directory(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.home_directory = input;
            self
        }
        pub fn home_directory_mappings(
            mut self,
            input: impl Into<crate::model::HomeDirectoryMapEntry>,
        ) -> Self {
            let mut v = self.home_directory_mappings.unwrap_or_default();
            v.push(input.into());
            self.home_directory_mappings = Some(v);
            self
        }
        pub fn set_home_directory_mappings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::HomeDirectoryMapEntry>>,
        ) -> Self {
            self.home_directory_mappings = input;
            self
        }
        /// <p>The type of landing directory (folder) you want your users' home directory to be when they log into the server.
        /// If you set it to <code>PATH</code>, the user will see the absolute Amazon S3 bucket or EFS paths as is in their file transfer protocol clients.
        /// If you set it <code>LOGICAL</code>, you will need to provide mappings in the <code>HomeDirectoryMappings</code> for how you want to make Amazon
        /// S3 or EFS paths visible to your users.</p>
        pub fn home_directory_type(mut self, input: crate::model::HomeDirectoryType) -> Self {
            self.home_directory_type = Some(input);
            self
        }
        pub fn set_home_directory_type(
            mut self,
            input: std::option::Option<crate::model::HomeDirectoryType>,
        ) -> Self {
            self.home_directory_type = input;
            self
        }
        /// <p>A scope-down policy for your user so that you can use the same IAM role across multiple users. This policy scopes down user
        /// access to portions of their Amazon S3 bucket. Variables that you can use inside this policy include <code>${Transfer:UserName}</code>,
        /// <code>${Transfer:HomeDirectory}</code>, and <code>${Transfer:HomeBucket}</code>.</p>
        pub fn policy(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy = Some(input.into());
            self
        }
        pub fn set_policy(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.policy = input;
            self
        }
        /// <p>Specifies the full POSIX identity, including user ID (<code>Uid</code>), group ID
        /// (<code>Gid</code>), and any secondary groups IDs (<code>SecondaryGids</code>), that controls
        /// your users' access to your Amazon Elastic File System (Amazon EFS) file systems. The POSIX
        /// permissions that are set on files and directories in your file system determine the level of
        /// access your users get when transferring files into and out of your Amazon EFS file
        /// systems.</p>
        pub fn posix_profile(mut self, input: crate::model::PosixProfile) -> Self {
            self.posix_profile = Some(input);
            self
        }
        pub fn set_posix_profile(
            mut self,
            input: std::option::Option<crate::model::PosixProfile>,
        ) -> Self {
            self.posix_profile = input;
            self
        }
        /// <p>Specifies the Amazon Resource Name (ARN) of the IAM role that controls your users' access to your Amazon S3 bucket or EFS
        /// file system. The policies attached to this role determine the level of access that you want to provide your users when transferring
        /// files into and out of your Amazon S3 bucket or EFS file system. The IAM role should also contain a trust relationship that allows the
        /// server to access your resources when servicing your users' transfer requests.</p>
        pub fn role(mut self, input: impl Into<std::string::String>) -> Self {
            self.role = Some(input.into());
            self
        }
        pub fn set_role(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role = input;
            self
        }
        pub fn ssh_public_keys(mut self, input: impl Into<crate::model::SshPublicKey>) -> Self {
            let mut v = self.ssh_public_keys.unwrap_or_default();
            v.push(input.into());
            self.ssh_public_keys = Some(v);
            self
        }
        pub fn set_ssh_public_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SshPublicKey>>,
        ) -> Self {
            self.ssh_public_keys = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>Specifies the name of the user that was requested to be described. User names are used for
        /// authentication purposes. This is the string that will be used by your user when they log in to
        /// your server.</p>
        pub fn user_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_name = Some(input.into());
            self
        }
        pub fn set_user_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.user_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribedUser`](crate::model::DescribedUser)
        pub fn build(self) -> crate::model::DescribedUser {
            crate::model::DescribedUser {
                arn: self.arn,
                home_directory: self.home_directory,
                home_directory_mappings: self.home_directory_mappings,
                home_directory_type: self.home_directory_type,
                policy: self.policy,
                posix_profile: self.posix_profile,
                role: self.role,
                ssh_public_keys: self.ssh_public_keys,
                tags: self.tags,
                user_name: self.user_name,
            }
        }
    }
}
impl DescribedUser {
    /// Creates a new builder-style object to manufacture [`DescribedUser`](crate::model::DescribedUser)
    pub fn builder() -> crate::model::described_user::Builder {
        crate::model::described_user::Builder::default()
    }
}

/// <p>Provides information about the public Secure Shell (SSH) key that is associated with a
/// user account for the specific file transfer protocol-enabled server (as identified by
/// <code>ServerId</code>). The information returned includes the date the key was imported, the
/// public key contents, and the public key ID. A user can store more than one SSH public key
/// associated with their user name on a specific server.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SshPublicKey {
    /// <p>Specifies the date that the public key was added to the user account.</p>
    pub date_imported: std::option::Option<smithy_types::Instant>,
    /// <p>Specifies the content of the SSH public key as specified by the
    /// <code>PublicKeyId</code>.</p>
    pub ssh_public_key_body: std::option::Option<std::string::String>,
    /// <p>Specifies the <code>SshPublicKeyId</code> parameter contains the identifier of the public
    /// key.</p>
    pub ssh_public_key_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SshPublicKey {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SshPublicKey");
        formatter.field("date_imported", &self.date_imported);
        formatter.field("ssh_public_key_body", &self.ssh_public_key_body);
        formatter.field("ssh_public_key_id", &self.ssh_public_key_id);
        formatter.finish()
    }
}
/// See [`SshPublicKey`](crate::model::SshPublicKey)
pub mod ssh_public_key {
    /// A builder for [`SshPublicKey`](crate::model::SshPublicKey)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) date_imported: std::option::Option<smithy_types::Instant>,
        pub(crate) ssh_public_key_body: std::option::Option<std::string::String>,
        pub(crate) ssh_public_key_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Specifies the date that the public key was added to the user account.</p>
        pub fn date_imported(mut self, input: smithy_types::Instant) -> Self {
            self.date_imported = Some(input);
            self
        }
        pub fn set_date_imported(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.date_imported = input;
            self
        }
        /// <p>Specifies the content of the SSH public key as specified by the
        /// <code>PublicKeyId</code>.</p>
        pub fn ssh_public_key_body(mut self, input: impl Into<std::string::String>) -> Self {
            self.ssh_public_key_body = Some(input.into());
            self
        }
        pub fn set_ssh_public_key_body(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ssh_public_key_body = input;
            self
        }
        /// <p>Specifies the <code>SshPublicKeyId</code> parameter contains the identifier of the public
        /// key.</p>
        pub fn ssh_public_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.ssh_public_key_id = Some(input.into());
            self
        }
        pub fn set_ssh_public_key_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ssh_public_key_id = input;
            self
        }
        /// Consumes the builder and constructs a [`SshPublicKey`](crate::model::SshPublicKey)
        pub fn build(self) -> crate::model::SshPublicKey {
            crate::model::SshPublicKey {
                date_imported: self.date_imported,
                ssh_public_key_body: self.ssh_public_key_body,
                ssh_public_key_id: self.ssh_public_key_id,
            }
        }
    }
}
impl SshPublicKey {
    /// Creates a new builder-style object to manufacture [`SshPublicKey`](crate::model::SshPublicKey)
    pub fn builder() -> crate::model::ssh_public_key::Builder {
        crate::model::ssh_public_key::Builder::default()
    }
}

/// <p>Describes the properties of a file transfer protocol-enabled server that was
/// specified.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribedServer {
    /// <p>Specifies the unique Amazon Resource Name (ARN) of the server.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>Specifies the ARN of the Amazon Web ServicesCertificate Manager (ACM) certificate. Required when
    /// <code>Protocols</code> is set to <code>FTPS</code>.</p>
    pub certificate: std::option::Option<std::string::String>,
    /// <p>
    /// The protocol settings that are configured for your server.
    /// </p>
    /// <p>
    /// Use the <code>PassiveIp</code> parameter to indicate passive mode.
    /// Enter a single dotted-quad IPv4 address, such as the external IP address of a firewall, router, or load balancer.
    /// </p>
    pub protocol_details: std::option::Option<crate::model::ProtocolDetails>,
    /// <p>Specifies the domain of the storage system that is used for file transfers.</p>
    pub domain: std::option::Option<crate::model::Domain>,
    /// <p>The virtual private cloud (VPC) endpoint settings that are configured for your server.
    /// When you host your endpoint within your VPC, you can make it accessible only to resources
    /// within your VPC, or you can attach Elastic IP addresses and make it accessible to clients over
    /// the internet. Your VPC's default security groups are automatically assigned to your
    /// endpoint.</p>
    pub endpoint_details: std::option::Option<crate::model::EndpointDetails>,
    /// <p>Defines the type of endpoint that your server is connected to. If your server is connected
    /// to a VPC endpoint, your server isn't accessible over the public internet.</p>
    pub endpoint_type: std::option::Option<crate::model::EndpointType>,
    /// <p>Specifies the Base64-encoded SHA256 fingerprint of the server's host key. This value
    /// is equivalent to the output of the <code>ssh-keygen -l -f my-new-server-key</code>
    /// command.</p>
    pub host_key_fingerprint: std::option::Option<std::string::String>,
    /// <p>Specifies information to call a customer-supplied authentication API. This field is not
    /// populated when the <code>IdentityProviderType</code> of a server is
    /// <code>AWS_DIRECTORY_SERVICE</code> or <code>SERVICE_MANAGED</code>.</p>
    pub identity_provider_details: std::option::Option<crate::model::IdentityProviderDetails>,
    /// <p>Specifies the mode of authentication for a server. The default value is
    /// <code>SERVICE_MANAGED</code>, which allows you to store and access user credentials within
    /// the Amazon Web Services Transfer Family service.</p>
    /// <p>Use <code>AWS_DIRECTORY_SERVICE</code> to provide access to
    /// Active Directory groups in Amazon Web Services Managed Active Directory or Microsoft Active Directory in your
    /// on-premises environment or in Amazon Web Services using AD Connectors. This option also requires you to
    /// provide a Directory ID using the <code>IdentityProviderDetails</code> parameter.</p>
    /// <p>Use the <code>API_GATEWAY</code> value to integrate with an identity provider of your choosing. The
    /// <code>API_GATEWAY</code> setting requires you to provide an API Gateway endpoint URL to call
    /// for authentication using the <code>IdentityProviderDetails</code> parameter.</p>
    pub identity_provider_type: std::option::Option<crate::model::IdentityProviderType>,
    /// <p>Specifies the Amazon Resource Name (ARN) of the Amazon Web Services Identity and Access Management (IAM) role that allows a server to turn
    /// on Amazon CloudWatch logging for Amazon S3 or Amazon EFS events. When set, user activity can be viewed in
    /// your CloudWatch logs.</p>
    pub logging_role: std::option::Option<std::string::String>,
    /// <p>Specifies the file transfer protocol or protocols over which your file transfer protocol
    /// client can connect to your server's endpoint. The available protocols are:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>SFTP</code> (Secure Shell (SSH) File Transfer Protocol): File transfer over
    /// SSH</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>FTPS</code> (File Transfer Protocol Secure): File transfer with TLS
    /// encryption</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>FTP</code> (File Transfer Protocol): Unencrypted file transfer</p>
    /// </li>
    /// </ul>
    pub protocols: std::option::Option<std::vec::Vec<crate::model::Protocol>>,
    /// <p>Specifies the name of the security policy that is attached to the server.</p>
    pub security_policy_name: std::option::Option<std::string::String>,
    /// <p>Specifies the unique system-assigned identifier for a server that you instantiate.</p>
    pub server_id: std::option::Option<std::string::String>,
    /// <p>Specifies the condition of a server for the server that was described. A value of
    /// <code>ONLINE</code> indicates that the server can accept jobs and transfer files. A
    /// <code>State</code> value of <code>OFFLINE</code> means that the server cannot perform file
    /// transfer operations.</p>
    /// <p>The states of <code>STARTING</code> and <code>STOPPING</code> indicate that the server is
    /// in an intermediate state, either not fully able to respond, or not fully offline. The values
    /// of <code>START_FAILED</code> or <code>STOP_FAILED</code> can indicate an error
    /// condition.</p>
    pub state: std::option::Option<crate::model::State>,
    /// <p>Specifies the key-value pairs that you can use to search for and group servers that were
    /// assigned to the server that was described.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>Specifies the number of users that are assigned to a server you specified with the
    /// <code>ServerId</code>.</p>
    pub user_count: std::option::Option<i32>,
}
impl std::fmt::Debug for DescribedServer {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribedServer");
        formatter.field("arn", &self.arn);
        formatter.field("certificate", &self.certificate);
        formatter.field("protocol_details", &self.protocol_details);
        formatter.field("domain", &self.domain);
        formatter.field("endpoint_details", &self.endpoint_details);
        formatter.field("endpoint_type", &self.endpoint_type);
        formatter.field("host_key_fingerprint", &self.host_key_fingerprint);
        formatter.field("identity_provider_details", &self.identity_provider_details);
        formatter.field("identity_provider_type", &self.identity_provider_type);
        formatter.field("logging_role", &self.logging_role);
        formatter.field("protocols", &self.protocols);
        formatter.field("security_policy_name", &self.security_policy_name);
        formatter.field("server_id", &self.server_id);
        formatter.field("state", &self.state);
        formatter.field("tags", &self.tags);
        formatter.field("user_count", &self.user_count);
        formatter.finish()
    }
}
/// See [`DescribedServer`](crate::model::DescribedServer)
pub mod described_server {
    /// A builder for [`DescribedServer`](crate::model::DescribedServer)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) certificate: std::option::Option<std::string::String>,
        pub(crate) protocol_details: std::option::Option<crate::model::ProtocolDetails>,
        pub(crate) domain: std::option::Option<crate::model::Domain>,
        pub(crate) endpoint_details: std::option::Option<crate::model::EndpointDetails>,
        pub(crate) endpoint_type: std::option::Option<crate::model::EndpointType>,
        pub(crate) host_key_fingerprint: std::option::Option<std::string::String>,
        pub(crate) identity_provider_details:
            std::option::Option<crate::model::IdentityProviderDetails>,
        pub(crate) identity_provider_type: std::option::Option<crate::model::IdentityProviderType>,
        pub(crate) logging_role: std::option::Option<std::string::String>,
        pub(crate) protocols: std::option::Option<std::vec::Vec<crate::model::Protocol>>,
        pub(crate) security_policy_name: std::option::Option<std::string::String>,
        pub(crate) server_id: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::State>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) user_count: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>Specifies the unique Amazon Resource Name (ARN) of the server.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>Specifies the ARN of the Amazon Web ServicesCertificate Manager (ACM) certificate. Required when
        /// <code>Protocols</code> is set to <code>FTPS</code>.</p>
        pub fn certificate(mut self, input: impl Into<std::string::String>) -> Self {
            self.certificate = Some(input.into());
            self
        }
        pub fn set_certificate(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.certificate = input;
            self
        }
        /// <p>
        /// The protocol settings that are configured for your server.
        /// </p>
        /// <p>
        /// Use the <code>PassiveIp</code> parameter to indicate passive mode.
        /// Enter a single dotted-quad IPv4 address, such as the external IP address of a firewall, router, or load balancer.
        /// </p>
        pub fn protocol_details(mut self, input: crate::model::ProtocolDetails) -> Self {
            self.protocol_details = Some(input);
            self
        }
        pub fn set_protocol_details(
            mut self,
            input: std::option::Option<crate::model::ProtocolDetails>,
        ) -> Self {
            self.protocol_details = input;
            self
        }
        /// <p>Specifies the domain of the storage system that is used for file transfers.</p>
        pub fn domain(mut self, input: crate::model::Domain) -> Self {
            self.domain = Some(input);
            self
        }
        pub fn set_domain(mut self, input: std::option::Option<crate::model::Domain>) -> Self {
            self.domain = input;
            self
        }
        /// <p>The virtual private cloud (VPC) endpoint settings that are configured for your server.
        /// When you host your endpoint within your VPC, you can make it accessible only to resources
        /// within your VPC, or you can attach Elastic IP addresses and make it accessible to clients over
        /// the internet. Your VPC's default security groups are automatically assigned to your
        /// endpoint.</p>
        pub fn endpoint_details(mut self, input: crate::model::EndpointDetails) -> Self {
            self.endpoint_details = Some(input);
            self
        }
        pub fn set_endpoint_details(
            mut self,
            input: std::option::Option<crate::model::EndpointDetails>,
        ) -> Self {
            self.endpoint_details = input;
            self
        }
        /// <p>Defines the type of endpoint that your server is connected to. If your server is connected
        /// to a VPC endpoint, your server isn't accessible over the public internet.</p>
        pub fn endpoint_type(mut self, input: crate::model::EndpointType) -> Self {
            self.endpoint_type = Some(input);
            self
        }
        pub fn set_endpoint_type(
            mut self,
            input: std::option::Option<crate::model::EndpointType>,
        ) -> Self {
            self.endpoint_type = input;
            self
        }
        /// <p>Specifies the Base64-encoded SHA256 fingerprint of the server's host key. This value
        /// is equivalent to the output of the <code>ssh-keygen -l -f my-new-server-key</code>
        /// command.</p>
        pub fn host_key_fingerprint(mut self, input: impl Into<std::string::String>) -> Self {
            self.host_key_fingerprint = Some(input.into());
            self
        }
        pub fn set_host_key_fingerprint(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.host_key_fingerprint = input;
            self
        }
        /// <p>Specifies information to call a customer-supplied authentication API. This field is not
        /// populated when the <code>IdentityProviderType</code> of a server is
        /// <code>AWS_DIRECTORY_SERVICE</code> or <code>SERVICE_MANAGED</code>.</p>
        pub fn identity_provider_details(
            mut self,
            input: crate::model::IdentityProviderDetails,
        ) -> Self {
            self.identity_provider_details = Some(input);
            self
        }
        pub fn set_identity_provider_details(
            mut self,
            input: std::option::Option<crate::model::IdentityProviderDetails>,
        ) -> Self {
            self.identity_provider_details = input;
            self
        }
        /// <p>Specifies the mode of authentication for a server. The default value is
        /// <code>SERVICE_MANAGED</code>, which allows you to store and access user credentials within
        /// the Amazon Web Services Transfer Family service.</p>
        /// <p>Use <code>AWS_DIRECTORY_SERVICE</code> to provide access to
        /// Active Directory groups in Amazon Web Services Managed Active Directory or Microsoft Active Directory in your
        /// on-premises environment or in Amazon Web Services using AD Connectors. This option also requires you to
        /// provide a Directory ID using the <code>IdentityProviderDetails</code> parameter.</p>
        /// <p>Use the <code>API_GATEWAY</code> value to integrate with an identity provider of your choosing. The
        /// <code>API_GATEWAY</code> setting requires you to provide an API Gateway endpoint URL to call
        /// for authentication using the <code>IdentityProviderDetails</code> parameter.</p>
        pub fn identity_provider_type(mut self, input: crate::model::IdentityProviderType) -> Self {
            self.identity_provider_type = Some(input);
            self
        }
        pub fn set_identity_provider_type(
            mut self,
            input: std::option::Option<crate::model::IdentityProviderType>,
        ) -> Self {
            self.identity_provider_type = input;
            self
        }
        /// <p>Specifies the Amazon Resource Name (ARN) of the Amazon Web Services Identity and Access Management (IAM) role that allows a server to turn
        /// on Amazon CloudWatch logging for Amazon S3 or Amazon EFS events. When set, user activity can be viewed in
        /// your CloudWatch logs.</p>
        pub fn logging_role(mut self, input: impl Into<std::string::String>) -> Self {
            self.logging_role = Some(input.into());
            self
        }
        pub fn set_logging_role(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.logging_role = input;
            self
        }
        pub fn protocols(mut self, input: impl Into<crate::model::Protocol>) -> Self {
            let mut v = self.protocols.unwrap_or_default();
            v.push(input.into());
            self.protocols = Some(v);
            self
        }
        pub fn set_protocols(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Protocol>>,
        ) -> Self {
            self.protocols = input;
            self
        }
        /// <p>Specifies the name of the security policy that is attached to the server.</p>
        pub fn security_policy_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.security_policy_name = Some(input.into());
            self
        }
        pub fn set_security_policy_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.security_policy_name = input;
            self
        }
        /// <p>Specifies the unique system-assigned identifier for a server that you instantiate.</p>
        pub fn server_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.server_id = Some(input.into());
            self
        }
        pub fn set_server_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.server_id = input;
            self
        }
        /// <p>Specifies the condition of a server for the server that was described. A value of
        /// <code>ONLINE</code> indicates that the server can accept jobs and transfer files. A
        /// <code>State</code> value of <code>OFFLINE</code> means that the server cannot perform file
        /// transfer operations.</p>
        /// <p>The states of <code>STARTING</code> and <code>STOPPING</code> indicate that the server is
        /// in an intermediate state, either not fully able to respond, or not fully offline. The values
        /// of <code>START_FAILED</code> or <code>STOP_FAILED</code> can indicate an error
        /// condition.</p>
        pub fn state(mut self, input: crate::model::State) -> Self {
            self.state = Some(input);
            self
        }
        pub fn set_state(mut self, input: std::option::Option<crate::model::State>) -> Self {
            self.state = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>Specifies the number of users that are assigned to a server you specified with the
        /// <code>ServerId</code>.</p>
        pub fn user_count(mut self, input: i32) -> Self {
            self.user_count = Some(input);
            self
        }
        pub fn set_user_count(mut self, input: std::option::Option<i32>) -> Self {
            self.user_count = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribedServer`](crate::model::DescribedServer)
        pub fn build(self) -> crate::model::DescribedServer {
            crate::model::DescribedServer {
                arn: self.arn,
                certificate: self.certificate,
                protocol_details: self.protocol_details,
                domain: self.domain,
                endpoint_details: self.endpoint_details,
                endpoint_type: self.endpoint_type,
                host_key_fingerprint: self.host_key_fingerprint,
                identity_provider_details: self.identity_provider_details,
                identity_provider_type: self.identity_provider_type,
                logging_role: self.logging_role,
                protocols: self.protocols,
                security_policy_name: self.security_policy_name,
                server_id: self.server_id,
                state: self.state,
                tags: self.tags,
                user_count: self.user_count,
            }
        }
    }
}
impl DescribedServer {
    /// Creates a new builder-style object to manufacture [`DescribedServer`](crate::model::DescribedServer)
    pub fn builder() -> crate::model::described_server::Builder {
        crate::model::described_server::Builder::default()
    }
}

/// <p>Describes the properties of a security policy that was specified. For more information
/// about security policies, see <a href="https://docs.aws.amazon.com/transfer/latest/userguide/security-policies.html">Working with security
/// policies</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribedSecurityPolicy {
    /// <p>Specifies whether this policy enables Federal Information Processing Standards
    /// (FIPS).</p>
    pub fips: std::option::Option<bool>,
    /// <p>Specifies the name of the security policy that is attached to the server.</p>
    pub security_policy_name: std::option::Option<std::string::String>,
    /// <p>Specifies the enabled Secure Shell (SSH) cipher encryption algorithms in the security
    /// policy that is attached to the server.</p>
    pub ssh_ciphers: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Specifies the enabled SSH key exchange (KEX) encryption algorithms in the security policy
    /// that is attached to the server.</p>
    pub ssh_kexs: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Specifies the enabled SSH message authentication code (MAC) encryption algorithms in the
    /// security policy that is attached to the server.</p>
    pub ssh_macs: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Specifies the enabled Transport Layer Security (TLS) cipher encryption algorithms in the
    /// security policy that is attached to the server.</p>
    pub tls_ciphers: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for DescribedSecurityPolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribedSecurityPolicy");
        formatter.field("fips", &self.fips);
        formatter.field("security_policy_name", &self.security_policy_name);
        formatter.field("ssh_ciphers", &self.ssh_ciphers);
        formatter.field("ssh_kexs", &self.ssh_kexs);
        formatter.field("ssh_macs", &self.ssh_macs);
        formatter.field("tls_ciphers", &self.tls_ciphers);
        formatter.finish()
    }
}
/// See [`DescribedSecurityPolicy`](crate::model::DescribedSecurityPolicy)
pub mod described_security_policy {
    /// A builder for [`DescribedSecurityPolicy`](crate::model::DescribedSecurityPolicy)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) fips: std::option::Option<bool>,
        pub(crate) security_policy_name: std::option::Option<std::string::String>,
        pub(crate) ssh_ciphers: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) ssh_kexs: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) ssh_macs: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) tls_ciphers: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>Specifies whether this policy enables Federal Information Processing Standards
        /// (FIPS).</p>
        pub fn fips(mut self, input: bool) -> Self {
            self.fips = Some(input);
            self
        }
        pub fn set_fips(mut self, input: std::option::Option<bool>) -> Self {
            self.fips = input;
            self
        }
        /// <p>Specifies the name of the security policy that is attached to the server.</p>
        pub fn security_policy_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.security_policy_name = Some(input.into());
            self
        }
        pub fn set_security_policy_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.security_policy_name = input;
            self
        }
        pub fn ssh_ciphers(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.ssh_ciphers.unwrap_or_default();
            v.push(input.into());
            self.ssh_ciphers = Some(v);
            self
        }
        pub fn set_ssh_ciphers(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.ssh_ciphers = input;
            self
        }
        pub fn ssh_kexs(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.ssh_kexs.unwrap_or_default();
            v.push(input.into());
            self.ssh_kexs = Some(v);
            self
        }
        pub fn set_ssh_kexs(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.ssh_kexs = input;
            self
        }
        pub fn ssh_macs(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.ssh_macs.unwrap_or_default();
            v.push(input.into());
            self.ssh_macs = Some(v);
            self
        }
        pub fn set_ssh_macs(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.ssh_macs = input;
            self
        }
        pub fn tls_ciphers(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.tls_ciphers.unwrap_or_default();
            v.push(input.into());
            self.tls_ciphers = Some(v);
            self
        }
        pub fn set_tls_ciphers(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.tls_ciphers = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribedSecurityPolicy`](crate::model::DescribedSecurityPolicy)
        pub fn build(self) -> crate::model::DescribedSecurityPolicy {
            crate::model::DescribedSecurityPolicy {
                fips: self.fips,
                security_policy_name: self.security_policy_name,
                ssh_ciphers: self.ssh_ciphers,
                ssh_kexs: self.ssh_kexs,
                ssh_macs: self.ssh_macs,
                tls_ciphers: self.tls_ciphers,
            }
        }
    }
}
impl DescribedSecurityPolicy {
    /// Creates a new builder-style object to manufacture [`DescribedSecurityPolicy`](crate::model::DescribedSecurityPolicy)
    pub fn builder() -> crate::model::described_security_policy::Builder {
        crate::model::described_security_policy::Builder::default()
    }
}

/// <p>Describes the properties of the access that was specified.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribedAccess {
    /// <p>The landing directory (folder) for a user when they log in to the server using the client.</p>
    /// <p>A <code>HomeDirectory</code> example is <code>/bucket_name/home/mydirectory</code>.</p>
    pub home_directory: std::option::Option<std::string::String>,
    /// <p>Logical directory mappings that specify what Amazon S3 or Amazon EFS paths and keys should
    /// be visible to your user and how you want to make them visible. You must specify the
    /// <code>Entry</code> and <code>Target</code> pair, where <code>Entry</code> shows how the path
    /// is made visible and <code>Target</code> is the actual Amazon S3 or Amazon EFS path. If you
    /// only specify a target, it is displayed as is. You also must ensure that your Amazon Web Services Identity
    /// and Access Management (IAM) role provides access to paths in <code>Target</code>. This value
    /// can only be set when <code>HomeDirectoryType</code> is set to
    /// <i>LOGICAL</i>.</p>
    /// <p>In most cases, you can use this value instead of the scope-down policy to lock down the
    /// associated access to the designated home directory ("<code>chroot</code>"). To do this, you
    /// can set <code>Entry</code> to '/' and set <code>Target</code> to the
    /// <code>HomeDirectory</code> parameter value.</p>
    pub home_directory_mappings:
        std::option::Option<std::vec::Vec<crate::model::HomeDirectoryMapEntry>>,
    /// <p>The type of landing directory (folder) you want your users' home directory to be when they log into the server.
    /// If you set it to <code>PATH</code>, the user will see the absolute Amazon S3 bucket or EFS paths as is in their file transfer protocol clients.
    /// If you set it <code>LOGICAL</code>, you will need to provide mappings in the <code>HomeDirectoryMappings</code> for how you want to make Amazon
    /// S3 or EFS paths visible to your users.</p>
    pub home_directory_type: std::option::Option<crate::model::HomeDirectoryType>,
    /// <p>A scope-down policy for your user so that you can use the same IAM role across multiple users. This policy scopes down user
    /// access to portions of their Amazon S3 bucket. Variables that you can use inside this policy include <code>${Transfer:UserName}</code>,
    /// <code>${Transfer:HomeDirectory}</code>, and <code>${Transfer:HomeBucket}</code>.</p>
    pub policy: std::option::Option<std::string::String>,
    /// <p>The full POSIX identity, including user ID (<code>Uid</code>), group ID
    /// (<code>Gid</code>), and any secondary groups IDs (<code>SecondaryGids</code>), that controls
    /// your users' access to your Amazon EFS file systems. The POSIX permissions that are set on
    /// files and directories in your file system determine the level of access your users get when
    /// transferring files into and out of your Amazon EFS file systems.</p>
    pub posix_profile: std::option::Option<crate::model::PosixProfile>,
    /// <p>Specifies the Amazon Resource Name (ARN) of the IAM role that controls your users' access to your Amazon S3 bucket or EFS
    /// file system. The policies attached to this role determine the level of access that you want to provide your users when transferring
    /// files into and out of your Amazon S3 bucket or EFS file system. The IAM role should also contain a trust relationship that allows the
    /// server to access your resources when servicing your users' transfer requests.</p>
    pub role: std::option::Option<std::string::String>,
    /// <p>A unique identifier that is required to identify specific groups within your directory.
    /// The users of the group that you associate have access to your Amazon S3 or Amazon EFS
    /// resources over the enabled protocols using Amazon Web Services Transfer Family. If you know the group name,
    /// you can view the SID values by running the following command using Windows PowerShell.</p>
    /// <p>
    /// <code>Get-ADGroup -Filter {samAccountName -like "<i>YourGroupName</i>*"} -Properties * | Select SamAccountName,ObjectSid</code>
    /// </p>
    /// <p>In that command, replace <i>YourGroupName</i> with the name of your Active Directory group.</p>
    /// <p>The regex used to validate this parameter is a string of characters consisting of uppercase and lowercase alphanumeric characters with no spaces.
    /// You can also include underscores or any of the following characters: =,.@:/-</p>
    pub external_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribedAccess {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribedAccess");
        formatter.field("home_directory", &self.home_directory);
        formatter.field("home_directory_mappings", &self.home_directory_mappings);
        formatter.field("home_directory_type", &self.home_directory_type);
        formatter.field("policy", &self.policy);
        formatter.field("posix_profile", &self.posix_profile);
        formatter.field("role", &self.role);
        formatter.field("external_id", &self.external_id);
        formatter.finish()
    }
}
/// See [`DescribedAccess`](crate::model::DescribedAccess)
pub mod described_access {
    /// A builder for [`DescribedAccess`](crate::model::DescribedAccess)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) home_directory: std::option::Option<std::string::String>,
        pub(crate) home_directory_mappings:
            std::option::Option<std::vec::Vec<crate::model::HomeDirectoryMapEntry>>,
        pub(crate) home_directory_type: std::option::Option<crate::model::HomeDirectoryType>,
        pub(crate) policy: std::option::Option<std::string::String>,
        pub(crate) posix_profile: std::option::Option<crate::model::PosixProfile>,
        pub(crate) role: std::option::Option<std::string::String>,
        pub(crate) external_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The landing directory (folder) for a user when they log in to the server using the client.</p>
        /// <p>A <code>HomeDirectory</code> example is <code>/bucket_name/home/mydirectory</code>.</p>
        pub fn home_directory(mut self, input: impl Into<std::string::String>) -> Self {
            self.home_directory = Some(input.into());
            self
        }
        pub fn set_home_directory(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.home_directory = input;
            self
        }
        pub fn home_directory_mappings(
            mut self,
            input: impl Into<crate::model::HomeDirectoryMapEntry>,
        ) -> Self {
            let mut v = self.home_directory_mappings.unwrap_or_default();
            v.push(input.into());
            self.home_directory_mappings = Some(v);
            self
        }
        pub fn set_home_directory_mappings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::HomeDirectoryMapEntry>>,
        ) -> Self {
            self.home_directory_mappings = input;
            self
        }
        /// <p>The type of landing directory (folder) you want your users' home directory to be when they log into the server.
        /// If you set it to <code>PATH</code>, the user will see the absolute Amazon S3 bucket or EFS paths as is in their file transfer protocol clients.
        /// If you set it <code>LOGICAL</code>, you will need to provide mappings in the <code>HomeDirectoryMappings</code> for how you want to make Amazon
        /// S3 or EFS paths visible to your users.</p>
        pub fn home_directory_type(mut self, input: crate::model::HomeDirectoryType) -> Self {
            self.home_directory_type = Some(input);
            self
        }
        pub fn set_home_directory_type(
            mut self,
            input: std::option::Option<crate::model::HomeDirectoryType>,
        ) -> Self {
            self.home_directory_type = input;
            self
        }
        /// <p>A scope-down policy for your user so that you can use the same IAM role across multiple users. This policy scopes down user
        /// access to portions of their Amazon S3 bucket. Variables that you can use inside this policy include <code>${Transfer:UserName}</code>,
        /// <code>${Transfer:HomeDirectory}</code>, and <code>${Transfer:HomeBucket}</code>.</p>
        pub fn policy(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy = Some(input.into());
            self
        }
        pub fn set_policy(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.policy = input;
            self
        }
        /// <p>The full POSIX identity, including user ID (<code>Uid</code>), group ID
        /// (<code>Gid</code>), and any secondary groups IDs (<code>SecondaryGids</code>), that controls
        /// your users' access to your Amazon EFS file systems. The POSIX permissions that are set on
        /// files and directories in your file system determine the level of access your users get when
        /// transferring files into and out of your Amazon EFS file systems.</p>
        pub fn posix_profile(mut self, input: crate::model::PosixProfile) -> Self {
            self.posix_profile = Some(input);
            self
        }
        pub fn set_posix_profile(
            mut self,
            input: std::option::Option<crate::model::PosixProfile>,
        ) -> Self {
            self.posix_profile = input;
            self
        }
        /// <p>Specifies the Amazon Resource Name (ARN) of the IAM role that controls your users' access to your Amazon S3 bucket or EFS
        /// file system. The policies attached to this role determine the level of access that you want to provide your users when transferring
        /// files into and out of your Amazon S3 bucket or EFS file system. The IAM role should also contain a trust relationship that allows the
        /// server to access your resources when servicing your users' transfer requests.</p>
        pub fn role(mut self, input: impl Into<std::string::String>) -> Self {
            self.role = Some(input.into());
            self
        }
        pub fn set_role(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role = input;
            self
        }
        /// <p>A unique identifier that is required to identify specific groups within your directory.
        /// The users of the group that you associate have access to your Amazon S3 or Amazon EFS
        /// resources over the enabled protocols using Amazon Web Services Transfer Family. If you know the group name,
        /// you can view the SID values by running the following command using Windows PowerShell.</p>
        /// <p>
        /// <code>Get-ADGroup -Filter {samAccountName -like "<i>YourGroupName</i>*"} -Properties * | Select SamAccountName,ObjectSid</code>
        /// </p>
        /// <p>In that command, replace <i>YourGroupName</i> with the name of your Active Directory group.</p>
        /// <p>The regex used to validate this parameter is a string of characters consisting of uppercase and lowercase alphanumeric characters with no spaces.
        /// You can also include underscores or any of the following characters: =,.@:/-</p>
        pub fn external_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.external_id = Some(input.into());
            self
        }
        pub fn set_external_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.external_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribedAccess`](crate::model::DescribedAccess)
        pub fn build(self) -> crate::model::DescribedAccess {
            crate::model::DescribedAccess {
                home_directory: self.home_directory,
                home_directory_mappings: self.home_directory_mappings,
                home_directory_type: self.home_directory_type,
                policy: self.policy,
                posix_profile: self.posix_profile,
                role: self.role,
                external_id: self.external_id,
            }
        }
    }
}
impl DescribedAccess {
    /// Creates a new builder-style object to manufacture [`DescribedAccess`](crate::model::DescribedAccess)
    pub fn builder() -> crate::model::described_access::Builder {
        crate::model::described_access::Builder::default()
    }
}
