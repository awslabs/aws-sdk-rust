// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>Used by administrators to choose which groups in the directory should have access to
/// upload and download files over the enabled protocols using Amazon Web Services Transfer Family. For example, a
/// Microsoft Active Directory might contain 50,000 users, but only a small fraction might need
/// the ability to transfer files to the server. An administrator can use
/// <code>CreateAccess</code> to limit the access to the correct set of users who need this
/// ability.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateAccess {
    _private: (),
}
impl CreateAccess {
    /// Creates a new builder-style object to manufacture [`CreateAccessInput`](crate::input::CreateAccessInput)
    pub fn builder() -> crate::input::create_access_input::Builder {
        crate::input::create_access_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateAccess {
    type Output =
        std::result::Result<crate::output::CreateAccessOutput, crate::error::CreateAccessError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_access_error(response)
        } else {
            crate::operation_deser::parse_create_access_response(response)
        }
    }
}

/// <p>Instantiates an auto-scaling virtual server based on the selected file transfer protocol
/// in Amazon Web Services. When you make updates to your file transfer protocol-enabled server or when you work
/// with users, use the service-generated <code>ServerId</code> property that is assigned to the
/// newly created server.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateServer {
    _private: (),
}
impl CreateServer {
    /// Creates a new builder-style object to manufacture [`CreateServerInput`](crate::input::CreateServerInput)
    pub fn builder() -> crate::input::create_server_input::Builder {
        crate::input::create_server_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateServer {
    type Output =
        std::result::Result<crate::output::CreateServerOutput, crate::error::CreateServerError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_server_error(response)
        } else {
            crate::operation_deser::parse_create_server_response(response)
        }
    }
}

/// <p>Creates a user and associates them with an existing file transfer protocol-enabled server.
/// You can only create and associate users with servers that have the
/// <code>IdentityProviderType</code> set to <code>SERVICE_MANAGED</code>. Using parameters for
/// <code>CreateUser</code>, you can specify the user name, set the home directory, store the
/// user's public key, and assign the user's Amazon Web Services Identity and Access Management (IAM)
/// role. You can also optionally add a session policy, and assign metadata with tags that can
/// be used to group and search for users.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateUser {
    _private: (),
}
impl CreateUser {
    /// Creates a new builder-style object to manufacture [`CreateUserInput`](crate::input::CreateUserInput)
    pub fn builder() -> crate::input::create_user_input::Builder {
        crate::input::create_user_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateUser {
    type Output =
        std::result::Result<crate::output::CreateUserOutput, crate::error::CreateUserError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_user_error(response)
        } else {
            crate::operation_deser::parse_create_user_response(response)
        }
    }
}

/// <p>
/// Allows you to create a workflow with specified steps and step details the workflow invokes after file transfer completes.
/// After creating a workflow, you can associate the workflow created with any transfer servers by specifying the <code>workflow-details</code> field in <code>CreateServer</code> and <code>UpdateServer</code> operations.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateWorkflow {
    _private: (),
}
impl CreateWorkflow {
    /// Creates a new builder-style object to manufacture [`CreateWorkflowInput`](crate::input::CreateWorkflowInput)
    pub fn builder() -> crate::input::create_workflow_input::Builder {
        crate::input::create_workflow_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateWorkflow {
    type Output =
        std::result::Result<crate::output::CreateWorkflowOutput, crate::error::CreateWorkflowError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_workflow_error(response)
        } else {
            crate::operation_deser::parse_create_workflow_response(response)
        }
    }
}

/// <p>Allows you to delete the access specified in the <code>ServerID</code> and
/// <code>ExternalID</code> parameters.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteAccess {
    _private: (),
}
impl DeleteAccess {
    /// Creates a new builder-style object to manufacture [`DeleteAccessInput`](crate::input::DeleteAccessInput)
    pub fn builder() -> crate::input::delete_access_input::Builder {
        crate::input::delete_access_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteAccess {
    type Output =
        std::result::Result<crate::output::DeleteAccessOutput, crate::error::DeleteAccessError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_access_error(response)
        } else {
            crate::operation_deser::parse_delete_access_response(response)
        }
    }
}

/// <p>Deletes the file transfer protocol-enabled server that you specify.</p>
/// <p>No response returns from this operation.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteServer {
    _private: (),
}
impl DeleteServer {
    /// Creates a new builder-style object to manufacture [`DeleteServerInput`](crate::input::DeleteServerInput)
    pub fn builder() -> crate::input::delete_server_input::Builder {
        crate::input::delete_server_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteServer {
    type Output =
        std::result::Result<crate::output::DeleteServerOutput, crate::error::DeleteServerError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_server_error(response)
        } else {
            crate::operation_deser::parse_delete_server_response(response)
        }
    }
}

/// <p>Deletes a user's Secure Shell (SSH) public key.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteSshPublicKey {
    _private: (),
}
impl DeleteSshPublicKey {
    /// Creates a new builder-style object to manufacture [`DeleteSshPublicKeyInput`](crate::input::DeleteSshPublicKeyInput)
    pub fn builder() -> crate::input::delete_ssh_public_key_input::Builder {
        crate::input::delete_ssh_public_key_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteSshPublicKey {
    type Output = std::result::Result<
        crate::output::DeleteSshPublicKeyOutput,
        crate::error::DeleteSshPublicKeyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_ssh_public_key_error(response)
        } else {
            crate::operation_deser::parse_delete_ssh_public_key_response(response)
        }
    }
}

/// <p>Deletes the user belonging to a file transfer protocol-enabled server you specify.</p>
/// <p>No response returns from this operation.</p>
/// <note>
/// <p>When you delete a user from a server, the user's information is lost.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteUser {
    _private: (),
}
impl DeleteUser {
    /// Creates a new builder-style object to manufacture [`DeleteUserInput`](crate::input::DeleteUserInput)
    pub fn builder() -> crate::input::delete_user_input::Builder {
        crate::input::delete_user_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteUser {
    type Output =
        std::result::Result<crate::output::DeleteUserOutput, crate::error::DeleteUserError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_user_error(response)
        } else {
            crate::operation_deser::parse_delete_user_response(response)
        }
    }
}

/// <p>Deletes the specified workflow.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteWorkflow {
    _private: (),
}
impl DeleteWorkflow {
    /// Creates a new builder-style object to manufacture [`DeleteWorkflowInput`](crate::input::DeleteWorkflowInput)
    pub fn builder() -> crate::input::delete_workflow_input::Builder {
        crate::input::delete_workflow_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteWorkflow {
    type Output =
        std::result::Result<crate::output::DeleteWorkflowOutput, crate::error::DeleteWorkflowError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_workflow_error(response)
        } else {
            crate::operation_deser::parse_delete_workflow_response(response)
        }
    }
}

/// <p>Describes the access that is assigned to the specific file transfer protocol-enabled
/// server, as identified by its <code>ServerId</code> property and its
/// <code>ExternalID</code>.</p>
/// <p>The response from this call returns the properties of the access that is associated with
/// the <code>ServerId</code> value that was specified.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeAccess {
    _private: (),
}
impl DescribeAccess {
    /// Creates a new builder-style object to manufacture [`DescribeAccessInput`](crate::input::DescribeAccessInput)
    pub fn builder() -> crate::input::describe_access_input::Builder {
        crate::input::describe_access_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeAccess {
    type Output =
        std::result::Result<crate::output::DescribeAccessOutput, crate::error::DescribeAccessError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_access_error(response)
        } else {
            crate::operation_deser::parse_describe_access_response(response)
        }
    }
}

/// <p>You can use <code>DescribeExecution</code> to check the details of the execution of the specified workflow.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeExecution {
    _private: (),
}
impl DescribeExecution {
    /// Creates a new builder-style object to manufacture [`DescribeExecutionInput`](crate::input::DescribeExecutionInput)
    pub fn builder() -> crate::input::describe_execution_input::Builder {
        crate::input::describe_execution_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeExecution {
    type Output = std::result::Result<
        crate::output::DescribeExecutionOutput,
        crate::error::DescribeExecutionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_execution_error(response)
        } else {
            crate::operation_deser::parse_describe_execution_response(response)
        }
    }
}

/// <p>Describes the security policy that is attached to your file transfer protocol-enabled
/// server. The response contains a description of the security policy's properties. For more
/// information about security policies, see <a href="https://docs.aws.amazon.com/transfer/latest/userguide/security-policies.html">Working with security
/// policies</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeSecurityPolicy {
    _private: (),
}
impl DescribeSecurityPolicy {
    /// Creates a new builder-style object to manufacture [`DescribeSecurityPolicyInput`](crate::input::DescribeSecurityPolicyInput)
    pub fn builder() -> crate::input::describe_security_policy_input::Builder {
        crate::input::describe_security_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeSecurityPolicy {
    type Output = std::result::Result<
        crate::output::DescribeSecurityPolicyOutput,
        crate::error::DescribeSecurityPolicyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_security_policy_error(response)
        } else {
            crate::operation_deser::parse_describe_security_policy_response(response)
        }
    }
}

/// <p>Describes a file transfer protocol-enabled server that you specify by passing the
/// <code>ServerId</code> parameter.</p>
/// <p>The response contains a description of a server's properties. When you set
/// <code>EndpointType</code> to VPC, the response will contain the
/// <code>EndpointDetails</code>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeServer {
    _private: (),
}
impl DescribeServer {
    /// Creates a new builder-style object to manufacture [`DescribeServerInput`](crate::input::DescribeServerInput)
    pub fn builder() -> crate::input::describe_server_input::Builder {
        crate::input::describe_server_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeServer {
    type Output =
        std::result::Result<crate::output::DescribeServerOutput, crate::error::DescribeServerError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_server_error(response)
        } else {
            crate::operation_deser::parse_describe_server_response(response)
        }
    }
}

/// <p>Describes the user assigned to the specific file transfer protocol-enabled server, as
/// identified by its <code>ServerId</code> property.</p>
/// <p>The response from this call returns the properties of the user associated with the
/// <code>ServerId</code> value that was specified.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeUser {
    _private: (),
}
impl DescribeUser {
    /// Creates a new builder-style object to manufacture [`DescribeUserInput`](crate::input::DescribeUserInput)
    pub fn builder() -> crate::input::describe_user_input::Builder {
        crate::input::describe_user_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeUser {
    type Output =
        std::result::Result<crate::output::DescribeUserOutput, crate::error::DescribeUserError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_user_error(response)
        } else {
            crate::operation_deser::parse_describe_user_response(response)
        }
    }
}

/// <p>Describes the specified workflow.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeWorkflow {
    _private: (),
}
impl DescribeWorkflow {
    /// Creates a new builder-style object to manufacture [`DescribeWorkflowInput`](crate::input::DescribeWorkflowInput)
    pub fn builder() -> crate::input::describe_workflow_input::Builder {
        crate::input::describe_workflow_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeWorkflow {
    type Output = std::result::Result<
        crate::output::DescribeWorkflowOutput,
        crate::error::DescribeWorkflowError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_workflow_error(response)
        } else {
            crate::operation_deser::parse_describe_workflow_response(response)
        }
    }
}

/// <p>Adds a Secure Shell (SSH) public key to a user account identified by a
/// <code>UserName</code> value assigned to the specific file transfer protocol-enabled server,
/// identified by <code>ServerId</code>.</p>
/// <p>The response returns the <code>UserName</code> value, the <code>ServerId</code> value, and
/// the name of the <code>SshPublicKeyId</code>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ImportSshPublicKey {
    _private: (),
}
impl ImportSshPublicKey {
    /// Creates a new builder-style object to manufacture [`ImportSshPublicKeyInput`](crate::input::ImportSshPublicKeyInput)
    pub fn builder() -> crate::input::import_ssh_public_key_input::Builder {
        crate::input::import_ssh_public_key_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ImportSshPublicKey {
    type Output = std::result::Result<
        crate::output::ImportSshPublicKeyOutput,
        crate::error::ImportSshPublicKeyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_import_ssh_public_key_error(response)
        } else {
            crate::operation_deser::parse_import_ssh_public_key_response(response)
        }
    }
}

/// <p>Lists the details for all the accesses you have on your server.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListAccesses {
    _private: (),
}
impl ListAccesses {
    /// Creates a new builder-style object to manufacture [`ListAccessesInput`](crate::input::ListAccessesInput)
    pub fn builder() -> crate::input::list_accesses_input::Builder {
        crate::input::list_accesses_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListAccesses {
    type Output =
        std::result::Result<crate::output::ListAccessesOutput, crate::error::ListAccessesError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_accesses_error(response)
        } else {
            crate::operation_deser::parse_list_accesses_response(response)
        }
    }
}

/// <p>Lists all executions for the specified workflow.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListExecutions {
    _private: (),
}
impl ListExecutions {
    /// Creates a new builder-style object to manufacture [`ListExecutionsInput`](crate::input::ListExecutionsInput)
    pub fn builder() -> crate::input::list_executions_input::Builder {
        crate::input::list_executions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListExecutions {
    type Output =
        std::result::Result<crate::output::ListExecutionsOutput, crate::error::ListExecutionsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_executions_error(response)
        } else {
            crate::operation_deser::parse_list_executions_response(response)
        }
    }
}

/// <p>Lists the security policies that are attached to your file transfer protocol-enabled
/// servers.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListSecurityPolicies {
    _private: (),
}
impl ListSecurityPolicies {
    /// Creates a new builder-style object to manufacture [`ListSecurityPoliciesInput`](crate::input::ListSecurityPoliciesInput)
    pub fn builder() -> crate::input::list_security_policies_input::Builder {
        crate::input::list_security_policies_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListSecurityPolicies {
    type Output = std::result::Result<
        crate::output::ListSecurityPoliciesOutput,
        crate::error::ListSecurityPoliciesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_security_policies_error(response)
        } else {
            crate::operation_deser::parse_list_security_policies_response(response)
        }
    }
}

/// <p>Lists the file transfer protocol-enabled servers that are associated with your Amazon Web Services
/// account.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListServers {
    _private: (),
}
impl ListServers {
    /// Creates a new builder-style object to manufacture [`ListServersInput`](crate::input::ListServersInput)
    pub fn builder() -> crate::input::list_servers_input::Builder {
        crate::input::list_servers_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListServers {
    type Output =
        std::result::Result<crate::output::ListServersOutput, crate::error::ListServersError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_servers_error(response)
        } else {
            crate::operation_deser::parse_list_servers_response(response)
        }
    }
}

/// <p>Lists all of the tags associated with the Amazon Resource Name (ARN) that you specify. The
/// resource can be a user, server, or role.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTagsForResource {
    _private: (),
}
impl ListTagsForResource {
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
    pub fn builder() -> crate::input::list_tags_for_resource_input::Builder {
        crate::input::list_tags_for_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTagsForResource {
    type Output = std::result::Result<
        crate::output::ListTagsForResourceOutput,
        crate::error::ListTagsForResourceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_tags_for_resource_error(response)
        } else {
            crate::operation_deser::parse_list_tags_for_resource_response(response)
        }
    }
}

/// <p>Lists the users for a file transfer protocol-enabled server that you specify by passing
/// the <code>ServerId</code> parameter.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListUsers {
    _private: (),
}
impl ListUsers {
    /// Creates a new builder-style object to manufacture [`ListUsersInput`](crate::input::ListUsersInput)
    pub fn builder() -> crate::input::list_users_input::Builder {
        crate::input::list_users_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListUsers {
    type Output = std::result::Result<crate::output::ListUsersOutput, crate::error::ListUsersError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_users_error(response)
        } else {
            crate::operation_deser::parse_list_users_response(response)
        }
    }
}

/// <p>Lists all of your workflows.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListWorkflows {
    _private: (),
}
impl ListWorkflows {
    /// Creates a new builder-style object to manufacture [`ListWorkflowsInput`](crate::input::ListWorkflowsInput)
    pub fn builder() -> crate::input::list_workflows_input::Builder {
        crate::input::list_workflows_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListWorkflows {
    type Output =
        std::result::Result<crate::output::ListWorkflowsOutput, crate::error::ListWorkflowsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_workflows_error(response)
        } else {
            crate::operation_deser::parse_list_workflows_response(response)
        }
    }
}

/// <p>Sends a callback for asynchronous custom steps.</p>
/// <p>
/// The <code>ExecutionId</code>, <code>WorkflowId</code>, and <code>Token</code> are passed to the target resource during execution of a custom step of a workflow.
/// You must include those with their callback as well as providing a status.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct SendWorkflowStepState {
    _private: (),
}
impl SendWorkflowStepState {
    /// Creates a new builder-style object to manufacture [`SendWorkflowStepStateInput`](crate::input::SendWorkflowStepStateInput)
    pub fn builder() -> crate::input::send_workflow_step_state_input::Builder {
        crate::input::send_workflow_step_state_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for SendWorkflowStepState {
    type Output = std::result::Result<
        crate::output::SendWorkflowStepStateOutput,
        crate::error::SendWorkflowStepStateError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_send_workflow_step_state_error(response)
        } else {
            crate::operation_deser::parse_send_workflow_step_state_response(response)
        }
    }
}

/// <p>Changes the state of a file transfer protocol-enabled server from <code>OFFLINE</code> to
/// <code>ONLINE</code>. It has no impact on a server that is already <code>ONLINE</code>. An
/// <code>ONLINE</code> server can accept and process file transfer jobs.</p>
/// <p>The state of <code>STARTING</code> indicates that the server is in an intermediate state,
/// either not fully able to respond, or not fully online. The values of <code>START_FAILED</code>
/// can indicate an error condition.</p>
/// <p>No response is returned from this call.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StartServer {
    _private: (),
}
impl StartServer {
    /// Creates a new builder-style object to manufacture [`StartServerInput`](crate::input::StartServerInput)
    pub fn builder() -> crate::input::start_server_input::Builder {
        crate::input::start_server_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StartServer {
    type Output =
        std::result::Result<crate::output::StartServerOutput, crate::error::StartServerError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_start_server_error(response)
        } else {
            crate::operation_deser::parse_start_server_response(response)
        }
    }
}

/// <p>Changes the state of a file transfer protocol-enabled server from <code>ONLINE</code> to
/// <code>OFFLINE</code>. An <code>OFFLINE</code> server cannot accept and process file transfer
/// jobs. Information tied to your server, such as server and user properties, are not affected by
/// stopping your server.</p>
/// <note>
/// <p>Stopping the server will not reduce or impact your file transfer protocol endpoint
/// billing; you must delete the server to stop being billed.</p>
/// </note>
/// <p>The state of <code>STOPPING</code> indicates that the server is in an intermediate state,
/// either not fully able to respond, or not fully offline. The values of <code>STOP_FAILED</code>
/// can indicate an error condition.</p>
/// <p>No response is returned from this call.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StopServer {
    _private: (),
}
impl StopServer {
    /// Creates a new builder-style object to manufacture [`StopServerInput`](crate::input::StopServerInput)
    pub fn builder() -> crate::input::stop_server_input::Builder {
        crate::input::stop_server_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StopServer {
    type Output =
        std::result::Result<crate::output::StopServerOutput, crate::error::StopServerError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_stop_server_error(response)
        } else {
            crate::operation_deser::parse_stop_server_response(response)
        }
    }
}

/// <p>Attaches a key-value pair to a resource, as identified by its Amazon Resource Name (ARN).
/// Resources are users, servers, roles, and other entities.</p>
/// <p>There is no response returned from this call.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct TagResource {
    _private: (),
}
impl TagResource {
    /// Creates a new builder-style object to manufacture [`TagResourceInput`](crate::input::TagResourceInput)
    pub fn builder() -> crate::input::tag_resource_input::Builder {
        crate::input::tag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for TagResource {
    type Output =
        std::result::Result<crate::output::TagResourceOutput, crate::error::TagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_tag_resource_error(response)
        } else {
            crate::operation_deser::parse_tag_resource_response(response)
        }
    }
}

/// <p>If the <code>IdentityProviderType</code> of a file transfer protocol-enabled server is
/// <code>AWS_DIRECTORY_SERVICE</code> or <code>API_Gateway</code>, tests whether your identity
/// provider is set up successfully. We highly recommend that you call this operation to test your
/// authentication method as soon as you create your server. By doing so, you can troubleshoot
/// issues with the identity provider integration to ensure that your users can successfully use
/// the service.</p>
/// <p>
/// The <code>ServerId</code> and <code>UserName</code> parameters are required. The <code>ServerProtocol</code>, <code>SourceIp</code>, and <code>UserPassword</code> are all optional.
/// </p>
/// <note>
/// <p>
/// You cannot use <code>TestIdentityProvider</code> if the <code>IdentityProviderType</code> of your server is <code>SERVICE_MANAGED</code>.
/// </p>
/// </note>
/// <ul>
/// <li>
/// <p>
/// If you provide any incorrect values for any parameters, the <code>Response</code> field is empty.
/// </p>
/// </li>
/// <li>
/// <p>
/// If you provide a server ID for a server that uses service-managed users, you get an error:
/// </p>
/// <p>
/// <code>
/// An error occurred (InvalidRequestException) when calling the TestIdentityProvider operation: s-<i>server-ID</i> not configured for external auth
/// </code>
/// </p>
/// </li>
/// <li>
/// <p>
/// If you enter a Server ID for the <code>--server-id</code> parameter that does not identify an actual Transfer server, you receive the following error:
/// </p>
/// <p>
/// <code>An error occurred (ResourceNotFoundException) when calling the TestIdentityProvider operation: Unknown server</code>
/// </p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct TestIdentityProvider {
    _private: (),
}
impl TestIdentityProvider {
    /// Creates a new builder-style object to manufacture [`TestIdentityProviderInput`](crate::input::TestIdentityProviderInput)
    pub fn builder() -> crate::input::test_identity_provider_input::Builder {
        crate::input::test_identity_provider_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for TestIdentityProvider {
    type Output = std::result::Result<
        crate::output::TestIdentityProviderOutput,
        crate::error::TestIdentityProviderError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_test_identity_provider_error(response)
        } else {
            crate::operation_deser::parse_test_identity_provider_response(response)
        }
    }
}

/// <p>Detaches a key-value pair from a resource, as identified by its Amazon Resource Name
/// (ARN). Resources are users, servers, roles, and other entities.</p>
/// <p>No response is returned from this call.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UntagResource {
    _private: (),
}
impl UntagResource {
    /// Creates a new builder-style object to manufacture [`UntagResourceInput`](crate::input::UntagResourceInput)
    pub fn builder() -> crate::input::untag_resource_input::Builder {
        crate::input::untag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UntagResource {
    type Output =
        std::result::Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_untag_resource_error(response)
        } else {
            crate::operation_deser::parse_untag_resource_response(response)
        }
    }
}

/// <p>Allows you to update parameters for the access specified in the <code>ServerID</code> and
/// <code>ExternalID</code> parameters.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateAccess {
    _private: (),
}
impl UpdateAccess {
    /// Creates a new builder-style object to manufacture [`UpdateAccessInput`](crate::input::UpdateAccessInput)
    pub fn builder() -> crate::input::update_access_input::Builder {
        crate::input::update_access_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateAccess {
    type Output =
        std::result::Result<crate::output::UpdateAccessOutput, crate::error::UpdateAccessError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_access_error(response)
        } else {
            crate::operation_deser::parse_update_access_response(response)
        }
    }
}

/// <p>Updates the file transfer protocol-enabled server's properties after that server has
/// been created.</p>
/// <p>The <code>UpdateServer</code> call returns the <code>ServerId</code> of the server you
/// updated.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateServer {
    _private: (),
}
impl UpdateServer {
    /// Creates a new builder-style object to manufacture [`UpdateServerInput`](crate::input::UpdateServerInput)
    pub fn builder() -> crate::input::update_server_input::Builder {
        crate::input::update_server_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateServer {
    type Output =
        std::result::Result<crate::output::UpdateServerOutput, crate::error::UpdateServerError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_server_error(response)
        } else {
            crate::operation_deser::parse_update_server_response(response)
        }
    }
}

/// <p>Assigns new properties to a user. Parameters you pass modify any or all of the following:
/// the home directory, role, and policy for the <code>UserName</code> and <code>ServerId</code>
/// you specify.</p>
/// <p>The response returns the <code>ServerId</code> and the <code>UserName</code> for the
/// updated user.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateUser {
    _private: (),
}
impl UpdateUser {
    /// Creates a new builder-style object to manufacture [`UpdateUserInput`](crate::input::UpdateUserInput)
    pub fn builder() -> crate::input::update_user_input::Builder {
        crate::input::update_user_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateUser {
    type Output =
        std::result::Result<crate::output::UpdateUserOutput, crate::error::UpdateUserError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_user_error(response)
        } else {
            crate::operation_deser::parse_update_user_response(response)
        }
    }
}
