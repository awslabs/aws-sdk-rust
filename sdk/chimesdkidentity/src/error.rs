// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateAppInstanceError {
    pub kind: CreateAppInstanceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateAppInstanceErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateAppInstanceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateAppInstanceErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateAppInstanceErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateAppInstanceErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            CreateAppInstanceErrorKind::ResourceLimitExceededException(_inner) => _inner.fmt(f),
            CreateAppInstanceErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            CreateAppInstanceErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateAppInstanceErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            CreateAppInstanceErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            CreateAppInstanceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateAppInstanceError {
    fn code(&self) -> Option<&str> {
        CreateAppInstanceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateAppInstanceError {
    pub fn new(kind: CreateAppInstanceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateAppInstanceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateAppInstanceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAppInstanceErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, CreateAppInstanceErrorKind::ConflictException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAppInstanceErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAppInstanceErrorKind::ResourceLimitExceededException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAppInstanceErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAppInstanceErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAppInstanceErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAppInstanceErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for CreateAppInstanceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateAppInstanceErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateAppInstanceErrorKind::ConflictException(_inner) => Some(_inner),
            CreateAppInstanceErrorKind::ForbiddenException(_inner) => Some(_inner),
            CreateAppInstanceErrorKind::ResourceLimitExceededException(_inner) => Some(_inner),
            CreateAppInstanceErrorKind::ServiceFailureException(_inner) => Some(_inner),
            CreateAppInstanceErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateAppInstanceErrorKind::ThrottledClientException(_inner) => Some(_inner),
            CreateAppInstanceErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            CreateAppInstanceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateAppInstanceAdminError {
    pub kind: CreateAppInstanceAdminErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateAppInstanceAdminErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateAppInstanceAdminError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateAppInstanceAdminErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateAppInstanceAdminErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateAppInstanceAdminErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            CreateAppInstanceAdminErrorKind::ResourceLimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            CreateAppInstanceAdminErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            CreateAppInstanceAdminErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateAppInstanceAdminErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            CreateAppInstanceAdminErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            CreateAppInstanceAdminErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateAppInstanceAdminError {
    fn code(&self) -> Option<&str> {
        CreateAppInstanceAdminError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateAppInstanceAdminError {
    pub fn new(kind: CreateAppInstanceAdminErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateAppInstanceAdminErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateAppInstanceAdminErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAppInstanceAdminErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAppInstanceAdminErrorKind::ConflictException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAppInstanceAdminErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAppInstanceAdminErrorKind::ResourceLimitExceededException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAppInstanceAdminErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAppInstanceAdminErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAppInstanceAdminErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAppInstanceAdminErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for CreateAppInstanceAdminError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateAppInstanceAdminErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateAppInstanceAdminErrorKind::ConflictException(_inner) => Some(_inner),
            CreateAppInstanceAdminErrorKind::ForbiddenException(_inner) => Some(_inner),
            CreateAppInstanceAdminErrorKind::ResourceLimitExceededException(_inner) => Some(_inner),
            CreateAppInstanceAdminErrorKind::ServiceFailureException(_inner) => Some(_inner),
            CreateAppInstanceAdminErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateAppInstanceAdminErrorKind::ThrottledClientException(_inner) => Some(_inner),
            CreateAppInstanceAdminErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            CreateAppInstanceAdminErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateAppInstanceUserError {
    pub kind: CreateAppInstanceUserErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateAppInstanceUserErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateAppInstanceUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateAppInstanceUserErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateAppInstanceUserErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateAppInstanceUserErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            CreateAppInstanceUserErrorKind::ResourceLimitExceededException(_inner) => _inner.fmt(f),
            CreateAppInstanceUserErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            CreateAppInstanceUserErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateAppInstanceUserErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            CreateAppInstanceUserErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            CreateAppInstanceUserErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateAppInstanceUserError {
    fn code(&self) -> Option<&str> {
        CreateAppInstanceUserError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateAppInstanceUserError {
    pub fn new(kind: CreateAppInstanceUserErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateAppInstanceUserErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateAppInstanceUserErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAppInstanceUserErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAppInstanceUserErrorKind::ConflictException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAppInstanceUserErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAppInstanceUserErrorKind::ResourceLimitExceededException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAppInstanceUserErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAppInstanceUserErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAppInstanceUserErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAppInstanceUserErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for CreateAppInstanceUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateAppInstanceUserErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateAppInstanceUserErrorKind::ConflictException(_inner) => Some(_inner),
            CreateAppInstanceUserErrorKind::ForbiddenException(_inner) => Some(_inner),
            CreateAppInstanceUserErrorKind::ResourceLimitExceededException(_inner) => Some(_inner),
            CreateAppInstanceUserErrorKind::ServiceFailureException(_inner) => Some(_inner),
            CreateAppInstanceUserErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            CreateAppInstanceUserErrorKind::ThrottledClientException(_inner) => Some(_inner),
            CreateAppInstanceUserErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            CreateAppInstanceUserErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteAppInstanceError {
    pub kind: DeleteAppInstanceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteAppInstanceErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteAppInstanceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteAppInstanceErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteAppInstanceErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteAppInstanceErrorKind::ResourceLimitExceededException(_inner) => _inner.fmt(f),
            DeleteAppInstanceErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            DeleteAppInstanceErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteAppInstanceErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            DeleteAppInstanceErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            DeleteAppInstanceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteAppInstanceError {
    fn code(&self) -> Option<&str> {
        DeleteAppInstanceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteAppInstanceError {
    pub fn new(kind: DeleteAppInstanceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteAppInstanceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteAppInstanceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAppInstanceErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAppInstanceErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAppInstanceErrorKind::ResourceLimitExceededException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAppInstanceErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAppInstanceErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAppInstanceErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAppInstanceErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for DeleteAppInstanceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteAppInstanceErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteAppInstanceErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteAppInstanceErrorKind::ResourceLimitExceededException(_inner) => Some(_inner),
            DeleteAppInstanceErrorKind::ServiceFailureException(_inner) => Some(_inner),
            DeleteAppInstanceErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteAppInstanceErrorKind::ThrottledClientException(_inner) => Some(_inner),
            DeleteAppInstanceErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            DeleteAppInstanceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteAppInstanceAdminError {
    pub kind: DeleteAppInstanceAdminErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteAppInstanceAdminErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteAppInstanceAdminError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteAppInstanceAdminErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteAppInstanceAdminErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteAppInstanceAdminErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteAppInstanceAdminErrorKind::ResourceLimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            DeleteAppInstanceAdminErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            DeleteAppInstanceAdminErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteAppInstanceAdminErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            DeleteAppInstanceAdminErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            DeleteAppInstanceAdminErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteAppInstanceAdminError {
    fn code(&self) -> Option<&str> {
        DeleteAppInstanceAdminError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteAppInstanceAdminError {
    pub fn new(kind: DeleteAppInstanceAdminErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteAppInstanceAdminErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteAppInstanceAdminErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAppInstanceAdminErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAppInstanceAdminErrorKind::ConflictException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAppInstanceAdminErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAppInstanceAdminErrorKind::ResourceLimitExceededException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAppInstanceAdminErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAppInstanceAdminErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAppInstanceAdminErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAppInstanceAdminErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for DeleteAppInstanceAdminError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteAppInstanceAdminErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteAppInstanceAdminErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteAppInstanceAdminErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteAppInstanceAdminErrorKind::ResourceLimitExceededException(_inner) => Some(_inner),
            DeleteAppInstanceAdminErrorKind::ServiceFailureException(_inner) => Some(_inner),
            DeleteAppInstanceAdminErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteAppInstanceAdminErrorKind::ThrottledClientException(_inner) => Some(_inner),
            DeleteAppInstanceAdminErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            DeleteAppInstanceAdminErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteAppInstanceUserError {
    pub kind: DeleteAppInstanceUserErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteAppInstanceUserErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteAppInstanceUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteAppInstanceUserErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteAppInstanceUserErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteAppInstanceUserErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteAppInstanceUserErrorKind::ResourceLimitExceededException(_inner) => _inner.fmt(f),
            DeleteAppInstanceUserErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            DeleteAppInstanceUserErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DeleteAppInstanceUserErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            DeleteAppInstanceUserErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            DeleteAppInstanceUserErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteAppInstanceUserError {
    fn code(&self) -> Option<&str> {
        DeleteAppInstanceUserError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteAppInstanceUserError {
    pub fn new(kind: DeleteAppInstanceUserErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteAppInstanceUserErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteAppInstanceUserErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAppInstanceUserErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAppInstanceUserErrorKind::ConflictException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAppInstanceUserErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAppInstanceUserErrorKind::ResourceLimitExceededException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAppInstanceUserErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAppInstanceUserErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAppInstanceUserErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAppInstanceUserErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for DeleteAppInstanceUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteAppInstanceUserErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteAppInstanceUserErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteAppInstanceUserErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteAppInstanceUserErrorKind::ResourceLimitExceededException(_inner) => Some(_inner),
            DeleteAppInstanceUserErrorKind::ServiceFailureException(_inner) => Some(_inner),
            DeleteAppInstanceUserErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DeleteAppInstanceUserErrorKind::ThrottledClientException(_inner) => Some(_inner),
            DeleteAppInstanceUserErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            DeleteAppInstanceUserErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeAppInstanceError {
    pub kind: DescribeAppInstanceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeAppInstanceErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeAppInstanceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeAppInstanceErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DescribeAppInstanceErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DescribeAppInstanceErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            DescribeAppInstanceErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DescribeAppInstanceErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            DescribeAppInstanceErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            DescribeAppInstanceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeAppInstanceError {
    fn code(&self) -> Option<&str> {
        DescribeAppInstanceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeAppInstanceError {
    pub fn new(kind: DescribeAppInstanceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeAppInstanceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeAppInstanceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAppInstanceErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAppInstanceErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAppInstanceErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAppInstanceErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAppInstanceErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAppInstanceErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for DescribeAppInstanceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeAppInstanceErrorKind::BadRequestException(_inner) => Some(_inner),
            DescribeAppInstanceErrorKind::ForbiddenException(_inner) => Some(_inner),
            DescribeAppInstanceErrorKind::ServiceFailureException(_inner) => Some(_inner),
            DescribeAppInstanceErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DescribeAppInstanceErrorKind::ThrottledClientException(_inner) => Some(_inner),
            DescribeAppInstanceErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            DescribeAppInstanceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeAppInstanceAdminError {
    pub kind: DescribeAppInstanceAdminErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeAppInstanceAdminErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeAppInstanceAdminError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeAppInstanceAdminErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DescribeAppInstanceAdminErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DescribeAppInstanceAdminErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            DescribeAppInstanceAdminErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DescribeAppInstanceAdminErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            DescribeAppInstanceAdminErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            DescribeAppInstanceAdminErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeAppInstanceAdminError {
    fn code(&self) -> Option<&str> {
        DescribeAppInstanceAdminError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeAppInstanceAdminError {
    pub fn new(kind: DescribeAppInstanceAdminErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeAppInstanceAdminErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeAppInstanceAdminErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAppInstanceAdminErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAppInstanceAdminErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAppInstanceAdminErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAppInstanceAdminErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAppInstanceAdminErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAppInstanceAdminErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for DescribeAppInstanceAdminError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeAppInstanceAdminErrorKind::BadRequestException(_inner) => Some(_inner),
            DescribeAppInstanceAdminErrorKind::ForbiddenException(_inner) => Some(_inner),
            DescribeAppInstanceAdminErrorKind::ServiceFailureException(_inner) => Some(_inner),
            DescribeAppInstanceAdminErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DescribeAppInstanceAdminErrorKind::ThrottledClientException(_inner) => Some(_inner),
            DescribeAppInstanceAdminErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            DescribeAppInstanceAdminErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeAppInstanceUserError {
    pub kind: DescribeAppInstanceUserErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeAppInstanceUserErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeAppInstanceUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeAppInstanceUserErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DescribeAppInstanceUserErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DescribeAppInstanceUserErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            DescribeAppInstanceUserErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            DescribeAppInstanceUserErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            DescribeAppInstanceUserErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            DescribeAppInstanceUserErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeAppInstanceUserError {
    fn code(&self) -> Option<&str> {
        DescribeAppInstanceUserError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeAppInstanceUserError {
    pub fn new(kind: DescribeAppInstanceUserErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeAppInstanceUserErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeAppInstanceUserErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAppInstanceUserErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAppInstanceUserErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAppInstanceUserErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAppInstanceUserErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAppInstanceUserErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeAppInstanceUserErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for DescribeAppInstanceUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeAppInstanceUserErrorKind::BadRequestException(_inner) => Some(_inner),
            DescribeAppInstanceUserErrorKind::ForbiddenException(_inner) => Some(_inner),
            DescribeAppInstanceUserErrorKind::ServiceFailureException(_inner) => Some(_inner),
            DescribeAppInstanceUserErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            DescribeAppInstanceUserErrorKind::ThrottledClientException(_inner) => Some(_inner),
            DescribeAppInstanceUserErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            DescribeAppInstanceUserErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetAppInstanceRetentionSettingsError {
    pub kind: GetAppInstanceRetentionSettingsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetAppInstanceRetentionSettingsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetAppInstanceRetentionSettingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetAppInstanceRetentionSettingsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetAppInstanceRetentionSettingsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetAppInstanceRetentionSettingsErrorKind::ServiceFailureException(_inner) => {
                _inner.fmt(f)
            }
            GetAppInstanceRetentionSettingsErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            GetAppInstanceRetentionSettingsErrorKind::ThrottledClientException(_inner) => {
                _inner.fmt(f)
            }
            GetAppInstanceRetentionSettingsErrorKind::UnauthorizedClientException(_inner) => {
                _inner.fmt(f)
            }
            GetAppInstanceRetentionSettingsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetAppInstanceRetentionSettingsError {
    fn code(&self) -> Option<&str> {
        GetAppInstanceRetentionSettingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetAppInstanceRetentionSettingsError {
    pub fn new(kind: GetAppInstanceRetentionSettingsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetAppInstanceRetentionSettingsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetAppInstanceRetentionSettingsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAppInstanceRetentionSettingsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAppInstanceRetentionSettingsErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAppInstanceRetentionSettingsErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAppInstanceRetentionSettingsErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAppInstanceRetentionSettingsErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAppInstanceRetentionSettingsErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for GetAppInstanceRetentionSettingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetAppInstanceRetentionSettingsErrorKind::BadRequestException(_inner) => Some(_inner),
            GetAppInstanceRetentionSettingsErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetAppInstanceRetentionSettingsErrorKind::ServiceFailureException(_inner) => {
                Some(_inner)
            }
            GetAppInstanceRetentionSettingsErrorKind::ServiceUnavailableException(_inner) => {
                Some(_inner)
            }
            GetAppInstanceRetentionSettingsErrorKind::ThrottledClientException(_inner) => {
                Some(_inner)
            }
            GetAppInstanceRetentionSettingsErrorKind::UnauthorizedClientException(_inner) => {
                Some(_inner)
            }
            GetAppInstanceRetentionSettingsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListAppInstanceAdminsError {
    pub kind: ListAppInstanceAdminsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAppInstanceAdminsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListAppInstanceAdminsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListAppInstanceAdminsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListAppInstanceAdminsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListAppInstanceAdminsErrorKind::ResourceLimitExceededException(_inner) => _inner.fmt(f),
            ListAppInstanceAdminsErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            ListAppInstanceAdminsErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListAppInstanceAdminsErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            ListAppInstanceAdminsErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            ListAppInstanceAdminsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListAppInstanceAdminsError {
    fn code(&self) -> Option<&str> {
        ListAppInstanceAdminsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListAppInstanceAdminsError {
    pub fn new(kind: ListAppInstanceAdminsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListAppInstanceAdminsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListAppInstanceAdminsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAppInstanceAdminsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAppInstanceAdminsErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAppInstanceAdminsErrorKind::ResourceLimitExceededException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAppInstanceAdminsErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAppInstanceAdminsErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAppInstanceAdminsErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAppInstanceAdminsErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for ListAppInstanceAdminsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListAppInstanceAdminsErrorKind::BadRequestException(_inner) => Some(_inner),
            ListAppInstanceAdminsErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListAppInstanceAdminsErrorKind::ResourceLimitExceededException(_inner) => Some(_inner),
            ListAppInstanceAdminsErrorKind::ServiceFailureException(_inner) => Some(_inner),
            ListAppInstanceAdminsErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListAppInstanceAdminsErrorKind::ThrottledClientException(_inner) => Some(_inner),
            ListAppInstanceAdminsErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            ListAppInstanceAdminsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListAppInstancesError {
    pub kind: ListAppInstancesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAppInstancesErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListAppInstancesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListAppInstancesErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListAppInstancesErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListAppInstancesErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            ListAppInstancesErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListAppInstancesErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            ListAppInstancesErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            ListAppInstancesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListAppInstancesError {
    fn code(&self) -> Option<&str> {
        ListAppInstancesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListAppInstancesError {
    pub fn new(kind: ListAppInstancesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListAppInstancesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListAppInstancesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAppInstancesErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, ListAppInstancesErrorKind::ForbiddenException(_))
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAppInstancesErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAppInstancesErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAppInstancesErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAppInstancesErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for ListAppInstancesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListAppInstancesErrorKind::BadRequestException(_inner) => Some(_inner),
            ListAppInstancesErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListAppInstancesErrorKind::ServiceFailureException(_inner) => Some(_inner),
            ListAppInstancesErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListAppInstancesErrorKind::ThrottledClientException(_inner) => Some(_inner),
            ListAppInstancesErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            ListAppInstancesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListAppInstanceUsersError {
    pub kind: ListAppInstanceUsersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAppInstanceUsersErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListAppInstanceUsersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListAppInstanceUsersErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListAppInstanceUsersErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListAppInstanceUsersErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            ListAppInstanceUsersErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListAppInstanceUsersErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            ListAppInstanceUsersErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            ListAppInstanceUsersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListAppInstanceUsersError {
    fn code(&self) -> Option<&str> {
        ListAppInstanceUsersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListAppInstanceUsersError {
    pub fn new(kind: ListAppInstanceUsersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListAppInstanceUsersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListAppInstanceUsersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAppInstanceUsersErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAppInstanceUsersErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAppInstanceUsersErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAppInstanceUsersErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAppInstanceUsersErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAppInstanceUsersErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for ListAppInstanceUsersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListAppInstanceUsersErrorKind::BadRequestException(_inner) => Some(_inner),
            ListAppInstanceUsersErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListAppInstanceUsersErrorKind::ServiceFailureException(_inner) => Some(_inner),
            ListAppInstanceUsersErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            ListAppInstanceUsersErrorKind::ThrottledClientException(_inner) => Some(_inner),
            ListAppInstanceUsersErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            ListAppInstanceUsersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutAppInstanceRetentionSettingsError {
    pub kind: PutAppInstanceRetentionSettingsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutAppInstanceRetentionSettingsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutAppInstanceRetentionSettingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutAppInstanceRetentionSettingsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            PutAppInstanceRetentionSettingsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            PutAppInstanceRetentionSettingsErrorKind::ServiceFailureException(_inner) => {
                _inner.fmt(f)
            }
            PutAppInstanceRetentionSettingsErrorKind::ServiceUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            PutAppInstanceRetentionSettingsErrorKind::ThrottledClientException(_inner) => {
                _inner.fmt(f)
            }
            PutAppInstanceRetentionSettingsErrorKind::UnauthorizedClientException(_inner) => {
                _inner.fmt(f)
            }
            PutAppInstanceRetentionSettingsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutAppInstanceRetentionSettingsError {
    fn code(&self) -> Option<&str> {
        PutAppInstanceRetentionSettingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutAppInstanceRetentionSettingsError {
    pub fn new(kind: PutAppInstanceRetentionSettingsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutAppInstanceRetentionSettingsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutAppInstanceRetentionSettingsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutAppInstanceRetentionSettingsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutAppInstanceRetentionSettingsErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutAppInstanceRetentionSettingsErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutAppInstanceRetentionSettingsErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutAppInstanceRetentionSettingsErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutAppInstanceRetentionSettingsErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for PutAppInstanceRetentionSettingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutAppInstanceRetentionSettingsErrorKind::BadRequestException(_inner) => Some(_inner),
            PutAppInstanceRetentionSettingsErrorKind::ForbiddenException(_inner) => Some(_inner),
            PutAppInstanceRetentionSettingsErrorKind::ServiceFailureException(_inner) => {
                Some(_inner)
            }
            PutAppInstanceRetentionSettingsErrorKind::ServiceUnavailableException(_inner) => {
                Some(_inner)
            }
            PutAppInstanceRetentionSettingsErrorKind::ThrottledClientException(_inner) => {
                Some(_inner)
            }
            PutAppInstanceRetentionSettingsErrorKind::UnauthorizedClientException(_inner) => {
                Some(_inner)
            }
            PutAppInstanceRetentionSettingsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateAppInstanceError {
    pub kind: UpdateAppInstanceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateAppInstanceErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateAppInstanceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateAppInstanceErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateAppInstanceErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateAppInstanceErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateAppInstanceErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            UpdateAppInstanceErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            UpdateAppInstanceErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            UpdateAppInstanceErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            UpdateAppInstanceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateAppInstanceError {
    fn code(&self) -> Option<&str> {
        UpdateAppInstanceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateAppInstanceError {
    pub fn new(kind: UpdateAppInstanceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateAppInstanceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateAppInstanceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAppInstanceErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, UpdateAppInstanceErrorKind::ConflictException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAppInstanceErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAppInstanceErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAppInstanceErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAppInstanceErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAppInstanceErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for UpdateAppInstanceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateAppInstanceErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateAppInstanceErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateAppInstanceErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateAppInstanceErrorKind::ServiceFailureException(_inner) => Some(_inner),
            UpdateAppInstanceErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UpdateAppInstanceErrorKind::ThrottledClientException(_inner) => Some(_inner),
            UpdateAppInstanceErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            UpdateAppInstanceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateAppInstanceUserError {
    pub kind: UpdateAppInstanceUserErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateAppInstanceUserErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    ServiceFailureException(crate::error::ServiceFailureException),
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    ThrottledClientException(crate::error::ThrottledClientException),
    UnauthorizedClientException(crate::error::UnauthorizedClientException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateAppInstanceUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateAppInstanceUserErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateAppInstanceUserErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateAppInstanceUserErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateAppInstanceUserErrorKind::ResourceLimitExceededException(_inner) => _inner.fmt(f),
            UpdateAppInstanceUserErrorKind::ServiceFailureException(_inner) => _inner.fmt(f),
            UpdateAppInstanceUserErrorKind::ServiceUnavailableException(_inner) => _inner.fmt(f),
            UpdateAppInstanceUserErrorKind::ThrottledClientException(_inner) => _inner.fmt(f),
            UpdateAppInstanceUserErrorKind::UnauthorizedClientException(_inner) => _inner.fmt(f),
            UpdateAppInstanceUserErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateAppInstanceUserError {
    fn code(&self) -> Option<&str> {
        UpdateAppInstanceUserError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateAppInstanceUserError {
    pub fn new(kind: UpdateAppInstanceUserErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateAppInstanceUserErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateAppInstanceUserErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAppInstanceUserErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAppInstanceUserErrorKind::ConflictException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAppInstanceUserErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAppInstanceUserErrorKind::ResourceLimitExceededException(_)
        )
    }
    pub fn is_service_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAppInstanceUserErrorKind::ServiceFailureException(_)
        )
    }
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAppInstanceUserErrorKind::ServiceUnavailableException(_)
        )
    }
    pub fn is_throttled_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAppInstanceUserErrorKind::ThrottledClientException(_)
        )
    }
    pub fn is_unauthorized_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAppInstanceUserErrorKind::UnauthorizedClientException(_)
        )
    }
}
impl std::error::Error for UpdateAppInstanceUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateAppInstanceUserErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateAppInstanceUserErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateAppInstanceUserErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateAppInstanceUserErrorKind::ResourceLimitExceededException(_inner) => Some(_inner),
            UpdateAppInstanceUserErrorKind::ServiceFailureException(_inner) => Some(_inner),
            UpdateAppInstanceUserErrorKind::ServiceUnavailableException(_inner) => Some(_inner),
            UpdateAppInstanceUserErrorKind::ThrottledClientException(_inner) => Some(_inner),
            UpdateAppInstanceUserErrorKind::UnauthorizedClientException(_inner) => Some(_inner),
            UpdateAppInstanceUserErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// <p>The client is not currently authorized to make the request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UnauthorizedClientException {
    pub code: std::option::Option<crate::model::ErrorCode>,
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UnauthorizedClientException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UnauthorizedClientException");
        formatter.field("code", &self.code);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl UnauthorizedClientException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UnauthorizedClientException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UnauthorizedClientException")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for UnauthorizedClientException {}
/// See [`UnauthorizedClientException`](crate::error::UnauthorizedClientException)
pub mod unauthorized_client_exception {
    /// A builder for [`UnauthorizedClientException`](crate::error::UnauthorizedClientException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<crate::model::ErrorCode>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn code(mut self, input: crate::model::ErrorCode) -> Self {
            self.code = Some(input);
            self
        }
        pub fn set_code(mut self, input: std::option::Option<crate::model::ErrorCode>) -> Self {
            self.code = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`UnauthorizedClientException`](crate::error::UnauthorizedClientException)
        pub fn build(self) -> crate::error::UnauthorizedClientException {
            crate::error::UnauthorizedClientException {
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl UnauthorizedClientException {
    /// Creates a new builder-style object to manufacture [`UnauthorizedClientException`](crate::error::UnauthorizedClientException)
    pub fn builder() -> crate::error::unauthorized_client_exception::Builder {
        crate::error::unauthorized_client_exception::Builder::default()
    }
}

/// <p>The client exceeded its request rate limit.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ThrottledClientException {
    pub code: std::option::Option<crate::model::ErrorCode>,
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ThrottledClientException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ThrottledClientException");
        formatter.field("code", &self.code);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ThrottledClientException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ThrottledClientException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ThrottledClientException")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for ThrottledClientException {}
/// See [`ThrottledClientException`](crate::error::ThrottledClientException)
pub mod throttled_client_exception {
    /// A builder for [`ThrottledClientException`](crate::error::ThrottledClientException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<crate::model::ErrorCode>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn code(mut self, input: crate::model::ErrorCode) -> Self {
            self.code = Some(input);
            self
        }
        pub fn set_code(mut self, input: std::option::Option<crate::model::ErrorCode>) -> Self {
            self.code = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ThrottledClientException`](crate::error::ThrottledClientException)
        pub fn build(self) -> crate::error::ThrottledClientException {
            crate::error::ThrottledClientException {
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl ThrottledClientException {
    /// Creates a new builder-style object to manufacture [`ThrottledClientException`](crate::error::ThrottledClientException)
    pub fn builder() -> crate::error::throttled_client_exception::Builder {
        crate::error::throttled_client_exception::Builder::default()
    }
}

/// <p>The service is currently unavailable.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ServiceUnavailableException {
    pub code: std::option::Option<crate::model::ErrorCode>,
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ServiceUnavailableException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ServiceUnavailableException");
        formatter.field("code", &self.code);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ServiceUnavailableException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ServiceUnavailableException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ServiceUnavailableException")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for ServiceUnavailableException {}
/// See [`ServiceUnavailableException`](crate::error::ServiceUnavailableException)
pub mod service_unavailable_exception {
    /// A builder for [`ServiceUnavailableException`](crate::error::ServiceUnavailableException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<crate::model::ErrorCode>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn code(mut self, input: crate::model::ErrorCode) -> Self {
            self.code = Some(input);
            self
        }
        pub fn set_code(mut self, input: std::option::Option<crate::model::ErrorCode>) -> Self {
            self.code = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ServiceUnavailableException`](crate::error::ServiceUnavailableException)
        pub fn build(self) -> crate::error::ServiceUnavailableException {
            crate::error::ServiceUnavailableException {
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl ServiceUnavailableException {
    /// Creates a new builder-style object to manufacture [`ServiceUnavailableException`](crate::error::ServiceUnavailableException)
    pub fn builder() -> crate::error::service_unavailable_exception::Builder {
        crate::error::service_unavailable_exception::Builder::default()
    }
}

/// <p>The service encountered an unexpected error.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ServiceFailureException {
    pub code: std::option::Option<crate::model::ErrorCode>,
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ServiceFailureException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ServiceFailureException");
        formatter.field("code", &self.code);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ServiceFailureException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ServiceFailureException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ServiceFailureException")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for ServiceFailureException {}
/// See [`ServiceFailureException`](crate::error::ServiceFailureException)
pub mod service_failure_exception {
    /// A builder for [`ServiceFailureException`](crate::error::ServiceFailureException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<crate::model::ErrorCode>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn code(mut self, input: crate::model::ErrorCode) -> Self {
            self.code = Some(input);
            self
        }
        pub fn set_code(mut self, input: std::option::Option<crate::model::ErrorCode>) -> Self {
            self.code = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ServiceFailureException`](crate::error::ServiceFailureException)
        pub fn build(self) -> crate::error::ServiceFailureException {
            crate::error::ServiceFailureException {
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl ServiceFailureException {
    /// Creates a new builder-style object to manufacture [`ServiceFailureException`](crate::error::ServiceFailureException)
    pub fn builder() -> crate::error::service_failure_exception::Builder {
        crate::error::service_failure_exception::Builder::default()
    }
}

/// <p>The request exceeds the resource limit.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceLimitExceededException {
    pub code: std::option::Option<crate::model::ErrorCode>,
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceLimitExceededException");
        formatter.field("code", &self.code);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ResourceLimitExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceLimitExceededException")?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceLimitExceededException {}
/// See [`ResourceLimitExceededException`](crate::error::ResourceLimitExceededException)
pub mod resource_limit_exceeded_exception {
    /// A builder for [`ResourceLimitExceededException`](crate::error::ResourceLimitExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<crate::model::ErrorCode>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn code(mut self, input: crate::model::ErrorCode) -> Self {
            self.code = Some(input);
            self
        }
        pub fn set_code(mut self, input: std::option::Option<crate::model::ErrorCode>) -> Self {
            self.code = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceLimitExceededException`](crate::error::ResourceLimitExceededException)
        pub fn build(self) -> crate::error::ResourceLimitExceededException {
            crate::error::ResourceLimitExceededException {
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl ResourceLimitExceededException {
    /// Creates a new builder-style object to manufacture [`ResourceLimitExceededException`](crate::error::ResourceLimitExceededException)
    pub fn builder() -> crate::error::resource_limit_exceeded_exception::Builder {
        crate::error::resource_limit_exceeded_exception::Builder::default()
    }
}

/// <p>The client is permanently forbidden from making the request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ForbiddenException {
    pub code: std::option::Option<crate::model::ErrorCode>,
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ForbiddenException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ForbiddenException");
        formatter.field("code", &self.code);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ForbiddenException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ForbiddenException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ForbiddenException")?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl std::error::Error for ForbiddenException {}
/// See [`ForbiddenException`](crate::error::ForbiddenException)
pub mod forbidden_exception {
    /// A builder for [`ForbiddenException`](crate::error::ForbiddenException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<crate::model::ErrorCode>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn code(mut self, input: crate::model::ErrorCode) -> Self {
            self.code = Some(input);
            self
        }
        pub fn set_code(mut self, input: std::option::Option<crate::model::ErrorCode>) -> Self {
            self.code = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ForbiddenException`](crate::error::ForbiddenException)
        pub fn build(self) -> crate::error::ForbiddenException {
            crate::error::ForbiddenException {
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl ForbiddenException {
    /// Creates a new builder-style object to manufacture [`ForbiddenException`](crate::error::ForbiddenException)
    pub fn builder() -> crate::error::forbidden_exception::Builder {
        crate::error::forbidden_exception::Builder::default()
    }
}

/// <p>The request could not be processed because of conflict in the current state of the
/// resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ConflictException {
    pub code: std::option::Option<crate::model::ErrorCode>,
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ConflictException");
        formatter.field("code", &self.code);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ConflictException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ConflictException")?;
        if let Some(inner_7) = &self.message {
            write!(f, ": {}", inner_7)?;
        }
        Ok(())
    }
}
impl std::error::Error for ConflictException {}
/// See [`ConflictException`](crate::error::ConflictException)
pub mod conflict_exception {
    /// A builder for [`ConflictException`](crate::error::ConflictException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<crate::model::ErrorCode>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn code(mut self, input: crate::model::ErrorCode) -> Self {
            self.code = Some(input);
            self
        }
        pub fn set_code(mut self, input: std::option::Option<crate::model::ErrorCode>) -> Self {
            self.code = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ConflictException`](crate::error::ConflictException)
        pub fn build(self) -> crate::error::ConflictException {
            crate::error::ConflictException {
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl ConflictException {
    /// Creates a new builder-style object to manufacture [`ConflictException`](crate::error::ConflictException)
    pub fn builder() -> crate::error::conflict_exception::Builder {
        crate::error::conflict_exception::Builder::default()
    }
}

/// <p>The input parameters don't match the service's restrictions.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BadRequestException {
    pub code: std::option::Option<crate::model::ErrorCode>,
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for BadRequestException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BadRequestException");
        formatter.field("code", &self.code);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl BadRequestException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for BadRequestException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "BadRequestException")?;
        if let Some(inner_8) = &self.message {
            write!(f, ": {}", inner_8)?;
        }
        Ok(())
    }
}
impl std::error::Error for BadRequestException {}
/// See [`BadRequestException`](crate::error::BadRequestException)
pub mod bad_request_exception {
    /// A builder for [`BadRequestException`](crate::error::BadRequestException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<crate::model::ErrorCode>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn code(mut self, input: crate::model::ErrorCode) -> Self {
            self.code = Some(input);
            self
        }
        pub fn set_code(mut self, input: std::option::Option<crate::model::ErrorCode>) -> Self {
            self.code = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`BadRequestException`](crate::error::BadRequestException)
        pub fn build(self) -> crate::error::BadRequestException {
            crate::error::BadRequestException {
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl BadRequestException {
    /// Creates a new builder-style object to manufacture [`BadRequestException`](crate::error::BadRequestException)
    pub fn builder() -> crate::error::bad_request_exception::Builder {
        crate::error::bad_request_exception::Builder::default()
    }
}
