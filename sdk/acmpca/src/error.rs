// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// Error type for the `CreateCertificateAuthority` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateCertificateAuthorityError {
    /// Kind of error that occurred.
    pub kind: CreateCertificateAuthorityErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CreateCertificateAuthority` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateCertificateAuthorityErrorKind {
    /// <p>One or more of the specified arguments was not valid.</p>
    InvalidArgsException(crate::error::InvalidArgsException),
    /// <p>The resource policy is invalid or is missing a required statement. For general
    /// information about IAM policy and statement structure, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#access_policies-json">Overview of JSON Policies</a>.</p>
    InvalidPolicyException(crate::error::InvalidPolicyException),
    /// <p>The tag associated with the CA is not valid. The invalid argument is contained in the
    /// message field.</p>
    InvalidTagException(crate::error::InvalidTagException),
    /// <p>An ACM Private CA quota has been exceeded. See the exception message returned to determine the
    /// quota that was exceeded.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateCertificateAuthorityError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateCertificateAuthorityErrorKind::InvalidArgsException(_inner) => _inner.fmt(f),
            CreateCertificateAuthorityErrorKind::InvalidPolicyException(_inner) => _inner.fmt(f),
            CreateCertificateAuthorityErrorKind::InvalidTagException(_inner) => _inner.fmt(f),
            CreateCertificateAuthorityErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateCertificateAuthorityErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateCertificateAuthorityError {
    fn code(&self) -> Option<&str> {
        CreateCertificateAuthorityError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateCertificateAuthorityError {
    /// Creates a new `CreateCertificateAuthorityError`.
    pub fn new(kind: CreateCertificateAuthorityErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `CreateCertificateAuthorityError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateCertificateAuthorityErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `CreateCertificateAuthorityError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateCertificateAuthorityErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns true if the error kind is `CreateCertificateAuthorityErrorKind::InvalidArgsException`.
    pub fn is_invalid_args_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCertificateAuthorityErrorKind::InvalidArgsException(_)
        )
    }
    /// Returns true if the error kind is `CreateCertificateAuthorityErrorKind::InvalidPolicyException`.
    pub fn is_invalid_policy_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCertificateAuthorityErrorKind::InvalidPolicyException(_)
        )
    }
    /// Returns true if the error kind is `CreateCertificateAuthorityErrorKind::InvalidTagException`.
    pub fn is_invalid_tag_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCertificateAuthorityErrorKind::InvalidTagException(_)
        )
    }
    /// Returns true if the error kind is `CreateCertificateAuthorityErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCertificateAuthorityErrorKind::LimitExceededException(_)
        )
    }
}
impl std::error::Error for CreateCertificateAuthorityError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateCertificateAuthorityErrorKind::InvalidArgsException(_inner) => Some(_inner),
            CreateCertificateAuthorityErrorKind::InvalidPolicyException(_inner) => Some(_inner),
            CreateCertificateAuthorityErrorKind::InvalidTagException(_inner) => Some(_inner),
            CreateCertificateAuthorityErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateCertificateAuthorityErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `CreateCertificateAuthorityAuditReport` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateCertificateAuthorityAuditReportError {
    /// Kind of error that occurred.
    pub kind: CreateCertificateAuthorityAuditReportErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CreateCertificateAuthorityAuditReport` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateCertificateAuthorityAuditReportErrorKind {
    /// <p>One or more of the specified arguments was not valid.</p>
    InvalidArgsException(crate::error::InvalidArgsException),
    /// <p>The requested Amazon Resource Name (ARN) does not refer to an existing
    /// resource.</p>
    InvalidArnException(crate::error::InvalidArnException),
    /// <p>The state of the private CA does not allow this action to occur.</p>
    InvalidStateException(crate::error::InvalidStateException),
    /// <p>The request has failed for an unspecified reason.</p>
    RequestFailedException(crate::error::RequestFailedException),
    /// <p>Your request is already in progress.</p>
    RequestInProgressException(crate::error::RequestInProgressException),
    /// <p>A resource such as a private CA, S3 bucket, certificate, audit report, or policy
    /// cannot be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateCertificateAuthorityAuditReportError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateCertificateAuthorityAuditReportErrorKind::InvalidArgsException(_inner) => {
                _inner.fmt(f)
            }
            CreateCertificateAuthorityAuditReportErrorKind::InvalidArnException(_inner) => {
                _inner.fmt(f)
            }
            CreateCertificateAuthorityAuditReportErrorKind::InvalidStateException(_inner) => {
                _inner.fmt(f)
            }
            CreateCertificateAuthorityAuditReportErrorKind::RequestFailedException(_inner) => {
                _inner.fmt(f)
            }
            CreateCertificateAuthorityAuditReportErrorKind::RequestInProgressException(_inner) => {
                _inner.fmt(f)
            }
            CreateCertificateAuthorityAuditReportErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            CreateCertificateAuthorityAuditReportErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateCertificateAuthorityAuditReportError {
    fn code(&self) -> Option<&str> {
        CreateCertificateAuthorityAuditReportError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateCertificateAuthorityAuditReportError {
    /// Creates a new `CreateCertificateAuthorityAuditReportError`.
    pub fn new(
        kind: CreateCertificateAuthorityAuditReportErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `CreateCertificateAuthorityAuditReportError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateCertificateAuthorityAuditReportErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `CreateCertificateAuthorityAuditReportError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateCertificateAuthorityAuditReportErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns true if the error kind is `CreateCertificateAuthorityAuditReportErrorKind::InvalidArgsException`.
    pub fn is_invalid_args_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCertificateAuthorityAuditReportErrorKind::InvalidArgsException(_)
        )
    }
    /// Returns true if the error kind is `CreateCertificateAuthorityAuditReportErrorKind::InvalidArnException`.
    pub fn is_invalid_arn_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCertificateAuthorityAuditReportErrorKind::InvalidArnException(_)
        )
    }
    /// Returns true if the error kind is `CreateCertificateAuthorityAuditReportErrorKind::InvalidStateException`.
    pub fn is_invalid_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCertificateAuthorityAuditReportErrorKind::InvalidStateException(_)
        )
    }
    /// Returns true if the error kind is `CreateCertificateAuthorityAuditReportErrorKind::RequestFailedException`.
    pub fn is_request_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCertificateAuthorityAuditReportErrorKind::RequestFailedException(_)
        )
    }
    /// Returns true if the error kind is `CreateCertificateAuthorityAuditReportErrorKind::RequestInProgressException`.
    pub fn is_request_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCertificateAuthorityAuditReportErrorKind::RequestInProgressException(_)
        )
    }
    /// Returns true if the error kind is `CreateCertificateAuthorityAuditReportErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCertificateAuthorityAuditReportErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for CreateCertificateAuthorityAuditReportError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateCertificateAuthorityAuditReportErrorKind::InvalidArgsException(_inner) => {
                Some(_inner)
            }
            CreateCertificateAuthorityAuditReportErrorKind::InvalidArnException(_inner) => {
                Some(_inner)
            }
            CreateCertificateAuthorityAuditReportErrorKind::InvalidStateException(_inner) => {
                Some(_inner)
            }
            CreateCertificateAuthorityAuditReportErrorKind::RequestFailedException(_inner) => {
                Some(_inner)
            }
            CreateCertificateAuthorityAuditReportErrorKind::RequestInProgressException(_inner) => {
                Some(_inner)
            }
            CreateCertificateAuthorityAuditReportErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            CreateCertificateAuthorityAuditReportErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

/// Error type for the `CreatePermission` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreatePermissionError {
    /// Kind of error that occurred.
    pub kind: CreatePermissionErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CreatePermission` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreatePermissionErrorKind {
    /// <p>The requested Amazon Resource Name (ARN) does not refer to an existing
    /// resource.</p>
    InvalidArnException(crate::error::InvalidArnException),
    /// <p>The state of the private CA does not allow this action to occur.</p>
    InvalidStateException(crate::error::InvalidStateException),
    /// <p>An ACM Private CA quota has been exceeded. See the exception message returned to determine the
    /// quota that was exceeded.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>The designated permission has already been given to the user.</p>
    PermissionAlreadyExistsException(crate::error::PermissionAlreadyExistsException),
    /// <p>The request has failed for an unspecified reason.</p>
    RequestFailedException(crate::error::RequestFailedException),
    /// <p>A resource such as a private CA, S3 bucket, certificate, audit report, or policy
    /// cannot be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreatePermissionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreatePermissionErrorKind::InvalidArnException(_inner) => _inner.fmt(f),
            CreatePermissionErrorKind::InvalidStateException(_inner) => _inner.fmt(f),
            CreatePermissionErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreatePermissionErrorKind::PermissionAlreadyExistsException(_inner) => _inner.fmt(f),
            CreatePermissionErrorKind::RequestFailedException(_inner) => _inner.fmt(f),
            CreatePermissionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreatePermissionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreatePermissionError {
    fn code(&self) -> Option<&str> {
        CreatePermissionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreatePermissionError {
    /// Creates a new `CreatePermissionError`.
    pub fn new(kind: CreatePermissionErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `CreatePermissionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreatePermissionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `CreatePermissionError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreatePermissionErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns true if the error kind is `CreatePermissionErrorKind::InvalidArnException`.
    pub fn is_invalid_arn_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePermissionErrorKind::InvalidArnException(_)
        )
    }
    /// Returns true if the error kind is `CreatePermissionErrorKind::InvalidStateException`.
    pub fn is_invalid_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePermissionErrorKind::InvalidStateException(_)
        )
    }
    /// Returns true if the error kind is `CreatePermissionErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePermissionErrorKind::LimitExceededException(_)
        )
    }
    /// Returns true if the error kind is `CreatePermissionErrorKind::PermissionAlreadyExistsException`.
    pub fn is_permission_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePermissionErrorKind::PermissionAlreadyExistsException(_)
        )
    }
    /// Returns true if the error kind is `CreatePermissionErrorKind::RequestFailedException`.
    pub fn is_request_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePermissionErrorKind::RequestFailedException(_)
        )
    }
    /// Returns true if the error kind is `CreatePermissionErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePermissionErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for CreatePermissionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreatePermissionErrorKind::InvalidArnException(_inner) => Some(_inner),
            CreatePermissionErrorKind::InvalidStateException(_inner) => Some(_inner),
            CreatePermissionErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreatePermissionErrorKind::PermissionAlreadyExistsException(_inner) => Some(_inner),
            CreatePermissionErrorKind::RequestFailedException(_inner) => Some(_inner),
            CreatePermissionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreatePermissionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DeleteCertificateAuthority` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteCertificateAuthorityError {
    /// Kind of error that occurred.
    pub kind: DeleteCertificateAuthorityErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DeleteCertificateAuthority` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteCertificateAuthorityErrorKind {
    /// <p>A previous update to your private CA is still ongoing.</p>
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    /// <p>The requested Amazon Resource Name (ARN) does not refer to an existing
    /// resource.</p>
    InvalidArnException(crate::error::InvalidArnException),
    /// <p>The state of the private CA does not allow this action to occur.</p>
    InvalidStateException(crate::error::InvalidStateException),
    /// <p>A resource such as a private CA, S3 bucket, certificate, audit report, or policy
    /// cannot be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteCertificateAuthorityError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteCertificateAuthorityErrorKind::ConcurrentModificationException(_inner) => {
                _inner.fmt(f)
            }
            DeleteCertificateAuthorityErrorKind::InvalidArnException(_inner) => _inner.fmt(f),
            DeleteCertificateAuthorityErrorKind::InvalidStateException(_inner) => _inner.fmt(f),
            DeleteCertificateAuthorityErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteCertificateAuthorityErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteCertificateAuthorityError {
    fn code(&self) -> Option<&str> {
        DeleteCertificateAuthorityError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteCertificateAuthorityError {
    /// Creates a new `DeleteCertificateAuthorityError`.
    pub fn new(kind: DeleteCertificateAuthorityErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DeleteCertificateAuthorityError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteCertificateAuthorityErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DeleteCertificateAuthorityError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteCertificateAuthorityErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns true if the error kind is `DeleteCertificateAuthorityErrorKind::ConcurrentModificationException`.
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCertificateAuthorityErrorKind::ConcurrentModificationException(_)
        )
    }
    /// Returns true if the error kind is `DeleteCertificateAuthorityErrorKind::InvalidArnException`.
    pub fn is_invalid_arn_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCertificateAuthorityErrorKind::InvalidArnException(_)
        )
    }
    /// Returns true if the error kind is `DeleteCertificateAuthorityErrorKind::InvalidStateException`.
    pub fn is_invalid_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCertificateAuthorityErrorKind::InvalidStateException(_)
        )
    }
    /// Returns true if the error kind is `DeleteCertificateAuthorityErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCertificateAuthorityErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for DeleteCertificateAuthorityError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteCertificateAuthorityErrorKind::ConcurrentModificationException(_inner) => {
                Some(_inner)
            }
            DeleteCertificateAuthorityErrorKind::InvalidArnException(_inner) => Some(_inner),
            DeleteCertificateAuthorityErrorKind::InvalidStateException(_inner) => Some(_inner),
            DeleteCertificateAuthorityErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteCertificateAuthorityErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DeletePermission` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeletePermissionError {
    /// Kind of error that occurred.
    pub kind: DeletePermissionErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DeletePermission` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeletePermissionErrorKind {
    /// <p>The requested Amazon Resource Name (ARN) does not refer to an existing
    /// resource.</p>
    InvalidArnException(crate::error::InvalidArnException),
    /// <p>The state of the private CA does not allow this action to occur.</p>
    InvalidStateException(crate::error::InvalidStateException),
    /// <p>The request has failed for an unspecified reason.</p>
    RequestFailedException(crate::error::RequestFailedException),
    /// <p>A resource such as a private CA, S3 bucket, certificate, audit report, or policy
    /// cannot be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeletePermissionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeletePermissionErrorKind::InvalidArnException(_inner) => _inner.fmt(f),
            DeletePermissionErrorKind::InvalidStateException(_inner) => _inner.fmt(f),
            DeletePermissionErrorKind::RequestFailedException(_inner) => _inner.fmt(f),
            DeletePermissionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeletePermissionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeletePermissionError {
    fn code(&self) -> Option<&str> {
        DeletePermissionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeletePermissionError {
    /// Creates a new `DeletePermissionError`.
    pub fn new(kind: DeletePermissionErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DeletePermissionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeletePermissionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DeletePermissionError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeletePermissionErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns true if the error kind is `DeletePermissionErrorKind::InvalidArnException`.
    pub fn is_invalid_arn_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePermissionErrorKind::InvalidArnException(_)
        )
    }
    /// Returns true if the error kind is `DeletePermissionErrorKind::InvalidStateException`.
    pub fn is_invalid_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePermissionErrorKind::InvalidStateException(_)
        )
    }
    /// Returns true if the error kind is `DeletePermissionErrorKind::RequestFailedException`.
    pub fn is_request_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePermissionErrorKind::RequestFailedException(_)
        )
    }
    /// Returns true if the error kind is `DeletePermissionErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePermissionErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for DeletePermissionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeletePermissionErrorKind::InvalidArnException(_inner) => Some(_inner),
            DeletePermissionErrorKind::InvalidStateException(_inner) => Some(_inner),
            DeletePermissionErrorKind::RequestFailedException(_inner) => Some(_inner),
            DeletePermissionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeletePermissionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DeletePolicy` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeletePolicyError {
    /// Kind of error that occurred.
    pub kind: DeletePolicyErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DeletePolicy` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeletePolicyErrorKind {
    /// <p>A previous update to your private CA is still ongoing.</p>
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    /// <p>The requested Amazon Resource Name (ARN) does not refer to an existing
    /// resource.</p>
    InvalidArnException(crate::error::InvalidArnException),
    /// <p>The state of the private CA does not allow this action to occur.</p>
    InvalidStateException(crate::error::InvalidStateException),
    /// <p>The current action was prevented because it would lock the caller out from performing
    /// subsequent actions. Verify that the specified parameters would not result in the caller
    /// being denied access to the resource. </p>
    LockoutPreventedException(crate::error::LockoutPreventedException),
    /// <p>The request has failed for an unspecified reason.</p>
    RequestFailedException(crate::error::RequestFailedException),
    /// <p>A resource such as a private CA, S3 bucket, certificate, audit report, or policy
    /// cannot be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeletePolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeletePolicyErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            DeletePolicyErrorKind::InvalidArnException(_inner) => _inner.fmt(f),
            DeletePolicyErrorKind::InvalidStateException(_inner) => _inner.fmt(f),
            DeletePolicyErrorKind::LockoutPreventedException(_inner) => _inner.fmt(f),
            DeletePolicyErrorKind::RequestFailedException(_inner) => _inner.fmt(f),
            DeletePolicyErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeletePolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeletePolicyError {
    fn code(&self) -> Option<&str> {
        DeletePolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeletePolicyError {
    /// Creates a new `DeletePolicyError`.
    pub fn new(kind: DeletePolicyErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DeletePolicyError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeletePolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DeletePolicyError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeletePolicyErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns true if the error kind is `DeletePolicyErrorKind::ConcurrentModificationException`.
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePolicyErrorKind::ConcurrentModificationException(_)
        )
    }
    /// Returns true if the error kind is `DeletePolicyErrorKind::InvalidArnException`.
    pub fn is_invalid_arn_exception(&self) -> bool {
        matches!(&self.kind, DeletePolicyErrorKind::InvalidArnException(_))
    }
    /// Returns true if the error kind is `DeletePolicyErrorKind::InvalidStateException`.
    pub fn is_invalid_state_exception(&self) -> bool {
        matches!(&self.kind, DeletePolicyErrorKind::InvalidStateException(_))
    }
    /// Returns true if the error kind is `DeletePolicyErrorKind::LockoutPreventedException`.
    pub fn is_lockout_prevented_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePolicyErrorKind::LockoutPreventedException(_)
        )
    }
    /// Returns true if the error kind is `DeletePolicyErrorKind::RequestFailedException`.
    pub fn is_request_failed_exception(&self) -> bool {
        matches!(&self.kind, DeletePolicyErrorKind::RequestFailedException(_))
    }
    /// Returns true if the error kind is `DeletePolicyErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePolicyErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for DeletePolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeletePolicyErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            DeletePolicyErrorKind::InvalidArnException(_inner) => Some(_inner),
            DeletePolicyErrorKind::InvalidStateException(_inner) => Some(_inner),
            DeletePolicyErrorKind::LockoutPreventedException(_inner) => Some(_inner),
            DeletePolicyErrorKind::RequestFailedException(_inner) => Some(_inner),
            DeletePolicyErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeletePolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DescribeCertificateAuthority` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeCertificateAuthorityError {
    /// Kind of error that occurred.
    pub kind: DescribeCertificateAuthorityErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DescribeCertificateAuthority` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeCertificateAuthorityErrorKind {
    /// <p>The requested Amazon Resource Name (ARN) does not refer to an existing
    /// resource.</p>
    InvalidArnException(crate::error::InvalidArnException),
    /// <p>A resource such as a private CA, S3 bucket, certificate, audit report, or policy
    /// cannot be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeCertificateAuthorityError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeCertificateAuthorityErrorKind::InvalidArnException(_inner) => _inner.fmt(f),
            DescribeCertificateAuthorityErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DescribeCertificateAuthorityErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeCertificateAuthorityError {
    fn code(&self) -> Option<&str> {
        DescribeCertificateAuthorityError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeCertificateAuthorityError {
    /// Creates a new `DescribeCertificateAuthorityError`.
    pub fn new(kind: DescribeCertificateAuthorityErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DescribeCertificateAuthorityError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeCertificateAuthorityErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DescribeCertificateAuthorityError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeCertificateAuthorityErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns true if the error kind is `DescribeCertificateAuthorityErrorKind::InvalidArnException`.
    pub fn is_invalid_arn_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCertificateAuthorityErrorKind::InvalidArnException(_)
        )
    }
    /// Returns true if the error kind is `DescribeCertificateAuthorityErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCertificateAuthorityErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for DescribeCertificateAuthorityError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeCertificateAuthorityErrorKind::InvalidArnException(_inner) => Some(_inner),
            DescribeCertificateAuthorityErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            DescribeCertificateAuthorityErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DescribeCertificateAuthorityAuditReport` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeCertificateAuthorityAuditReportError {
    /// Kind of error that occurred.
    pub kind: DescribeCertificateAuthorityAuditReportErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DescribeCertificateAuthorityAuditReport` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeCertificateAuthorityAuditReportErrorKind {
    /// <p>One or more of the specified arguments was not valid.</p>
    InvalidArgsException(crate::error::InvalidArgsException),
    /// <p>The requested Amazon Resource Name (ARN) does not refer to an existing
    /// resource.</p>
    InvalidArnException(crate::error::InvalidArnException),
    /// <p>A resource such as a private CA, S3 bucket, certificate, audit report, or policy
    /// cannot be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeCertificateAuthorityAuditReportError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeCertificateAuthorityAuditReportErrorKind::InvalidArgsException(_inner) => {
                _inner.fmt(f)
            }
            DescribeCertificateAuthorityAuditReportErrorKind::InvalidArnException(_inner) => {
                _inner.fmt(f)
            }
            DescribeCertificateAuthorityAuditReportErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DescribeCertificateAuthorityAuditReportErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeCertificateAuthorityAuditReportError {
    fn code(&self) -> Option<&str> {
        DescribeCertificateAuthorityAuditReportError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeCertificateAuthorityAuditReportError {
    /// Creates a new `DescribeCertificateAuthorityAuditReportError`.
    pub fn new(
        kind: DescribeCertificateAuthorityAuditReportErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DescribeCertificateAuthorityAuditReportError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeCertificateAuthorityAuditReportErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DescribeCertificateAuthorityAuditReportError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeCertificateAuthorityAuditReportErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns true if the error kind is `DescribeCertificateAuthorityAuditReportErrorKind::InvalidArgsException`.
    pub fn is_invalid_args_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCertificateAuthorityAuditReportErrorKind::InvalidArgsException(_)
        )
    }
    /// Returns true if the error kind is `DescribeCertificateAuthorityAuditReportErrorKind::InvalidArnException`.
    pub fn is_invalid_arn_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCertificateAuthorityAuditReportErrorKind::InvalidArnException(_)
        )
    }
    /// Returns true if the error kind is `DescribeCertificateAuthorityAuditReportErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCertificateAuthorityAuditReportErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for DescribeCertificateAuthorityAuditReportError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeCertificateAuthorityAuditReportErrorKind::InvalidArgsException(_inner) => {
                Some(_inner)
            }
            DescribeCertificateAuthorityAuditReportErrorKind::InvalidArnException(_inner) => {
                Some(_inner)
            }
            DescribeCertificateAuthorityAuditReportErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            DescribeCertificateAuthorityAuditReportErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

/// Error type for the `GetCertificate` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetCertificateError {
    /// Kind of error that occurred.
    pub kind: GetCertificateErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetCertificate` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetCertificateErrorKind {
    /// <p>The requested Amazon Resource Name (ARN) does not refer to an existing
    /// resource.</p>
    InvalidArnException(crate::error::InvalidArnException),
    /// <p>The state of the private CA does not allow this action to occur.</p>
    InvalidStateException(crate::error::InvalidStateException),
    /// <p>The request has failed for an unspecified reason.</p>
    RequestFailedException(crate::error::RequestFailedException),
    /// <p>Your request is already in progress.</p>
    RequestInProgressException(crate::error::RequestInProgressException),
    /// <p>A resource such as a private CA, S3 bucket, certificate, audit report, or policy
    /// cannot be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetCertificateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetCertificateErrorKind::InvalidArnException(_inner) => _inner.fmt(f),
            GetCertificateErrorKind::InvalidStateException(_inner) => _inner.fmt(f),
            GetCertificateErrorKind::RequestFailedException(_inner) => _inner.fmt(f),
            GetCertificateErrorKind::RequestInProgressException(_inner) => _inner.fmt(f),
            GetCertificateErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetCertificateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetCertificateError {
    fn code(&self) -> Option<&str> {
        GetCertificateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetCertificateError {
    /// Creates a new `GetCertificateError`.
    pub fn new(kind: GetCertificateErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetCertificateError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetCertificateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `GetCertificateError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetCertificateErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns true if the error kind is `GetCertificateErrorKind::InvalidArnException`.
    pub fn is_invalid_arn_exception(&self) -> bool {
        matches!(&self.kind, GetCertificateErrorKind::InvalidArnException(_))
    }
    /// Returns true if the error kind is `GetCertificateErrorKind::InvalidStateException`.
    pub fn is_invalid_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCertificateErrorKind::InvalidStateException(_)
        )
    }
    /// Returns true if the error kind is `GetCertificateErrorKind::RequestFailedException`.
    pub fn is_request_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCertificateErrorKind::RequestFailedException(_)
        )
    }
    /// Returns true if the error kind is `GetCertificateErrorKind::RequestInProgressException`.
    pub fn is_request_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCertificateErrorKind::RequestInProgressException(_)
        )
    }
    /// Returns true if the error kind is `GetCertificateErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCertificateErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for GetCertificateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetCertificateErrorKind::InvalidArnException(_inner) => Some(_inner),
            GetCertificateErrorKind::InvalidStateException(_inner) => Some(_inner),
            GetCertificateErrorKind::RequestFailedException(_inner) => Some(_inner),
            GetCertificateErrorKind::RequestInProgressException(_inner) => Some(_inner),
            GetCertificateErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetCertificateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `GetCertificateAuthorityCertificate` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetCertificateAuthorityCertificateError {
    /// Kind of error that occurred.
    pub kind: GetCertificateAuthorityCertificateErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetCertificateAuthorityCertificate` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetCertificateAuthorityCertificateErrorKind {
    /// <p>The requested Amazon Resource Name (ARN) does not refer to an existing
    /// resource.</p>
    InvalidArnException(crate::error::InvalidArnException),
    /// <p>The state of the private CA does not allow this action to occur.</p>
    InvalidStateException(crate::error::InvalidStateException),
    /// <p>A resource such as a private CA, S3 bucket, certificate, audit report, or policy
    /// cannot be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetCertificateAuthorityCertificateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetCertificateAuthorityCertificateErrorKind::InvalidArnException(_inner) => {
                _inner.fmt(f)
            }
            GetCertificateAuthorityCertificateErrorKind::InvalidStateException(_inner) => {
                _inner.fmt(f)
            }
            GetCertificateAuthorityCertificateErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            GetCertificateAuthorityCertificateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetCertificateAuthorityCertificateError {
    fn code(&self) -> Option<&str> {
        GetCertificateAuthorityCertificateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetCertificateAuthorityCertificateError {
    /// Creates a new `GetCertificateAuthorityCertificateError`.
    pub fn new(
        kind: GetCertificateAuthorityCertificateErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetCertificateAuthorityCertificateError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetCertificateAuthorityCertificateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `GetCertificateAuthorityCertificateError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetCertificateAuthorityCertificateErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns true if the error kind is `GetCertificateAuthorityCertificateErrorKind::InvalidArnException`.
    pub fn is_invalid_arn_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCertificateAuthorityCertificateErrorKind::InvalidArnException(_)
        )
    }
    /// Returns true if the error kind is `GetCertificateAuthorityCertificateErrorKind::InvalidStateException`.
    pub fn is_invalid_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCertificateAuthorityCertificateErrorKind::InvalidStateException(_)
        )
    }
    /// Returns true if the error kind is `GetCertificateAuthorityCertificateErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCertificateAuthorityCertificateErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for GetCertificateAuthorityCertificateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetCertificateAuthorityCertificateErrorKind::InvalidArnException(_inner) => {
                Some(_inner)
            }
            GetCertificateAuthorityCertificateErrorKind::InvalidStateException(_inner) => {
                Some(_inner)
            }
            GetCertificateAuthorityCertificateErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            GetCertificateAuthorityCertificateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `GetCertificateAuthorityCsr` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetCertificateAuthorityCsrError {
    /// Kind of error that occurred.
    pub kind: GetCertificateAuthorityCsrErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetCertificateAuthorityCsr` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetCertificateAuthorityCsrErrorKind {
    /// <p>The requested Amazon Resource Name (ARN) does not refer to an existing
    /// resource.</p>
    InvalidArnException(crate::error::InvalidArnException),
    /// <p>The state of the private CA does not allow this action to occur.</p>
    InvalidStateException(crate::error::InvalidStateException),
    /// <p>The request has failed for an unspecified reason.</p>
    RequestFailedException(crate::error::RequestFailedException),
    /// <p>Your request is already in progress.</p>
    RequestInProgressException(crate::error::RequestInProgressException),
    /// <p>A resource such as a private CA, S3 bucket, certificate, audit report, or policy
    /// cannot be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetCertificateAuthorityCsrError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetCertificateAuthorityCsrErrorKind::InvalidArnException(_inner) => _inner.fmt(f),
            GetCertificateAuthorityCsrErrorKind::InvalidStateException(_inner) => _inner.fmt(f),
            GetCertificateAuthorityCsrErrorKind::RequestFailedException(_inner) => _inner.fmt(f),
            GetCertificateAuthorityCsrErrorKind::RequestInProgressException(_inner) => {
                _inner.fmt(f)
            }
            GetCertificateAuthorityCsrErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetCertificateAuthorityCsrErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetCertificateAuthorityCsrError {
    fn code(&self) -> Option<&str> {
        GetCertificateAuthorityCsrError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetCertificateAuthorityCsrError {
    /// Creates a new `GetCertificateAuthorityCsrError`.
    pub fn new(kind: GetCertificateAuthorityCsrErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetCertificateAuthorityCsrError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetCertificateAuthorityCsrErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `GetCertificateAuthorityCsrError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetCertificateAuthorityCsrErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns true if the error kind is `GetCertificateAuthorityCsrErrorKind::InvalidArnException`.
    pub fn is_invalid_arn_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCertificateAuthorityCsrErrorKind::InvalidArnException(_)
        )
    }
    /// Returns true if the error kind is `GetCertificateAuthorityCsrErrorKind::InvalidStateException`.
    pub fn is_invalid_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCertificateAuthorityCsrErrorKind::InvalidStateException(_)
        )
    }
    /// Returns true if the error kind is `GetCertificateAuthorityCsrErrorKind::RequestFailedException`.
    pub fn is_request_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCertificateAuthorityCsrErrorKind::RequestFailedException(_)
        )
    }
    /// Returns true if the error kind is `GetCertificateAuthorityCsrErrorKind::RequestInProgressException`.
    pub fn is_request_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCertificateAuthorityCsrErrorKind::RequestInProgressException(_)
        )
    }
    /// Returns true if the error kind is `GetCertificateAuthorityCsrErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCertificateAuthorityCsrErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for GetCertificateAuthorityCsrError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetCertificateAuthorityCsrErrorKind::InvalidArnException(_inner) => Some(_inner),
            GetCertificateAuthorityCsrErrorKind::InvalidStateException(_inner) => Some(_inner),
            GetCertificateAuthorityCsrErrorKind::RequestFailedException(_inner) => Some(_inner),
            GetCertificateAuthorityCsrErrorKind::RequestInProgressException(_inner) => Some(_inner),
            GetCertificateAuthorityCsrErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetCertificateAuthorityCsrErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `GetPolicy` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetPolicyError {
    /// Kind of error that occurred.
    pub kind: GetPolicyErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetPolicy` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetPolicyErrorKind {
    /// <p>The requested Amazon Resource Name (ARN) does not refer to an existing
    /// resource.</p>
    InvalidArnException(crate::error::InvalidArnException),
    /// <p>The state of the private CA does not allow this action to occur.</p>
    InvalidStateException(crate::error::InvalidStateException),
    /// <p>The request has failed for an unspecified reason.</p>
    RequestFailedException(crate::error::RequestFailedException),
    /// <p>A resource such as a private CA, S3 bucket, certificate, audit report, or policy
    /// cannot be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetPolicyErrorKind::InvalidArnException(_inner) => _inner.fmt(f),
            GetPolicyErrorKind::InvalidStateException(_inner) => _inner.fmt(f),
            GetPolicyErrorKind::RequestFailedException(_inner) => _inner.fmt(f),
            GetPolicyErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetPolicyError {
    fn code(&self) -> Option<&str> {
        GetPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetPolicyError {
    /// Creates a new `GetPolicyError`.
    pub fn new(kind: GetPolicyErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetPolicyError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `GetPolicyError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns true if the error kind is `GetPolicyErrorKind::InvalidArnException`.
    pub fn is_invalid_arn_exception(&self) -> bool {
        matches!(&self.kind, GetPolicyErrorKind::InvalidArnException(_))
    }
    /// Returns true if the error kind is `GetPolicyErrorKind::InvalidStateException`.
    pub fn is_invalid_state_exception(&self) -> bool {
        matches!(&self.kind, GetPolicyErrorKind::InvalidStateException(_))
    }
    /// Returns true if the error kind is `GetPolicyErrorKind::RequestFailedException`.
    pub fn is_request_failed_exception(&self) -> bool {
        matches!(&self.kind, GetPolicyErrorKind::RequestFailedException(_))
    }
    /// Returns true if the error kind is `GetPolicyErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetPolicyErrorKind::ResourceNotFoundException(_))
    }
}
impl std::error::Error for GetPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetPolicyErrorKind::InvalidArnException(_inner) => Some(_inner),
            GetPolicyErrorKind::InvalidStateException(_inner) => Some(_inner),
            GetPolicyErrorKind::RequestFailedException(_inner) => Some(_inner),
            GetPolicyErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ImportCertificateAuthorityCertificate` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ImportCertificateAuthorityCertificateError {
    /// Kind of error that occurred.
    pub kind: ImportCertificateAuthorityCertificateErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ImportCertificateAuthorityCertificate` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ImportCertificateAuthorityCertificateErrorKind {
    /// <p>The certificate authority certificate you are importing does not comply with
    /// conditions specified in the certificate that signed it.</p>
    CertificateMismatchException(crate::error::CertificateMismatchException),
    /// <p>A previous update to your private CA is still ongoing.</p>
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    /// <p>The requested Amazon Resource Name (ARN) does not refer to an existing
    /// resource.</p>
    InvalidArnException(crate::error::InvalidArnException),
    /// <p>The request action cannot be performed or is prohibited.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The state of the private CA does not allow this action to occur.</p>
    InvalidStateException(crate::error::InvalidStateException),
    /// <p>One or more fields in the certificate are invalid.</p>
    MalformedCertificateException(crate::error::MalformedCertificateException),
    /// <p>The request has failed for an unspecified reason.</p>
    RequestFailedException(crate::error::RequestFailedException),
    /// <p>Your request is already in progress.</p>
    RequestInProgressException(crate::error::RequestInProgressException),
    /// <p>A resource such as a private CA, S3 bucket, certificate, audit report, or policy
    /// cannot be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ImportCertificateAuthorityCertificateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ImportCertificateAuthorityCertificateErrorKind::CertificateMismatchException(
                _inner,
            ) => _inner.fmt(f),
            ImportCertificateAuthorityCertificateErrorKind::ConcurrentModificationException(
                _inner,
            ) => _inner.fmt(f),
            ImportCertificateAuthorityCertificateErrorKind::InvalidArnException(_inner) => {
                _inner.fmt(f)
            }
            ImportCertificateAuthorityCertificateErrorKind::InvalidRequestException(_inner) => {
                _inner.fmt(f)
            }
            ImportCertificateAuthorityCertificateErrorKind::InvalidStateException(_inner) => {
                _inner.fmt(f)
            }
            ImportCertificateAuthorityCertificateErrorKind::MalformedCertificateException(
                _inner,
            ) => _inner.fmt(f),
            ImportCertificateAuthorityCertificateErrorKind::RequestFailedException(_inner) => {
                _inner.fmt(f)
            }
            ImportCertificateAuthorityCertificateErrorKind::RequestInProgressException(_inner) => {
                _inner.fmt(f)
            }
            ImportCertificateAuthorityCertificateErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            ImportCertificateAuthorityCertificateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ImportCertificateAuthorityCertificateError {
    fn code(&self) -> Option<&str> {
        ImportCertificateAuthorityCertificateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ImportCertificateAuthorityCertificateError {
    /// Creates a new `ImportCertificateAuthorityCertificateError`.
    pub fn new(
        kind: ImportCertificateAuthorityCertificateErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ImportCertificateAuthorityCertificateError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ImportCertificateAuthorityCertificateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ImportCertificateAuthorityCertificateError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ImportCertificateAuthorityCertificateErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns true if the error kind is `ImportCertificateAuthorityCertificateErrorKind::CertificateMismatchException`.
    pub fn is_certificate_mismatch_exception(&self) -> bool {
        matches!(
            &self.kind,
            ImportCertificateAuthorityCertificateErrorKind::CertificateMismatchException(_)
        )
    }
    /// Returns true if the error kind is `ImportCertificateAuthorityCertificateErrorKind::ConcurrentModificationException`.
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            ImportCertificateAuthorityCertificateErrorKind::ConcurrentModificationException(_)
        )
    }
    /// Returns true if the error kind is `ImportCertificateAuthorityCertificateErrorKind::InvalidArnException`.
    pub fn is_invalid_arn_exception(&self) -> bool {
        matches!(
            &self.kind,
            ImportCertificateAuthorityCertificateErrorKind::InvalidArnException(_)
        )
    }
    /// Returns true if the error kind is `ImportCertificateAuthorityCertificateErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ImportCertificateAuthorityCertificateErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns true if the error kind is `ImportCertificateAuthorityCertificateErrorKind::InvalidStateException`.
    pub fn is_invalid_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            ImportCertificateAuthorityCertificateErrorKind::InvalidStateException(_)
        )
    }
    /// Returns true if the error kind is `ImportCertificateAuthorityCertificateErrorKind::MalformedCertificateException`.
    pub fn is_malformed_certificate_exception(&self) -> bool {
        matches!(
            &self.kind,
            ImportCertificateAuthorityCertificateErrorKind::MalformedCertificateException(_)
        )
    }
    /// Returns true if the error kind is `ImportCertificateAuthorityCertificateErrorKind::RequestFailedException`.
    pub fn is_request_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            ImportCertificateAuthorityCertificateErrorKind::RequestFailedException(_)
        )
    }
    /// Returns true if the error kind is `ImportCertificateAuthorityCertificateErrorKind::RequestInProgressException`.
    pub fn is_request_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            ImportCertificateAuthorityCertificateErrorKind::RequestInProgressException(_)
        )
    }
    /// Returns true if the error kind is `ImportCertificateAuthorityCertificateErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ImportCertificateAuthorityCertificateErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for ImportCertificateAuthorityCertificateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ImportCertificateAuthorityCertificateErrorKind::CertificateMismatchException(
                _inner,
            ) => Some(_inner),
            ImportCertificateAuthorityCertificateErrorKind::ConcurrentModificationException(
                _inner,
            ) => Some(_inner),
            ImportCertificateAuthorityCertificateErrorKind::InvalidArnException(_inner) => {
                Some(_inner)
            }
            ImportCertificateAuthorityCertificateErrorKind::InvalidRequestException(_inner) => {
                Some(_inner)
            }
            ImportCertificateAuthorityCertificateErrorKind::InvalidStateException(_inner) => {
                Some(_inner)
            }
            ImportCertificateAuthorityCertificateErrorKind::MalformedCertificateException(
                _inner,
            ) => Some(_inner),
            ImportCertificateAuthorityCertificateErrorKind::RequestFailedException(_inner) => {
                Some(_inner)
            }
            ImportCertificateAuthorityCertificateErrorKind::RequestInProgressException(_inner) => {
                Some(_inner)
            }
            ImportCertificateAuthorityCertificateErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            ImportCertificateAuthorityCertificateErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

/// Error type for the `IssueCertificate` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct IssueCertificateError {
    /// Kind of error that occurred.
    pub kind: IssueCertificateErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `IssueCertificate` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum IssueCertificateErrorKind {
    /// <p>One or more of the specified arguments was not valid.</p>
    InvalidArgsException(crate::error::InvalidArgsException),
    /// <p>The requested Amazon Resource Name (ARN) does not refer to an existing
    /// resource.</p>
    InvalidArnException(crate::error::InvalidArnException),
    /// <p>The state of the private CA does not allow this action to occur.</p>
    InvalidStateException(crate::error::InvalidStateException),
    /// <p>An ACM Private CA quota has been exceeded. See the exception message returned to determine the
    /// quota that was exceeded.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>The certificate signing request is invalid.</p>
    MalformedCsrException(crate::error::MalformedCsrException),
    /// <p>A resource such as a private CA, S3 bucket, certificate, audit report, or policy
    /// cannot be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for IssueCertificateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            IssueCertificateErrorKind::InvalidArgsException(_inner) => _inner.fmt(f),
            IssueCertificateErrorKind::InvalidArnException(_inner) => _inner.fmt(f),
            IssueCertificateErrorKind::InvalidStateException(_inner) => _inner.fmt(f),
            IssueCertificateErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            IssueCertificateErrorKind::MalformedCsrException(_inner) => _inner.fmt(f),
            IssueCertificateErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            IssueCertificateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for IssueCertificateError {
    fn code(&self) -> Option<&str> {
        IssueCertificateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl IssueCertificateError {
    /// Creates a new `IssueCertificateError`.
    pub fn new(kind: IssueCertificateErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `IssueCertificateError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: IssueCertificateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `IssueCertificateError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: IssueCertificateErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns true if the error kind is `IssueCertificateErrorKind::InvalidArgsException`.
    pub fn is_invalid_args_exception(&self) -> bool {
        matches!(
            &self.kind,
            IssueCertificateErrorKind::InvalidArgsException(_)
        )
    }
    /// Returns true if the error kind is `IssueCertificateErrorKind::InvalidArnException`.
    pub fn is_invalid_arn_exception(&self) -> bool {
        matches!(
            &self.kind,
            IssueCertificateErrorKind::InvalidArnException(_)
        )
    }
    /// Returns true if the error kind is `IssueCertificateErrorKind::InvalidStateException`.
    pub fn is_invalid_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            IssueCertificateErrorKind::InvalidStateException(_)
        )
    }
    /// Returns true if the error kind is `IssueCertificateErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            IssueCertificateErrorKind::LimitExceededException(_)
        )
    }
    /// Returns true if the error kind is `IssueCertificateErrorKind::MalformedCsrException`.
    pub fn is_malformed_csr_exception(&self) -> bool {
        matches!(
            &self.kind,
            IssueCertificateErrorKind::MalformedCsrException(_)
        )
    }
    /// Returns true if the error kind is `IssueCertificateErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            IssueCertificateErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for IssueCertificateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            IssueCertificateErrorKind::InvalidArgsException(_inner) => Some(_inner),
            IssueCertificateErrorKind::InvalidArnException(_inner) => Some(_inner),
            IssueCertificateErrorKind::InvalidStateException(_inner) => Some(_inner),
            IssueCertificateErrorKind::LimitExceededException(_inner) => Some(_inner),
            IssueCertificateErrorKind::MalformedCsrException(_inner) => Some(_inner),
            IssueCertificateErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            IssueCertificateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListCertificateAuthorities` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListCertificateAuthoritiesError {
    /// Kind of error that occurred.
    pub kind: ListCertificateAuthoritiesErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListCertificateAuthorities` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListCertificateAuthoritiesErrorKind {
    /// <p>The token specified in the <code>NextToken</code> argument is not valid. Use the token
    /// returned from your previous call to <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_ListCertificateAuthorities.html">ListCertificateAuthorities</a>.</p>
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListCertificateAuthoritiesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListCertificateAuthoritiesErrorKind::InvalidNextTokenException(_inner) => _inner.fmt(f),
            ListCertificateAuthoritiesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListCertificateAuthoritiesError {
    fn code(&self) -> Option<&str> {
        ListCertificateAuthoritiesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListCertificateAuthoritiesError {
    /// Creates a new `ListCertificateAuthoritiesError`.
    pub fn new(kind: ListCertificateAuthoritiesErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListCertificateAuthoritiesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListCertificateAuthoritiesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListCertificateAuthoritiesError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListCertificateAuthoritiesErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns true if the error kind is `ListCertificateAuthoritiesErrorKind::InvalidNextTokenException`.
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListCertificateAuthoritiesErrorKind::InvalidNextTokenException(_)
        )
    }
}
impl std::error::Error for ListCertificateAuthoritiesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListCertificateAuthoritiesErrorKind::InvalidNextTokenException(_inner) => Some(_inner),
            ListCertificateAuthoritiesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListPermissions` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListPermissionsError {
    /// Kind of error that occurred.
    pub kind: ListPermissionsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListPermissions` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListPermissionsErrorKind {
    /// <p>The requested Amazon Resource Name (ARN) does not refer to an existing
    /// resource.</p>
    InvalidArnException(crate::error::InvalidArnException),
    /// <p>The token specified in the <code>NextToken</code> argument is not valid. Use the token
    /// returned from your previous call to <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_ListCertificateAuthorities.html">ListCertificateAuthorities</a>.</p>
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    /// <p>The state of the private CA does not allow this action to occur.</p>
    InvalidStateException(crate::error::InvalidStateException),
    /// <p>The request has failed for an unspecified reason.</p>
    RequestFailedException(crate::error::RequestFailedException),
    /// <p>A resource such as a private CA, S3 bucket, certificate, audit report, or policy
    /// cannot be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListPermissionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListPermissionsErrorKind::InvalidArnException(_inner) => _inner.fmt(f),
            ListPermissionsErrorKind::InvalidNextTokenException(_inner) => _inner.fmt(f),
            ListPermissionsErrorKind::InvalidStateException(_inner) => _inner.fmt(f),
            ListPermissionsErrorKind::RequestFailedException(_inner) => _inner.fmt(f),
            ListPermissionsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListPermissionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListPermissionsError {
    fn code(&self) -> Option<&str> {
        ListPermissionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListPermissionsError {
    /// Creates a new `ListPermissionsError`.
    pub fn new(kind: ListPermissionsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListPermissionsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListPermissionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListPermissionsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListPermissionsErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns true if the error kind is `ListPermissionsErrorKind::InvalidArnException`.
    pub fn is_invalid_arn_exception(&self) -> bool {
        matches!(&self.kind, ListPermissionsErrorKind::InvalidArnException(_))
    }
    /// Returns true if the error kind is `ListPermissionsErrorKind::InvalidNextTokenException`.
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPermissionsErrorKind::InvalidNextTokenException(_)
        )
    }
    /// Returns true if the error kind is `ListPermissionsErrorKind::InvalidStateException`.
    pub fn is_invalid_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPermissionsErrorKind::InvalidStateException(_)
        )
    }
    /// Returns true if the error kind is `ListPermissionsErrorKind::RequestFailedException`.
    pub fn is_request_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPermissionsErrorKind::RequestFailedException(_)
        )
    }
    /// Returns true if the error kind is `ListPermissionsErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPermissionsErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for ListPermissionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListPermissionsErrorKind::InvalidArnException(_inner) => Some(_inner),
            ListPermissionsErrorKind::InvalidNextTokenException(_inner) => Some(_inner),
            ListPermissionsErrorKind::InvalidStateException(_inner) => Some(_inner),
            ListPermissionsErrorKind::RequestFailedException(_inner) => Some(_inner),
            ListPermissionsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListPermissionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListTags` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTagsError {
    /// Kind of error that occurred.
    pub kind: ListTagsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListTags` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTagsErrorKind {
    /// <p>The requested Amazon Resource Name (ARN) does not refer to an existing
    /// resource.</p>
    InvalidArnException(crate::error::InvalidArnException),
    /// <p>The state of the private CA does not allow this action to occur.</p>
    InvalidStateException(crate::error::InvalidStateException),
    /// <p>A resource such as a private CA, S3 bucket, certificate, audit report, or policy
    /// cannot be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTagsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTagsErrorKind::InvalidArnException(_inner) => _inner.fmt(f),
            ListTagsErrorKind::InvalidStateException(_inner) => _inner.fmt(f),
            ListTagsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListTagsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListTagsError {
    fn code(&self) -> Option<&str> {
        ListTagsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTagsError {
    /// Creates a new `ListTagsError`.
    pub fn new(kind: ListTagsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListTagsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTagsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListTagsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTagsErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns true if the error kind is `ListTagsErrorKind::InvalidArnException`.
    pub fn is_invalid_arn_exception(&self) -> bool {
        matches!(&self.kind, ListTagsErrorKind::InvalidArnException(_))
    }
    /// Returns true if the error kind is `ListTagsErrorKind::InvalidStateException`.
    pub fn is_invalid_state_exception(&self) -> bool {
        matches!(&self.kind, ListTagsErrorKind::InvalidStateException(_))
    }
    /// Returns true if the error kind is `ListTagsErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListTagsErrorKind::ResourceNotFoundException(_))
    }
}
impl std::error::Error for ListTagsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTagsErrorKind::InvalidArnException(_inner) => Some(_inner),
            ListTagsErrorKind::InvalidStateException(_inner) => Some(_inner),
            ListTagsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListTagsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `PutPolicy` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutPolicyError {
    /// Kind of error that occurred.
    pub kind: PutPolicyErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `PutPolicy` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutPolicyErrorKind {
    /// <p>A previous update to your private CA is still ongoing.</p>
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    /// <p>The requested Amazon Resource Name (ARN) does not refer to an existing
    /// resource.</p>
    InvalidArnException(crate::error::InvalidArnException),
    /// <p>The resource policy is invalid or is missing a required statement. For general
    /// information about IAM policy and statement structure, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#access_policies-json">Overview of JSON Policies</a>.</p>
    InvalidPolicyException(crate::error::InvalidPolicyException),
    /// <p>The state of the private CA does not allow this action to occur.</p>
    InvalidStateException(crate::error::InvalidStateException),
    /// <p>The current action was prevented because it would lock the caller out from performing
    /// subsequent actions. Verify that the specified parameters would not result in the caller
    /// being denied access to the resource. </p>
    LockoutPreventedException(crate::error::LockoutPreventedException),
    /// <p>The request has failed for an unspecified reason.</p>
    RequestFailedException(crate::error::RequestFailedException),
    /// <p>A resource such as a private CA, S3 bucket, certificate, audit report, or policy
    /// cannot be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutPolicyErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            PutPolicyErrorKind::InvalidArnException(_inner) => _inner.fmt(f),
            PutPolicyErrorKind::InvalidPolicyException(_inner) => _inner.fmt(f),
            PutPolicyErrorKind::InvalidStateException(_inner) => _inner.fmt(f),
            PutPolicyErrorKind::LockoutPreventedException(_inner) => _inner.fmt(f),
            PutPolicyErrorKind::RequestFailedException(_inner) => _inner.fmt(f),
            PutPolicyErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            PutPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for PutPolicyError {
    fn code(&self) -> Option<&str> {
        PutPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutPolicyError {
    /// Creates a new `PutPolicyError`.
    pub fn new(kind: PutPolicyErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `PutPolicyError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `PutPolicyError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns true if the error kind is `PutPolicyErrorKind::ConcurrentModificationException`.
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutPolicyErrorKind::ConcurrentModificationException(_)
        )
    }
    /// Returns true if the error kind is `PutPolicyErrorKind::InvalidArnException`.
    pub fn is_invalid_arn_exception(&self) -> bool {
        matches!(&self.kind, PutPolicyErrorKind::InvalidArnException(_))
    }
    /// Returns true if the error kind is `PutPolicyErrorKind::InvalidPolicyException`.
    pub fn is_invalid_policy_exception(&self) -> bool {
        matches!(&self.kind, PutPolicyErrorKind::InvalidPolicyException(_))
    }
    /// Returns true if the error kind is `PutPolicyErrorKind::InvalidStateException`.
    pub fn is_invalid_state_exception(&self) -> bool {
        matches!(&self.kind, PutPolicyErrorKind::InvalidStateException(_))
    }
    /// Returns true if the error kind is `PutPolicyErrorKind::LockoutPreventedException`.
    pub fn is_lockout_prevented_exception(&self) -> bool {
        matches!(&self.kind, PutPolicyErrorKind::LockoutPreventedException(_))
    }
    /// Returns true if the error kind is `PutPolicyErrorKind::RequestFailedException`.
    pub fn is_request_failed_exception(&self) -> bool {
        matches!(&self.kind, PutPolicyErrorKind::RequestFailedException(_))
    }
    /// Returns true if the error kind is `PutPolicyErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, PutPolicyErrorKind::ResourceNotFoundException(_))
    }
}
impl std::error::Error for PutPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutPolicyErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            PutPolicyErrorKind::InvalidArnException(_inner) => Some(_inner),
            PutPolicyErrorKind::InvalidPolicyException(_inner) => Some(_inner),
            PutPolicyErrorKind::InvalidStateException(_inner) => Some(_inner),
            PutPolicyErrorKind::LockoutPreventedException(_inner) => Some(_inner),
            PutPolicyErrorKind::RequestFailedException(_inner) => Some(_inner),
            PutPolicyErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            PutPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `RestoreCertificateAuthority` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RestoreCertificateAuthorityError {
    /// Kind of error that occurred.
    pub kind: RestoreCertificateAuthorityErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `RestoreCertificateAuthority` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RestoreCertificateAuthorityErrorKind {
    /// <p>The requested Amazon Resource Name (ARN) does not refer to an existing
    /// resource.</p>
    InvalidArnException(crate::error::InvalidArnException),
    /// <p>The state of the private CA does not allow this action to occur.</p>
    InvalidStateException(crate::error::InvalidStateException),
    /// <p>A resource such as a private CA, S3 bucket, certificate, audit report, or policy
    /// cannot be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RestoreCertificateAuthorityError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RestoreCertificateAuthorityErrorKind::InvalidArnException(_inner) => _inner.fmt(f),
            RestoreCertificateAuthorityErrorKind::InvalidStateException(_inner) => _inner.fmt(f),
            RestoreCertificateAuthorityErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            RestoreCertificateAuthorityErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for RestoreCertificateAuthorityError {
    fn code(&self) -> Option<&str> {
        RestoreCertificateAuthorityError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl RestoreCertificateAuthorityError {
    /// Creates a new `RestoreCertificateAuthorityError`.
    pub fn new(kind: RestoreCertificateAuthorityErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `RestoreCertificateAuthorityError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RestoreCertificateAuthorityErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `RestoreCertificateAuthorityError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RestoreCertificateAuthorityErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns true if the error kind is `RestoreCertificateAuthorityErrorKind::InvalidArnException`.
    pub fn is_invalid_arn_exception(&self) -> bool {
        matches!(
            &self.kind,
            RestoreCertificateAuthorityErrorKind::InvalidArnException(_)
        )
    }
    /// Returns true if the error kind is `RestoreCertificateAuthorityErrorKind::InvalidStateException`.
    pub fn is_invalid_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            RestoreCertificateAuthorityErrorKind::InvalidStateException(_)
        )
    }
    /// Returns true if the error kind is `RestoreCertificateAuthorityErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            RestoreCertificateAuthorityErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for RestoreCertificateAuthorityError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RestoreCertificateAuthorityErrorKind::InvalidArnException(_inner) => Some(_inner),
            RestoreCertificateAuthorityErrorKind::InvalidStateException(_inner) => Some(_inner),
            RestoreCertificateAuthorityErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            RestoreCertificateAuthorityErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `RevokeCertificate` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RevokeCertificateError {
    /// Kind of error that occurred.
    pub kind: RevokeCertificateErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `RevokeCertificate` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RevokeCertificateErrorKind {
    /// <p>A previous update to your private CA is still ongoing.</p>
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    /// <p>The requested Amazon Resource Name (ARN) does not refer to an existing
    /// resource.</p>
    InvalidArnException(crate::error::InvalidArnException),
    /// <p>The request action cannot be performed or is prohibited.</p>
    InvalidRequestException(crate::error::InvalidRequestException),
    /// <p>The state of the private CA does not allow this action to occur.</p>
    InvalidStateException(crate::error::InvalidStateException),
    /// <p>An ACM Private CA quota has been exceeded. See the exception message returned to determine the
    /// quota that was exceeded.</p>
    LimitExceededException(crate::error::LimitExceededException),
    /// <p>Your request has already been completed.</p>
    RequestAlreadyProcessedException(crate::error::RequestAlreadyProcessedException),
    /// <p>The request has failed for an unspecified reason.</p>
    RequestFailedException(crate::error::RequestFailedException),
    /// <p>Your request is already in progress.</p>
    RequestInProgressException(crate::error::RequestInProgressException),
    /// <p>A resource such as a private CA, S3 bucket, certificate, audit report, or policy
    /// cannot be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RevokeCertificateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RevokeCertificateErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            RevokeCertificateErrorKind::InvalidArnException(_inner) => _inner.fmt(f),
            RevokeCertificateErrorKind::InvalidRequestException(_inner) => _inner.fmt(f),
            RevokeCertificateErrorKind::InvalidStateException(_inner) => _inner.fmt(f),
            RevokeCertificateErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            RevokeCertificateErrorKind::RequestAlreadyProcessedException(_inner) => _inner.fmt(f),
            RevokeCertificateErrorKind::RequestFailedException(_inner) => _inner.fmt(f),
            RevokeCertificateErrorKind::RequestInProgressException(_inner) => _inner.fmt(f),
            RevokeCertificateErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            RevokeCertificateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for RevokeCertificateError {
    fn code(&self) -> Option<&str> {
        RevokeCertificateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl RevokeCertificateError {
    /// Creates a new `RevokeCertificateError`.
    pub fn new(kind: RevokeCertificateErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `RevokeCertificateError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RevokeCertificateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `RevokeCertificateError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RevokeCertificateErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns true if the error kind is `RevokeCertificateErrorKind::ConcurrentModificationException`.
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            RevokeCertificateErrorKind::ConcurrentModificationException(_)
        )
    }
    /// Returns true if the error kind is `RevokeCertificateErrorKind::InvalidArnException`.
    pub fn is_invalid_arn_exception(&self) -> bool {
        matches!(
            &self.kind,
            RevokeCertificateErrorKind::InvalidArnException(_)
        )
    }
    /// Returns true if the error kind is `RevokeCertificateErrorKind::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            RevokeCertificateErrorKind::InvalidRequestException(_)
        )
    }
    /// Returns true if the error kind is `RevokeCertificateErrorKind::InvalidStateException`.
    pub fn is_invalid_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            RevokeCertificateErrorKind::InvalidStateException(_)
        )
    }
    /// Returns true if the error kind is `RevokeCertificateErrorKind::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            RevokeCertificateErrorKind::LimitExceededException(_)
        )
    }
    /// Returns true if the error kind is `RevokeCertificateErrorKind::RequestAlreadyProcessedException`.
    pub fn is_request_already_processed_exception(&self) -> bool {
        matches!(
            &self.kind,
            RevokeCertificateErrorKind::RequestAlreadyProcessedException(_)
        )
    }
    /// Returns true if the error kind is `RevokeCertificateErrorKind::RequestFailedException`.
    pub fn is_request_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            RevokeCertificateErrorKind::RequestFailedException(_)
        )
    }
    /// Returns true if the error kind is `RevokeCertificateErrorKind::RequestInProgressException`.
    pub fn is_request_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            RevokeCertificateErrorKind::RequestInProgressException(_)
        )
    }
    /// Returns true if the error kind is `RevokeCertificateErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            RevokeCertificateErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for RevokeCertificateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RevokeCertificateErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            RevokeCertificateErrorKind::InvalidArnException(_inner) => Some(_inner),
            RevokeCertificateErrorKind::InvalidRequestException(_inner) => Some(_inner),
            RevokeCertificateErrorKind::InvalidStateException(_inner) => Some(_inner),
            RevokeCertificateErrorKind::LimitExceededException(_inner) => Some(_inner),
            RevokeCertificateErrorKind::RequestAlreadyProcessedException(_inner) => Some(_inner),
            RevokeCertificateErrorKind::RequestFailedException(_inner) => Some(_inner),
            RevokeCertificateErrorKind::RequestInProgressException(_inner) => Some(_inner),
            RevokeCertificateErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            RevokeCertificateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `TagCertificateAuthority` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagCertificateAuthorityError {
    /// Kind of error that occurred.
    pub kind: TagCertificateAuthorityErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `TagCertificateAuthority` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagCertificateAuthorityErrorKind {
    /// <p>The requested Amazon Resource Name (ARN) does not refer to an existing
    /// resource.</p>
    InvalidArnException(crate::error::InvalidArnException),
    /// <p>The state of the private CA does not allow this action to occur.</p>
    InvalidStateException(crate::error::InvalidStateException),
    /// <p>The tag associated with the CA is not valid. The invalid argument is contained in the
    /// message field.</p>
    InvalidTagException(crate::error::InvalidTagException),
    /// <p>A resource such as a private CA, S3 bucket, certificate, audit report, or policy
    /// cannot be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>You can associate up to 50 tags with a private CA. Exception information is contained
    /// in the exception message field.</p>
    TooManyTagsException(crate::error::TooManyTagsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TagCertificateAuthorityError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagCertificateAuthorityErrorKind::InvalidArnException(_inner) => _inner.fmt(f),
            TagCertificateAuthorityErrorKind::InvalidStateException(_inner) => _inner.fmt(f),
            TagCertificateAuthorityErrorKind::InvalidTagException(_inner) => _inner.fmt(f),
            TagCertificateAuthorityErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            TagCertificateAuthorityErrorKind::TooManyTagsException(_inner) => _inner.fmt(f),
            TagCertificateAuthorityErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for TagCertificateAuthorityError {
    fn code(&self) -> Option<&str> {
        TagCertificateAuthorityError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagCertificateAuthorityError {
    /// Creates a new `TagCertificateAuthorityError`.
    pub fn new(kind: TagCertificateAuthorityErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `TagCertificateAuthorityError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TagCertificateAuthorityErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `TagCertificateAuthorityError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TagCertificateAuthorityErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns true if the error kind is `TagCertificateAuthorityErrorKind::InvalidArnException`.
    pub fn is_invalid_arn_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagCertificateAuthorityErrorKind::InvalidArnException(_)
        )
    }
    /// Returns true if the error kind is `TagCertificateAuthorityErrorKind::InvalidStateException`.
    pub fn is_invalid_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagCertificateAuthorityErrorKind::InvalidStateException(_)
        )
    }
    /// Returns true if the error kind is `TagCertificateAuthorityErrorKind::InvalidTagException`.
    pub fn is_invalid_tag_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagCertificateAuthorityErrorKind::InvalidTagException(_)
        )
    }
    /// Returns true if the error kind is `TagCertificateAuthorityErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagCertificateAuthorityErrorKind::ResourceNotFoundException(_)
        )
    }
    /// Returns true if the error kind is `TagCertificateAuthorityErrorKind::TooManyTagsException`.
    pub fn is_too_many_tags_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagCertificateAuthorityErrorKind::TooManyTagsException(_)
        )
    }
}
impl std::error::Error for TagCertificateAuthorityError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagCertificateAuthorityErrorKind::InvalidArnException(_inner) => Some(_inner),
            TagCertificateAuthorityErrorKind::InvalidStateException(_inner) => Some(_inner),
            TagCertificateAuthorityErrorKind::InvalidTagException(_inner) => Some(_inner),
            TagCertificateAuthorityErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            TagCertificateAuthorityErrorKind::TooManyTagsException(_inner) => Some(_inner),
            TagCertificateAuthorityErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `UntagCertificateAuthority` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagCertificateAuthorityError {
    /// Kind of error that occurred.
    pub kind: UntagCertificateAuthorityErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `UntagCertificateAuthority` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagCertificateAuthorityErrorKind {
    /// <p>The requested Amazon Resource Name (ARN) does not refer to an existing
    /// resource.</p>
    InvalidArnException(crate::error::InvalidArnException),
    /// <p>The state of the private CA does not allow this action to occur.</p>
    InvalidStateException(crate::error::InvalidStateException),
    /// <p>The tag associated with the CA is not valid. The invalid argument is contained in the
    /// message field.</p>
    InvalidTagException(crate::error::InvalidTagException),
    /// <p>A resource such as a private CA, S3 bucket, certificate, audit report, or policy
    /// cannot be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UntagCertificateAuthorityError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagCertificateAuthorityErrorKind::InvalidArnException(_inner) => _inner.fmt(f),
            UntagCertificateAuthorityErrorKind::InvalidStateException(_inner) => _inner.fmt(f),
            UntagCertificateAuthorityErrorKind::InvalidTagException(_inner) => _inner.fmt(f),
            UntagCertificateAuthorityErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UntagCertificateAuthorityErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UntagCertificateAuthorityError {
    fn code(&self) -> Option<&str> {
        UntagCertificateAuthorityError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagCertificateAuthorityError {
    /// Creates a new `UntagCertificateAuthorityError`.
    pub fn new(kind: UntagCertificateAuthorityErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `UntagCertificateAuthorityError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UntagCertificateAuthorityErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `UntagCertificateAuthorityError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UntagCertificateAuthorityErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns true if the error kind is `UntagCertificateAuthorityErrorKind::InvalidArnException`.
    pub fn is_invalid_arn_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagCertificateAuthorityErrorKind::InvalidArnException(_)
        )
    }
    /// Returns true if the error kind is `UntagCertificateAuthorityErrorKind::InvalidStateException`.
    pub fn is_invalid_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagCertificateAuthorityErrorKind::InvalidStateException(_)
        )
    }
    /// Returns true if the error kind is `UntagCertificateAuthorityErrorKind::InvalidTagException`.
    pub fn is_invalid_tag_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagCertificateAuthorityErrorKind::InvalidTagException(_)
        )
    }
    /// Returns true if the error kind is `UntagCertificateAuthorityErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagCertificateAuthorityErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for UntagCertificateAuthorityError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagCertificateAuthorityErrorKind::InvalidArnException(_inner) => Some(_inner),
            UntagCertificateAuthorityErrorKind::InvalidStateException(_inner) => Some(_inner),
            UntagCertificateAuthorityErrorKind::InvalidTagException(_inner) => Some(_inner),
            UntagCertificateAuthorityErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UntagCertificateAuthorityErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `UpdateCertificateAuthority` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateCertificateAuthorityError {
    /// Kind of error that occurred.
    pub kind: UpdateCertificateAuthorityErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `UpdateCertificateAuthority` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateCertificateAuthorityErrorKind {
    /// <p>A previous update to your private CA is still ongoing.</p>
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    /// <p>One or more of the specified arguments was not valid.</p>
    InvalidArgsException(crate::error::InvalidArgsException),
    /// <p>The requested Amazon Resource Name (ARN) does not refer to an existing
    /// resource.</p>
    InvalidArnException(crate::error::InvalidArnException),
    /// <p>The resource policy is invalid or is missing a required statement. For general
    /// information about IAM policy and statement structure, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#access_policies-json">Overview of JSON Policies</a>.</p>
    InvalidPolicyException(crate::error::InvalidPolicyException),
    /// <p>The state of the private CA does not allow this action to occur.</p>
    InvalidStateException(crate::error::InvalidStateException),
    /// <p>A resource such as a private CA, S3 bucket, certificate, audit report, or policy
    /// cannot be found.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateCertificateAuthorityError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateCertificateAuthorityErrorKind::ConcurrentModificationException(_inner) => {
                _inner.fmt(f)
            }
            UpdateCertificateAuthorityErrorKind::InvalidArgsException(_inner) => _inner.fmt(f),
            UpdateCertificateAuthorityErrorKind::InvalidArnException(_inner) => _inner.fmt(f),
            UpdateCertificateAuthorityErrorKind::InvalidPolicyException(_inner) => _inner.fmt(f),
            UpdateCertificateAuthorityErrorKind::InvalidStateException(_inner) => _inner.fmt(f),
            UpdateCertificateAuthorityErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateCertificateAuthorityErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateCertificateAuthorityError {
    fn code(&self) -> Option<&str> {
        UpdateCertificateAuthorityError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateCertificateAuthorityError {
    /// Creates a new `UpdateCertificateAuthorityError`.
    pub fn new(kind: UpdateCertificateAuthorityErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `UpdateCertificateAuthorityError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateCertificateAuthorityErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `UpdateCertificateAuthorityError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateCertificateAuthorityErrorKind::Unhandled(err.into()),
        }
    }

    // TODO: Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns true if the error kind is `UpdateCertificateAuthorityErrorKind::ConcurrentModificationException`.
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCertificateAuthorityErrorKind::ConcurrentModificationException(_)
        )
    }
    /// Returns true if the error kind is `UpdateCertificateAuthorityErrorKind::InvalidArgsException`.
    pub fn is_invalid_args_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCertificateAuthorityErrorKind::InvalidArgsException(_)
        )
    }
    /// Returns true if the error kind is `UpdateCertificateAuthorityErrorKind::InvalidArnException`.
    pub fn is_invalid_arn_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCertificateAuthorityErrorKind::InvalidArnException(_)
        )
    }
    /// Returns true if the error kind is `UpdateCertificateAuthorityErrorKind::InvalidPolicyException`.
    pub fn is_invalid_policy_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCertificateAuthorityErrorKind::InvalidPolicyException(_)
        )
    }
    /// Returns true if the error kind is `UpdateCertificateAuthorityErrorKind::InvalidStateException`.
    pub fn is_invalid_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCertificateAuthorityErrorKind::InvalidStateException(_)
        )
    }
    /// Returns true if the error kind is `UpdateCertificateAuthorityErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCertificateAuthorityErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for UpdateCertificateAuthorityError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateCertificateAuthorityErrorKind::ConcurrentModificationException(_inner) => {
                Some(_inner)
            }
            UpdateCertificateAuthorityErrorKind::InvalidArgsException(_inner) => Some(_inner),
            UpdateCertificateAuthorityErrorKind::InvalidArnException(_inner) => Some(_inner),
            UpdateCertificateAuthorityErrorKind::InvalidPolicyException(_inner) => Some(_inner),
            UpdateCertificateAuthorityErrorKind::InvalidStateException(_inner) => Some(_inner),
            UpdateCertificateAuthorityErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateCertificateAuthorityErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// <p>A resource such as a private CA, S3 bucket, certificate, audit report, or policy
/// cannot be found.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceNotFoundException {
    #[allow(missing_docs)] // documentation missing in model
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceNotFoundException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ResourceNotFoundException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceNotFoundException")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceNotFoundException {}
/// See [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
pub mod resource_not_found_exception {
    /// A builder for [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
        pub fn build(self) -> crate::error::ResourceNotFoundException {
            crate::error::ResourceNotFoundException {
                message: self.message,
            }
        }
    }
}
impl ResourceNotFoundException {
    /// Creates a new builder-style object to manufacture [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
    pub fn builder() -> crate::error::resource_not_found_exception::Builder {
        crate::error::resource_not_found_exception::Builder::default()
    }
}

/// <p>The state of the private CA does not allow this action to occur.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidStateException {
    #[allow(missing_docs)] // documentation missing in model
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidStateException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidStateException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidStateException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidStateException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidStateException")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidStateException {}
/// See [`InvalidStateException`](crate::error::InvalidStateException)
pub mod invalid_state_exception {
    /// A builder for [`InvalidStateException`](crate::error::InvalidStateException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidStateException`](crate::error::InvalidStateException)
        pub fn build(self) -> crate::error::InvalidStateException {
            crate::error::InvalidStateException {
                message: self.message,
            }
        }
    }
}
impl InvalidStateException {
    /// Creates a new builder-style object to manufacture [`InvalidStateException`](crate::error::InvalidStateException)
    pub fn builder() -> crate::error::invalid_state_exception::Builder {
        crate::error::invalid_state_exception::Builder::default()
    }
}

/// <p>The resource policy is invalid or is missing a required statement. For general
/// information about IAM policy and statement structure, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#access_policies-json">Overview of JSON Policies</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidPolicyException {
    #[allow(missing_docs)] // documentation missing in model
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidPolicyException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidPolicyException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidPolicyException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidPolicyException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidPolicyException")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidPolicyException {}
/// See [`InvalidPolicyException`](crate::error::InvalidPolicyException)
pub mod invalid_policy_exception {
    /// A builder for [`InvalidPolicyException`](crate::error::InvalidPolicyException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidPolicyException`](crate::error::InvalidPolicyException)
        pub fn build(self) -> crate::error::InvalidPolicyException {
            crate::error::InvalidPolicyException {
                message: self.message,
            }
        }
    }
}
impl InvalidPolicyException {
    /// Creates a new builder-style object to manufacture [`InvalidPolicyException`](crate::error::InvalidPolicyException)
    pub fn builder() -> crate::error::invalid_policy_exception::Builder {
        crate::error::invalid_policy_exception::Builder::default()
    }
}

/// <p>The requested Amazon Resource Name (ARN) does not refer to an existing
/// resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidArnException {
    #[allow(missing_docs)] // documentation missing in model
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidArnException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidArnException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidArnException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidArnException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidArnException")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidArnException {}
/// See [`InvalidArnException`](crate::error::InvalidArnException)
pub mod invalid_arn_exception {
    /// A builder for [`InvalidArnException`](crate::error::InvalidArnException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidArnException`](crate::error::InvalidArnException)
        pub fn build(self) -> crate::error::InvalidArnException {
            crate::error::InvalidArnException {
                message: self.message,
            }
        }
    }
}
impl InvalidArnException {
    /// Creates a new builder-style object to manufacture [`InvalidArnException`](crate::error::InvalidArnException)
    pub fn builder() -> crate::error::invalid_arn_exception::Builder {
        crate::error::invalid_arn_exception::Builder::default()
    }
}

/// <p>One or more of the specified arguments was not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidArgsException {
    #[allow(missing_docs)] // documentation missing in model
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidArgsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidArgsException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidArgsException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidArgsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidArgsException")?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidArgsException {}
/// See [`InvalidArgsException`](crate::error::InvalidArgsException)
pub mod invalid_args_exception {
    /// A builder for [`InvalidArgsException`](crate::error::InvalidArgsException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidArgsException`](crate::error::InvalidArgsException)
        pub fn build(self) -> crate::error::InvalidArgsException {
            crate::error::InvalidArgsException {
                message: self.message,
            }
        }
    }
}
impl InvalidArgsException {
    /// Creates a new builder-style object to manufacture [`InvalidArgsException`](crate::error::InvalidArgsException)
    pub fn builder() -> crate::error::invalid_args_exception::Builder {
        crate::error::invalid_args_exception::Builder::default()
    }
}

/// <p>A previous update to your private CA is still ongoing.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ConcurrentModificationException {
    #[allow(missing_docs)] // documentation missing in model
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ConcurrentModificationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ConcurrentModificationException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ConcurrentModificationException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ConcurrentModificationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ConcurrentModificationException")?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl std::error::Error for ConcurrentModificationException {}
/// See [`ConcurrentModificationException`](crate::error::ConcurrentModificationException)
pub mod concurrent_modification_exception {
    /// A builder for [`ConcurrentModificationException`](crate::error::ConcurrentModificationException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ConcurrentModificationException`](crate::error::ConcurrentModificationException)
        pub fn build(self) -> crate::error::ConcurrentModificationException {
            crate::error::ConcurrentModificationException {
                message: self.message,
            }
        }
    }
}
impl ConcurrentModificationException {
    /// Creates a new builder-style object to manufacture [`ConcurrentModificationException`](crate::error::ConcurrentModificationException)
    pub fn builder() -> crate::error::concurrent_modification_exception::Builder {
        crate::error::concurrent_modification_exception::Builder::default()
    }
}

/// <p>The tag associated with the CA is not valid. The invalid argument is contained in the
/// message field.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidTagException {
    #[allow(missing_docs)] // documentation missing in model
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidTagException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidTagException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidTagException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidTagException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidTagException")?;
        if let Some(inner_7) = &self.message {
            write!(f, ": {}", inner_7)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidTagException {}
/// See [`InvalidTagException`](crate::error::InvalidTagException)
pub mod invalid_tag_exception {
    /// A builder for [`InvalidTagException`](crate::error::InvalidTagException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidTagException`](crate::error::InvalidTagException)
        pub fn build(self) -> crate::error::InvalidTagException {
            crate::error::InvalidTagException {
                message: self.message,
            }
        }
    }
}
impl InvalidTagException {
    /// Creates a new builder-style object to manufacture [`InvalidTagException`](crate::error::InvalidTagException)
    pub fn builder() -> crate::error::invalid_tag_exception::Builder {
        crate::error::invalid_tag_exception::Builder::default()
    }
}

/// <p>You can associate up to 50 tags with a private CA. Exception information is contained
/// in the exception message field.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TooManyTagsException {
    #[allow(missing_docs)] // documentation missing in model
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TooManyTagsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TooManyTagsException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TooManyTagsException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyTagsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyTagsException")?;
        if let Some(inner_8) = &self.message {
            write!(f, ": {}", inner_8)?;
        }
        Ok(())
    }
}
impl std::error::Error for TooManyTagsException {}
/// See [`TooManyTagsException`](crate::error::TooManyTagsException)
pub mod too_many_tags_exception {
    /// A builder for [`TooManyTagsException`](crate::error::TooManyTagsException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`TooManyTagsException`](crate::error::TooManyTagsException)
        pub fn build(self) -> crate::error::TooManyTagsException {
            crate::error::TooManyTagsException {
                message: self.message,
            }
        }
    }
}
impl TooManyTagsException {
    /// Creates a new builder-style object to manufacture [`TooManyTagsException`](crate::error::TooManyTagsException)
    pub fn builder() -> crate::error::too_many_tags_exception::Builder {
        crate::error::too_many_tags_exception::Builder::default()
    }
}

/// <p>Your request is already in progress.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RequestInProgressException {
    #[allow(missing_docs)] // documentation missing in model
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for RequestInProgressException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RequestInProgressException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl RequestInProgressException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for RequestInProgressException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "RequestInProgressException")?;
        if let Some(inner_9) = &self.message {
            write!(f, ": {}", inner_9)?;
        }
        Ok(())
    }
}
impl std::error::Error for RequestInProgressException {}
/// See [`RequestInProgressException`](crate::error::RequestInProgressException)
pub mod request_in_progress_exception {
    /// A builder for [`RequestInProgressException`](crate::error::RequestInProgressException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`RequestInProgressException`](crate::error::RequestInProgressException)
        pub fn build(self) -> crate::error::RequestInProgressException {
            crate::error::RequestInProgressException {
                message: self.message,
            }
        }
    }
}
impl RequestInProgressException {
    /// Creates a new builder-style object to manufacture [`RequestInProgressException`](crate::error::RequestInProgressException)
    pub fn builder() -> crate::error::request_in_progress_exception::Builder {
        crate::error::request_in_progress_exception::Builder::default()
    }
}

/// <p>The request has failed for an unspecified reason.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RequestFailedException {
    #[allow(missing_docs)] // documentation missing in model
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for RequestFailedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RequestFailedException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl RequestFailedException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for RequestFailedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "RequestFailedException")?;
        if let Some(inner_10) = &self.message {
            write!(f, ": {}", inner_10)?;
        }
        Ok(())
    }
}
impl std::error::Error for RequestFailedException {}
/// See [`RequestFailedException`](crate::error::RequestFailedException)
pub mod request_failed_exception {
    /// A builder for [`RequestFailedException`](crate::error::RequestFailedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`RequestFailedException`](crate::error::RequestFailedException)
        pub fn build(self) -> crate::error::RequestFailedException {
            crate::error::RequestFailedException {
                message: self.message,
            }
        }
    }
}
impl RequestFailedException {
    /// Creates a new builder-style object to manufacture [`RequestFailedException`](crate::error::RequestFailedException)
    pub fn builder() -> crate::error::request_failed_exception::Builder {
        crate::error::request_failed_exception::Builder::default()
    }
}

/// <p>Your request has already been completed.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RequestAlreadyProcessedException {
    #[allow(missing_docs)] // documentation missing in model
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for RequestAlreadyProcessedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RequestAlreadyProcessedException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl RequestAlreadyProcessedException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for RequestAlreadyProcessedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "RequestAlreadyProcessedException")?;
        if let Some(inner_11) = &self.message {
            write!(f, ": {}", inner_11)?;
        }
        Ok(())
    }
}
impl std::error::Error for RequestAlreadyProcessedException {}
/// See [`RequestAlreadyProcessedException`](crate::error::RequestAlreadyProcessedException)
pub mod request_already_processed_exception {
    /// A builder for [`RequestAlreadyProcessedException`](crate::error::RequestAlreadyProcessedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`RequestAlreadyProcessedException`](crate::error::RequestAlreadyProcessedException)
        pub fn build(self) -> crate::error::RequestAlreadyProcessedException {
            crate::error::RequestAlreadyProcessedException {
                message: self.message,
            }
        }
    }
}
impl RequestAlreadyProcessedException {
    /// Creates a new builder-style object to manufacture [`RequestAlreadyProcessedException`](crate::error::RequestAlreadyProcessedException)
    pub fn builder() -> crate::error::request_already_processed_exception::Builder {
        crate::error::request_already_processed_exception::Builder::default()
    }
}

/// <p>An ACM Private CA quota has been exceeded. See the exception message returned to determine the
/// quota that was exceeded.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LimitExceededException {
    #[allow(missing_docs)] // documentation missing in model
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LimitExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl LimitExceededException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for LimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "LimitExceededException")?;
        if let Some(inner_12) = &self.message {
            write!(f, ": {}", inner_12)?;
        }
        Ok(())
    }
}
impl std::error::Error for LimitExceededException {}
/// See [`LimitExceededException`](crate::error::LimitExceededException)
pub mod limit_exceeded_exception {
    /// A builder for [`LimitExceededException`](crate::error::LimitExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`LimitExceededException`](crate::error::LimitExceededException)
        pub fn build(self) -> crate::error::LimitExceededException {
            crate::error::LimitExceededException {
                message: self.message,
            }
        }
    }
}
impl LimitExceededException {
    /// Creates a new builder-style object to manufacture [`LimitExceededException`](crate::error::LimitExceededException)
    pub fn builder() -> crate::error::limit_exceeded_exception::Builder {
        crate::error::limit_exceeded_exception::Builder::default()
    }
}

/// <p>The request action cannot be performed or is prohibited.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidRequestException {
    #[allow(missing_docs)] // documentation missing in model
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidRequestException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidRequestException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidRequestException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidRequestException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidRequestException")?;
        if let Some(inner_13) = &self.message {
            write!(f, ": {}", inner_13)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidRequestException {}
/// See [`InvalidRequestException`](crate::error::InvalidRequestException)
pub mod invalid_request_exception {
    /// A builder for [`InvalidRequestException`](crate::error::InvalidRequestException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidRequestException`](crate::error::InvalidRequestException)
        pub fn build(self) -> crate::error::InvalidRequestException {
            crate::error::InvalidRequestException {
                message: self.message,
            }
        }
    }
}
impl InvalidRequestException {
    /// Creates a new builder-style object to manufacture [`InvalidRequestException`](crate::error::InvalidRequestException)
    pub fn builder() -> crate::error::invalid_request_exception::Builder {
        crate::error::invalid_request_exception::Builder::default()
    }
}

/// <p>The current action was prevented because it would lock the caller out from performing
/// subsequent actions. Verify that the specified parameters would not result in the caller
/// being denied access to the resource. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LockoutPreventedException {
    #[allow(missing_docs)] // documentation missing in model
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LockoutPreventedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LockoutPreventedException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl LockoutPreventedException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for LockoutPreventedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "LockoutPreventedException")?;
        if let Some(inner_14) = &self.message {
            write!(f, ": {}", inner_14)?;
        }
        Ok(())
    }
}
impl std::error::Error for LockoutPreventedException {}
/// See [`LockoutPreventedException`](crate::error::LockoutPreventedException)
pub mod lockout_prevented_exception {
    /// A builder for [`LockoutPreventedException`](crate::error::LockoutPreventedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`LockoutPreventedException`](crate::error::LockoutPreventedException)
        pub fn build(self) -> crate::error::LockoutPreventedException {
            crate::error::LockoutPreventedException {
                message: self.message,
            }
        }
    }
}
impl LockoutPreventedException {
    /// Creates a new builder-style object to manufacture [`LockoutPreventedException`](crate::error::LockoutPreventedException)
    pub fn builder() -> crate::error::lockout_prevented_exception::Builder {
        crate::error::lockout_prevented_exception::Builder::default()
    }
}

/// <p>The token specified in the <code>NextToken</code> argument is not valid. Use the token
/// returned from your previous call to <a href="https://docs.aws.amazon.com/acm-pca/latest/APIReference/API_ListCertificateAuthorities.html">ListCertificateAuthorities</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidNextTokenException {
    #[allow(missing_docs)] // documentation missing in model
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidNextTokenException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidNextTokenException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidNextTokenException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidNextTokenException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidNextTokenException")?;
        if let Some(inner_15) = &self.message {
            write!(f, ": {}", inner_15)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidNextTokenException {}
/// See [`InvalidNextTokenException`](crate::error::InvalidNextTokenException)
pub mod invalid_next_token_exception {
    /// A builder for [`InvalidNextTokenException`](crate::error::InvalidNextTokenException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidNextTokenException`](crate::error::InvalidNextTokenException)
        pub fn build(self) -> crate::error::InvalidNextTokenException {
            crate::error::InvalidNextTokenException {
                message: self.message,
            }
        }
    }
}
impl InvalidNextTokenException {
    /// Creates a new builder-style object to manufacture [`InvalidNextTokenException`](crate::error::InvalidNextTokenException)
    pub fn builder() -> crate::error::invalid_next_token_exception::Builder {
        crate::error::invalid_next_token_exception::Builder::default()
    }
}

/// <p>The certificate signing request is invalid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MalformedCsrException {
    #[allow(missing_docs)] // documentation missing in model
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MalformedCsrException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MalformedCsrException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl MalformedCsrException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MalformedCsrException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MalformedCsrException [MalformedCSRException]")?;
        if let Some(inner_16) = &self.message {
            write!(f, ": {}", inner_16)?;
        }
        Ok(())
    }
}
impl std::error::Error for MalformedCsrException {}
/// See [`MalformedCsrException`](crate::error::MalformedCsrException)
pub mod malformed_csr_exception {
    /// A builder for [`MalformedCsrException`](crate::error::MalformedCsrException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`MalformedCsrException`](crate::error::MalformedCsrException)
        pub fn build(self) -> crate::error::MalformedCsrException {
            crate::error::MalformedCsrException {
                message: self.message,
            }
        }
    }
}
impl MalformedCsrException {
    /// Creates a new builder-style object to manufacture [`MalformedCsrException`](crate::error::MalformedCsrException)
    pub fn builder() -> crate::error::malformed_csr_exception::Builder {
        crate::error::malformed_csr_exception::Builder::default()
    }
}

/// <p>One or more fields in the certificate are invalid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MalformedCertificateException {
    #[allow(missing_docs)] // documentation missing in model
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MalformedCertificateException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MalformedCertificateException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl MalformedCertificateException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MalformedCertificateException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MalformedCertificateException")?;
        if let Some(inner_17) = &self.message {
            write!(f, ": {}", inner_17)?;
        }
        Ok(())
    }
}
impl std::error::Error for MalformedCertificateException {}
/// See [`MalformedCertificateException`](crate::error::MalformedCertificateException)
pub mod malformed_certificate_exception {
    /// A builder for [`MalformedCertificateException`](crate::error::MalformedCertificateException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`MalformedCertificateException`](crate::error::MalformedCertificateException)
        pub fn build(self) -> crate::error::MalformedCertificateException {
            crate::error::MalformedCertificateException {
                message: self.message,
            }
        }
    }
}
impl MalformedCertificateException {
    /// Creates a new builder-style object to manufacture [`MalformedCertificateException`](crate::error::MalformedCertificateException)
    pub fn builder() -> crate::error::malformed_certificate_exception::Builder {
        crate::error::malformed_certificate_exception::Builder::default()
    }
}

/// <p>The certificate authority certificate you are importing does not comply with
/// conditions specified in the certificate that signed it.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CertificateMismatchException {
    #[allow(missing_docs)] // documentation missing in model
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CertificateMismatchException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CertificateMismatchException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CertificateMismatchException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CertificateMismatchException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CertificateMismatchException")?;
        if let Some(inner_18) = &self.message {
            write!(f, ": {}", inner_18)?;
        }
        Ok(())
    }
}
impl std::error::Error for CertificateMismatchException {}
/// See [`CertificateMismatchException`](crate::error::CertificateMismatchException)
pub mod certificate_mismatch_exception {
    /// A builder for [`CertificateMismatchException`](crate::error::CertificateMismatchException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CertificateMismatchException`](crate::error::CertificateMismatchException)
        pub fn build(self) -> crate::error::CertificateMismatchException {
            crate::error::CertificateMismatchException {
                message: self.message,
            }
        }
    }
}
impl CertificateMismatchException {
    /// Creates a new builder-style object to manufacture [`CertificateMismatchException`](crate::error::CertificateMismatchException)
    pub fn builder() -> crate::error::certificate_mismatch_exception::Builder {
        crate::error::certificate_mismatch_exception::Builder::default()
    }
}

/// <p>The designated permission has already been given to the user.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PermissionAlreadyExistsException {
    #[allow(missing_docs)] // documentation missing in model
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PermissionAlreadyExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PermissionAlreadyExistsException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl PermissionAlreadyExistsException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for PermissionAlreadyExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "PermissionAlreadyExistsException")?;
        if let Some(inner_19) = &self.message {
            write!(f, ": {}", inner_19)?;
        }
        Ok(())
    }
}
impl std::error::Error for PermissionAlreadyExistsException {}
/// See [`PermissionAlreadyExistsException`](crate::error::PermissionAlreadyExistsException)
pub mod permission_already_exists_exception {
    /// A builder for [`PermissionAlreadyExistsException`](crate::error::PermissionAlreadyExistsException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`PermissionAlreadyExistsException`](crate::error::PermissionAlreadyExistsException)
        pub fn build(self) -> crate::error::PermissionAlreadyExistsException {
            crate::error::PermissionAlreadyExistsException {
                message: self.message,
            }
        }
    }
}
impl PermissionAlreadyExistsException {
    /// Creates a new builder-style object to manufacture [`PermissionAlreadyExistsException`](crate::error::PermissionAlreadyExistsException)
    pub fn builder() -> crate::error::permission_already_exists_exception::Builder {
        crate::error::permission_already_exists_exception::Builder::default()
    }
}
