// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>A validation error due to mismatch between the expected data type, length, or pattern of the parameter and the input.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ValidationExceptionField {
    /// <p>The name of the parameter field with the validation error.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>A message about the validation error.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl ValidationExceptionField {
    /// <p>The name of the parameter field with the validation error.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A message about the validation error.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
/// See [`ValidationExceptionField`](crate::model::ValidationExceptionField).
pub mod validation_exception_field {

    /// A builder for [`ValidationExceptionField`](crate::model::ValidationExceptionField).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the parameter field with the validation error.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the parameter field with the validation error.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A message about the validation error.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message about the validation error.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ValidationExceptionField`](crate::model::ValidationExceptionField).
        pub fn build(self) -> crate::model::ValidationExceptionField {
            crate::model::ValidationExceptionField {
                name: self.name,
                message: self.message,
            }
        }
    }
}
impl ValidationExceptionField {
    /// Creates a new builder-style object to manufacture [`ValidationExceptionField`](crate::model::ValidationExceptionField).
    pub fn builder() -> crate::model::validation_exception_field::Builder {
        crate::model::validation_exception_field::Builder::default()
    }
}

/// When writing a match expression against `ValidationExceptionReason`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let validationexceptionreason = unimplemented!();
/// match validationexceptionreason {
///     ValidationExceptionReason::CannotParse => { /* ... */ },
///     ValidationExceptionReason::FieldValidationFailed => { /* ... */ },
///     ValidationExceptionReason::Other => { /* ... */ },
///     ValidationExceptionReason::UnknownOperation => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `validationexceptionreason` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ValidationExceptionReason::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ValidationExceptionReason::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ValidationExceptionReason::NewFeature` is defined.
/// Specifically, when `validationexceptionreason` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ValidationExceptionReason::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ValidationExceptionReason {
    #[allow(missing_docs)] // documentation missing in model
    CannotParse,
    #[allow(missing_docs)] // documentation missing in model
    FieldValidationFailed,
    #[allow(missing_docs)] // documentation missing in model
    Other,
    #[allow(missing_docs)] // documentation missing in model
    UnknownOperation,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ValidationExceptionReason {
    fn from(s: &str) -> Self {
        match s {
            "cannotParse" => ValidationExceptionReason::CannotParse,
            "fieldValidationFailed" => ValidationExceptionReason::FieldValidationFailed,
            "other" => ValidationExceptionReason::Other,
            "unknownOperation" => ValidationExceptionReason::UnknownOperation,
            other => ValidationExceptionReason::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for ValidationExceptionReason {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ValidationExceptionReason::from(s))
    }
}
impl ValidationExceptionReason {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ValidationExceptionReason::CannotParse => "cannotParse",
            ValidationExceptionReason::FieldValidationFailed => "fieldValidationFailed",
            ValidationExceptionReason::Other => "other",
            ValidationExceptionReason::UnknownOperation => "unknownOperation",
            ValidationExceptionReason::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "cannotParse",
            "fieldValidationFailed",
            "other",
            "unknownOperation",
        ]
    }
}
impl AsRef<str> for ValidationExceptionReason {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about a vehicle.</p>
/// <p>To return this information about vehicles in your account, you can use the API operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct VehicleSummary {
    /// <p>The unique ID of the vehicle.</p>
    #[doc(hidden)]
    pub vehicle_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the vehicle.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The ARN of a vehicle model (model manifest) associated with the vehicle.</p>
    #[doc(hidden)]
    pub model_manifest_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of a decoder manifest associated with the vehicle.</p>
    #[doc(hidden)]
    pub decoder_manifest_arn: std::option::Option<std::string::String>,
    /// <p>The time the vehicle was created in seconds since epoch (January 1, 1970 at midnight UTC time).</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time the vehicle was last updated in seconds since epoch (January 1, 1970 at midnight UTC time). </p>
    #[doc(hidden)]
    pub last_modification_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl VehicleSummary {
    /// <p>The unique ID of the vehicle.</p>
    pub fn vehicle_name(&self) -> std::option::Option<&str> {
        self.vehicle_name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the vehicle.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The ARN of a vehicle model (model manifest) associated with the vehicle.</p>
    pub fn model_manifest_arn(&self) -> std::option::Option<&str> {
        self.model_manifest_arn.as_deref()
    }
    /// <p>The ARN of a decoder manifest associated with the vehicle.</p>
    pub fn decoder_manifest_arn(&self) -> std::option::Option<&str> {
        self.decoder_manifest_arn.as_deref()
    }
    /// <p>The time the vehicle was created in seconds since epoch (January 1, 1970 at midnight UTC time).</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The time the vehicle was last updated in seconds since epoch (January 1, 1970 at midnight UTC time). </p>
    pub fn last_modification_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modification_time.as_ref()
    }
}
/// See [`VehicleSummary`](crate::model::VehicleSummary).
pub mod vehicle_summary {

    /// A builder for [`VehicleSummary`](crate::model::VehicleSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) vehicle_name: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) model_manifest_arn: std::option::Option<std::string::String>,
        pub(crate) decoder_manifest_arn: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modification_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The unique ID of the vehicle.</p>
        pub fn vehicle_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.vehicle_name = Some(input.into());
            self
        }
        /// <p>The unique ID of the vehicle.</p>
        pub fn set_vehicle_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vehicle_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the vehicle.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the vehicle.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The ARN of a vehicle model (model manifest) associated with the vehicle.</p>
        pub fn model_manifest_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_manifest_arn = Some(input.into());
            self
        }
        /// <p>The ARN of a vehicle model (model manifest) associated with the vehicle.</p>
        pub fn set_model_manifest_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_manifest_arn = input;
            self
        }
        /// <p>The ARN of a decoder manifest associated with the vehicle.</p>
        pub fn decoder_manifest_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.decoder_manifest_arn = Some(input.into());
            self
        }
        /// <p>The ARN of a decoder manifest associated with the vehicle.</p>
        pub fn set_decoder_manifest_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.decoder_manifest_arn = input;
            self
        }
        /// <p>The time the vehicle was created in seconds since epoch (January 1, 1970 at midnight UTC time).</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The time the vehicle was created in seconds since epoch (January 1, 1970 at midnight UTC time).</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The time the vehicle was last updated in seconds since epoch (January 1, 1970 at midnight UTC time). </p>
        pub fn last_modification_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modification_time = Some(input);
            self
        }
        /// <p>The time the vehicle was last updated in seconds since epoch (January 1, 1970 at midnight UTC time). </p>
        pub fn set_last_modification_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modification_time = input;
            self
        }
        /// Consumes the builder and constructs a [`VehicleSummary`](crate::model::VehicleSummary).
        pub fn build(self) -> crate::model::VehicleSummary {
            crate::model::VehicleSummary {
                vehicle_name: self.vehicle_name,
                arn: self.arn,
                model_manifest_arn: self.model_manifest_arn,
                decoder_manifest_arn: self.decoder_manifest_arn,
                creation_time: self.creation_time,
                last_modification_time: self.last_modification_time,
            }
        }
    }
}
impl VehicleSummary {
    /// Creates a new builder-style object to manufacture [`VehicleSummary`](crate::model::VehicleSummary).
    pub fn builder() -> crate::model::vehicle_summary::Builder {
        crate::model::vehicle_summary::Builder::default()
    }
}

/// <p>A set of key/value pairs that are used to manage the resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Tag {
    /// <p>The tag's key.</p>
    #[doc(hidden)]
    pub key: std::option::Option<std::string::String>,
    /// <p>The tag's value.</p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
}
impl Tag {
    /// <p>The tag's key.</p>
    pub fn key(&self) -> std::option::Option<&str> {
        self.key.as_deref()
    }
    /// <p>The tag's value.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
/// See [`Tag`](crate::model::Tag).
pub mod tag {

    /// A builder for [`Tag`](crate::model::Tag).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The tag's key.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        /// <p>The tag's key.</p>
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The tag's value.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The tag's value.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`Tag`](crate::model::Tag).
        pub fn build(self) -> crate::model::Tag {
            crate::model::Tag {
                key: self.key,
                value: self.value,
            }
        }
    }
}
impl Tag {
    /// Creates a new builder-style object to manufacture [`Tag`](crate::model::Tag).
    pub fn builder() -> crate::model::tag::Builder {
        crate::model::tag::Builder::default()
    }
}

/// When writing a match expression against `VehicleAssociationBehavior`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let vehicleassociationbehavior = unimplemented!();
/// match vehicleassociationbehavior {
///     VehicleAssociationBehavior::CreateIotThing => { /* ... */ },
///     VehicleAssociationBehavior::ValidateIotThingExists => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `vehicleassociationbehavior` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `VehicleAssociationBehavior::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `VehicleAssociationBehavior::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `VehicleAssociationBehavior::NewFeature` is defined.
/// Specifically, when `vehicleassociationbehavior` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `VehicleAssociationBehavior::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum VehicleAssociationBehavior {
    #[allow(missing_docs)] // documentation missing in model
    CreateIotThing,
    #[allow(missing_docs)] // documentation missing in model
    ValidateIotThingExists,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for VehicleAssociationBehavior {
    fn from(s: &str) -> Self {
        match s {
            "CreateIotThing" => VehicleAssociationBehavior::CreateIotThing,
            "ValidateIotThingExists" => VehicleAssociationBehavior::ValidateIotThingExists,
            other => VehicleAssociationBehavior::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for VehicleAssociationBehavior {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(VehicleAssociationBehavior::from(s))
    }
}
impl VehicleAssociationBehavior {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            VehicleAssociationBehavior::CreateIotThing => "CreateIotThing",
            VehicleAssociationBehavior::ValidateIotThingExists => "ValidateIotThingExists",
            VehicleAssociationBehavior::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CreateIotThing", "ValidateIotThingExists"]
    }
}
impl AsRef<str> for VehicleAssociationBehavior {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `UpdateMode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let updatemode = unimplemented!();
/// match updatemode {
///     UpdateMode::Merge => { /* ... */ },
///     UpdateMode::Overwrite => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `updatemode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `UpdateMode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `UpdateMode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `UpdateMode::NewFeature` is defined.
/// Specifically, when `updatemode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `UpdateMode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum UpdateMode {
    #[allow(missing_docs)] // documentation missing in model
    Merge,
    #[allow(missing_docs)] // documentation missing in model
    Overwrite,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for UpdateMode {
    fn from(s: &str) -> Self {
        match s {
            "Merge" => UpdateMode::Merge,
            "Overwrite" => UpdateMode::Overwrite,
            other => UpdateMode::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for UpdateMode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(UpdateMode::from(s))
    }
}
impl UpdateMode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            UpdateMode::Merge => "Merge",
            UpdateMode::Overwrite => "Overwrite",
            UpdateMode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["Merge", "Overwrite"]
    }
}
impl AsRef<str> for UpdateMode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A general abstraction of a signal. A node can be specified as an actuator, attribute, branch, or sensor.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum Node {
    /// <p>Information about a node specified as an actuator.</p> <note>
    /// <p>An actuator is a digital representation of a vehicle device.</p>
    /// </note>
    Actuator(crate::model::Actuator),
    /// <p>Information about a node specified as an attribute.</p> <note>
    /// <p>An attribute represents static information about a vehicle.</p>
    /// </note>
    Attribute(crate::model::Attribute),
    /// <p>Information about a node specified as a branch.</p> <note>
    /// <p>A group of signals that are defined in a hierarchical structure.</p>
    /// </note>
    Branch(crate::model::Branch),
    /// <p>An input component that reports the environmental condition of a vehicle.</p> <note>
    /// <p>You can collect data about fluid levels, temperatures, vibrations, or battery voltage from sensors.</p>
    /// </note>
    Sensor(crate::model::Sensor),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl Node {
    /// Tries to convert the enum instance into [`Actuator`](crate::model::Node::Actuator), extracting the inner [`Actuator`](crate::model::Actuator).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_actuator(&self) -> std::result::Result<&crate::model::Actuator, &Self> {
        if let Node::Actuator(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`Actuator`](crate::model::Node::Actuator).
    pub fn is_actuator(&self) -> bool {
        self.as_actuator().is_ok()
    }
    /// Tries to convert the enum instance into [`Attribute`](crate::model::Node::Attribute), extracting the inner [`Attribute`](crate::model::Attribute).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_attribute(&self) -> std::result::Result<&crate::model::Attribute, &Self> {
        if let Node::Attribute(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`Attribute`](crate::model::Node::Attribute).
    pub fn is_attribute(&self) -> bool {
        self.as_attribute().is_ok()
    }
    /// Tries to convert the enum instance into [`Branch`](crate::model::Node::Branch), extracting the inner [`Branch`](crate::model::Branch).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_branch(&self) -> std::result::Result<&crate::model::Branch, &Self> {
        if let Node::Branch(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`Branch`](crate::model::Node::Branch).
    pub fn is_branch(&self) -> bool {
        self.as_branch().is_ok()
    }
    /// Tries to convert the enum instance into [`Sensor`](crate::model::Node::Sensor), extracting the inner [`Sensor`](crate::model::Sensor).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_sensor(&self) -> std::result::Result<&crate::model::Sensor, &Self> {
        if let Node::Sensor(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`Sensor`](crate::model::Node::Sensor).
    pub fn is_sensor(&self) -> bool {
        self.as_sensor().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p>A signal that represents static information about the vehicle, such as engine type or manufacturing date.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Attribute {
    /// <p>The fully qualified name of the attribute. For example, the fully qualified name of an attribute might be <code>Vehicle.Body.Engine.Type</code>.</p>
    #[doc(hidden)]
    pub fully_qualified_name: std::option::Option<std::string::String>,
    /// <p>The specified data type of the attribute. </p>
    #[doc(hidden)]
    pub data_type: std::option::Option<crate::model::NodeDataType>,
    /// <p>A brief description of the attribute.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The scientific unit for the attribute.</p>
    #[doc(hidden)]
    pub unit: std::option::Option<std::string::String>,
    /// <p>A list of possible values an attribute can be assigned.</p>
    #[doc(hidden)]
    pub allowed_values: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The specified possible minimum value of the attribute.</p>
    #[doc(hidden)]
    pub min: std::option::Option<f64>,
    /// <p>The specified possible maximum value of the attribute.</p>
    #[doc(hidden)]
    pub max: std::option::Option<f64>,
    /// <p>A specified value for the attribute.</p>
    #[deprecated(note = "assignedValue is no longer in use")]
    #[doc(hidden)]
    pub assigned_value: std::option::Option<std::string::String>,
    /// <p>The default value of the attribute.</p>
    #[doc(hidden)]
    pub default_value: std::option::Option<std::string::String>,
}
impl Attribute {
    /// <p>The fully qualified name of the attribute. For example, the fully qualified name of an attribute might be <code>Vehicle.Body.Engine.Type</code>.</p>
    pub fn fully_qualified_name(&self) -> std::option::Option<&str> {
        self.fully_qualified_name.as_deref()
    }
    /// <p>The specified data type of the attribute. </p>
    pub fn data_type(&self) -> std::option::Option<&crate::model::NodeDataType> {
        self.data_type.as_ref()
    }
    /// <p>A brief description of the attribute.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The scientific unit for the attribute.</p>
    pub fn unit(&self) -> std::option::Option<&str> {
        self.unit.as_deref()
    }
    /// <p>A list of possible values an attribute can be assigned.</p>
    pub fn allowed_values(&self) -> std::option::Option<&[std::string::String]> {
        self.allowed_values.as_deref()
    }
    /// <p>The specified possible minimum value of the attribute.</p>
    pub fn min(&self) -> std::option::Option<f64> {
        self.min
    }
    /// <p>The specified possible maximum value of the attribute.</p>
    pub fn max(&self) -> std::option::Option<f64> {
        self.max
    }
    /// <p>A specified value for the attribute.</p>
    #[deprecated(note = "assignedValue is no longer in use")]
    pub fn assigned_value(&self) -> std::option::Option<&str> {
        self.assigned_value.as_deref()
    }
    /// <p>The default value of the attribute.</p>
    pub fn default_value(&self) -> std::option::Option<&str> {
        self.default_value.as_deref()
    }
}
/// See [`Attribute`](crate::model::Attribute).
pub mod attribute {

    /// A builder for [`Attribute`](crate::model::Attribute).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) fully_qualified_name: std::option::Option<std::string::String>,
        pub(crate) data_type: std::option::Option<crate::model::NodeDataType>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) unit: std::option::Option<std::string::String>,
        pub(crate) allowed_values: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) min: std::option::Option<f64>,
        pub(crate) max: std::option::Option<f64>,
        pub(crate) assigned_value: std::option::Option<std::string::String>,
        pub(crate) default_value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The fully qualified name of the attribute. For example, the fully qualified name of an attribute might be <code>Vehicle.Body.Engine.Type</code>.</p>
        pub fn fully_qualified_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.fully_qualified_name = Some(input.into());
            self
        }
        /// <p>The fully qualified name of the attribute. For example, the fully qualified name of an attribute might be <code>Vehicle.Body.Engine.Type</code>.</p>
        pub fn set_fully_qualified_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.fully_qualified_name = input;
            self
        }
        /// <p>The specified data type of the attribute. </p>
        pub fn data_type(mut self, input: crate::model::NodeDataType) -> Self {
            self.data_type = Some(input);
            self
        }
        /// <p>The specified data type of the attribute. </p>
        pub fn set_data_type(
            mut self,
            input: std::option::Option<crate::model::NodeDataType>,
        ) -> Self {
            self.data_type = input;
            self
        }
        /// <p>A brief description of the attribute.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A brief description of the attribute.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The scientific unit for the attribute.</p>
        pub fn unit(mut self, input: impl Into<std::string::String>) -> Self {
            self.unit = Some(input.into());
            self
        }
        /// <p>The scientific unit for the attribute.</p>
        pub fn set_unit(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.unit = input;
            self
        }
        /// Appends an item to `allowed_values`.
        ///
        /// To override the contents of this collection use [`set_allowed_values`](Self::set_allowed_values).
        ///
        /// <p>A list of possible values an attribute can be assigned.</p>
        pub fn allowed_values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.allowed_values.unwrap_or_default();
            v.push(input.into());
            self.allowed_values = Some(v);
            self
        }
        /// <p>A list of possible values an attribute can be assigned.</p>
        pub fn set_allowed_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.allowed_values = input;
            self
        }
        /// <p>The specified possible minimum value of the attribute.</p>
        pub fn min(mut self, input: f64) -> Self {
            self.min = Some(input);
            self
        }
        /// <p>The specified possible minimum value of the attribute.</p>
        pub fn set_min(mut self, input: std::option::Option<f64>) -> Self {
            self.min = input;
            self
        }
        /// <p>The specified possible maximum value of the attribute.</p>
        pub fn max(mut self, input: f64) -> Self {
            self.max = Some(input);
            self
        }
        /// <p>The specified possible maximum value of the attribute.</p>
        pub fn set_max(mut self, input: std::option::Option<f64>) -> Self {
            self.max = input;
            self
        }
        /// <p>A specified value for the attribute.</p>
        #[deprecated(note = "assignedValue is no longer in use")]
        pub fn assigned_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.assigned_value = Some(input.into());
            self
        }
        /// <p>A specified value for the attribute.</p>
        #[deprecated(note = "assignedValue is no longer in use")]
        pub fn set_assigned_value(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.assigned_value = input;
            self
        }
        /// <p>The default value of the attribute.</p>
        pub fn default_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.default_value = Some(input.into());
            self
        }
        /// <p>The default value of the attribute.</p>
        pub fn set_default_value(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.default_value = input;
            self
        }
        /// Consumes the builder and constructs a [`Attribute`](crate::model::Attribute).
        pub fn build(self) -> crate::model::Attribute {
            crate::model::Attribute {
                fully_qualified_name: self.fully_qualified_name,
                data_type: self.data_type,
                description: self.description,
                unit: self.unit,
                allowed_values: self.allowed_values,
                min: self.min,
                max: self.max,
                assigned_value: self.assigned_value,
                default_value: self.default_value,
            }
        }
    }
}
impl Attribute {
    /// Creates a new builder-style object to manufacture [`Attribute`](crate::model::Attribute).
    pub fn builder() -> crate::model::attribute::Builder {
        crate::model::attribute::Builder::default()
    }
}

/// When writing a match expression against `NodeDataType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let nodedatatype = unimplemented!();
/// match nodedatatype {
///     NodeDataType::Boolean => { /* ... */ },
///     NodeDataType::BooleanArray => { /* ... */ },
///     NodeDataType::Double => { /* ... */ },
///     NodeDataType::DoubleArray => { /* ... */ },
///     NodeDataType::Float => { /* ... */ },
///     NodeDataType::FloatArray => { /* ... */ },
///     NodeDataType::Int16 => { /* ... */ },
///     NodeDataType::Int16Array => { /* ... */ },
///     NodeDataType::Int32 => { /* ... */ },
///     NodeDataType::Int32Array => { /* ... */ },
///     NodeDataType::Int64 => { /* ... */ },
///     NodeDataType::Int64Array => { /* ... */ },
///     NodeDataType::Int8 => { /* ... */ },
///     NodeDataType::Int8Array => { /* ... */ },
///     NodeDataType::String => { /* ... */ },
///     NodeDataType::StringArray => { /* ... */ },
///     NodeDataType::Uint16 => { /* ... */ },
///     NodeDataType::Uint16Array => { /* ... */ },
///     NodeDataType::Uint32 => { /* ... */ },
///     NodeDataType::Uint32Array => { /* ... */ },
///     NodeDataType::Uint64 => { /* ... */ },
///     NodeDataType::Uint64Array => { /* ... */ },
///     NodeDataType::Uint8 => { /* ... */ },
///     NodeDataType::Uint8Array => { /* ... */ },
///     NodeDataType::UnixTimestamp => { /* ... */ },
///     NodeDataType::UnixTimestampArray => { /* ... */ },
///     NodeDataType::UnknownValue => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `nodedatatype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `NodeDataType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `NodeDataType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `NodeDataType::NewFeature` is defined.
/// Specifically, when `nodedatatype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `NodeDataType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// _Note: `NodeDataType::Unknown` has been renamed to `::UnknownValue`._
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum NodeDataType {
    #[allow(missing_docs)] // documentation missing in model
    Boolean,
    #[allow(missing_docs)] // documentation missing in model
    BooleanArray,
    #[allow(missing_docs)] // documentation missing in model
    Double,
    #[allow(missing_docs)] // documentation missing in model
    DoubleArray,
    #[allow(missing_docs)] // documentation missing in model
    Float,
    #[allow(missing_docs)] // documentation missing in model
    FloatArray,
    #[allow(missing_docs)] // documentation missing in model
    Int16,
    #[allow(missing_docs)] // documentation missing in model
    Int16Array,
    #[allow(missing_docs)] // documentation missing in model
    Int32,
    #[allow(missing_docs)] // documentation missing in model
    Int32Array,
    #[allow(missing_docs)] // documentation missing in model
    Int64,
    #[allow(missing_docs)] // documentation missing in model
    Int64Array,
    #[allow(missing_docs)] // documentation missing in model
    Int8,
    #[allow(missing_docs)] // documentation missing in model
    Int8Array,
    #[allow(missing_docs)] // documentation missing in model
    String,
    #[allow(missing_docs)] // documentation missing in model
    StringArray,
    #[allow(missing_docs)] // documentation missing in model
    Uint16,
    #[allow(missing_docs)] // documentation missing in model
    Uint16Array,
    #[allow(missing_docs)] // documentation missing in model
    Uint32,
    #[allow(missing_docs)] // documentation missing in model
    Uint32Array,
    #[allow(missing_docs)] // documentation missing in model
    Uint64,
    #[allow(missing_docs)] // documentation missing in model
    Uint64Array,
    #[allow(missing_docs)] // documentation missing in model
    Uint8,
    #[allow(missing_docs)] // documentation missing in model
    Uint8Array,
    #[allow(missing_docs)] // documentation missing in model
    UnixTimestamp,
    #[allow(missing_docs)] // documentation missing in model
    UnixTimestampArray,
    /// _Note: `::Unknown` has been renamed to `::UnknownValue`._
    UnknownValue,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for NodeDataType {
    fn from(s: &str) -> Self {
        match s {
            "BOOLEAN" => NodeDataType::Boolean,
            "BOOLEAN_ARRAY" => NodeDataType::BooleanArray,
            "DOUBLE" => NodeDataType::Double,
            "DOUBLE_ARRAY" => NodeDataType::DoubleArray,
            "FLOAT" => NodeDataType::Float,
            "FLOAT_ARRAY" => NodeDataType::FloatArray,
            "INT16" => NodeDataType::Int16,
            "INT16_ARRAY" => NodeDataType::Int16Array,
            "INT32" => NodeDataType::Int32,
            "INT32_ARRAY" => NodeDataType::Int32Array,
            "INT64" => NodeDataType::Int64,
            "INT64_ARRAY" => NodeDataType::Int64Array,
            "INT8" => NodeDataType::Int8,
            "INT8_ARRAY" => NodeDataType::Int8Array,
            "STRING" => NodeDataType::String,
            "STRING_ARRAY" => NodeDataType::StringArray,
            "UINT16" => NodeDataType::Uint16,
            "UINT16_ARRAY" => NodeDataType::Uint16Array,
            "UINT32" => NodeDataType::Uint32,
            "UINT32_ARRAY" => NodeDataType::Uint32Array,
            "UINT64" => NodeDataType::Uint64,
            "UINT64_ARRAY" => NodeDataType::Uint64Array,
            "UINT8" => NodeDataType::Uint8,
            "UINT8_ARRAY" => NodeDataType::Uint8Array,
            "UNIX_TIMESTAMP" => NodeDataType::UnixTimestamp,
            "UNIX_TIMESTAMP_ARRAY" => NodeDataType::UnixTimestampArray,
            "UNKNOWN" => NodeDataType::UnknownValue,
            other => NodeDataType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for NodeDataType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(NodeDataType::from(s))
    }
}
impl NodeDataType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            NodeDataType::Boolean => "BOOLEAN",
            NodeDataType::BooleanArray => "BOOLEAN_ARRAY",
            NodeDataType::Double => "DOUBLE",
            NodeDataType::DoubleArray => "DOUBLE_ARRAY",
            NodeDataType::Float => "FLOAT",
            NodeDataType::FloatArray => "FLOAT_ARRAY",
            NodeDataType::Int16 => "INT16",
            NodeDataType::Int16Array => "INT16_ARRAY",
            NodeDataType::Int32 => "INT32",
            NodeDataType::Int32Array => "INT32_ARRAY",
            NodeDataType::Int64 => "INT64",
            NodeDataType::Int64Array => "INT64_ARRAY",
            NodeDataType::Int8 => "INT8",
            NodeDataType::Int8Array => "INT8_ARRAY",
            NodeDataType::String => "STRING",
            NodeDataType::StringArray => "STRING_ARRAY",
            NodeDataType::Uint16 => "UINT16",
            NodeDataType::Uint16Array => "UINT16_ARRAY",
            NodeDataType::Uint32 => "UINT32",
            NodeDataType::Uint32Array => "UINT32_ARRAY",
            NodeDataType::Uint64 => "UINT64",
            NodeDataType::Uint64Array => "UINT64_ARRAY",
            NodeDataType::Uint8 => "UINT8",
            NodeDataType::Uint8Array => "UINT8_ARRAY",
            NodeDataType::UnixTimestamp => "UNIX_TIMESTAMP",
            NodeDataType::UnixTimestampArray => "UNIX_TIMESTAMP_ARRAY",
            NodeDataType::UnknownValue => "UNKNOWN",
            NodeDataType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "BOOLEAN",
            "BOOLEAN_ARRAY",
            "DOUBLE",
            "DOUBLE_ARRAY",
            "FLOAT",
            "FLOAT_ARRAY",
            "INT16",
            "INT16_ARRAY",
            "INT32",
            "INT32_ARRAY",
            "INT64",
            "INT64_ARRAY",
            "INT8",
            "INT8_ARRAY",
            "STRING",
            "STRING_ARRAY",
            "UINT16",
            "UINT16_ARRAY",
            "UINT32",
            "UINT32_ARRAY",
            "UINT64",
            "UINT64_ARRAY",
            "UINT8",
            "UINT8_ARRAY",
            "UNIX_TIMESTAMP",
            "UNIX_TIMESTAMP_ARRAY",
            "UNKNOWN",
        ]
    }
}
impl AsRef<str> for NodeDataType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A signal that represents a vehicle device such as the engine, heater, and door locks. Data from an actuator reports the state of a certain vehicle device.</p> <note>
/// <p> Updating actuator data can change the state of a device. For example, you can turn on or off the heater by updating its actuator data.</p>
/// </note>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Actuator {
    /// <p>The fully qualified name of the actuator. For example, the fully qualified name of an actuator might be <code>Vehicle.Front.Left.Door.Lock</code>.</p>
    #[doc(hidden)]
    pub fully_qualified_name: std::option::Option<std::string::String>,
    /// <p>The specified data type of the actuator. </p>
    #[doc(hidden)]
    pub data_type: std::option::Option<crate::model::NodeDataType>,
    /// <p>A brief description of the actuator.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The scientific unit for the actuator.</p>
    #[doc(hidden)]
    pub unit: std::option::Option<std::string::String>,
    /// <p>A list of possible values an actuator can take.</p>
    #[doc(hidden)]
    pub allowed_values: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The specified possible minimum value of an actuator.</p>
    #[doc(hidden)]
    pub min: std::option::Option<f64>,
    /// <p>The specified possible maximum value of an actuator.</p>
    #[doc(hidden)]
    pub max: std::option::Option<f64>,
    /// <p>A specified value for the actuator.</p>
    #[deprecated(note = "assignedValue is no longer in use")]
    #[doc(hidden)]
    pub assigned_value: std::option::Option<std::string::String>,
}
impl Actuator {
    /// <p>The fully qualified name of the actuator. For example, the fully qualified name of an actuator might be <code>Vehicle.Front.Left.Door.Lock</code>.</p>
    pub fn fully_qualified_name(&self) -> std::option::Option<&str> {
        self.fully_qualified_name.as_deref()
    }
    /// <p>The specified data type of the actuator. </p>
    pub fn data_type(&self) -> std::option::Option<&crate::model::NodeDataType> {
        self.data_type.as_ref()
    }
    /// <p>A brief description of the actuator.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The scientific unit for the actuator.</p>
    pub fn unit(&self) -> std::option::Option<&str> {
        self.unit.as_deref()
    }
    /// <p>A list of possible values an actuator can take.</p>
    pub fn allowed_values(&self) -> std::option::Option<&[std::string::String]> {
        self.allowed_values.as_deref()
    }
    /// <p>The specified possible minimum value of an actuator.</p>
    pub fn min(&self) -> std::option::Option<f64> {
        self.min
    }
    /// <p>The specified possible maximum value of an actuator.</p>
    pub fn max(&self) -> std::option::Option<f64> {
        self.max
    }
    /// <p>A specified value for the actuator.</p>
    #[deprecated(note = "assignedValue is no longer in use")]
    pub fn assigned_value(&self) -> std::option::Option<&str> {
        self.assigned_value.as_deref()
    }
}
/// See [`Actuator`](crate::model::Actuator).
pub mod actuator {

    /// A builder for [`Actuator`](crate::model::Actuator).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) fully_qualified_name: std::option::Option<std::string::String>,
        pub(crate) data_type: std::option::Option<crate::model::NodeDataType>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) unit: std::option::Option<std::string::String>,
        pub(crate) allowed_values: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) min: std::option::Option<f64>,
        pub(crate) max: std::option::Option<f64>,
        pub(crate) assigned_value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The fully qualified name of the actuator. For example, the fully qualified name of an actuator might be <code>Vehicle.Front.Left.Door.Lock</code>.</p>
        pub fn fully_qualified_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.fully_qualified_name = Some(input.into());
            self
        }
        /// <p>The fully qualified name of the actuator. For example, the fully qualified name of an actuator might be <code>Vehicle.Front.Left.Door.Lock</code>.</p>
        pub fn set_fully_qualified_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.fully_qualified_name = input;
            self
        }
        /// <p>The specified data type of the actuator. </p>
        pub fn data_type(mut self, input: crate::model::NodeDataType) -> Self {
            self.data_type = Some(input);
            self
        }
        /// <p>The specified data type of the actuator. </p>
        pub fn set_data_type(
            mut self,
            input: std::option::Option<crate::model::NodeDataType>,
        ) -> Self {
            self.data_type = input;
            self
        }
        /// <p>A brief description of the actuator.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A brief description of the actuator.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The scientific unit for the actuator.</p>
        pub fn unit(mut self, input: impl Into<std::string::String>) -> Self {
            self.unit = Some(input.into());
            self
        }
        /// <p>The scientific unit for the actuator.</p>
        pub fn set_unit(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.unit = input;
            self
        }
        /// Appends an item to `allowed_values`.
        ///
        /// To override the contents of this collection use [`set_allowed_values`](Self::set_allowed_values).
        ///
        /// <p>A list of possible values an actuator can take.</p>
        pub fn allowed_values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.allowed_values.unwrap_or_default();
            v.push(input.into());
            self.allowed_values = Some(v);
            self
        }
        /// <p>A list of possible values an actuator can take.</p>
        pub fn set_allowed_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.allowed_values = input;
            self
        }
        /// <p>The specified possible minimum value of an actuator.</p>
        pub fn min(mut self, input: f64) -> Self {
            self.min = Some(input);
            self
        }
        /// <p>The specified possible minimum value of an actuator.</p>
        pub fn set_min(mut self, input: std::option::Option<f64>) -> Self {
            self.min = input;
            self
        }
        /// <p>The specified possible maximum value of an actuator.</p>
        pub fn max(mut self, input: f64) -> Self {
            self.max = Some(input);
            self
        }
        /// <p>The specified possible maximum value of an actuator.</p>
        pub fn set_max(mut self, input: std::option::Option<f64>) -> Self {
            self.max = input;
            self
        }
        /// <p>A specified value for the actuator.</p>
        #[deprecated(note = "assignedValue is no longer in use")]
        pub fn assigned_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.assigned_value = Some(input.into());
            self
        }
        /// <p>A specified value for the actuator.</p>
        #[deprecated(note = "assignedValue is no longer in use")]
        pub fn set_assigned_value(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.assigned_value = input;
            self
        }
        /// Consumes the builder and constructs a [`Actuator`](crate::model::Actuator).
        pub fn build(self) -> crate::model::Actuator {
            crate::model::Actuator {
                fully_qualified_name: self.fully_qualified_name,
                data_type: self.data_type,
                description: self.description,
                unit: self.unit,
                allowed_values: self.allowed_values,
                min: self.min,
                max: self.max,
                assigned_value: self.assigned_value,
            }
        }
    }
}
impl Actuator {
    /// Creates a new builder-style object to manufacture [`Actuator`](crate::model::Actuator).
    pub fn builder() -> crate::model::actuator::Builder {
        crate::model::actuator::Builder::default()
    }
}

/// <p>An input component that reports the environmental condition of a vehicle.</p> <note>
/// <p>You can collect data about fluid levels, temperatures, vibrations, or battery voltage from sensors.</p>
/// </note>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Sensor {
    /// <p>The fully qualified name of the sensor. For example, the fully qualified name of a sensor might be <code>Vehicle.Body.Engine.Battery</code>.</p>
    #[doc(hidden)]
    pub fully_qualified_name: std::option::Option<std::string::String>,
    /// <p>The specified data type of the sensor. </p>
    #[doc(hidden)]
    pub data_type: std::option::Option<crate::model::NodeDataType>,
    /// <p>A brief description of a sensor.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The scientific unit of measurement for data collected by the sensor.</p>
    #[doc(hidden)]
    pub unit: std::option::Option<std::string::String>,
    /// <p>A list of possible values a sensor can take.</p>
    #[doc(hidden)]
    pub allowed_values: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The specified possible minimum value of the sensor.</p>
    #[doc(hidden)]
    pub min: std::option::Option<f64>,
    /// <p>The specified possible maximum value of the sensor.</p>
    #[doc(hidden)]
    pub max: std::option::Option<f64>,
}
impl Sensor {
    /// <p>The fully qualified name of the sensor. For example, the fully qualified name of a sensor might be <code>Vehicle.Body.Engine.Battery</code>.</p>
    pub fn fully_qualified_name(&self) -> std::option::Option<&str> {
        self.fully_qualified_name.as_deref()
    }
    /// <p>The specified data type of the sensor. </p>
    pub fn data_type(&self) -> std::option::Option<&crate::model::NodeDataType> {
        self.data_type.as_ref()
    }
    /// <p>A brief description of a sensor.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The scientific unit of measurement for data collected by the sensor.</p>
    pub fn unit(&self) -> std::option::Option<&str> {
        self.unit.as_deref()
    }
    /// <p>A list of possible values a sensor can take.</p>
    pub fn allowed_values(&self) -> std::option::Option<&[std::string::String]> {
        self.allowed_values.as_deref()
    }
    /// <p>The specified possible minimum value of the sensor.</p>
    pub fn min(&self) -> std::option::Option<f64> {
        self.min
    }
    /// <p>The specified possible maximum value of the sensor.</p>
    pub fn max(&self) -> std::option::Option<f64> {
        self.max
    }
}
/// See [`Sensor`](crate::model::Sensor).
pub mod sensor {

    /// A builder for [`Sensor`](crate::model::Sensor).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) fully_qualified_name: std::option::Option<std::string::String>,
        pub(crate) data_type: std::option::Option<crate::model::NodeDataType>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) unit: std::option::Option<std::string::String>,
        pub(crate) allowed_values: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) min: std::option::Option<f64>,
        pub(crate) max: std::option::Option<f64>,
    }
    impl Builder {
        /// <p>The fully qualified name of the sensor. For example, the fully qualified name of a sensor might be <code>Vehicle.Body.Engine.Battery</code>.</p>
        pub fn fully_qualified_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.fully_qualified_name = Some(input.into());
            self
        }
        /// <p>The fully qualified name of the sensor. For example, the fully qualified name of a sensor might be <code>Vehicle.Body.Engine.Battery</code>.</p>
        pub fn set_fully_qualified_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.fully_qualified_name = input;
            self
        }
        /// <p>The specified data type of the sensor. </p>
        pub fn data_type(mut self, input: crate::model::NodeDataType) -> Self {
            self.data_type = Some(input);
            self
        }
        /// <p>The specified data type of the sensor. </p>
        pub fn set_data_type(
            mut self,
            input: std::option::Option<crate::model::NodeDataType>,
        ) -> Self {
            self.data_type = input;
            self
        }
        /// <p>A brief description of a sensor.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A brief description of a sensor.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The scientific unit of measurement for data collected by the sensor.</p>
        pub fn unit(mut self, input: impl Into<std::string::String>) -> Self {
            self.unit = Some(input.into());
            self
        }
        /// <p>The scientific unit of measurement for data collected by the sensor.</p>
        pub fn set_unit(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.unit = input;
            self
        }
        /// Appends an item to `allowed_values`.
        ///
        /// To override the contents of this collection use [`set_allowed_values`](Self::set_allowed_values).
        ///
        /// <p>A list of possible values a sensor can take.</p>
        pub fn allowed_values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.allowed_values.unwrap_or_default();
            v.push(input.into());
            self.allowed_values = Some(v);
            self
        }
        /// <p>A list of possible values a sensor can take.</p>
        pub fn set_allowed_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.allowed_values = input;
            self
        }
        /// <p>The specified possible minimum value of the sensor.</p>
        pub fn min(mut self, input: f64) -> Self {
            self.min = Some(input);
            self
        }
        /// <p>The specified possible minimum value of the sensor.</p>
        pub fn set_min(mut self, input: std::option::Option<f64>) -> Self {
            self.min = input;
            self
        }
        /// <p>The specified possible maximum value of the sensor.</p>
        pub fn max(mut self, input: f64) -> Self {
            self.max = Some(input);
            self
        }
        /// <p>The specified possible maximum value of the sensor.</p>
        pub fn set_max(mut self, input: std::option::Option<f64>) -> Self {
            self.max = input;
            self
        }
        /// Consumes the builder and constructs a [`Sensor`](crate::model::Sensor).
        pub fn build(self) -> crate::model::Sensor {
            crate::model::Sensor {
                fully_qualified_name: self.fully_qualified_name,
                data_type: self.data_type,
                description: self.description,
                unit: self.unit,
                allowed_values: self.allowed_values,
                min: self.min,
                max: self.max,
            }
        }
    }
}
impl Sensor {
    /// Creates a new builder-style object to manufacture [`Sensor`](crate::model::Sensor).
    pub fn builder() -> crate::model::sensor::Builder {
        crate::model::sensor::Builder::default()
    }
}

/// <p>A group of signals that are defined in a hierarchical structure.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Branch {
    /// <p>The fully qualified name of the branch. For example, the fully qualified name of a branch might be <code>Vehicle.Body.Engine</code>.</p>
    #[doc(hidden)]
    pub fully_qualified_name: std::option::Option<std::string::String>,
    /// <p>A brief description of the branch.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
}
impl Branch {
    /// <p>The fully qualified name of the branch. For example, the fully qualified name of a branch might be <code>Vehicle.Body.Engine</code>.</p>
    pub fn fully_qualified_name(&self) -> std::option::Option<&str> {
        self.fully_qualified_name.as_deref()
    }
    /// <p>A brief description of the branch.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
}
/// See [`Branch`](crate::model::Branch).
pub mod branch {

    /// A builder for [`Branch`](crate::model::Branch).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) fully_qualified_name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The fully qualified name of the branch. For example, the fully qualified name of a branch might be <code>Vehicle.Body.Engine</code>.</p>
        pub fn fully_qualified_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.fully_qualified_name = Some(input.into());
            self
        }
        /// <p>The fully qualified name of the branch. For example, the fully qualified name of a branch might be <code>Vehicle.Body.Engine</code>.</p>
        pub fn set_fully_qualified_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.fully_qualified_name = input;
            self
        }
        /// <p>A brief description of the branch.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A brief description of the branch.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Consumes the builder and constructs a [`Branch`](crate::model::Branch).
        pub fn build(self) -> crate::model::Branch {
            crate::model::Branch {
                fully_qualified_name: self.fully_qualified_name,
                description: self.description,
            }
        }
    }
}
impl Branch {
    /// Creates a new builder-style object to manufacture [`Branch`](crate::model::Branch).
    pub fn builder() -> crate::model::branch::Builder {
        crate::model::branch::Builder::default()
    }
}

/// <p>A reason that a signal isn't valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidSignal {
    /// <p>The name of the signal that isn't valid.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>A message about why the signal isn't valid.</p>
    #[doc(hidden)]
    pub reason: std::option::Option<std::string::String>,
}
impl InvalidSignal {
    /// <p>The name of the signal that isn't valid.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A message about why the signal isn't valid.</p>
    pub fn reason(&self) -> std::option::Option<&str> {
        self.reason.as_deref()
    }
}
/// See [`InvalidSignal`](crate::model::InvalidSignal).
pub mod invalid_signal {

    /// A builder for [`InvalidSignal`](crate::model::InvalidSignal).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) reason: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the signal that isn't valid.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the signal that isn't valid.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A message about why the signal isn't valid.</p>
        pub fn reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.reason = Some(input.into());
            self
        }
        /// <p>A message about why the signal isn't valid.</p>
        pub fn set_reason(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.reason = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidSignal`](crate::model::InvalidSignal).
        pub fn build(self) -> crate::model::InvalidSignal {
            crate::model::InvalidSignal {
                name: self.name,
                reason: self.reason,
            }
        }
    }
}
impl InvalidSignal {
    /// Creates a new builder-style object to manufacture [`InvalidSignal`](crate::model::InvalidSignal).
    pub fn builder() -> crate::model::invalid_signal::Builder {
        crate::model::invalid_signal::Builder::default()
    }
}

/// <p>Vehicle Signal Specification (VSS) is a precise language used to describe and model signals in vehicle networks. The JSON file collects signal specificiations in a VSS format.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum FormattedVss {
    /// <p>Provides the VSS in JSON format.</p>
    VssJson(std::string::String),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl FormattedVss {
    #[allow(irrefutable_let_patterns)]
    /// Tries to convert the enum instance into [`VssJson`](crate::model::FormattedVss::VssJson), extracting the inner [`String`](std::string::String).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_vss_json(&self) -> std::result::Result<&std::string::String, &Self> {
        if let FormattedVss::VssJson(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`VssJson`](crate::model::FormattedVss::VssJson).
    pub fn is_vss_json(&self) -> bool {
        self.as_vss_json().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p>Information about a collection of standardized signals, which can be attributes, branches, sensors, or actuators.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SignalCatalogSummary {
    /// <p>The name of the signal catalog.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the signal catalog.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The time the signal catalog was created in seconds since epoch (January 1, 1970 at midnight UTC time). </p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time the signal catalog was last updated in seconds since epoch (January 1, 1970 at midnight UTC time). </p>
    #[doc(hidden)]
    pub last_modification_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl SignalCatalogSummary {
    /// <p>The name of the signal catalog.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the signal catalog.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The time the signal catalog was created in seconds since epoch (January 1, 1970 at midnight UTC time). </p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The time the signal catalog was last updated in seconds since epoch (January 1, 1970 at midnight UTC time). </p>
    pub fn last_modification_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modification_time.as_ref()
    }
}
/// See [`SignalCatalogSummary`](crate::model::SignalCatalogSummary).
pub mod signal_catalog_summary {

    /// A builder for [`SignalCatalogSummary`](crate::model::SignalCatalogSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modification_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The name of the signal catalog.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the signal catalog.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the signal catalog.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the signal catalog.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The time the signal catalog was created in seconds since epoch (January 1, 1970 at midnight UTC time). </p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The time the signal catalog was created in seconds since epoch (January 1, 1970 at midnight UTC time). </p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The time the signal catalog was last updated in seconds since epoch (January 1, 1970 at midnight UTC time). </p>
        pub fn last_modification_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modification_time = Some(input);
            self
        }
        /// <p>The time the signal catalog was last updated in seconds since epoch (January 1, 1970 at midnight UTC time). </p>
        pub fn set_last_modification_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modification_time = input;
            self
        }
        /// Consumes the builder and constructs a [`SignalCatalogSummary`](crate::model::SignalCatalogSummary).
        pub fn build(self) -> crate::model::SignalCatalogSummary {
            crate::model::SignalCatalogSummary {
                name: self.name,
                arn: self.arn,
                creation_time: self.creation_time,
                last_modification_time: self.last_modification_time,
            }
        }
    }
}
impl SignalCatalogSummary {
    /// Creates a new builder-style object to manufacture [`SignalCatalogSummary`](crate::model::SignalCatalogSummary).
    pub fn builder() -> crate::model::signal_catalog_summary::Builder {
        crate::model::signal_catalog_summary::Builder::default()
    }
}

/// <p>Information about the number of nodes and node types in a vehicle network.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NodeCounts {
    /// <p>The total number of nodes in a vehicle network.</p>
    #[doc(hidden)]
    pub total_nodes: i32,
    /// <p>The total number of nodes in a vehicle network that represent branches.</p>
    #[doc(hidden)]
    pub total_branches: i32,
    /// <p>The total number of nodes in a vehicle network that represent sensors.</p>
    #[doc(hidden)]
    pub total_sensors: i32,
    /// <p>The total number of nodes in a vehicle network that represent attributes.</p>
    #[doc(hidden)]
    pub total_attributes: i32,
    /// <p>The total number of nodes in a vehicle network that represent actuators.</p>
    #[doc(hidden)]
    pub total_actuators: i32,
}
impl NodeCounts {
    /// <p>The total number of nodes in a vehicle network.</p>
    pub fn total_nodes(&self) -> i32 {
        self.total_nodes
    }
    /// <p>The total number of nodes in a vehicle network that represent branches.</p>
    pub fn total_branches(&self) -> i32 {
        self.total_branches
    }
    /// <p>The total number of nodes in a vehicle network that represent sensors.</p>
    pub fn total_sensors(&self) -> i32 {
        self.total_sensors
    }
    /// <p>The total number of nodes in a vehicle network that represent attributes.</p>
    pub fn total_attributes(&self) -> i32 {
        self.total_attributes
    }
    /// <p>The total number of nodes in a vehicle network that represent actuators.</p>
    pub fn total_actuators(&self) -> i32 {
        self.total_actuators
    }
}
/// See [`NodeCounts`](crate::model::NodeCounts).
pub mod node_counts {

    /// A builder for [`NodeCounts`](crate::model::NodeCounts).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) total_nodes: std::option::Option<i32>,
        pub(crate) total_branches: std::option::Option<i32>,
        pub(crate) total_sensors: std::option::Option<i32>,
        pub(crate) total_attributes: std::option::Option<i32>,
        pub(crate) total_actuators: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The total number of nodes in a vehicle network.</p>
        pub fn total_nodes(mut self, input: i32) -> Self {
            self.total_nodes = Some(input);
            self
        }
        /// <p>The total number of nodes in a vehicle network.</p>
        pub fn set_total_nodes(mut self, input: std::option::Option<i32>) -> Self {
            self.total_nodes = input;
            self
        }
        /// <p>The total number of nodes in a vehicle network that represent branches.</p>
        pub fn total_branches(mut self, input: i32) -> Self {
            self.total_branches = Some(input);
            self
        }
        /// <p>The total number of nodes in a vehicle network that represent branches.</p>
        pub fn set_total_branches(mut self, input: std::option::Option<i32>) -> Self {
            self.total_branches = input;
            self
        }
        /// <p>The total number of nodes in a vehicle network that represent sensors.</p>
        pub fn total_sensors(mut self, input: i32) -> Self {
            self.total_sensors = Some(input);
            self
        }
        /// <p>The total number of nodes in a vehicle network that represent sensors.</p>
        pub fn set_total_sensors(mut self, input: std::option::Option<i32>) -> Self {
            self.total_sensors = input;
            self
        }
        /// <p>The total number of nodes in a vehicle network that represent attributes.</p>
        pub fn total_attributes(mut self, input: i32) -> Self {
            self.total_attributes = Some(input);
            self
        }
        /// <p>The total number of nodes in a vehicle network that represent attributes.</p>
        pub fn set_total_attributes(mut self, input: std::option::Option<i32>) -> Self {
            self.total_attributes = input;
            self
        }
        /// <p>The total number of nodes in a vehicle network that represent actuators.</p>
        pub fn total_actuators(mut self, input: i32) -> Self {
            self.total_actuators = Some(input);
            self
        }
        /// <p>The total number of nodes in a vehicle network that represent actuators.</p>
        pub fn set_total_actuators(mut self, input: std::option::Option<i32>) -> Self {
            self.total_actuators = input;
            self
        }
        /// Consumes the builder and constructs a [`NodeCounts`](crate::model::NodeCounts).
        pub fn build(self) -> crate::model::NodeCounts {
            crate::model::NodeCounts {
                total_nodes: self.total_nodes.unwrap_or_default(),
                total_branches: self.total_branches.unwrap_or_default(),
                total_sensors: self.total_sensors.unwrap_or_default(),
                total_attributes: self.total_attributes.unwrap_or_default(),
                total_actuators: self.total_actuators.unwrap_or_default(),
            }
        }
    }
}
impl NodeCounts {
    /// Creates a new builder-style object to manufacture [`NodeCounts`](crate::model::NodeCounts).
    pub fn builder() -> crate::model::node_counts::Builder {
        crate::model::node_counts::Builder::default()
    }
}

/// <p>Information about a vehicle model (model manifest). You can use the API operation to return this information about multiple vehicle models.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ModelManifestSummary {
    /// <p>The name of the vehicle model.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the vehicle model.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The ARN of the signal catalog associated with the vehicle model.</p>
    #[doc(hidden)]
    pub signal_catalog_arn: std::option::Option<std::string::String>,
    /// <p>A brief description of the vehicle model.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The state of the vehicle model. If the status is <code>ACTIVE</code>, the vehicle model can't be edited. If the status is <code>DRAFT</code>, you can edit the vehicle model.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::ManifestStatus>,
    /// <p>The time the vehicle model was created, in seconds since epoch (January 1, 1970 at midnight UTC time).</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time the vehicle model was last updated, in seconds since epoch (January 1, 1970 at midnight UTC time).</p>
    #[doc(hidden)]
    pub last_modification_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl ModelManifestSummary {
    /// <p>The name of the vehicle model.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the vehicle model.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The ARN of the signal catalog associated with the vehicle model.</p>
    pub fn signal_catalog_arn(&self) -> std::option::Option<&str> {
        self.signal_catalog_arn.as_deref()
    }
    /// <p>A brief description of the vehicle model.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The state of the vehicle model. If the status is <code>ACTIVE</code>, the vehicle model can't be edited. If the status is <code>DRAFT</code>, you can edit the vehicle model.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::ManifestStatus> {
        self.status.as_ref()
    }
    /// <p>The time the vehicle model was created, in seconds since epoch (January 1, 1970 at midnight UTC time).</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The time the vehicle model was last updated, in seconds since epoch (January 1, 1970 at midnight UTC time).</p>
    pub fn last_modification_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modification_time.as_ref()
    }
}
/// See [`ModelManifestSummary`](crate::model::ModelManifestSummary).
pub mod model_manifest_summary {

    /// A builder for [`ModelManifestSummary`](crate::model::ModelManifestSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) signal_catalog_arn: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::ManifestStatus>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modification_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The name of the vehicle model.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the vehicle model.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the vehicle model.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the vehicle model.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The ARN of the signal catalog associated with the vehicle model.</p>
        pub fn signal_catalog_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.signal_catalog_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the signal catalog associated with the vehicle model.</p>
        pub fn set_signal_catalog_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.signal_catalog_arn = input;
            self
        }
        /// <p>A brief description of the vehicle model.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A brief description of the vehicle model.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The state of the vehicle model. If the status is <code>ACTIVE</code>, the vehicle model can't be edited. If the status is <code>DRAFT</code>, you can edit the vehicle model.</p>
        pub fn status(mut self, input: crate::model::ManifestStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The state of the vehicle model. If the status is <code>ACTIVE</code>, the vehicle model can't be edited. If the status is <code>DRAFT</code>, you can edit the vehicle model.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ManifestStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The time the vehicle model was created, in seconds since epoch (January 1, 1970 at midnight UTC time).</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The time the vehicle model was created, in seconds since epoch (January 1, 1970 at midnight UTC time).</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The time the vehicle model was last updated, in seconds since epoch (January 1, 1970 at midnight UTC time).</p>
        pub fn last_modification_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modification_time = Some(input);
            self
        }
        /// <p>The time the vehicle model was last updated, in seconds since epoch (January 1, 1970 at midnight UTC time).</p>
        pub fn set_last_modification_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modification_time = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelManifestSummary`](crate::model::ModelManifestSummary).
        pub fn build(self) -> crate::model::ModelManifestSummary {
            crate::model::ModelManifestSummary {
                name: self.name,
                arn: self.arn,
                signal_catalog_arn: self.signal_catalog_arn,
                description: self.description,
                status: self.status,
                creation_time: self.creation_time,
                last_modification_time: self.last_modification_time,
            }
        }
    }
}
impl ModelManifestSummary {
    /// Creates a new builder-style object to manufacture [`ModelManifestSummary`](crate::model::ModelManifestSummary).
    pub fn builder() -> crate::model::model_manifest_summary::Builder {
        crate::model::model_manifest_summary::Builder::default()
    }
}

/// When writing a match expression against `ManifestStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let manifeststatus = unimplemented!();
/// match manifeststatus {
///     ManifestStatus::Active => { /* ... */ },
///     ManifestStatus::Draft => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `manifeststatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ManifestStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ManifestStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ManifestStatus::NewFeature` is defined.
/// Specifically, when `manifeststatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ManifestStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ManifestStatus {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Draft,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ManifestStatus {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => ManifestStatus::Active,
            "DRAFT" => ManifestStatus::Draft,
            other => ManifestStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ManifestStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ManifestStatus::from(s))
    }
}
impl ManifestStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ManifestStatus::Active => "ACTIVE",
            ManifestStatus::Draft => "DRAFT",
            ManifestStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ACTIVE", "DRAFT"]
    }
}
impl AsRef<str> for ManifestStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about a fleet.</p>
/// <p>You can use the API operation to return this information about multiple fleets.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FleetSummary {
    /// <p>The unique ID of the fleet.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the fleet.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>A brief description of the fleet.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The ARN of the signal catalog associated with the fleet.</p>
    #[doc(hidden)]
    pub signal_catalog_arn: std::option::Option<std::string::String>,
    /// <p>The time the fleet was created, in seconds since epoch (January 1, 1970 at midnight UTC time).</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time the fleet was last updated in seconds since epoch (January 1, 1970 at midnight UTC time).</p>
    #[doc(hidden)]
    pub last_modification_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl FleetSummary {
    /// <p>The unique ID of the fleet.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the fleet.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>A brief description of the fleet.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The ARN of the signal catalog associated with the fleet.</p>
    pub fn signal_catalog_arn(&self) -> std::option::Option<&str> {
        self.signal_catalog_arn.as_deref()
    }
    /// <p>The time the fleet was created, in seconds since epoch (January 1, 1970 at midnight UTC time).</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The time the fleet was last updated in seconds since epoch (January 1, 1970 at midnight UTC time).</p>
    pub fn last_modification_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modification_time.as_ref()
    }
}
/// See [`FleetSummary`](crate::model::FleetSummary).
pub mod fleet_summary {

    /// A builder for [`FleetSummary`](crate::model::FleetSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) signal_catalog_arn: std::option::Option<std::string::String>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modification_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The unique ID of the fleet.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The unique ID of the fleet.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the fleet.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the fleet.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>A brief description of the fleet.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A brief description of the fleet.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The ARN of the signal catalog associated with the fleet.</p>
        pub fn signal_catalog_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.signal_catalog_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the signal catalog associated with the fleet.</p>
        pub fn set_signal_catalog_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.signal_catalog_arn = input;
            self
        }
        /// <p>The time the fleet was created, in seconds since epoch (January 1, 1970 at midnight UTC time).</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The time the fleet was created, in seconds since epoch (January 1, 1970 at midnight UTC time).</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The time the fleet was last updated in seconds since epoch (January 1, 1970 at midnight UTC time).</p>
        pub fn last_modification_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modification_time = Some(input);
            self
        }
        /// <p>The time the fleet was last updated in seconds since epoch (January 1, 1970 at midnight UTC time).</p>
        pub fn set_last_modification_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modification_time = input;
            self
        }
        /// Consumes the builder and constructs a [`FleetSummary`](crate::model::FleetSummary).
        pub fn build(self) -> crate::model::FleetSummary {
            crate::model::FleetSummary {
                id: self.id,
                arn: self.arn,
                description: self.description,
                signal_catalog_arn: self.signal_catalog_arn,
                creation_time: self.creation_time,
                last_modification_time: self.last_modification_time,
            }
        }
    }
}
impl FleetSummary {
    /// Creates a new builder-style object to manufacture [`FleetSummary`](crate::model::FleetSummary).
    pub fn builder() -> crate::model::fleet_summary::Builder {
        crate::model::fleet_summary::Builder::default()
    }
}

/// <p>Information about a signal decoder.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SignalDecoder {
    /// <p>The fully qualified name of a signal decoder as defined in a vehicle model.</p>
    #[doc(hidden)]
    pub fully_qualified_name: std::option::Option<std::string::String>,
    /// <p>The network protocol for the vehicle. For example, <code>CAN_SIGNAL</code> specifies a protocol that defines how data is communicated between electronic control units (ECUs). <code>OBD_SIGNAL</code> specifies a protocol that defines how self-diagnostic data is communicated between ECUs.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::SignalDecoderType>,
    /// <p>The ID of a network interface that specifies what network protocol a vehicle follows.</p>
    #[doc(hidden)]
    pub interface_id: std::option::Option<std::string::String>,
    /// <p>Information about signal decoder using the Controller Area Network (CAN) protocol.</p>
    #[doc(hidden)]
    pub can_signal: std::option::Option<crate::model::CanSignal>,
    /// <p>Information about signal decoder using the On-board diagnostic (OBD) II protocol.</p>
    #[doc(hidden)]
    pub obd_signal: std::option::Option<crate::model::ObdSignal>,
}
impl SignalDecoder {
    /// <p>The fully qualified name of a signal decoder as defined in a vehicle model.</p>
    pub fn fully_qualified_name(&self) -> std::option::Option<&str> {
        self.fully_qualified_name.as_deref()
    }
    /// <p>The network protocol for the vehicle. For example, <code>CAN_SIGNAL</code> specifies a protocol that defines how data is communicated between electronic control units (ECUs). <code>OBD_SIGNAL</code> specifies a protocol that defines how self-diagnostic data is communicated between ECUs.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::SignalDecoderType> {
        self.r#type.as_ref()
    }
    /// <p>The ID of a network interface that specifies what network protocol a vehicle follows.</p>
    pub fn interface_id(&self) -> std::option::Option<&str> {
        self.interface_id.as_deref()
    }
    /// <p>Information about signal decoder using the Controller Area Network (CAN) protocol.</p>
    pub fn can_signal(&self) -> std::option::Option<&crate::model::CanSignal> {
        self.can_signal.as_ref()
    }
    /// <p>Information about signal decoder using the On-board diagnostic (OBD) II protocol.</p>
    pub fn obd_signal(&self) -> std::option::Option<&crate::model::ObdSignal> {
        self.obd_signal.as_ref()
    }
}
/// See [`SignalDecoder`](crate::model::SignalDecoder).
pub mod signal_decoder {

    /// A builder for [`SignalDecoder`](crate::model::SignalDecoder).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) fully_qualified_name: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::SignalDecoderType>,
        pub(crate) interface_id: std::option::Option<std::string::String>,
        pub(crate) can_signal: std::option::Option<crate::model::CanSignal>,
        pub(crate) obd_signal: std::option::Option<crate::model::ObdSignal>,
    }
    impl Builder {
        /// <p>The fully qualified name of a signal decoder as defined in a vehicle model.</p>
        pub fn fully_qualified_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.fully_qualified_name = Some(input.into());
            self
        }
        /// <p>The fully qualified name of a signal decoder as defined in a vehicle model.</p>
        pub fn set_fully_qualified_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.fully_qualified_name = input;
            self
        }
        /// <p>The network protocol for the vehicle. For example, <code>CAN_SIGNAL</code> specifies a protocol that defines how data is communicated between electronic control units (ECUs). <code>OBD_SIGNAL</code> specifies a protocol that defines how self-diagnostic data is communicated between ECUs.</p>
        pub fn r#type(mut self, input: crate::model::SignalDecoderType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The network protocol for the vehicle. For example, <code>CAN_SIGNAL</code> specifies a protocol that defines how data is communicated between electronic control units (ECUs). <code>OBD_SIGNAL</code> specifies a protocol that defines how self-diagnostic data is communicated between ECUs.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::SignalDecoderType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The ID of a network interface that specifies what network protocol a vehicle follows.</p>
        pub fn interface_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.interface_id = Some(input.into());
            self
        }
        /// <p>The ID of a network interface that specifies what network protocol a vehicle follows.</p>
        pub fn set_interface_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.interface_id = input;
            self
        }
        /// <p>Information about signal decoder using the Controller Area Network (CAN) protocol.</p>
        pub fn can_signal(mut self, input: crate::model::CanSignal) -> Self {
            self.can_signal = Some(input);
            self
        }
        /// <p>Information about signal decoder using the Controller Area Network (CAN) protocol.</p>
        pub fn set_can_signal(
            mut self,
            input: std::option::Option<crate::model::CanSignal>,
        ) -> Self {
            self.can_signal = input;
            self
        }
        /// <p>Information about signal decoder using the On-board diagnostic (OBD) II protocol.</p>
        pub fn obd_signal(mut self, input: crate::model::ObdSignal) -> Self {
            self.obd_signal = Some(input);
            self
        }
        /// <p>Information about signal decoder using the On-board diagnostic (OBD) II protocol.</p>
        pub fn set_obd_signal(
            mut self,
            input: std::option::Option<crate::model::ObdSignal>,
        ) -> Self {
            self.obd_signal = input;
            self
        }
        /// Consumes the builder and constructs a [`SignalDecoder`](crate::model::SignalDecoder).
        pub fn build(self) -> crate::model::SignalDecoder {
            crate::model::SignalDecoder {
                fully_qualified_name: self.fully_qualified_name,
                r#type: self.r#type,
                interface_id: self.interface_id,
                can_signal: self.can_signal,
                obd_signal: self.obd_signal,
            }
        }
    }
}
impl SignalDecoder {
    /// Creates a new builder-style object to manufacture [`SignalDecoder`](crate::model::SignalDecoder).
    pub fn builder() -> crate::model::signal_decoder::Builder {
        crate::model::signal_decoder::Builder::default()
    }
}

/// <p>Information about signal messages using the on-board diagnostics (OBD) II protocol in a vehicle.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ObdSignal {
    /// <p>The length of the requested data.</p>
    #[doc(hidden)]
    pub pid_response_length: i32,
    /// <p>The mode of operation (diagnostic service) in a message.</p>
    #[doc(hidden)]
    pub service_mode: i32,
    /// <p>The diagnostic code used to request data from a vehicle for this signal.</p>
    #[doc(hidden)]
    pub pid: i32,
    /// <p>A multiplier used to decode the message.</p>
    #[doc(hidden)]
    pub scaling: std::option::Option<f64>,
    /// <p>Indicates where data appears in the message.</p>
    #[doc(hidden)]
    pub offset: std::option::Option<f64>,
    /// <p>Indicates the beginning of the message.</p>
    #[doc(hidden)]
    pub start_byte: i32,
    /// <p>The length of a message.</p>
    #[doc(hidden)]
    pub byte_length: std::option::Option<i32>,
    /// <p>The number of positions to shift bits in the message.</p>
    #[doc(hidden)]
    pub bit_right_shift: i32,
    /// <p>The number of bits to mask in a message.</p>
    #[doc(hidden)]
    pub bit_mask_length: std::option::Option<i32>,
}
impl ObdSignal {
    /// <p>The length of the requested data.</p>
    pub fn pid_response_length(&self) -> i32 {
        self.pid_response_length
    }
    /// <p>The mode of operation (diagnostic service) in a message.</p>
    pub fn service_mode(&self) -> i32 {
        self.service_mode
    }
    /// <p>The diagnostic code used to request data from a vehicle for this signal.</p>
    pub fn pid(&self) -> i32 {
        self.pid
    }
    /// <p>A multiplier used to decode the message.</p>
    pub fn scaling(&self) -> std::option::Option<f64> {
        self.scaling
    }
    /// <p>Indicates where data appears in the message.</p>
    pub fn offset(&self) -> std::option::Option<f64> {
        self.offset
    }
    /// <p>Indicates the beginning of the message.</p>
    pub fn start_byte(&self) -> i32 {
        self.start_byte
    }
    /// <p>The length of a message.</p>
    pub fn byte_length(&self) -> std::option::Option<i32> {
        self.byte_length
    }
    /// <p>The number of positions to shift bits in the message.</p>
    pub fn bit_right_shift(&self) -> i32 {
        self.bit_right_shift
    }
    /// <p>The number of bits to mask in a message.</p>
    pub fn bit_mask_length(&self) -> std::option::Option<i32> {
        self.bit_mask_length
    }
}
/// See [`ObdSignal`](crate::model::ObdSignal).
pub mod obd_signal {

    /// A builder for [`ObdSignal`](crate::model::ObdSignal).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) pid_response_length: std::option::Option<i32>,
        pub(crate) service_mode: std::option::Option<i32>,
        pub(crate) pid: std::option::Option<i32>,
        pub(crate) scaling: std::option::Option<f64>,
        pub(crate) offset: std::option::Option<f64>,
        pub(crate) start_byte: std::option::Option<i32>,
        pub(crate) byte_length: std::option::Option<i32>,
        pub(crate) bit_right_shift: std::option::Option<i32>,
        pub(crate) bit_mask_length: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The length of the requested data.</p>
        pub fn pid_response_length(mut self, input: i32) -> Self {
            self.pid_response_length = Some(input);
            self
        }
        /// <p>The length of the requested data.</p>
        pub fn set_pid_response_length(mut self, input: std::option::Option<i32>) -> Self {
            self.pid_response_length = input;
            self
        }
        /// <p>The mode of operation (diagnostic service) in a message.</p>
        pub fn service_mode(mut self, input: i32) -> Self {
            self.service_mode = Some(input);
            self
        }
        /// <p>The mode of operation (diagnostic service) in a message.</p>
        pub fn set_service_mode(mut self, input: std::option::Option<i32>) -> Self {
            self.service_mode = input;
            self
        }
        /// <p>The diagnostic code used to request data from a vehicle for this signal.</p>
        pub fn pid(mut self, input: i32) -> Self {
            self.pid = Some(input);
            self
        }
        /// <p>The diagnostic code used to request data from a vehicle for this signal.</p>
        pub fn set_pid(mut self, input: std::option::Option<i32>) -> Self {
            self.pid = input;
            self
        }
        /// <p>A multiplier used to decode the message.</p>
        pub fn scaling(mut self, input: f64) -> Self {
            self.scaling = Some(input);
            self
        }
        /// <p>A multiplier used to decode the message.</p>
        pub fn set_scaling(mut self, input: std::option::Option<f64>) -> Self {
            self.scaling = input;
            self
        }
        /// <p>Indicates where data appears in the message.</p>
        pub fn offset(mut self, input: f64) -> Self {
            self.offset = Some(input);
            self
        }
        /// <p>Indicates where data appears in the message.</p>
        pub fn set_offset(mut self, input: std::option::Option<f64>) -> Self {
            self.offset = input;
            self
        }
        /// <p>Indicates the beginning of the message.</p>
        pub fn start_byte(mut self, input: i32) -> Self {
            self.start_byte = Some(input);
            self
        }
        /// <p>Indicates the beginning of the message.</p>
        pub fn set_start_byte(mut self, input: std::option::Option<i32>) -> Self {
            self.start_byte = input;
            self
        }
        /// <p>The length of a message.</p>
        pub fn byte_length(mut self, input: i32) -> Self {
            self.byte_length = Some(input);
            self
        }
        /// <p>The length of a message.</p>
        pub fn set_byte_length(mut self, input: std::option::Option<i32>) -> Self {
            self.byte_length = input;
            self
        }
        /// <p>The number of positions to shift bits in the message.</p>
        pub fn bit_right_shift(mut self, input: i32) -> Self {
            self.bit_right_shift = Some(input);
            self
        }
        /// <p>The number of positions to shift bits in the message.</p>
        pub fn set_bit_right_shift(mut self, input: std::option::Option<i32>) -> Self {
            self.bit_right_shift = input;
            self
        }
        /// <p>The number of bits to mask in a message.</p>
        pub fn bit_mask_length(mut self, input: i32) -> Self {
            self.bit_mask_length = Some(input);
            self
        }
        /// <p>The number of bits to mask in a message.</p>
        pub fn set_bit_mask_length(mut self, input: std::option::Option<i32>) -> Self {
            self.bit_mask_length = input;
            self
        }
        /// Consumes the builder and constructs a [`ObdSignal`](crate::model::ObdSignal).
        pub fn build(self) -> crate::model::ObdSignal {
            crate::model::ObdSignal {
                pid_response_length: self.pid_response_length.unwrap_or_default(),
                service_mode: self.service_mode.unwrap_or_default(),
                pid: self.pid.unwrap_or_default(),
                scaling: self.scaling,
                offset: self.offset,
                start_byte: self.start_byte.unwrap_or_default(),
                byte_length: self.byte_length,
                bit_right_shift: self.bit_right_shift.unwrap_or_default(),
                bit_mask_length: self.bit_mask_length,
            }
        }
    }
}
impl ObdSignal {
    /// Creates a new builder-style object to manufacture [`ObdSignal`](crate::model::ObdSignal).
    pub fn builder() -> crate::model::obd_signal::Builder {
        crate::model::obd_signal::Builder::default()
    }
}

/// <p>Information about a single controller area network (CAN) signal and the messages it receives and transmits.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CanSignal {
    /// <p>The ID of the message.</p>
    #[doc(hidden)]
    pub message_id: i32,
    /// <p>Whether the byte ordering of a CAN message is big-endian.</p>
    #[doc(hidden)]
    pub is_big_endian: bool,
    /// <p>Whether the message data is specified as a signed value.</p>
    #[doc(hidden)]
    pub is_signed: bool,
    /// <p>Indicates the beginning of the CAN message.</p>
    #[doc(hidden)]
    pub start_bit: i32,
    /// <p>Indicates where data appears in the CAN message.</p>
    #[doc(hidden)]
    pub offset: std::option::Option<f64>,
    /// <p>A multiplier used to decode the CAN message.</p>
    #[doc(hidden)]
    pub factor: std::option::Option<f64>,
    /// <p>How many bytes of data are in the message.</p>
    #[doc(hidden)]
    pub length: i32,
    /// <p>The name of the signal.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
}
impl CanSignal {
    /// <p>The ID of the message.</p>
    pub fn message_id(&self) -> i32 {
        self.message_id
    }
    /// <p>Whether the byte ordering of a CAN message is big-endian.</p>
    pub fn is_big_endian(&self) -> bool {
        self.is_big_endian
    }
    /// <p>Whether the message data is specified as a signed value.</p>
    pub fn is_signed(&self) -> bool {
        self.is_signed
    }
    /// <p>Indicates the beginning of the CAN message.</p>
    pub fn start_bit(&self) -> i32 {
        self.start_bit
    }
    /// <p>Indicates where data appears in the CAN message.</p>
    pub fn offset(&self) -> std::option::Option<f64> {
        self.offset
    }
    /// <p>A multiplier used to decode the CAN message.</p>
    pub fn factor(&self) -> std::option::Option<f64> {
        self.factor
    }
    /// <p>How many bytes of data are in the message.</p>
    pub fn length(&self) -> i32 {
        self.length
    }
    /// <p>The name of the signal.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
}
/// See [`CanSignal`](crate::model::CanSignal).
pub mod can_signal {

    /// A builder for [`CanSignal`](crate::model::CanSignal).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message_id: std::option::Option<i32>,
        pub(crate) is_big_endian: std::option::Option<bool>,
        pub(crate) is_signed: std::option::Option<bool>,
        pub(crate) start_bit: std::option::Option<i32>,
        pub(crate) offset: std::option::Option<f64>,
        pub(crate) factor: std::option::Option<f64>,
        pub(crate) length: std::option::Option<i32>,
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the message.</p>
        pub fn message_id(mut self, input: i32) -> Self {
            self.message_id = Some(input);
            self
        }
        /// <p>The ID of the message.</p>
        pub fn set_message_id(mut self, input: std::option::Option<i32>) -> Self {
            self.message_id = input;
            self
        }
        /// <p>Whether the byte ordering of a CAN message is big-endian.</p>
        pub fn is_big_endian(mut self, input: bool) -> Self {
            self.is_big_endian = Some(input);
            self
        }
        /// <p>Whether the byte ordering of a CAN message is big-endian.</p>
        pub fn set_is_big_endian(mut self, input: std::option::Option<bool>) -> Self {
            self.is_big_endian = input;
            self
        }
        /// <p>Whether the message data is specified as a signed value.</p>
        pub fn is_signed(mut self, input: bool) -> Self {
            self.is_signed = Some(input);
            self
        }
        /// <p>Whether the message data is specified as a signed value.</p>
        pub fn set_is_signed(mut self, input: std::option::Option<bool>) -> Self {
            self.is_signed = input;
            self
        }
        /// <p>Indicates the beginning of the CAN message.</p>
        pub fn start_bit(mut self, input: i32) -> Self {
            self.start_bit = Some(input);
            self
        }
        /// <p>Indicates the beginning of the CAN message.</p>
        pub fn set_start_bit(mut self, input: std::option::Option<i32>) -> Self {
            self.start_bit = input;
            self
        }
        /// <p>Indicates where data appears in the CAN message.</p>
        pub fn offset(mut self, input: f64) -> Self {
            self.offset = Some(input);
            self
        }
        /// <p>Indicates where data appears in the CAN message.</p>
        pub fn set_offset(mut self, input: std::option::Option<f64>) -> Self {
            self.offset = input;
            self
        }
        /// <p>A multiplier used to decode the CAN message.</p>
        pub fn factor(mut self, input: f64) -> Self {
            self.factor = Some(input);
            self
        }
        /// <p>A multiplier used to decode the CAN message.</p>
        pub fn set_factor(mut self, input: std::option::Option<f64>) -> Self {
            self.factor = input;
            self
        }
        /// <p>How many bytes of data are in the message.</p>
        pub fn length(mut self, input: i32) -> Self {
            self.length = Some(input);
            self
        }
        /// <p>How many bytes of data are in the message.</p>
        pub fn set_length(mut self, input: std::option::Option<i32>) -> Self {
            self.length = input;
            self
        }
        /// <p>The name of the signal.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the signal.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`CanSignal`](crate::model::CanSignal).
        pub fn build(self) -> crate::model::CanSignal {
            crate::model::CanSignal {
                message_id: self.message_id.unwrap_or_default(),
                is_big_endian: self.is_big_endian.unwrap_or_default(),
                is_signed: self.is_signed.unwrap_or_default(),
                start_bit: self.start_bit.unwrap_or_default(),
                offset: self.offset,
                factor: self.factor,
                length: self.length.unwrap_or_default(),
                name: self.name,
            }
        }
    }
}
impl CanSignal {
    /// Creates a new builder-style object to manufacture [`CanSignal`](crate::model::CanSignal).
    pub fn builder() -> crate::model::can_signal::Builder {
        crate::model::can_signal::Builder::default()
    }
}

/// When writing a match expression against `SignalDecoderType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let signaldecodertype = unimplemented!();
/// match signaldecodertype {
///     SignalDecoderType::CanSignal => { /* ... */ },
///     SignalDecoderType::ObdSignal => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `signaldecodertype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SignalDecoderType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SignalDecoderType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SignalDecoderType::NewFeature` is defined.
/// Specifically, when `signaldecodertype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SignalDecoderType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SignalDecoderType {
    #[allow(missing_docs)] // documentation missing in model
    CanSignal,
    #[allow(missing_docs)] // documentation missing in model
    ObdSignal,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for SignalDecoderType {
    fn from(s: &str) -> Self {
        match s {
            "CAN_SIGNAL" => SignalDecoderType::CanSignal,
            "OBD_SIGNAL" => SignalDecoderType::ObdSignal,
            other => {
                SignalDecoderType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for SignalDecoderType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SignalDecoderType::from(s))
    }
}
impl SignalDecoderType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SignalDecoderType::CanSignal => "CAN_SIGNAL",
            SignalDecoderType::ObdSignal => "OBD_SIGNAL",
            SignalDecoderType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CAN_SIGNAL", "OBD_SIGNAL"]
    }
}
impl AsRef<str> for SignalDecoderType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Represents a node and its specifications in an in-vehicle communication network. All signal decoders must be associated with a network node. </p>
/// <p> To return this information about all the network interfaces specified in a decoder manifest, use the API operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NetworkInterface {
    /// <p>The ID of the network interface.</p>
    #[doc(hidden)]
    pub interface_id: std::option::Option<std::string::String>,
    /// <p>The network protocol for the vehicle. For example, <code>CAN_SIGNAL</code> specifies a protocol that defines how data is communicated between electronic control units (ECUs). <code>OBD_SIGNAL</code> specifies a protocol that defines how self-diagnostic data is communicated between ECUs.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::NetworkInterfaceType>,
    /// <p>Information about a network interface specified by the Controller Area Network (CAN) protocol.</p>
    #[doc(hidden)]
    pub can_interface: std::option::Option<crate::model::CanInterface>,
    /// <p>Information about a network interface specified by the On-board diagnostic (OBD) II protocol.</p>
    #[doc(hidden)]
    pub obd_interface: std::option::Option<crate::model::ObdInterface>,
}
impl NetworkInterface {
    /// <p>The ID of the network interface.</p>
    pub fn interface_id(&self) -> std::option::Option<&str> {
        self.interface_id.as_deref()
    }
    /// <p>The network protocol for the vehicle. For example, <code>CAN_SIGNAL</code> specifies a protocol that defines how data is communicated between electronic control units (ECUs). <code>OBD_SIGNAL</code> specifies a protocol that defines how self-diagnostic data is communicated between ECUs.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::NetworkInterfaceType> {
        self.r#type.as_ref()
    }
    /// <p>Information about a network interface specified by the Controller Area Network (CAN) protocol.</p>
    pub fn can_interface(&self) -> std::option::Option<&crate::model::CanInterface> {
        self.can_interface.as_ref()
    }
    /// <p>Information about a network interface specified by the On-board diagnostic (OBD) II protocol.</p>
    pub fn obd_interface(&self) -> std::option::Option<&crate::model::ObdInterface> {
        self.obd_interface.as_ref()
    }
}
/// See [`NetworkInterface`](crate::model::NetworkInterface).
pub mod network_interface {

    /// A builder for [`NetworkInterface`](crate::model::NetworkInterface).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) interface_id: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::NetworkInterfaceType>,
        pub(crate) can_interface: std::option::Option<crate::model::CanInterface>,
        pub(crate) obd_interface: std::option::Option<crate::model::ObdInterface>,
    }
    impl Builder {
        /// <p>The ID of the network interface.</p>
        pub fn interface_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.interface_id = Some(input.into());
            self
        }
        /// <p>The ID of the network interface.</p>
        pub fn set_interface_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.interface_id = input;
            self
        }
        /// <p>The network protocol for the vehicle. For example, <code>CAN_SIGNAL</code> specifies a protocol that defines how data is communicated between electronic control units (ECUs). <code>OBD_SIGNAL</code> specifies a protocol that defines how self-diagnostic data is communicated between ECUs.</p>
        pub fn r#type(mut self, input: crate::model::NetworkInterfaceType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The network protocol for the vehicle. For example, <code>CAN_SIGNAL</code> specifies a protocol that defines how data is communicated between electronic control units (ECUs). <code>OBD_SIGNAL</code> specifies a protocol that defines how self-diagnostic data is communicated between ECUs.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::NetworkInterfaceType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>Information about a network interface specified by the Controller Area Network (CAN) protocol.</p>
        pub fn can_interface(mut self, input: crate::model::CanInterface) -> Self {
            self.can_interface = Some(input);
            self
        }
        /// <p>Information about a network interface specified by the Controller Area Network (CAN) protocol.</p>
        pub fn set_can_interface(
            mut self,
            input: std::option::Option<crate::model::CanInterface>,
        ) -> Self {
            self.can_interface = input;
            self
        }
        /// <p>Information about a network interface specified by the On-board diagnostic (OBD) II protocol.</p>
        pub fn obd_interface(mut self, input: crate::model::ObdInterface) -> Self {
            self.obd_interface = Some(input);
            self
        }
        /// <p>Information about a network interface specified by the On-board diagnostic (OBD) II protocol.</p>
        pub fn set_obd_interface(
            mut self,
            input: std::option::Option<crate::model::ObdInterface>,
        ) -> Self {
            self.obd_interface = input;
            self
        }
        /// Consumes the builder and constructs a [`NetworkInterface`](crate::model::NetworkInterface).
        pub fn build(self) -> crate::model::NetworkInterface {
            crate::model::NetworkInterface {
                interface_id: self.interface_id,
                r#type: self.r#type,
                can_interface: self.can_interface,
                obd_interface: self.obd_interface,
            }
        }
    }
}
impl NetworkInterface {
    /// Creates a new builder-style object to manufacture [`NetworkInterface`](crate::model::NetworkInterface).
    pub fn builder() -> crate::model::network_interface::Builder {
        crate::model::network_interface::Builder::default()
    }
}

/// <p>A network interface that specifies the On-board diagnostic (OBD) II network protocol.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ObdInterface {
    /// <p>The name of the interface.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The ID of the message requesting vehicle data.</p>
    #[doc(hidden)]
    pub request_message_id: i32,
    /// <p>The standard OBD II PID.</p>
    #[doc(hidden)]
    pub obd_standard: std::option::Option<std::string::String>,
    /// <p>The maximum number message requests per second.</p>
    #[doc(hidden)]
    pub pid_request_interval_seconds: i32,
    /// <p>The maximum number message requests per diagnostic trouble code per second.</p>
    #[doc(hidden)]
    pub dtc_request_interval_seconds: i32,
    /// <p>Whether to use extended IDs in the message.</p>
    #[doc(hidden)]
    pub use_extended_ids: bool,
    /// <p>Whether the vehicle has a transmission control module (TCM).</p>
    #[doc(hidden)]
    pub has_transmission_ecu: bool,
}
impl ObdInterface {
    /// <p>The name of the interface.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The ID of the message requesting vehicle data.</p>
    pub fn request_message_id(&self) -> i32 {
        self.request_message_id
    }
    /// <p>The standard OBD II PID.</p>
    pub fn obd_standard(&self) -> std::option::Option<&str> {
        self.obd_standard.as_deref()
    }
    /// <p>The maximum number message requests per second.</p>
    pub fn pid_request_interval_seconds(&self) -> i32 {
        self.pid_request_interval_seconds
    }
    /// <p>The maximum number message requests per diagnostic trouble code per second.</p>
    pub fn dtc_request_interval_seconds(&self) -> i32 {
        self.dtc_request_interval_seconds
    }
    /// <p>Whether to use extended IDs in the message.</p>
    pub fn use_extended_ids(&self) -> bool {
        self.use_extended_ids
    }
    /// <p>Whether the vehicle has a transmission control module (TCM).</p>
    pub fn has_transmission_ecu(&self) -> bool {
        self.has_transmission_ecu
    }
}
/// See [`ObdInterface`](crate::model::ObdInterface).
pub mod obd_interface {

    /// A builder for [`ObdInterface`](crate::model::ObdInterface).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) request_message_id: std::option::Option<i32>,
        pub(crate) obd_standard: std::option::Option<std::string::String>,
        pub(crate) pid_request_interval_seconds: std::option::Option<i32>,
        pub(crate) dtc_request_interval_seconds: std::option::Option<i32>,
        pub(crate) use_extended_ids: std::option::Option<bool>,
        pub(crate) has_transmission_ecu: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The name of the interface.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the interface.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The ID of the message requesting vehicle data.</p>
        pub fn request_message_id(mut self, input: i32) -> Self {
            self.request_message_id = Some(input);
            self
        }
        /// <p>The ID of the message requesting vehicle data.</p>
        pub fn set_request_message_id(mut self, input: std::option::Option<i32>) -> Self {
            self.request_message_id = input;
            self
        }
        /// <p>The standard OBD II PID.</p>
        pub fn obd_standard(mut self, input: impl Into<std::string::String>) -> Self {
            self.obd_standard = Some(input.into());
            self
        }
        /// <p>The standard OBD II PID.</p>
        pub fn set_obd_standard(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.obd_standard = input;
            self
        }
        /// <p>The maximum number message requests per second.</p>
        pub fn pid_request_interval_seconds(mut self, input: i32) -> Self {
            self.pid_request_interval_seconds = Some(input);
            self
        }
        /// <p>The maximum number message requests per second.</p>
        pub fn set_pid_request_interval_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.pid_request_interval_seconds = input;
            self
        }
        /// <p>The maximum number message requests per diagnostic trouble code per second.</p>
        pub fn dtc_request_interval_seconds(mut self, input: i32) -> Self {
            self.dtc_request_interval_seconds = Some(input);
            self
        }
        /// <p>The maximum number message requests per diagnostic trouble code per second.</p>
        pub fn set_dtc_request_interval_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.dtc_request_interval_seconds = input;
            self
        }
        /// <p>Whether to use extended IDs in the message.</p>
        pub fn use_extended_ids(mut self, input: bool) -> Self {
            self.use_extended_ids = Some(input);
            self
        }
        /// <p>Whether to use extended IDs in the message.</p>
        pub fn set_use_extended_ids(mut self, input: std::option::Option<bool>) -> Self {
            self.use_extended_ids = input;
            self
        }
        /// <p>Whether the vehicle has a transmission control module (TCM).</p>
        pub fn has_transmission_ecu(mut self, input: bool) -> Self {
            self.has_transmission_ecu = Some(input);
            self
        }
        /// <p>Whether the vehicle has a transmission control module (TCM).</p>
        pub fn set_has_transmission_ecu(mut self, input: std::option::Option<bool>) -> Self {
            self.has_transmission_ecu = input;
            self
        }
        /// Consumes the builder and constructs a [`ObdInterface`](crate::model::ObdInterface).
        pub fn build(self) -> crate::model::ObdInterface {
            crate::model::ObdInterface {
                name: self.name,
                request_message_id: self.request_message_id.unwrap_or_default(),
                obd_standard: self.obd_standard,
                pid_request_interval_seconds: self.pid_request_interval_seconds.unwrap_or_default(),
                dtc_request_interval_seconds: self.dtc_request_interval_seconds.unwrap_or_default(),
                use_extended_ids: self.use_extended_ids.unwrap_or_default(),
                has_transmission_ecu: self.has_transmission_ecu.unwrap_or_default(),
            }
        }
    }
}
impl ObdInterface {
    /// Creates a new builder-style object to manufacture [`ObdInterface`](crate::model::ObdInterface).
    pub fn builder() -> crate::model::obd_interface::Builder {
        crate::model::obd_interface::Builder::default()
    }
}

/// <p>A single controller area network (CAN) device interface.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CanInterface {
    /// <p>The unique name of the interface.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The name of the communication protocol for the interface.</p>
    #[doc(hidden)]
    pub protocol_name: std::option::Option<std::string::String>,
    /// <p>The version of the communication protocol for the interface.</p>
    #[doc(hidden)]
    pub protocol_version: std::option::Option<std::string::String>,
}
impl CanInterface {
    /// <p>The unique name of the interface.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The name of the communication protocol for the interface.</p>
    pub fn protocol_name(&self) -> std::option::Option<&str> {
        self.protocol_name.as_deref()
    }
    /// <p>The version of the communication protocol for the interface.</p>
    pub fn protocol_version(&self) -> std::option::Option<&str> {
        self.protocol_version.as_deref()
    }
}
/// See [`CanInterface`](crate::model::CanInterface).
pub mod can_interface {

    /// A builder for [`CanInterface`](crate::model::CanInterface).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) protocol_name: std::option::Option<std::string::String>,
        pub(crate) protocol_version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique name of the interface.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The unique name of the interface.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The name of the communication protocol for the interface.</p>
        pub fn protocol_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.protocol_name = Some(input.into());
            self
        }
        /// <p>The name of the communication protocol for the interface.</p>
        pub fn set_protocol_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.protocol_name = input;
            self
        }
        /// <p>The version of the communication protocol for the interface.</p>
        pub fn protocol_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.protocol_version = Some(input.into());
            self
        }
        /// <p>The version of the communication protocol for the interface.</p>
        pub fn set_protocol_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.protocol_version = input;
            self
        }
        /// Consumes the builder and constructs a [`CanInterface`](crate::model::CanInterface).
        pub fn build(self) -> crate::model::CanInterface {
            crate::model::CanInterface {
                name: self.name,
                protocol_name: self.protocol_name,
                protocol_version: self.protocol_version,
            }
        }
    }
}
impl CanInterface {
    /// Creates a new builder-style object to manufacture [`CanInterface`](crate::model::CanInterface).
    pub fn builder() -> crate::model::can_interface::Builder {
        crate::model::can_interface::Builder::default()
    }
}

/// When writing a match expression against `NetworkInterfaceType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let networkinterfacetype = unimplemented!();
/// match networkinterfacetype {
///     NetworkInterfaceType::CanInterface => { /* ... */ },
///     NetworkInterfaceType::ObdInterface => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `networkinterfacetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `NetworkInterfaceType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `NetworkInterfaceType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `NetworkInterfaceType::NewFeature` is defined.
/// Specifically, when `networkinterfacetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `NetworkInterfaceType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum NetworkInterfaceType {
    #[allow(missing_docs)] // documentation missing in model
    CanInterface,
    #[allow(missing_docs)] // documentation missing in model
    ObdInterface,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for NetworkInterfaceType {
    fn from(s: &str) -> Self {
        match s {
            "CAN_INTERFACE" => NetworkInterfaceType::CanInterface,
            "OBD_INTERFACE" => NetworkInterfaceType::ObdInterface,
            other => {
                NetworkInterfaceType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for NetworkInterfaceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(NetworkInterfaceType::from(s))
    }
}
impl NetworkInterfaceType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            NetworkInterfaceType::CanInterface => "CAN_INTERFACE",
            NetworkInterfaceType::ObdInterface => "OBD_INTERFACE",
            NetworkInterfaceType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CAN_INTERFACE", "OBD_INTERFACE"]
    }
}
impl AsRef<str> for NetworkInterfaceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A reason a vehicle network interface isn't valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidNetworkInterface {
    /// <p>The ID of the interface that isn't valid.</p>
    #[doc(hidden)]
    pub interface_id: std::option::Option<std::string::String>,
    /// <p>A message about why the interface isn't valid. </p>
    #[doc(hidden)]
    pub reason: std::option::Option<crate::model::NetworkInterfaceFailureReason>,
}
impl InvalidNetworkInterface {
    /// <p>The ID of the interface that isn't valid.</p>
    pub fn interface_id(&self) -> std::option::Option<&str> {
        self.interface_id.as_deref()
    }
    /// <p>A message about why the interface isn't valid. </p>
    pub fn reason(&self) -> std::option::Option<&crate::model::NetworkInterfaceFailureReason> {
        self.reason.as_ref()
    }
}
/// See [`InvalidNetworkInterface`](crate::model::InvalidNetworkInterface).
pub mod invalid_network_interface {

    /// A builder for [`InvalidNetworkInterface`](crate::model::InvalidNetworkInterface).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) interface_id: std::option::Option<std::string::String>,
        pub(crate) reason: std::option::Option<crate::model::NetworkInterfaceFailureReason>,
    }
    impl Builder {
        /// <p>The ID of the interface that isn't valid.</p>
        pub fn interface_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.interface_id = Some(input.into());
            self
        }
        /// <p>The ID of the interface that isn't valid.</p>
        pub fn set_interface_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.interface_id = input;
            self
        }
        /// <p>A message about why the interface isn't valid. </p>
        pub fn reason(mut self, input: crate::model::NetworkInterfaceFailureReason) -> Self {
            self.reason = Some(input);
            self
        }
        /// <p>A message about why the interface isn't valid. </p>
        pub fn set_reason(
            mut self,
            input: std::option::Option<crate::model::NetworkInterfaceFailureReason>,
        ) -> Self {
            self.reason = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidNetworkInterface`](crate::model::InvalidNetworkInterface).
        pub fn build(self) -> crate::model::InvalidNetworkInterface {
            crate::model::InvalidNetworkInterface {
                interface_id: self.interface_id,
                reason: self.reason,
            }
        }
    }
}
impl InvalidNetworkInterface {
    /// Creates a new builder-style object to manufacture [`InvalidNetworkInterface`](crate::model::InvalidNetworkInterface).
    pub fn builder() -> crate::model::invalid_network_interface::Builder {
        crate::model::invalid_network_interface::Builder::default()
    }
}

/// When writing a match expression against `NetworkInterfaceFailureReason`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let networkinterfacefailurereason = unimplemented!();
/// match networkinterfacefailurereason {
///     NetworkInterfaceFailureReason::CanNetworkInterfaceInfoIsNull => { /* ... */ },
///     NetworkInterfaceFailureReason::ConflictingNetworkInterface => { /* ... */ },
///     NetworkInterfaceFailureReason::DuplicateInterface => { /* ... */ },
///     NetworkInterfaceFailureReason::NetworkInterfaceToAddAlreadyExists => { /* ... */ },
///     NetworkInterfaceFailureReason::NetworkInterfaceToRemoveAssociatedWithSignals => { /* ... */ },
///     NetworkInterfaceFailureReason::ObdNetworkInterfaceInfoIsNull => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `networkinterfacefailurereason` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `NetworkInterfaceFailureReason::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `NetworkInterfaceFailureReason::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `NetworkInterfaceFailureReason::NewFeature` is defined.
/// Specifically, when `networkinterfacefailurereason` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `NetworkInterfaceFailureReason::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum NetworkInterfaceFailureReason {
    #[allow(missing_docs)] // documentation missing in model
    CanNetworkInterfaceInfoIsNull,
    #[allow(missing_docs)] // documentation missing in model
    ConflictingNetworkInterface,
    #[allow(missing_docs)] // documentation missing in model
    DuplicateInterface,
    #[allow(missing_docs)] // documentation missing in model
    NetworkInterfaceToAddAlreadyExists,
    #[allow(missing_docs)] // documentation missing in model
    NetworkInterfaceToRemoveAssociatedWithSignals,
    #[allow(missing_docs)] // documentation missing in model
    ObdNetworkInterfaceInfoIsNull,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for NetworkInterfaceFailureReason {
    fn from(s: &str) -> Self {
        match s {
            "CAN_NETWORK_INTERFACE_INFO_IS_NULL" => {
                NetworkInterfaceFailureReason::CanNetworkInterfaceInfoIsNull
            }
            "CONFLICTING_NETWORK_INTERFACE" => {
                NetworkInterfaceFailureReason::ConflictingNetworkInterface
            }
            "DUPLICATE_NETWORK_INTERFACE" => NetworkInterfaceFailureReason::DuplicateInterface,
            "NETWORK_INTERFACE_TO_ADD_ALREADY_EXISTS" => {
                NetworkInterfaceFailureReason::NetworkInterfaceToAddAlreadyExists
            }
            "NETWORK_INTERFACE_TO_REMOVE_ASSOCIATED_WITH_SIGNALS" => {
                NetworkInterfaceFailureReason::NetworkInterfaceToRemoveAssociatedWithSignals
            }
            "OBD_NETWORK_INTERFACE_INFO_IS_NULL" => {
                NetworkInterfaceFailureReason::ObdNetworkInterfaceInfoIsNull
            }
            other => NetworkInterfaceFailureReason::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for NetworkInterfaceFailureReason {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(NetworkInterfaceFailureReason::from(s))
    }
}
impl NetworkInterfaceFailureReason {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            NetworkInterfaceFailureReason::CanNetworkInterfaceInfoIsNull => {
                "CAN_NETWORK_INTERFACE_INFO_IS_NULL"
            }
            NetworkInterfaceFailureReason::ConflictingNetworkInterface => {
                "CONFLICTING_NETWORK_INTERFACE"
            }
            NetworkInterfaceFailureReason::DuplicateInterface => "DUPLICATE_NETWORK_INTERFACE",
            NetworkInterfaceFailureReason::NetworkInterfaceToAddAlreadyExists => {
                "NETWORK_INTERFACE_TO_ADD_ALREADY_EXISTS"
            }
            NetworkInterfaceFailureReason::NetworkInterfaceToRemoveAssociatedWithSignals => {
                "NETWORK_INTERFACE_TO_REMOVE_ASSOCIATED_WITH_SIGNALS"
            }
            NetworkInterfaceFailureReason::ObdNetworkInterfaceInfoIsNull => {
                "OBD_NETWORK_INTERFACE_INFO_IS_NULL"
            }
            NetworkInterfaceFailureReason::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CAN_NETWORK_INTERFACE_INFO_IS_NULL",
            "CONFLICTING_NETWORK_INTERFACE",
            "DUPLICATE_NETWORK_INTERFACE",
            "NETWORK_INTERFACE_TO_ADD_ALREADY_EXISTS",
            "NETWORK_INTERFACE_TO_REMOVE_ASSOCIATED_WITH_SIGNALS",
            "OBD_NETWORK_INTERFACE_INFO_IS_NULL",
        ]
    }
}
impl AsRef<str> for NetworkInterfaceFailureReason {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A reason that a signal decoder isn't valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidSignalDecoder {
    /// <p>The name of a signal decoder that isn't valid.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>A message about why the signal decoder isn't valid.</p>
    #[doc(hidden)]
    pub reason: std::option::Option<crate::model::SignalDecoderFailureReason>,
}
impl InvalidSignalDecoder {
    /// <p>The name of a signal decoder that isn't valid.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A message about why the signal decoder isn't valid.</p>
    pub fn reason(&self) -> std::option::Option<&crate::model::SignalDecoderFailureReason> {
        self.reason.as_ref()
    }
}
/// See [`InvalidSignalDecoder`](crate::model::InvalidSignalDecoder).
pub mod invalid_signal_decoder {

    /// A builder for [`InvalidSignalDecoder`](crate::model::InvalidSignalDecoder).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) reason: std::option::Option<crate::model::SignalDecoderFailureReason>,
    }
    impl Builder {
        /// <p>The name of a signal decoder that isn't valid.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of a signal decoder that isn't valid.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A message about why the signal decoder isn't valid.</p>
        pub fn reason(mut self, input: crate::model::SignalDecoderFailureReason) -> Self {
            self.reason = Some(input);
            self
        }
        /// <p>A message about why the signal decoder isn't valid.</p>
        pub fn set_reason(
            mut self,
            input: std::option::Option<crate::model::SignalDecoderFailureReason>,
        ) -> Self {
            self.reason = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidSignalDecoder`](crate::model::InvalidSignalDecoder).
        pub fn build(self) -> crate::model::InvalidSignalDecoder {
            crate::model::InvalidSignalDecoder {
                name: self.name,
                reason: self.reason,
            }
        }
    }
}
impl InvalidSignalDecoder {
    /// Creates a new builder-style object to manufacture [`InvalidSignalDecoder`](crate::model::InvalidSignalDecoder).
    pub fn builder() -> crate::model::invalid_signal_decoder::Builder {
        crate::model::invalid_signal_decoder::Builder::default()
    }
}

/// When writing a match expression against `SignalDecoderFailureReason`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let signaldecoderfailurereason = unimplemented!();
/// match signaldecoderfailurereason {
///     SignalDecoderFailureReason::CanSignalInfoIsNull => { /* ... */ },
///     SignalDecoderFailureReason::ConflictingSignal => { /* ... */ },
///     SignalDecoderFailureReason::DuplicateSignal => { /* ... */ },
///     SignalDecoderFailureReason::NetworkInterfaceTypeIncompatibleWithSignalDecoderType => { /* ... */ },
///     SignalDecoderFailureReason::NoDecoderInfoForSignalInModel => { /* ... */ },
///     SignalDecoderFailureReason::ObdSignalInfoIsNull => { /* ... */ },
///     SignalDecoderFailureReason::SignalNotAssociatedWithNetworkInterface => { /* ... */ },
///     SignalDecoderFailureReason::SignalNotInModel => { /* ... */ },
///     SignalDecoderFailureReason::SignalToAddAlreadyExists => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `signaldecoderfailurereason` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SignalDecoderFailureReason::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SignalDecoderFailureReason::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SignalDecoderFailureReason::NewFeature` is defined.
/// Specifically, when `signaldecoderfailurereason` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SignalDecoderFailureReason::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SignalDecoderFailureReason {
    #[allow(missing_docs)] // documentation missing in model
    CanSignalInfoIsNull,
    #[allow(missing_docs)] // documentation missing in model
    ConflictingSignal,
    #[allow(missing_docs)] // documentation missing in model
    DuplicateSignal,
    #[allow(missing_docs)] // documentation missing in model
    NetworkInterfaceTypeIncompatibleWithSignalDecoderType,
    #[allow(missing_docs)] // documentation missing in model
    NoDecoderInfoForSignalInModel,
    #[allow(missing_docs)] // documentation missing in model
    ObdSignalInfoIsNull,
    #[allow(missing_docs)] // documentation missing in model
    SignalNotAssociatedWithNetworkInterface,
    #[allow(missing_docs)] // documentation missing in model
    SignalNotInModel,
    #[allow(missing_docs)] // documentation missing in model
    SignalToAddAlreadyExists,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for SignalDecoderFailureReason {
    fn from(s: &str) -> Self {
        match s {
            "CAN_SIGNAL_INFO_IS_NULL" => SignalDecoderFailureReason::CanSignalInfoIsNull,
            "CONFLICTING_SIGNAL" => SignalDecoderFailureReason::ConflictingSignal,
            "DUPLICATE_SIGNAL" => SignalDecoderFailureReason::DuplicateSignal,
            "NETWORK_INTERFACE_TYPE_INCOMPATIBLE_WITH_SIGNAL_DECODER_TYPE" => {
                SignalDecoderFailureReason::NetworkInterfaceTypeIncompatibleWithSignalDecoderType
            }
            "NO_DECODER_INFO_FOR_SIGNAL_IN_MODEL" => {
                SignalDecoderFailureReason::NoDecoderInfoForSignalInModel
            }
            "OBD_SIGNAL_INFO_IS_NULL" => SignalDecoderFailureReason::ObdSignalInfoIsNull,
            "SIGNAL_NOT_ASSOCIATED_WITH_NETWORK_INTERFACE" => {
                SignalDecoderFailureReason::SignalNotAssociatedWithNetworkInterface
            }
            "SIGNAL_NOT_IN_MODEL" => SignalDecoderFailureReason::SignalNotInModel,
            "SIGNAL_TO_ADD_ALREADY_EXISTS" => SignalDecoderFailureReason::SignalToAddAlreadyExists,
            other => SignalDecoderFailureReason::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for SignalDecoderFailureReason {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SignalDecoderFailureReason::from(s))
    }
}
impl SignalDecoderFailureReason {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SignalDecoderFailureReason::CanSignalInfoIsNull => "CAN_SIGNAL_INFO_IS_NULL",
            SignalDecoderFailureReason::ConflictingSignal => "CONFLICTING_SIGNAL",
            SignalDecoderFailureReason::DuplicateSignal => "DUPLICATE_SIGNAL",
            SignalDecoderFailureReason::NetworkInterfaceTypeIncompatibleWithSignalDecoderType => {
                "NETWORK_INTERFACE_TYPE_INCOMPATIBLE_WITH_SIGNAL_DECODER_TYPE"
            }
            SignalDecoderFailureReason::NoDecoderInfoForSignalInModel => {
                "NO_DECODER_INFO_FOR_SIGNAL_IN_MODEL"
            }
            SignalDecoderFailureReason::ObdSignalInfoIsNull => "OBD_SIGNAL_INFO_IS_NULL",
            SignalDecoderFailureReason::SignalNotAssociatedWithNetworkInterface => {
                "SIGNAL_NOT_ASSOCIATED_WITH_NETWORK_INTERFACE"
            }
            SignalDecoderFailureReason::SignalNotInModel => "SIGNAL_NOT_IN_MODEL",
            SignalDecoderFailureReason::SignalToAddAlreadyExists => "SIGNAL_TO_ADD_ALREADY_EXISTS",
            SignalDecoderFailureReason::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CAN_SIGNAL_INFO_IS_NULL",
            "CONFLICTING_SIGNAL",
            "DUPLICATE_SIGNAL",
            "NETWORK_INTERFACE_TYPE_INCOMPATIBLE_WITH_SIGNAL_DECODER_TYPE",
            "NO_DECODER_INFO_FOR_SIGNAL_IN_MODEL",
            "OBD_SIGNAL_INFO_IS_NULL",
            "SIGNAL_NOT_ASSOCIATED_WITH_NETWORK_INTERFACE",
            "SIGNAL_NOT_IN_MODEL",
            "SIGNAL_TO_ADD_ALREADY_EXISTS",
        ]
    }
}
impl AsRef<str> for SignalDecoderFailureReason {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifications for defining a vehicle network.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum NetworkFileDefinition {
    /// <p>Information, including CAN DBC files, about the configurations used to create a decoder manifest.</p>
    CanDbc(crate::model::CanDbcDefinition),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl NetworkFileDefinition {
    #[allow(irrefutable_let_patterns)]
    /// Tries to convert the enum instance into [`CanDbc`](crate::model::NetworkFileDefinition::CanDbc), extracting the inner [`CanDbcDefinition`](crate::model::CanDbcDefinition).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_can_dbc(&self) -> std::result::Result<&crate::model::CanDbcDefinition, &Self> {
        if let NetworkFileDefinition::CanDbc(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`CanDbc`](crate::model::NetworkFileDefinition::CanDbc).
    pub fn is_can_dbc(&self) -> bool {
        self.as_can_dbc().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p>Configurations used to create a decoder manifest.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CanDbcDefinition {
    /// <p>Contains information about a network interface.</p>
    #[doc(hidden)]
    pub network_interface: std::option::Option<std::string::String>,
    /// <p>A list of DBC files. You can upload only one DBC file for each network interface and specify up to five (inclusive) files in the list.</p>
    #[doc(hidden)]
    pub can_dbc_files: std::option::Option<std::vec::Vec<aws_smithy_types::Blob>>,
    /// <p>Pairs every signal specified in your vehicle model with a signal decoder.</p>
    #[doc(hidden)]
    pub signals_map:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl CanDbcDefinition {
    /// <p>Contains information about a network interface.</p>
    pub fn network_interface(&self) -> std::option::Option<&str> {
        self.network_interface.as_deref()
    }
    /// <p>A list of DBC files. You can upload only one DBC file for each network interface and specify up to five (inclusive) files in the list.</p>
    pub fn can_dbc_files(&self) -> std::option::Option<&[aws_smithy_types::Blob]> {
        self.can_dbc_files.as_deref()
    }
    /// <p>Pairs every signal specified in your vehicle model with a signal decoder.</p>
    pub fn signals_map(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.signals_map.as_ref()
    }
}
/// See [`CanDbcDefinition`](crate::model::CanDbcDefinition).
pub mod can_dbc_definition {

    /// A builder for [`CanDbcDefinition`](crate::model::CanDbcDefinition).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) network_interface: std::option::Option<std::string::String>,
        pub(crate) can_dbc_files: std::option::Option<std::vec::Vec<aws_smithy_types::Blob>>,
        pub(crate) signals_map: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>Contains information about a network interface.</p>
        pub fn network_interface(mut self, input: impl Into<std::string::String>) -> Self {
            self.network_interface = Some(input.into());
            self
        }
        /// <p>Contains information about a network interface.</p>
        pub fn set_network_interface(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.network_interface = input;
            self
        }
        /// Appends an item to `can_dbc_files`.
        ///
        /// To override the contents of this collection use [`set_can_dbc_files`](Self::set_can_dbc_files).
        ///
        /// <p>A list of DBC files. You can upload only one DBC file for each network interface and specify up to five (inclusive) files in the list.</p>
        pub fn can_dbc_files(mut self, input: aws_smithy_types::Blob) -> Self {
            let mut v = self.can_dbc_files.unwrap_or_default();
            v.push(input);
            self.can_dbc_files = Some(v);
            self
        }
        /// <p>A list of DBC files. You can upload only one DBC file for each network interface and specify up to five (inclusive) files in the list.</p>
        pub fn set_can_dbc_files(
            mut self,
            input: std::option::Option<std::vec::Vec<aws_smithy_types::Blob>>,
        ) -> Self {
            self.can_dbc_files = input;
            self
        }
        /// Adds a key-value pair to `signals_map`.
        ///
        /// To override the contents of this collection use [`set_signals_map`](Self::set_signals_map).
        ///
        /// <p>Pairs every signal specified in your vehicle model with a signal decoder.</p>
        pub fn signals_map(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.signals_map.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.signals_map = Some(hash_map);
            self
        }
        /// <p>Pairs every signal specified in your vehicle model with a signal decoder.</p>
        pub fn set_signals_map(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.signals_map = input;
            self
        }
        /// Consumes the builder and constructs a [`CanDbcDefinition`](crate::model::CanDbcDefinition).
        pub fn build(self) -> crate::model::CanDbcDefinition {
            crate::model::CanDbcDefinition {
                network_interface: self.network_interface,
                can_dbc_files: self.can_dbc_files,
                signals_map: self.signals_map,
            }
        }
    }
}
impl CanDbcDefinition {
    /// Creates a new builder-style object to manufacture [`CanDbcDefinition`](crate::model::CanDbcDefinition).
    pub fn builder() -> crate::model::can_dbc_definition::Builder {
        crate::model::can_dbc_definition::Builder::default()
    }
}

/// <p>Information about a created decoder manifest. You can use the API operation to return this information about multiple decoder manifests.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DecoderManifestSummary {
    /// <p>The name of the decoder manifest.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The ARN of a vehicle model (model manifest) associated with the decoder manifest. </p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The ARN of a vehicle model (model manifest) associated with the decoder manifest.</p>
    #[doc(hidden)]
    pub model_manifest_arn: std::option::Option<std::string::String>,
    /// <p>A brief description of the decoder manifest.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The state of the decoder manifest. If the status is <code>ACTIVE</code>, the decoder manifest can't be edited. If the status is marked <code>DRAFT</code>, you can edit the decoder manifest.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::ManifestStatus>,
    /// <p>The time the decoder manifest was created in seconds since epoch (January 1, 1970 at midnight UTC time).</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time the decoder manifest was last updated in seconds since epoch (January 1, 1970 at midnight UTC time).</p>
    #[doc(hidden)]
    pub last_modification_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl DecoderManifestSummary {
    /// <p>The name of the decoder manifest.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The ARN of a vehicle model (model manifest) associated with the decoder manifest. </p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The ARN of a vehicle model (model manifest) associated with the decoder manifest.</p>
    pub fn model_manifest_arn(&self) -> std::option::Option<&str> {
        self.model_manifest_arn.as_deref()
    }
    /// <p>A brief description of the decoder manifest.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The state of the decoder manifest. If the status is <code>ACTIVE</code>, the decoder manifest can't be edited. If the status is marked <code>DRAFT</code>, you can edit the decoder manifest.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::ManifestStatus> {
        self.status.as_ref()
    }
    /// <p>The time the decoder manifest was created in seconds since epoch (January 1, 1970 at midnight UTC time).</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The time the decoder manifest was last updated in seconds since epoch (January 1, 1970 at midnight UTC time).</p>
    pub fn last_modification_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modification_time.as_ref()
    }
}
/// See [`DecoderManifestSummary`](crate::model::DecoderManifestSummary).
pub mod decoder_manifest_summary {

    /// A builder for [`DecoderManifestSummary`](crate::model::DecoderManifestSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) model_manifest_arn: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::ManifestStatus>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modification_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The name of the decoder manifest.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the decoder manifest.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The ARN of a vehicle model (model manifest) associated with the decoder manifest. </p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The ARN of a vehicle model (model manifest) associated with the decoder manifest. </p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The ARN of a vehicle model (model manifest) associated with the decoder manifest.</p>
        pub fn model_manifest_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_manifest_arn = Some(input.into());
            self
        }
        /// <p>The ARN of a vehicle model (model manifest) associated with the decoder manifest.</p>
        pub fn set_model_manifest_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_manifest_arn = input;
            self
        }
        /// <p>A brief description of the decoder manifest.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A brief description of the decoder manifest.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The state of the decoder manifest. If the status is <code>ACTIVE</code>, the decoder manifest can't be edited. If the status is marked <code>DRAFT</code>, you can edit the decoder manifest.</p>
        pub fn status(mut self, input: crate::model::ManifestStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The state of the decoder manifest. If the status is <code>ACTIVE</code>, the decoder manifest can't be edited. If the status is marked <code>DRAFT</code>, you can edit the decoder manifest.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ManifestStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The time the decoder manifest was created in seconds since epoch (January 1, 1970 at midnight UTC time).</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The time the decoder manifest was created in seconds since epoch (January 1, 1970 at midnight UTC time).</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The time the decoder manifest was last updated in seconds since epoch (January 1, 1970 at midnight UTC time).</p>
        pub fn last_modification_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modification_time = Some(input);
            self
        }
        /// <p>The time the decoder manifest was last updated in seconds since epoch (January 1, 1970 at midnight UTC time).</p>
        pub fn set_last_modification_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modification_time = input;
            self
        }
        /// Consumes the builder and constructs a [`DecoderManifestSummary`](crate::model::DecoderManifestSummary).
        pub fn build(self) -> crate::model::DecoderManifestSummary {
            crate::model::DecoderManifestSummary {
                name: self.name,
                arn: self.arn,
                model_manifest_arn: self.model_manifest_arn,
                description: self.description,
                status: self.status,
                creation_time: self.creation_time,
                last_modification_time: self.last_modification_time,
            }
        }
    }
}
impl DecoderManifestSummary {
    /// Creates a new builder-style object to manufacture [`DecoderManifestSummary`](crate::model::DecoderManifestSummary).
    pub fn builder() -> crate::model::decoder_manifest_summary::Builder {
        crate::model::decoder_manifest_summary::Builder::default()
    }
}

/// <p>Information about a campaign. </p>
/// <p>You can use the API operation to return this information about multiple created campaigns.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CampaignSummary {
    /// <p>The Amazon Resource Name (ARN) of a campaign.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The name of a campaign.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The description of the campaign.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The ARN of the signal catalog associated with the campaign.</p>
    #[doc(hidden)]
    pub signal_catalog_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of a vehicle or fleet to which the campaign is deployed.</p>
    #[doc(hidden)]
    pub target_arn: std::option::Option<std::string::String>,
    /// <p>The state of a campaign. The status can be one of the following:</p>
    /// <ul>
    /// <li> <p> <code>CREATING</code> - Amazon Web Services IoT FleetWise is processing your request to create the campaign.</p> </li>
    /// <li> <p> <code>WAITING_FOR_APPROVAL</code> - After a campaign is created, it enters the <code>WAITING_FOR_APPROVAL</code> state. To allow Amazon Web Services IoT FleetWise to deploy the campaign to the target vehicle or fleet, use the API operation to approve the campaign. </p> </li>
    /// <li> <p> <code>RUNNING</code> - The campaign is active. </p> </li>
    /// <li> <p> <code>SUSPENDED</code> - The campaign is suspended. To resume the campaign, use the API operation. </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::CampaignStatus>,
    /// <p>The time the campaign was created.</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The last time the campaign was modified.</p>
    #[doc(hidden)]
    pub last_modification_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl CampaignSummary {
    /// <p>The Amazon Resource Name (ARN) of a campaign.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The name of a campaign.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The description of the campaign.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The ARN of the signal catalog associated with the campaign.</p>
    pub fn signal_catalog_arn(&self) -> std::option::Option<&str> {
        self.signal_catalog_arn.as_deref()
    }
    /// <p>The ARN of a vehicle or fleet to which the campaign is deployed.</p>
    pub fn target_arn(&self) -> std::option::Option<&str> {
        self.target_arn.as_deref()
    }
    /// <p>The state of a campaign. The status can be one of the following:</p>
    /// <ul>
    /// <li> <p> <code>CREATING</code> - Amazon Web Services IoT FleetWise is processing your request to create the campaign.</p> </li>
    /// <li> <p> <code>WAITING_FOR_APPROVAL</code> - After a campaign is created, it enters the <code>WAITING_FOR_APPROVAL</code> state. To allow Amazon Web Services IoT FleetWise to deploy the campaign to the target vehicle or fleet, use the API operation to approve the campaign. </p> </li>
    /// <li> <p> <code>RUNNING</code> - The campaign is active. </p> </li>
    /// <li> <p> <code>SUSPENDED</code> - The campaign is suspended. To resume the campaign, use the API operation. </p> </li>
    /// </ul>
    pub fn status(&self) -> std::option::Option<&crate::model::CampaignStatus> {
        self.status.as_ref()
    }
    /// <p>The time the campaign was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The last time the campaign was modified.</p>
    pub fn last_modification_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modification_time.as_ref()
    }
}
/// See [`CampaignSummary`](crate::model::CampaignSummary).
pub mod campaign_summary {

    /// A builder for [`CampaignSummary`](crate::model::CampaignSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) signal_catalog_arn: std::option::Option<std::string::String>,
        pub(crate) target_arn: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::CampaignStatus>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modification_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of a campaign.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of a campaign.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The name of a campaign.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of a campaign.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The description of the campaign.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the campaign.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The ARN of the signal catalog associated with the campaign.</p>
        pub fn signal_catalog_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.signal_catalog_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the signal catalog associated with the campaign.</p>
        pub fn set_signal_catalog_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.signal_catalog_arn = input;
            self
        }
        /// <p>The ARN of a vehicle or fleet to which the campaign is deployed.</p>
        pub fn target_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.target_arn = Some(input.into());
            self
        }
        /// <p>The ARN of a vehicle or fleet to which the campaign is deployed.</p>
        pub fn set_target_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.target_arn = input;
            self
        }
        /// <p>The state of a campaign. The status can be one of the following:</p>
        /// <ul>
        /// <li> <p> <code>CREATING</code> - Amazon Web Services IoT FleetWise is processing your request to create the campaign.</p> </li>
        /// <li> <p> <code>WAITING_FOR_APPROVAL</code> - After a campaign is created, it enters the <code>WAITING_FOR_APPROVAL</code> state. To allow Amazon Web Services IoT FleetWise to deploy the campaign to the target vehicle or fleet, use the API operation to approve the campaign. </p> </li>
        /// <li> <p> <code>RUNNING</code> - The campaign is active. </p> </li>
        /// <li> <p> <code>SUSPENDED</code> - The campaign is suspended. To resume the campaign, use the API operation. </p> </li>
        /// </ul>
        pub fn status(mut self, input: crate::model::CampaignStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The state of a campaign. The status can be one of the following:</p>
        /// <ul>
        /// <li> <p> <code>CREATING</code> - Amazon Web Services IoT FleetWise is processing your request to create the campaign.</p> </li>
        /// <li> <p> <code>WAITING_FOR_APPROVAL</code> - After a campaign is created, it enters the <code>WAITING_FOR_APPROVAL</code> state. To allow Amazon Web Services IoT FleetWise to deploy the campaign to the target vehicle or fleet, use the API operation to approve the campaign. </p> </li>
        /// <li> <p> <code>RUNNING</code> - The campaign is active. </p> </li>
        /// <li> <p> <code>SUSPENDED</code> - The campaign is suspended. To resume the campaign, use the API operation. </p> </li>
        /// </ul>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::CampaignStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The time the campaign was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The time the campaign was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The last time the campaign was modified.</p>
        pub fn last_modification_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modification_time = Some(input);
            self
        }
        /// <p>The last time the campaign was modified.</p>
        pub fn set_last_modification_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modification_time = input;
            self
        }
        /// Consumes the builder and constructs a [`CampaignSummary`](crate::model::CampaignSummary).
        pub fn build(self) -> crate::model::CampaignSummary {
            crate::model::CampaignSummary {
                arn: self.arn,
                name: self.name,
                description: self.description,
                signal_catalog_arn: self.signal_catalog_arn,
                target_arn: self.target_arn,
                status: self.status,
                creation_time: self.creation_time,
                last_modification_time: self.last_modification_time,
            }
        }
    }
}
impl CampaignSummary {
    /// Creates a new builder-style object to manufacture [`CampaignSummary`](crate::model::CampaignSummary).
    pub fn builder() -> crate::model::campaign_summary::Builder {
        crate::model::campaign_summary::Builder::default()
    }
}

/// When writing a match expression against `CampaignStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let campaignstatus = unimplemented!();
/// match campaignstatus {
///     CampaignStatus::Creating => { /* ... */ },
///     CampaignStatus::Running => { /* ... */ },
///     CampaignStatus::Suspended => { /* ... */ },
///     CampaignStatus::WaitingForApproval => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `campaignstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `CampaignStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `CampaignStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `CampaignStatus::NewFeature` is defined.
/// Specifically, when `campaignstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `CampaignStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CampaignStatus {
    #[allow(missing_docs)] // documentation missing in model
    Creating,
    #[allow(missing_docs)] // documentation missing in model
    Running,
    #[allow(missing_docs)] // documentation missing in model
    Suspended,
    #[allow(missing_docs)] // documentation missing in model
    WaitingForApproval,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for CampaignStatus {
    fn from(s: &str) -> Self {
        match s {
            "CREATING" => CampaignStatus::Creating,
            "RUNNING" => CampaignStatus::Running,
            "SUSPENDED" => CampaignStatus::Suspended,
            "WAITING_FOR_APPROVAL" => CampaignStatus::WaitingForApproval,
            other => CampaignStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for CampaignStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CampaignStatus::from(s))
    }
}
impl CampaignStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            CampaignStatus::Creating => "CREATING",
            CampaignStatus::Running => "RUNNING",
            CampaignStatus::Suspended => "SUSPENDED",
            CampaignStatus::WaitingForApproval => "WAITING_FOR_APPROVAL",
            CampaignStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CREATING", "RUNNING", "SUSPENDED", "WAITING_FOR_APPROVAL"]
    }
}
impl AsRef<str> for CampaignStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies what data to collect and how often or when to collect it.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum CollectionScheme {
    /// <p>Information about a collection scheme that uses a simple logical expression to recognize what data to collect.</p>
    ConditionBasedCollectionScheme(crate::model::ConditionBasedCollectionScheme),
    /// <p>Information about a collection scheme that uses a time period to decide how often to collect data.</p>
    TimeBasedCollectionScheme(crate::model::TimeBasedCollectionScheme),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl CollectionScheme {
    /// Tries to convert the enum instance into [`ConditionBasedCollectionScheme`](crate::model::CollectionScheme::ConditionBasedCollectionScheme), extracting the inner [`ConditionBasedCollectionScheme`](crate::model::ConditionBasedCollectionScheme).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_condition_based_collection_scheme(
        &self,
    ) -> std::result::Result<&crate::model::ConditionBasedCollectionScheme, &Self> {
        if let CollectionScheme::ConditionBasedCollectionScheme(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`ConditionBasedCollectionScheme`](crate::model::CollectionScheme::ConditionBasedCollectionScheme).
    pub fn is_condition_based_collection_scheme(&self) -> bool {
        self.as_condition_based_collection_scheme().is_ok()
    }
    /// Tries to convert the enum instance into [`TimeBasedCollectionScheme`](crate::model::CollectionScheme::TimeBasedCollectionScheme), extracting the inner [`TimeBasedCollectionScheme`](crate::model::TimeBasedCollectionScheme).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_time_based_collection_scheme(
        &self,
    ) -> std::result::Result<&crate::model::TimeBasedCollectionScheme, &Self> {
        if let CollectionScheme::TimeBasedCollectionScheme(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`TimeBasedCollectionScheme`](crate::model::CollectionScheme::TimeBasedCollectionScheme).
    pub fn is_time_based_collection_scheme(&self) -> bool {
        self.as_time_based_collection_scheme().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p>Information about a collection scheme that uses a simple logical expression to recognize what data to collect.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConditionBasedCollectionScheme {
    /// <p>The logical expression used to recognize what data to collect. For example, <code>$variable.Vehicle.OutsideAirTemperature &gt;= 105.0</code>.</p>
    #[doc(hidden)]
    pub expression: std::option::Option<std::string::String>,
    /// <p>The minimum duration of time between two triggering events to collect data, in milliseconds.</p> <note>
    /// <p>If a signal changes often, you might want to collect data at a slower rate.</p>
    /// </note>
    #[doc(hidden)]
    pub minimum_trigger_interval_ms: std::option::Option<i64>,
    /// <p>Whether to collect data for all triggering events (<code>ALWAYS</code>). Specify (<code>RISING_EDGE</code>), or specify only when the condition first evaluates to false. For example, triggering on "AirbagDeployed"; Users aren't interested on triggering when the airbag is already exploded; they only care about the change from not deployed =&gt; deployed.</p>
    #[doc(hidden)]
    pub trigger_mode: std::option::Option<crate::model::TriggerMode>,
    /// <p>Specifies the version of the conditional expression language.</p>
    #[doc(hidden)]
    pub condition_language_version: std::option::Option<i32>,
}
impl ConditionBasedCollectionScheme {
    /// <p>The logical expression used to recognize what data to collect. For example, <code>$variable.Vehicle.OutsideAirTemperature &gt;= 105.0</code>.</p>
    pub fn expression(&self) -> std::option::Option<&str> {
        self.expression.as_deref()
    }
    /// <p>The minimum duration of time between two triggering events to collect data, in milliseconds.</p> <note>
    /// <p>If a signal changes often, you might want to collect data at a slower rate.</p>
    /// </note>
    pub fn minimum_trigger_interval_ms(&self) -> std::option::Option<i64> {
        self.minimum_trigger_interval_ms
    }
    /// <p>Whether to collect data for all triggering events (<code>ALWAYS</code>). Specify (<code>RISING_EDGE</code>), or specify only when the condition first evaluates to false. For example, triggering on "AirbagDeployed"; Users aren't interested on triggering when the airbag is already exploded; they only care about the change from not deployed =&gt; deployed.</p>
    pub fn trigger_mode(&self) -> std::option::Option<&crate::model::TriggerMode> {
        self.trigger_mode.as_ref()
    }
    /// <p>Specifies the version of the conditional expression language.</p>
    pub fn condition_language_version(&self) -> std::option::Option<i32> {
        self.condition_language_version
    }
}
/// See [`ConditionBasedCollectionScheme`](crate::model::ConditionBasedCollectionScheme).
pub mod condition_based_collection_scheme {

    /// A builder for [`ConditionBasedCollectionScheme`](crate::model::ConditionBasedCollectionScheme).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) expression: std::option::Option<std::string::String>,
        pub(crate) minimum_trigger_interval_ms: std::option::Option<i64>,
        pub(crate) trigger_mode: std::option::Option<crate::model::TriggerMode>,
        pub(crate) condition_language_version: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The logical expression used to recognize what data to collect. For example, <code>$variable.Vehicle.OutsideAirTemperature &gt;= 105.0</code>.</p>
        pub fn expression(mut self, input: impl Into<std::string::String>) -> Self {
            self.expression = Some(input.into());
            self
        }
        /// <p>The logical expression used to recognize what data to collect. For example, <code>$variable.Vehicle.OutsideAirTemperature &gt;= 105.0</code>.</p>
        pub fn set_expression(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.expression = input;
            self
        }
        /// <p>The minimum duration of time between two triggering events to collect data, in milliseconds.</p> <note>
        /// <p>If a signal changes often, you might want to collect data at a slower rate.</p>
        /// </note>
        pub fn minimum_trigger_interval_ms(mut self, input: i64) -> Self {
            self.minimum_trigger_interval_ms = Some(input);
            self
        }
        /// <p>The minimum duration of time between two triggering events to collect data, in milliseconds.</p> <note>
        /// <p>If a signal changes often, you might want to collect data at a slower rate.</p>
        /// </note>
        pub fn set_minimum_trigger_interval_ms(mut self, input: std::option::Option<i64>) -> Self {
            self.minimum_trigger_interval_ms = input;
            self
        }
        /// <p>Whether to collect data for all triggering events (<code>ALWAYS</code>). Specify (<code>RISING_EDGE</code>), or specify only when the condition first evaluates to false. For example, triggering on "AirbagDeployed"; Users aren't interested on triggering when the airbag is already exploded; they only care about the change from not deployed =&gt; deployed.</p>
        pub fn trigger_mode(mut self, input: crate::model::TriggerMode) -> Self {
            self.trigger_mode = Some(input);
            self
        }
        /// <p>Whether to collect data for all triggering events (<code>ALWAYS</code>). Specify (<code>RISING_EDGE</code>), or specify only when the condition first evaluates to false. For example, triggering on "AirbagDeployed"; Users aren't interested on triggering when the airbag is already exploded; they only care about the change from not deployed =&gt; deployed.</p>
        pub fn set_trigger_mode(
            mut self,
            input: std::option::Option<crate::model::TriggerMode>,
        ) -> Self {
            self.trigger_mode = input;
            self
        }
        /// <p>Specifies the version of the conditional expression language.</p>
        pub fn condition_language_version(mut self, input: i32) -> Self {
            self.condition_language_version = Some(input);
            self
        }
        /// <p>Specifies the version of the conditional expression language.</p>
        pub fn set_condition_language_version(mut self, input: std::option::Option<i32>) -> Self {
            self.condition_language_version = input;
            self
        }
        /// Consumes the builder and constructs a [`ConditionBasedCollectionScheme`](crate::model::ConditionBasedCollectionScheme).
        pub fn build(self) -> crate::model::ConditionBasedCollectionScheme {
            crate::model::ConditionBasedCollectionScheme {
                expression: self.expression,
                minimum_trigger_interval_ms: self.minimum_trigger_interval_ms,
                trigger_mode: self.trigger_mode,
                condition_language_version: self.condition_language_version,
            }
        }
    }
}
impl ConditionBasedCollectionScheme {
    /// Creates a new builder-style object to manufacture [`ConditionBasedCollectionScheme`](crate::model::ConditionBasedCollectionScheme).
    pub fn builder() -> crate::model::condition_based_collection_scheme::Builder {
        crate::model::condition_based_collection_scheme::Builder::default()
    }
}

/// When writing a match expression against `TriggerMode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let triggermode = unimplemented!();
/// match triggermode {
///     TriggerMode::Always => { /* ... */ },
///     TriggerMode::RisingEdge => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `triggermode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `TriggerMode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `TriggerMode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `TriggerMode::NewFeature` is defined.
/// Specifically, when `triggermode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `TriggerMode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TriggerMode {
    #[allow(missing_docs)] // documentation missing in model
    Always,
    #[allow(missing_docs)] // documentation missing in model
    RisingEdge,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for TriggerMode {
    fn from(s: &str) -> Self {
        match s {
            "ALWAYS" => TriggerMode::Always,
            "RISING_EDGE" => TriggerMode::RisingEdge,
            other => TriggerMode::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for TriggerMode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TriggerMode::from(s))
    }
}
impl TriggerMode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TriggerMode::Always => "ALWAYS",
            TriggerMode::RisingEdge => "RISING_EDGE",
            TriggerMode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ALWAYS", "RISING_EDGE"]
    }
}
impl AsRef<str> for TriggerMode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about a collection scheme that uses a time period to decide how often to collect data.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TimeBasedCollectionScheme {
    /// <p>The time period (in milliseconds) to decide how often to collect data. For example, if the time period is <code>60000</code>, the Edge Agent software collects data once every minute.</p>
    #[doc(hidden)]
    pub period_ms: std::option::Option<i64>,
}
impl TimeBasedCollectionScheme {
    /// <p>The time period (in milliseconds) to decide how often to collect data. For example, if the time period is <code>60000</code>, the Edge Agent software collects data once every minute.</p>
    pub fn period_ms(&self) -> std::option::Option<i64> {
        self.period_ms
    }
}
/// See [`TimeBasedCollectionScheme`](crate::model::TimeBasedCollectionScheme).
pub mod time_based_collection_scheme {

    /// A builder for [`TimeBasedCollectionScheme`](crate::model::TimeBasedCollectionScheme).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) period_ms: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The time period (in milliseconds) to decide how often to collect data. For example, if the time period is <code>60000</code>, the Edge Agent software collects data once every minute.</p>
        pub fn period_ms(mut self, input: i64) -> Self {
            self.period_ms = Some(input);
            self
        }
        /// <p>The time period (in milliseconds) to decide how often to collect data. For example, if the time period is <code>60000</code>, the Edge Agent software collects data once every minute.</p>
        pub fn set_period_ms(mut self, input: std::option::Option<i64>) -> Self {
            self.period_ms = input;
            self
        }
        /// Consumes the builder and constructs a [`TimeBasedCollectionScheme`](crate::model::TimeBasedCollectionScheme).
        pub fn build(self) -> crate::model::TimeBasedCollectionScheme {
            crate::model::TimeBasedCollectionScheme {
                period_ms: self.period_ms,
            }
        }
    }
}
impl TimeBasedCollectionScheme {
    /// Creates a new builder-style object to manufacture [`TimeBasedCollectionScheme`](crate::model::TimeBasedCollectionScheme).
    pub fn builder() -> crate::model::time_based_collection_scheme::Builder {
        crate::model::time_based_collection_scheme::Builder::default()
    }
}

/// <p>Information about a signal.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SignalInformation {
    /// <p>The name of the signal.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The maximum number of samples to collect.</p>
    #[doc(hidden)]
    pub max_sample_count: std::option::Option<i64>,
    /// <p>The minimum duration of time (in milliseconds) between two triggering events to collect data.</p> <note>
    /// <p>If a signal changes often, you might want to collect data at a slower rate.</p>
    /// </note>
    #[doc(hidden)]
    pub minimum_sampling_interval_ms: std::option::Option<i64>,
}
impl SignalInformation {
    /// <p>The name of the signal.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The maximum number of samples to collect.</p>
    pub fn max_sample_count(&self) -> std::option::Option<i64> {
        self.max_sample_count
    }
    /// <p>The minimum duration of time (in milliseconds) between two triggering events to collect data.</p> <note>
    /// <p>If a signal changes often, you might want to collect data at a slower rate.</p>
    /// </note>
    pub fn minimum_sampling_interval_ms(&self) -> std::option::Option<i64> {
        self.minimum_sampling_interval_ms
    }
}
/// See [`SignalInformation`](crate::model::SignalInformation).
pub mod signal_information {

    /// A builder for [`SignalInformation`](crate::model::SignalInformation).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) max_sample_count: std::option::Option<i64>,
        pub(crate) minimum_sampling_interval_ms: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The name of the signal.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the signal.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The maximum number of samples to collect.</p>
        pub fn max_sample_count(mut self, input: i64) -> Self {
            self.max_sample_count = Some(input);
            self
        }
        /// <p>The maximum number of samples to collect.</p>
        pub fn set_max_sample_count(mut self, input: std::option::Option<i64>) -> Self {
            self.max_sample_count = input;
            self
        }
        /// <p>The minimum duration of time (in milliseconds) between two triggering events to collect data.</p> <note>
        /// <p>If a signal changes often, you might want to collect data at a slower rate.</p>
        /// </note>
        pub fn minimum_sampling_interval_ms(mut self, input: i64) -> Self {
            self.minimum_sampling_interval_ms = Some(input);
            self
        }
        /// <p>The minimum duration of time (in milliseconds) between two triggering events to collect data.</p> <note>
        /// <p>If a signal changes often, you might want to collect data at a slower rate.</p>
        /// </note>
        pub fn set_minimum_sampling_interval_ms(mut self, input: std::option::Option<i64>) -> Self {
            self.minimum_sampling_interval_ms = input;
            self
        }
        /// Consumes the builder and constructs a [`SignalInformation`](crate::model::SignalInformation).
        pub fn build(self) -> crate::model::SignalInformation {
            crate::model::SignalInformation {
                name: self.name,
                max_sample_count: self.max_sample_count,
                minimum_sampling_interval_ms: self.minimum_sampling_interval_ms,
            }
        }
    }
}
impl SignalInformation {
    /// Creates a new builder-style object to manufacture [`SignalInformation`](crate::model::SignalInformation).
    pub fn builder() -> crate::model::signal_information::Builder {
        crate::model::signal_information::Builder::default()
    }
}

/// When writing a match expression against `Compression`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let compression = unimplemented!();
/// match compression {
///     Compression::Off => { /* ... */ },
///     Compression::Snappy => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `compression` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Compression::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Compression::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Compression::NewFeature` is defined.
/// Specifically, when `compression` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Compression::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Compression {
    #[allow(missing_docs)] // documentation missing in model
    Off,
    #[allow(missing_docs)] // documentation missing in model
    Snappy,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Compression {
    fn from(s: &str) -> Self {
        match s {
            "OFF" => Compression::Off,
            "SNAPPY" => Compression::Snappy,
            other => Compression::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Compression {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Compression::from(s))
    }
}
impl Compression {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Compression::Off => "OFF",
            Compression::Snappy => "SNAPPY",
            Compression::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["OFF", "SNAPPY"]
    }
}
impl AsRef<str> for Compression {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `SpoolingMode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let spoolingmode = unimplemented!();
/// match spoolingmode {
///     SpoolingMode::Off => { /* ... */ },
///     SpoolingMode::ToDisk => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `spoolingmode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SpoolingMode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SpoolingMode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SpoolingMode::NewFeature` is defined.
/// Specifically, when `spoolingmode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SpoolingMode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SpoolingMode {
    #[allow(missing_docs)] // documentation missing in model
    Off,
    #[allow(missing_docs)] // documentation missing in model
    ToDisk,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for SpoolingMode {
    fn from(s: &str) -> Self {
        match s {
            "OFF" => SpoolingMode::Off,
            "TO_DISK" => SpoolingMode::ToDisk,
            other => SpoolingMode::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for SpoolingMode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SpoolingMode::from(s))
    }
}
impl SpoolingMode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SpoolingMode::Off => "OFF",
            SpoolingMode::ToDisk => "TO_DISK",
            SpoolingMode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["OFF", "TO_DISK"]
    }
}
impl AsRef<str> for SpoolingMode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `DiagnosticsMode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let diagnosticsmode = unimplemented!();
/// match diagnosticsmode {
///     DiagnosticsMode::Off => { /* ... */ },
///     DiagnosticsMode::SendActiveDtcs => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `diagnosticsmode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DiagnosticsMode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DiagnosticsMode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DiagnosticsMode::NewFeature` is defined.
/// Specifically, when `diagnosticsmode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DiagnosticsMode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DiagnosticsMode {
    #[allow(missing_docs)] // documentation missing in model
    Off,
    #[allow(missing_docs)] // documentation missing in model
    SendActiveDtcs,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DiagnosticsMode {
    fn from(s: &str) -> Self {
        match s {
            "OFF" => DiagnosticsMode::Off,
            "SEND_ACTIVE_DTCS" => DiagnosticsMode::SendActiveDtcs,
            other => DiagnosticsMode::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for DiagnosticsMode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DiagnosticsMode::from(s))
    }
}
impl DiagnosticsMode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DiagnosticsMode::Off => "OFF",
            DiagnosticsMode::SendActiveDtcs => "SEND_ACTIVE_DTCS",
            DiagnosticsMode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["OFF", "SEND_ACTIVE_DTCS"]
    }
}
impl AsRef<str> for DiagnosticsMode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `UpdateCampaignAction`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let updatecampaignaction = unimplemented!();
/// match updatecampaignaction {
///     UpdateCampaignAction::Approve => { /* ... */ },
///     UpdateCampaignAction::Resume => { /* ... */ },
///     UpdateCampaignAction::Suspend => { /* ... */ },
///     UpdateCampaignAction::Update => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `updatecampaignaction` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `UpdateCampaignAction::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `UpdateCampaignAction::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `UpdateCampaignAction::NewFeature` is defined.
/// Specifically, when `updatecampaignaction` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `UpdateCampaignAction::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum UpdateCampaignAction {
    #[allow(missing_docs)] // documentation missing in model
    Approve,
    #[allow(missing_docs)] // documentation missing in model
    Resume,
    #[allow(missing_docs)] // documentation missing in model
    Suspend,
    #[allow(missing_docs)] // documentation missing in model
    Update,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for UpdateCampaignAction {
    fn from(s: &str) -> Self {
        match s {
            "APPROVE" => UpdateCampaignAction::Approve,
            "RESUME" => UpdateCampaignAction::Resume,
            "SUSPEND" => UpdateCampaignAction::Suspend,
            "UPDATE" => UpdateCampaignAction::Update,
            other => {
                UpdateCampaignAction::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for UpdateCampaignAction {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(UpdateCampaignAction::from(s))
    }
}
impl UpdateCampaignAction {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            UpdateCampaignAction::Approve => "APPROVE",
            UpdateCampaignAction::Resume => "RESUME",
            UpdateCampaignAction::Suspend => "SUSPEND",
            UpdateCampaignAction::Update => "UPDATE",
            UpdateCampaignAction::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["APPROVE", "RESUME", "SUSPEND", "UPDATE"]
    }
}
impl AsRef<str> for UpdateCampaignAction {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The IAM resource that enables Amazon Web Services IoT FleetWise edge agent software to send data to Amazon Timestream. </p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles.html">IAM roles</a> in the <i>Identity and Access Management User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct IamResources {
    /// <p>The Amazon Resource Name (ARN) of the IAM resource that allows Amazon Web Services IoT FleetWise to send data to Amazon Timestream. For example, <code>arn:aws:iam::123456789012:role/SERVICE-ROLE-ARN</code>. </p>
    #[doc(hidden)]
    pub role_arn: std::option::Option<std::string::String>,
}
impl IamResources {
    /// <p>The Amazon Resource Name (ARN) of the IAM resource that allows Amazon Web Services IoT FleetWise to send data to Amazon Timestream. For example, <code>arn:aws:iam::123456789012:role/SERVICE-ROLE-ARN</code>. </p>
    pub fn role_arn(&self) -> std::option::Option<&str> {
        self.role_arn.as_deref()
    }
}
/// See [`IamResources`](crate::model::IamResources).
pub mod iam_resources {

    /// A builder for [`IamResources`](crate::model::IamResources).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) role_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the IAM resource that allows Amazon Web Services IoT FleetWise to send data to Amazon Timestream. For example, <code>arn:aws:iam::123456789012:role/SERVICE-ROLE-ARN</code>. </p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the IAM resource that allows Amazon Web Services IoT FleetWise to send data to Amazon Timestream. For example, <code>arn:aws:iam::123456789012:role/SERVICE-ROLE-ARN</code>. </p>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`IamResources`](crate::model::IamResources).
        pub fn build(self) -> crate::model::IamResources {
            crate::model::IamResources {
                role_arn: self.role_arn,
            }
        }
    }
}
impl IamResources {
    /// Creates a new builder-style object to manufacture [`IamResources`](crate::model::IamResources).
    pub fn builder() -> crate::model::iam_resources::Builder {
        crate::model::iam_resources::Builder::default()
    }
}

/// <p>The registered Amazon Timestream resources that Amazon Web Services IoT FleetWise edge agent software can transfer your vehicle data to.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TimestreamResources {
    /// <p>The name of the registered Amazon Timestream database.</p>
    #[doc(hidden)]
    pub timestream_database_name: std::option::Option<std::string::String>,
    /// <p>The name of the registered Amazon Timestream database table.</p>
    #[doc(hidden)]
    pub timestream_table_name: std::option::Option<std::string::String>,
}
impl TimestreamResources {
    /// <p>The name of the registered Amazon Timestream database.</p>
    pub fn timestream_database_name(&self) -> std::option::Option<&str> {
        self.timestream_database_name.as_deref()
    }
    /// <p>The name of the registered Amazon Timestream database table.</p>
    pub fn timestream_table_name(&self) -> std::option::Option<&str> {
        self.timestream_table_name.as_deref()
    }
}
/// See [`TimestreamResources`](crate::model::TimestreamResources).
pub mod timestream_resources {

    /// A builder for [`TimestreamResources`](crate::model::TimestreamResources).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) timestream_database_name: std::option::Option<std::string::String>,
        pub(crate) timestream_table_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the registered Amazon Timestream database.</p>
        pub fn timestream_database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.timestream_database_name = Some(input.into());
            self
        }
        /// <p>The name of the registered Amazon Timestream database.</p>
        pub fn set_timestream_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.timestream_database_name = input;
            self
        }
        /// <p>The name of the registered Amazon Timestream database table.</p>
        pub fn timestream_table_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.timestream_table_name = Some(input.into());
            self
        }
        /// <p>The name of the registered Amazon Timestream database table.</p>
        pub fn set_timestream_table_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.timestream_table_name = input;
            self
        }
        /// Consumes the builder and constructs a [`TimestreamResources`](crate::model::TimestreamResources).
        pub fn build(self) -> crate::model::TimestreamResources {
            crate::model::TimestreamResources {
                timestream_database_name: self.timestream_database_name,
                timestream_table_name: self.timestream_table_name,
            }
        }
    }
}
impl TimestreamResources {
    /// Creates a new builder-style object to manufacture [`TimestreamResources`](crate::model::TimestreamResources).
    pub fn builder() -> crate::model::timestream_resources::Builder {
        crate::model::timestream_resources::Builder::default()
    }
}

/// When writing a match expression against `RegistrationStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let registrationstatus = unimplemented!();
/// match registrationstatus {
///     RegistrationStatus::RegistrationFailure => { /* ... */ },
///     RegistrationStatus::RegistrationPending => { /* ... */ },
///     RegistrationStatus::RegistrationSuccess => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `registrationstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `RegistrationStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `RegistrationStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `RegistrationStatus::NewFeature` is defined.
/// Specifically, when `registrationstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `RegistrationStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RegistrationStatus {
    #[allow(missing_docs)] // documentation missing in model
    RegistrationFailure,
    #[allow(missing_docs)] // documentation missing in model
    RegistrationPending,
    #[allow(missing_docs)] // documentation missing in model
    RegistrationSuccess,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for RegistrationStatus {
    fn from(s: &str) -> Self {
        match s {
            "REGISTRATION_FAILURE" => RegistrationStatus::RegistrationFailure,
            "REGISTRATION_PENDING" => RegistrationStatus::RegistrationPending,
            "REGISTRATION_SUCCESS" => RegistrationStatus::RegistrationSuccess,
            other => {
                RegistrationStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for RegistrationStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RegistrationStatus::from(s))
    }
}
impl RegistrationStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            RegistrationStatus::RegistrationFailure => "REGISTRATION_FAILURE",
            RegistrationStatus::RegistrationPending => "REGISTRATION_PENDING",
            RegistrationStatus::RegistrationSuccess => "REGISTRATION_SUCCESS",
            RegistrationStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "REGISTRATION_FAILURE",
            "REGISTRATION_PENDING",
            "REGISTRATION_SUCCESS",
        ]
    }
}
impl AsRef<str> for RegistrationStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The log delivery option to send data to Amazon CloudWatch Logs.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CloudWatchLogDeliveryOptions {
    /// <p>The type of log to send data to Amazon CloudWatch Logs.</p>
    #[doc(hidden)]
    pub log_type: std::option::Option<crate::model::LogType>,
    /// <p>The Amazon CloudWatch Logs group the operation sends data to.</p>
    #[doc(hidden)]
    pub log_group_name: std::option::Option<std::string::String>,
}
impl CloudWatchLogDeliveryOptions {
    /// <p>The type of log to send data to Amazon CloudWatch Logs.</p>
    pub fn log_type(&self) -> std::option::Option<&crate::model::LogType> {
        self.log_type.as_ref()
    }
    /// <p>The Amazon CloudWatch Logs group the operation sends data to.</p>
    pub fn log_group_name(&self) -> std::option::Option<&str> {
        self.log_group_name.as_deref()
    }
}
/// See [`CloudWatchLogDeliveryOptions`](crate::model::CloudWatchLogDeliveryOptions).
pub mod cloud_watch_log_delivery_options {

    /// A builder for [`CloudWatchLogDeliveryOptions`](crate::model::CloudWatchLogDeliveryOptions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) log_type: std::option::Option<crate::model::LogType>,
        pub(crate) log_group_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The type of log to send data to Amazon CloudWatch Logs.</p>
        pub fn log_type(mut self, input: crate::model::LogType) -> Self {
            self.log_type = Some(input);
            self
        }
        /// <p>The type of log to send data to Amazon CloudWatch Logs.</p>
        pub fn set_log_type(mut self, input: std::option::Option<crate::model::LogType>) -> Self {
            self.log_type = input;
            self
        }
        /// <p>The Amazon CloudWatch Logs group the operation sends data to.</p>
        pub fn log_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.log_group_name = Some(input.into());
            self
        }
        /// <p>The Amazon CloudWatch Logs group the operation sends data to.</p>
        pub fn set_log_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.log_group_name = input;
            self
        }
        /// Consumes the builder and constructs a [`CloudWatchLogDeliveryOptions`](crate::model::CloudWatchLogDeliveryOptions).
        pub fn build(self) -> crate::model::CloudWatchLogDeliveryOptions {
            crate::model::CloudWatchLogDeliveryOptions {
                log_type: self.log_type,
                log_group_name: self.log_group_name,
            }
        }
    }
}
impl CloudWatchLogDeliveryOptions {
    /// Creates a new builder-style object to manufacture [`CloudWatchLogDeliveryOptions`](crate::model::CloudWatchLogDeliveryOptions).
    pub fn builder() -> crate::model::cloud_watch_log_delivery_options::Builder {
        crate::model::cloud_watch_log_delivery_options::Builder::default()
    }
}

/// When writing a match expression against `LogType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let logtype = unimplemented!();
/// match logtype {
///     LogType::Error => { /* ... */ },
///     LogType::Off => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `logtype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `LogType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `LogType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `LogType::NewFeature` is defined.
/// Specifically, when `logtype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `LogType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LogType {
    #[allow(missing_docs)] // documentation missing in model
    Error,
    #[allow(missing_docs)] // documentation missing in model
    Off,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for LogType {
    fn from(s: &str) -> Self {
        match s {
            "ERROR" => LogType::Error,
            "OFF" => LogType::Off,
            other => LogType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for LogType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LogType::from(s))
    }
}
impl LogType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            LogType::Error => "ERROR",
            LogType::Off => "OFF",
            LogType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ERROR", "OFF"]
    }
}
impl AsRef<str> for LogType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about the state of a vehicle and how it relates to the status of a campaign.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct VehicleStatus {
    /// <p>The name of a campaign.</p>
    #[doc(hidden)]
    pub campaign_name: std::option::Option<std::string::String>,
    /// <p>The unique ID of the vehicle.</p>
    #[doc(hidden)]
    pub vehicle_name: std::option::Option<std::string::String>,
    /// <p>The state of a vehicle, which can be one of the following:</p>
    /// <ul>
    /// <li> <p> <code>CREATED</code> - Amazon Web Services IoT FleetWise sucessfully created the vehicle. </p> </li>
    /// <li> <p> <code>READY</code> - The vehicle is ready to receive a campaign deployment. </p> </li>
    /// <li> <p> <code>HEALTHY</code> - A campaign deployment was delivered to the vehicle. </p> </li>
    /// <li> <p> <code>SUSPENDED</code> - A campaign associated with the vehicle was suspended and data collection was paused. </p> </li>
    /// <li> <p> <code>DELETING</code> - Amazon Web Services IoT FleetWise is removing a campaign from the vehicle. </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::VehicleState>,
}
impl VehicleStatus {
    /// <p>The name of a campaign.</p>
    pub fn campaign_name(&self) -> std::option::Option<&str> {
        self.campaign_name.as_deref()
    }
    /// <p>The unique ID of the vehicle.</p>
    pub fn vehicle_name(&self) -> std::option::Option<&str> {
        self.vehicle_name.as_deref()
    }
    /// <p>The state of a vehicle, which can be one of the following:</p>
    /// <ul>
    /// <li> <p> <code>CREATED</code> - Amazon Web Services IoT FleetWise sucessfully created the vehicle. </p> </li>
    /// <li> <p> <code>READY</code> - The vehicle is ready to receive a campaign deployment. </p> </li>
    /// <li> <p> <code>HEALTHY</code> - A campaign deployment was delivered to the vehicle. </p> </li>
    /// <li> <p> <code>SUSPENDED</code> - A campaign associated with the vehicle was suspended and data collection was paused. </p> </li>
    /// <li> <p> <code>DELETING</code> - Amazon Web Services IoT FleetWise is removing a campaign from the vehicle. </p> </li>
    /// </ul>
    pub fn status(&self) -> std::option::Option<&crate::model::VehicleState> {
        self.status.as_ref()
    }
}
/// See [`VehicleStatus`](crate::model::VehicleStatus).
pub mod vehicle_status {

    /// A builder for [`VehicleStatus`](crate::model::VehicleStatus).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) campaign_name: std::option::Option<std::string::String>,
        pub(crate) vehicle_name: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::VehicleState>,
    }
    impl Builder {
        /// <p>The name of a campaign.</p>
        pub fn campaign_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.campaign_name = Some(input.into());
            self
        }
        /// <p>The name of a campaign.</p>
        pub fn set_campaign_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.campaign_name = input;
            self
        }
        /// <p>The unique ID of the vehicle.</p>
        pub fn vehicle_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.vehicle_name = Some(input.into());
            self
        }
        /// <p>The unique ID of the vehicle.</p>
        pub fn set_vehicle_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vehicle_name = input;
            self
        }
        /// <p>The state of a vehicle, which can be one of the following:</p>
        /// <ul>
        /// <li> <p> <code>CREATED</code> - Amazon Web Services IoT FleetWise sucessfully created the vehicle. </p> </li>
        /// <li> <p> <code>READY</code> - The vehicle is ready to receive a campaign deployment. </p> </li>
        /// <li> <p> <code>HEALTHY</code> - A campaign deployment was delivered to the vehicle. </p> </li>
        /// <li> <p> <code>SUSPENDED</code> - A campaign associated with the vehicle was suspended and data collection was paused. </p> </li>
        /// <li> <p> <code>DELETING</code> - Amazon Web Services IoT FleetWise is removing a campaign from the vehicle. </p> </li>
        /// </ul>
        pub fn status(mut self, input: crate::model::VehicleState) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The state of a vehicle, which can be one of the following:</p>
        /// <ul>
        /// <li> <p> <code>CREATED</code> - Amazon Web Services IoT FleetWise sucessfully created the vehicle. </p> </li>
        /// <li> <p> <code>READY</code> - The vehicle is ready to receive a campaign deployment. </p> </li>
        /// <li> <p> <code>HEALTHY</code> - A campaign deployment was delivered to the vehicle. </p> </li>
        /// <li> <p> <code>SUSPENDED</code> - A campaign associated with the vehicle was suspended and data collection was paused. </p> </li>
        /// <li> <p> <code>DELETING</code> - Amazon Web Services IoT FleetWise is removing a campaign from the vehicle. </p> </li>
        /// </ul>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::VehicleState>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`VehicleStatus`](crate::model::VehicleStatus).
        pub fn build(self) -> crate::model::VehicleStatus {
            crate::model::VehicleStatus {
                campaign_name: self.campaign_name,
                vehicle_name: self.vehicle_name,
                status: self.status,
            }
        }
    }
}
impl VehicleStatus {
    /// Creates a new builder-style object to manufacture [`VehicleStatus`](crate::model::VehicleStatus).
    pub fn builder() -> crate::model::vehicle_status::Builder {
        crate::model::vehicle_status::Builder::default()
    }
}

/// When writing a match expression against `VehicleState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let vehiclestate = unimplemented!();
/// match vehiclestate {
///     VehicleState::Created => { /* ... */ },
///     VehicleState::Deleting => { /* ... */ },
///     VehicleState::Healthy => { /* ... */ },
///     VehicleState::Ready => { /* ... */ },
///     VehicleState::Suspended => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `vehiclestate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `VehicleState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `VehicleState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `VehicleState::NewFeature` is defined.
/// Specifically, when `vehiclestate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `VehicleState::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum VehicleState {
    #[allow(missing_docs)] // documentation missing in model
    Created,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    Healthy,
    #[allow(missing_docs)] // documentation missing in model
    Ready,
    #[allow(missing_docs)] // documentation missing in model
    Suspended,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for VehicleState {
    fn from(s: &str) -> Self {
        match s {
            "CREATED" => VehicleState::Created,
            "DELETING" => VehicleState::Deleting,
            "HEALTHY" => VehicleState::Healthy,
            "READY" => VehicleState::Ready,
            "SUSPENDED" => VehicleState::Suspended,
            other => VehicleState::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for VehicleState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(VehicleState::from(s))
    }
}
impl VehicleState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            VehicleState::Created => "CREATED",
            VehicleState::Deleting => "DELETING",
            VehicleState::Healthy => "HEALTHY",
            VehicleState::Ready => "READY",
            VehicleState::Suspended => "SUSPENDED",
            VehicleState::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CREATED", "DELETING", "HEALTHY", "READY", "SUSPENDED"]
    }
}
impl AsRef<str> for VehicleState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about registering an Identity and Access Management (IAM) resource so Amazon Web Services IoT FleetWise edge agent software can transfer your vehicle data to Amazon Timestream.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct IamRegistrationResponse {
    /// <p>The Amazon Resource Name (ARN) of the IAM role to register.</p>
    #[doc(hidden)]
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>The status of registering your IAM resource. The status can be one of <code>REGISTRATION_SUCCESS</code>, <code>REGISTRATION_PENDING</code>, <code>REGISTRATION_FAILURE</code>.</p>
    #[doc(hidden)]
    pub registration_status: std::option::Option<crate::model::RegistrationStatus>,
    /// <p>A message associated with a registration error.</p>
    #[doc(hidden)]
    pub error_message: std::option::Option<std::string::String>,
}
impl IamRegistrationResponse {
    /// <p>The Amazon Resource Name (ARN) of the IAM role to register.</p>
    pub fn role_arn(&self) -> std::option::Option<&str> {
        self.role_arn.as_deref()
    }
    /// <p>The status of registering your IAM resource. The status can be one of <code>REGISTRATION_SUCCESS</code>, <code>REGISTRATION_PENDING</code>, <code>REGISTRATION_FAILURE</code>.</p>
    pub fn registration_status(&self) -> std::option::Option<&crate::model::RegistrationStatus> {
        self.registration_status.as_ref()
    }
    /// <p>A message associated with a registration error.</p>
    pub fn error_message(&self) -> std::option::Option<&str> {
        self.error_message.as_deref()
    }
}
/// See [`IamRegistrationResponse`](crate::model::IamRegistrationResponse).
pub mod iam_registration_response {

    /// A builder for [`IamRegistrationResponse`](crate::model::IamRegistrationResponse).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) role_arn: std::option::Option<std::string::String>,
        pub(crate) registration_status: std::option::Option<crate::model::RegistrationStatus>,
        pub(crate) error_message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the IAM role to register.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the IAM role to register.</p>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// <p>The status of registering your IAM resource. The status can be one of <code>REGISTRATION_SUCCESS</code>, <code>REGISTRATION_PENDING</code>, <code>REGISTRATION_FAILURE</code>.</p>
        pub fn registration_status(mut self, input: crate::model::RegistrationStatus) -> Self {
            self.registration_status = Some(input);
            self
        }
        /// <p>The status of registering your IAM resource. The status can be one of <code>REGISTRATION_SUCCESS</code>, <code>REGISTRATION_PENDING</code>, <code>REGISTRATION_FAILURE</code>.</p>
        pub fn set_registration_status(
            mut self,
            input: std::option::Option<crate::model::RegistrationStatus>,
        ) -> Self {
            self.registration_status = input;
            self
        }
        /// <p>A message associated with a registration error.</p>
        pub fn error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_message = Some(input.into());
            self
        }
        /// <p>A message associated with a registration error.</p>
        pub fn set_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_message = input;
            self
        }
        /// Consumes the builder and constructs a [`IamRegistrationResponse`](crate::model::IamRegistrationResponse).
        pub fn build(self) -> crate::model::IamRegistrationResponse {
            crate::model::IamRegistrationResponse {
                role_arn: self.role_arn,
                registration_status: self.registration_status,
                error_message: self.error_message,
            }
        }
    }
}
impl IamRegistrationResponse {
    /// Creates a new builder-style object to manufacture [`IamRegistrationResponse`](crate::model::IamRegistrationResponse).
    pub fn builder() -> crate::model::iam_registration_response::Builder {
        crate::model::iam_registration_response::Builder::default()
    }
}

/// <p>Information about the registered Amazon Timestream resources or errors, if any.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TimestreamRegistrationResponse {
    /// <p>The name of the Timestream database.</p>
    #[doc(hidden)]
    pub timestream_database_name: std::option::Option<std::string::String>,
    /// <p>The name of the Timestream database table.</p>
    #[doc(hidden)]
    pub timestream_table_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the Timestream database.</p>
    #[doc(hidden)]
    pub timestream_database_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of the Timestream database table.</p>
    #[doc(hidden)]
    pub timestream_table_arn: std::option::Option<std::string::String>,
    /// <p>The status of registering your Amazon Timestream resources. The status can be one of <code>REGISTRATION_SUCCESS</code>, <code>REGISTRATION_PENDING</code>, <code>REGISTRATION_FAILURE</code>.</p>
    #[doc(hidden)]
    pub registration_status: std::option::Option<crate::model::RegistrationStatus>,
    /// <p>A message associated with a registration error.</p>
    #[doc(hidden)]
    pub error_message: std::option::Option<std::string::String>,
}
impl TimestreamRegistrationResponse {
    /// <p>The name of the Timestream database.</p>
    pub fn timestream_database_name(&self) -> std::option::Option<&str> {
        self.timestream_database_name.as_deref()
    }
    /// <p>The name of the Timestream database table.</p>
    pub fn timestream_table_name(&self) -> std::option::Option<&str> {
        self.timestream_table_name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the Timestream database.</p>
    pub fn timestream_database_arn(&self) -> std::option::Option<&str> {
        self.timestream_database_arn.as_deref()
    }
    /// <p>The ARN of the Timestream database table.</p>
    pub fn timestream_table_arn(&self) -> std::option::Option<&str> {
        self.timestream_table_arn.as_deref()
    }
    /// <p>The status of registering your Amazon Timestream resources. The status can be one of <code>REGISTRATION_SUCCESS</code>, <code>REGISTRATION_PENDING</code>, <code>REGISTRATION_FAILURE</code>.</p>
    pub fn registration_status(&self) -> std::option::Option<&crate::model::RegistrationStatus> {
        self.registration_status.as_ref()
    }
    /// <p>A message associated with a registration error.</p>
    pub fn error_message(&self) -> std::option::Option<&str> {
        self.error_message.as_deref()
    }
}
/// See [`TimestreamRegistrationResponse`](crate::model::TimestreamRegistrationResponse).
pub mod timestream_registration_response {

    /// A builder for [`TimestreamRegistrationResponse`](crate::model::TimestreamRegistrationResponse).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) timestream_database_name: std::option::Option<std::string::String>,
        pub(crate) timestream_table_name: std::option::Option<std::string::String>,
        pub(crate) timestream_database_arn: std::option::Option<std::string::String>,
        pub(crate) timestream_table_arn: std::option::Option<std::string::String>,
        pub(crate) registration_status: std::option::Option<crate::model::RegistrationStatus>,
        pub(crate) error_message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the Timestream database.</p>
        pub fn timestream_database_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.timestream_database_name = Some(input.into());
            self
        }
        /// <p>The name of the Timestream database.</p>
        pub fn set_timestream_database_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.timestream_database_name = input;
            self
        }
        /// <p>The name of the Timestream database table.</p>
        pub fn timestream_table_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.timestream_table_name = Some(input.into());
            self
        }
        /// <p>The name of the Timestream database table.</p>
        pub fn set_timestream_table_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.timestream_table_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Timestream database.</p>
        pub fn timestream_database_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.timestream_database_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Timestream database.</p>
        pub fn set_timestream_database_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.timestream_database_arn = input;
            self
        }
        /// <p>The ARN of the Timestream database table.</p>
        pub fn timestream_table_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.timestream_table_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the Timestream database table.</p>
        pub fn set_timestream_table_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.timestream_table_arn = input;
            self
        }
        /// <p>The status of registering your Amazon Timestream resources. The status can be one of <code>REGISTRATION_SUCCESS</code>, <code>REGISTRATION_PENDING</code>, <code>REGISTRATION_FAILURE</code>.</p>
        pub fn registration_status(mut self, input: crate::model::RegistrationStatus) -> Self {
            self.registration_status = Some(input);
            self
        }
        /// <p>The status of registering your Amazon Timestream resources. The status can be one of <code>REGISTRATION_SUCCESS</code>, <code>REGISTRATION_PENDING</code>, <code>REGISTRATION_FAILURE</code>.</p>
        pub fn set_registration_status(
            mut self,
            input: std::option::Option<crate::model::RegistrationStatus>,
        ) -> Self {
            self.registration_status = input;
            self
        }
        /// <p>A message associated with a registration error.</p>
        pub fn error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_message = Some(input.into());
            self
        }
        /// <p>A message associated with a registration error.</p>
        pub fn set_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_message = input;
            self
        }
        /// Consumes the builder and constructs a [`TimestreamRegistrationResponse`](crate::model::TimestreamRegistrationResponse).
        pub fn build(self) -> crate::model::TimestreamRegistrationResponse {
            crate::model::TimestreamRegistrationResponse {
                timestream_database_name: self.timestream_database_name,
                timestream_table_name: self.timestream_table_name,
                timestream_database_arn: self.timestream_database_arn,
                timestream_table_arn: self.timestream_table_arn,
                registration_status: self.registration_status,
                error_message: self.error_message,
            }
        }
    }
}
impl TimestreamRegistrationResponse {
    /// Creates a new builder-style object to manufacture [`TimestreamRegistrationResponse`](crate::model::TimestreamRegistrationResponse).
    pub fn builder() -> crate::model::timestream_registration_response::Builder {
        crate::model::timestream_registration_response::Builder::default()
    }
}

/// <p>An HTTP error resulting from updating the description for a vehicle.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateVehicleError {
    /// <p>The ID of the vehicle with the error.</p>
    #[doc(hidden)]
    pub vehicle_name: std::option::Option<std::string::String>,
    /// <p>The relevant HTTP error code (400+).</p>
    #[doc(hidden)]
    pub code: i32,
    /// <p>A message associated with the error.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl UpdateVehicleError {
    /// <p>The ID of the vehicle with the error.</p>
    pub fn vehicle_name(&self) -> std::option::Option<&str> {
        self.vehicle_name.as_deref()
    }
    /// <p>The relevant HTTP error code (400+).</p>
    pub fn code(&self) -> i32 {
        self.code
    }
    /// <p>A message associated with the error.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
/// See [`UpdateVehicleError`](crate::model::UpdateVehicleError).
pub mod update_vehicle_error {

    /// A builder for [`UpdateVehicleError`](crate::model::UpdateVehicleError).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) vehicle_name: std::option::Option<std::string::String>,
        pub(crate) code: std::option::Option<i32>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the vehicle with the error.</p>
        pub fn vehicle_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.vehicle_name = Some(input.into());
            self
        }
        /// <p>The ID of the vehicle with the error.</p>
        pub fn set_vehicle_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vehicle_name = input;
            self
        }
        /// <p>The relevant HTTP error code (400+).</p>
        pub fn code(mut self, input: i32) -> Self {
            self.code = Some(input);
            self
        }
        /// <p>The relevant HTTP error code (400+).</p>
        pub fn set_code(mut self, input: std::option::Option<i32>) -> Self {
            self.code = input;
            self
        }
        /// <p>A message associated with the error.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A message associated with the error.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateVehicleError`](crate::model::UpdateVehicleError).
        pub fn build(self) -> crate::model::UpdateVehicleError {
            crate::model::UpdateVehicleError {
                vehicle_name: self.vehicle_name,
                code: self.code.unwrap_or_default(),
                message: self.message,
            }
        }
    }
}
impl UpdateVehicleError {
    /// Creates a new builder-style object to manufacture [`UpdateVehicleError`](crate::model::UpdateVehicleError).
    pub fn builder() -> crate::model::update_vehicle_error::Builder {
        crate::model::update_vehicle_error::Builder::default()
    }
}

/// <p>Information about the updated vehicle.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateVehicleResponseItem {
    /// <p>The unique ID of the updated vehicle.</p>
    #[doc(hidden)]
    pub vehicle_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the updated vehicle.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
}
impl UpdateVehicleResponseItem {
    /// <p>The unique ID of the updated vehicle.</p>
    pub fn vehicle_name(&self) -> std::option::Option<&str> {
        self.vehicle_name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the updated vehicle.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
}
/// See [`UpdateVehicleResponseItem`](crate::model::UpdateVehicleResponseItem).
pub mod update_vehicle_response_item {

    /// A builder for [`UpdateVehicleResponseItem`](crate::model::UpdateVehicleResponseItem).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) vehicle_name: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique ID of the updated vehicle.</p>
        pub fn vehicle_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.vehicle_name = Some(input.into());
            self
        }
        /// <p>The unique ID of the updated vehicle.</p>
        pub fn set_vehicle_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vehicle_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the updated vehicle.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the updated vehicle.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateVehicleResponseItem`](crate::model::UpdateVehicleResponseItem).
        pub fn build(self) -> crate::model::UpdateVehicleResponseItem {
            crate::model::UpdateVehicleResponseItem {
                vehicle_name: self.vehicle_name,
                arn: self.arn,
            }
        }
    }
}
impl UpdateVehicleResponseItem {
    /// Creates a new builder-style object to manufacture [`UpdateVehicleResponseItem`](crate::model::UpdateVehicleResponseItem).
    pub fn builder() -> crate::model::update_vehicle_response_item::Builder {
        crate::model::update_vehicle_response_item::Builder::default()
    }
}

/// <p>Information about the vehicle to update.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateVehicleRequestItem {
    /// <p>The unique ID of the vehicle to update.</p>
    #[doc(hidden)]
    pub vehicle_name: std::option::Option<std::string::String>,
    /// <p>The ARN of the vehicle model (model manifest) associated with the vehicle to update.</p>
    #[doc(hidden)]
    pub model_manifest_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of the signal decoder manifest associated with the vehicle to update.</p>
    #[doc(hidden)]
    pub decoder_manifest_arn: std::option::Option<std::string::String>,
    /// <p>Static information about a vehicle in a key-value pair. For example:</p>
    /// <p> <code>"engineType"</code> : <code>"1.3 L R2"</code> </p>
    #[doc(hidden)]
    pub attributes:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The method the specified attributes will update the existing attributes on the vehicle. Use<code>Overwite</code> to replace the vehicle attributes with the specified attributes. Or use <code>Merge</code> to combine all attributes.</p>
    /// <p>This is required if attributes are present in the input.</p>
    #[doc(hidden)]
    pub attribute_update_mode: std::option::Option<crate::model::UpdateMode>,
}
impl UpdateVehicleRequestItem {
    /// <p>The unique ID of the vehicle to update.</p>
    pub fn vehicle_name(&self) -> std::option::Option<&str> {
        self.vehicle_name.as_deref()
    }
    /// <p>The ARN of the vehicle model (model manifest) associated with the vehicle to update.</p>
    pub fn model_manifest_arn(&self) -> std::option::Option<&str> {
        self.model_manifest_arn.as_deref()
    }
    /// <p>The ARN of the signal decoder manifest associated with the vehicle to update.</p>
    pub fn decoder_manifest_arn(&self) -> std::option::Option<&str> {
        self.decoder_manifest_arn.as_deref()
    }
    /// <p>Static information about a vehicle in a key-value pair. For example:</p>
    /// <p> <code>"engineType"</code> : <code>"1.3 L R2"</code> </p>
    pub fn attributes(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.attributes.as_ref()
    }
    /// <p>The method the specified attributes will update the existing attributes on the vehicle. Use<code>Overwite</code> to replace the vehicle attributes with the specified attributes. Or use <code>Merge</code> to combine all attributes.</p>
    /// <p>This is required if attributes are present in the input.</p>
    pub fn attribute_update_mode(&self) -> std::option::Option<&crate::model::UpdateMode> {
        self.attribute_update_mode.as_ref()
    }
}
/// See [`UpdateVehicleRequestItem`](crate::model::UpdateVehicleRequestItem).
pub mod update_vehicle_request_item {

    /// A builder for [`UpdateVehicleRequestItem`](crate::model::UpdateVehicleRequestItem).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) vehicle_name: std::option::Option<std::string::String>,
        pub(crate) model_manifest_arn: std::option::Option<std::string::String>,
        pub(crate) decoder_manifest_arn: std::option::Option<std::string::String>,
        pub(crate) attributes: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) attribute_update_mode: std::option::Option<crate::model::UpdateMode>,
    }
    impl Builder {
        /// <p>The unique ID of the vehicle to update.</p>
        pub fn vehicle_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.vehicle_name = Some(input.into());
            self
        }
        /// <p>The unique ID of the vehicle to update.</p>
        pub fn set_vehicle_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vehicle_name = input;
            self
        }
        /// <p>The ARN of the vehicle model (model manifest) associated with the vehicle to update.</p>
        pub fn model_manifest_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_manifest_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the vehicle model (model manifest) associated with the vehicle to update.</p>
        pub fn set_model_manifest_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_manifest_arn = input;
            self
        }
        /// <p>The ARN of the signal decoder manifest associated with the vehicle to update.</p>
        pub fn decoder_manifest_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.decoder_manifest_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the signal decoder manifest associated with the vehicle to update.</p>
        pub fn set_decoder_manifest_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.decoder_manifest_arn = input;
            self
        }
        /// Adds a key-value pair to `attributes`.
        ///
        /// To override the contents of this collection use [`set_attributes`](Self::set_attributes).
        ///
        /// <p>Static information about a vehicle in a key-value pair. For example:</p>
        /// <p> <code>"engineType"</code> : <code>"1.3 L R2"</code> </p>
        pub fn attributes(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.attributes.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.attributes = Some(hash_map);
            self
        }
        /// <p>Static information about a vehicle in a key-value pair. For example:</p>
        /// <p> <code>"engineType"</code> : <code>"1.3 L R2"</code> </p>
        pub fn set_attributes(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.attributes = input;
            self
        }
        /// <p>The method the specified attributes will update the existing attributes on the vehicle. Use<code>Overwite</code> to replace the vehicle attributes with the specified attributes. Or use <code>Merge</code> to combine all attributes.</p>
        /// <p>This is required if attributes are present in the input.</p>
        pub fn attribute_update_mode(mut self, input: crate::model::UpdateMode) -> Self {
            self.attribute_update_mode = Some(input);
            self
        }
        /// <p>The method the specified attributes will update the existing attributes on the vehicle. Use<code>Overwite</code> to replace the vehicle attributes with the specified attributes. Or use <code>Merge</code> to combine all attributes.</p>
        /// <p>This is required if attributes are present in the input.</p>
        pub fn set_attribute_update_mode(
            mut self,
            input: std::option::Option<crate::model::UpdateMode>,
        ) -> Self {
            self.attribute_update_mode = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateVehicleRequestItem`](crate::model::UpdateVehicleRequestItem).
        pub fn build(self) -> crate::model::UpdateVehicleRequestItem {
            crate::model::UpdateVehicleRequestItem {
                vehicle_name: self.vehicle_name,
                model_manifest_arn: self.model_manifest_arn,
                decoder_manifest_arn: self.decoder_manifest_arn,
                attributes: self.attributes,
                attribute_update_mode: self.attribute_update_mode,
            }
        }
    }
}
impl UpdateVehicleRequestItem {
    /// Creates a new builder-style object to manufacture [`UpdateVehicleRequestItem`](crate::model::UpdateVehicleRequestItem).
    pub fn builder() -> crate::model::update_vehicle_request_item::Builder {
        crate::model::update_vehicle_request_item::Builder::default()
    }
}

/// <p>An HTTP error resulting from creating a vehicle.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateVehicleError {
    /// <p>The ID of the vehicle with the error.</p>
    #[doc(hidden)]
    pub vehicle_name: std::option::Option<std::string::String>,
    /// <p>An HTTP error code.</p>
    #[doc(hidden)]
    pub code: std::option::Option<std::string::String>,
    /// <p>A description of the HTTP error.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl CreateVehicleError {
    /// <p>The ID of the vehicle with the error.</p>
    pub fn vehicle_name(&self) -> std::option::Option<&str> {
        self.vehicle_name.as_deref()
    }
    /// <p>An HTTP error code.</p>
    pub fn code(&self) -> std::option::Option<&str> {
        self.code.as_deref()
    }
    /// <p>A description of the HTTP error.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
/// See [`CreateVehicleError`](crate::model::CreateVehicleError).
pub mod create_vehicle_error {

    /// A builder for [`CreateVehicleError`](crate::model::CreateVehicleError).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) vehicle_name: std::option::Option<std::string::String>,
        pub(crate) code: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the vehicle with the error.</p>
        pub fn vehicle_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.vehicle_name = Some(input.into());
            self
        }
        /// <p>The ID of the vehicle with the error.</p>
        pub fn set_vehicle_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vehicle_name = input;
            self
        }
        /// <p>An HTTP error code.</p>
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        /// <p>An HTTP error code.</p>
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// <p>A description of the HTTP error.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A description of the HTTP error.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateVehicleError`](crate::model::CreateVehicleError).
        pub fn build(self) -> crate::model::CreateVehicleError {
            crate::model::CreateVehicleError {
                vehicle_name: self.vehicle_name,
                code: self.code,
                message: self.message,
            }
        }
    }
}
impl CreateVehicleError {
    /// Creates a new builder-style object to manufacture [`CreateVehicleError`](crate::model::CreateVehicleError).
    pub fn builder() -> crate::model::create_vehicle_error::Builder {
        crate::model::create_vehicle_error::Builder::default()
    }
}

/// <p>Information about a created vehicle.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateVehicleResponseItem {
    /// <p>The unique ID of the vehicle to create.</p>
    #[doc(hidden)]
    pub vehicle_name: std::option::Option<std::string::String>,
    /// <p>The ARN of the created vehicle.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The ARN of a created or validated Amazon Web Services IoT thing.</p>
    #[doc(hidden)]
    pub thing_arn: std::option::Option<std::string::String>,
}
impl CreateVehicleResponseItem {
    /// <p>The unique ID of the vehicle to create.</p>
    pub fn vehicle_name(&self) -> std::option::Option<&str> {
        self.vehicle_name.as_deref()
    }
    /// <p>The ARN of the created vehicle.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The ARN of a created or validated Amazon Web Services IoT thing.</p>
    pub fn thing_arn(&self) -> std::option::Option<&str> {
        self.thing_arn.as_deref()
    }
}
/// See [`CreateVehicleResponseItem`](crate::model::CreateVehicleResponseItem).
pub mod create_vehicle_response_item {

    /// A builder for [`CreateVehicleResponseItem`](crate::model::CreateVehicleResponseItem).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) vehicle_name: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) thing_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique ID of the vehicle to create.</p>
        pub fn vehicle_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.vehicle_name = Some(input.into());
            self
        }
        /// <p>The unique ID of the vehicle to create.</p>
        pub fn set_vehicle_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vehicle_name = input;
            self
        }
        /// <p>The ARN of the created vehicle.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The ARN of the created vehicle.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The ARN of a created or validated Amazon Web Services IoT thing.</p>
        pub fn thing_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.thing_arn = Some(input.into());
            self
        }
        /// <p>The ARN of a created or validated Amazon Web Services IoT thing.</p>
        pub fn set_thing_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.thing_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateVehicleResponseItem`](crate::model::CreateVehicleResponseItem).
        pub fn build(self) -> crate::model::CreateVehicleResponseItem {
            crate::model::CreateVehicleResponseItem {
                vehicle_name: self.vehicle_name,
                arn: self.arn,
                thing_arn: self.thing_arn,
            }
        }
    }
}
impl CreateVehicleResponseItem {
    /// Creates a new builder-style object to manufacture [`CreateVehicleResponseItem`](crate::model::CreateVehicleResponseItem).
    pub fn builder() -> crate::model::create_vehicle_response_item::Builder {
        crate::model::create_vehicle_response_item::Builder::default()
    }
}

/// <p>Information about the vehicle to create.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateVehicleRequestItem {
    /// <p>The unique ID of the vehicle to create.</p>
    #[doc(hidden)]
    pub vehicle_name: std::option::Option<std::string::String>,
    /// <p>The ARN of the vehicle model (model manifest) to create the vehicle from.</p>
    #[doc(hidden)]
    pub model_manifest_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of a decoder manifest associated with the vehicle to create. </p>
    #[doc(hidden)]
    pub decoder_manifest_arn: std::option::Option<std::string::String>,
    /// <p>Static information about a vehicle in a key-value pair. For example: <code>"engine Type"</code> : <code>"v6"</code> </p>
    #[doc(hidden)]
    pub attributes:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>An option to create a new Amazon Web Services IoT thing when creating a vehicle, or to validate an existing thing as a vehicle.</p>
    #[doc(hidden)]
    pub association_behavior: std::option::Option<crate::model::VehicleAssociationBehavior>,
    /// <p>Metadata which can be used to manage the vehicle.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl CreateVehicleRequestItem {
    /// <p>The unique ID of the vehicle to create.</p>
    pub fn vehicle_name(&self) -> std::option::Option<&str> {
        self.vehicle_name.as_deref()
    }
    /// <p>The ARN of the vehicle model (model manifest) to create the vehicle from.</p>
    pub fn model_manifest_arn(&self) -> std::option::Option<&str> {
        self.model_manifest_arn.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of a decoder manifest associated with the vehicle to create. </p>
    pub fn decoder_manifest_arn(&self) -> std::option::Option<&str> {
        self.decoder_manifest_arn.as_deref()
    }
    /// <p>Static information about a vehicle in a key-value pair. For example: <code>"engine Type"</code> : <code>"v6"</code> </p>
    pub fn attributes(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.attributes.as_ref()
    }
    /// <p>An option to create a new Amazon Web Services IoT thing when creating a vehicle, or to validate an existing thing as a vehicle.</p>
    pub fn association_behavior(
        &self,
    ) -> std::option::Option<&crate::model::VehicleAssociationBehavior> {
        self.association_behavior.as_ref()
    }
    /// <p>Metadata which can be used to manage the vehicle.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
}
/// See [`CreateVehicleRequestItem`](crate::model::CreateVehicleRequestItem).
pub mod create_vehicle_request_item {

    /// A builder for [`CreateVehicleRequestItem`](crate::model::CreateVehicleRequestItem).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) vehicle_name: std::option::Option<std::string::String>,
        pub(crate) model_manifest_arn: std::option::Option<std::string::String>,
        pub(crate) decoder_manifest_arn: std::option::Option<std::string::String>,
        pub(crate) attributes: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) association_behavior:
            std::option::Option<crate::model::VehicleAssociationBehavior>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The unique ID of the vehicle to create.</p>
        pub fn vehicle_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.vehicle_name = Some(input.into());
            self
        }
        /// <p>The unique ID of the vehicle to create.</p>
        pub fn set_vehicle_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vehicle_name = input;
            self
        }
        /// <p>The ARN of the vehicle model (model manifest) to create the vehicle from.</p>
        pub fn model_manifest_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_manifest_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the vehicle model (model manifest) to create the vehicle from.</p>
        pub fn set_model_manifest_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_manifest_arn = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of a decoder manifest associated with the vehicle to create. </p>
        pub fn decoder_manifest_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.decoder_manifest_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of a decoder manifest associated with the vehicle to create. </p>
        pub fn set_decoder_manifest_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.decoder_manifest_arn = input;
            self
        }
        /// Adds a key-value pair to `attributes`.
        ///
        /// To override the contents of this collection use [`set_attributes`](Self::set_attributes).
        ///
        /// <p>Static information about a vehicle in a key-value pair. For example: <code>"engine Type"</code> : <code>"v6"</code> </p>
        pub fn attributes(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.attributes.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.attributes = Some(hash_map);
            self
        }
        /// <p>Static information about a vehicle in a key-value pair. For example: <code>"engine Type"</code> : <code>"v6"</code> </p>
        pub fn set_attributes(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.attributes = input;
            self
        }
        /// <p>An option to create a new Amazon Web Services IoT thing when creating a vehicle, or to validate an existing thing as a vehicle.</p>
        pub fn association_behavior(
            mut self,
            input: crate::model::VehicleAssociationBehavior,
        ) -> Self {
            self.association_behavior = Some(input);
            self
        }
        /// <p>An option to create a new Amazon Web Services IoT thing when creating a vehicle, or to validate an existing thing as a vehicle.</p>
        pub fn set_association_behavior(
            mut self,
            input: std::option::Option<crate::model::VehicleAssociationBehavior>,
        ) -> Self {
            self.association_behavior = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Metadata which can be used to manage the vehicle.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>Metadata which can be used to manage the vehicle.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateVehicleRequestItem`](crate::model::CreateVehicleRequestItem).
        pub fn build(self) -> crate::model::CreateVehicleRequestItem {
            crate::model::CreateVehicleRequestItem {
                vehicle_name: self.vehicle_name,
                model_manifest_arn: self.model_manifest_arn,
                decoder_manifest_arn: self.decoder_manifest_arn,
                attributes: self.attributes,
                association_behavior: self.association_behavior,
                tags: self.tags,
            }
        }
    }
}
impl CreateVehicleRequestItem {
    /// Creates a new builder-style object to manufacture [`CreateVehicleRequestItem`](crate::model::CreateVehicleRequestItem).
    pub fn builder() -> crate::model::create_vehicle_request_item::Builder {
        crate::model::create_vehicle_request_item::Builder::default()
    }
}
