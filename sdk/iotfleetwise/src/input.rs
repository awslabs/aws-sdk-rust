// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use std::fmt::Write;
impl AssociateVehicleFleetInput {
    /// Consumes the builder and constructs an Operation<[`AssociateVehicleFleet`](crate::operation::AssociateVehicleFleet)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::AssociateVehicleFleet,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::AssociateVehicleFleetInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::AssociateVehicleFleetInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.0",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "IoTAutobahnControlPlane.AssociateVehicleFleet",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_associate_vehicle_fleet::ser_associate_vehicle_fleet_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::AssociateVehicleFleet::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "AssociateVehicleFleet",
            "iotfleetwise",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl BatchCreateVehicleInput {
    /// Consumes the builder and constructs an Operation<[`BatchCreateVehicle`](crate::operation::BatchCreateVehicle)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::BatchCreateVehicle,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::BatchCreateVehicleInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::BatchCreateVehicleInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.0",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "IoTAutobahnControlPlane.BatchCreateVehicle",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_batch_create_vehicle::ser_batch_create_vehicle_input(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::BatchCreateVehicle::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "BatchCreateVehicle",
            "iotfleetwise",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl BatchUpdateVehicleInput {
    /// Consumes the builder and constructs an Operation<[`BatchUpdateVehicle`](crate::operation::BatchUpdateVehicle)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::BatchUpdateVehicle,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::BatchUpdateVehicleInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::BatchUpdateVehicleInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.0",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "IoTAutobahnControlPlane.BatchUpdateVehicle",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_batch_update_vehicle::ser_batch_update_vehicle_input(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::BatchUpdateVehicle::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "BatchUpdateVehicle",
            "iotfleetwise",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl CreateCampaignInput {
    /// Consumes the builder and constructs an Operation<[`CreateCampaign`](crate::operation::CreateCampaign)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateCampaign,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateCampaignInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateCampaignInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.0",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "IoTAutobahnControlPlane.CreateCampaign",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_create_campaign::ser_create_campaign_input(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateCampaign::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateCampaign",
            "iotfleetwise",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl CreateDecoderManifestInput {
    /// Consumes the builder and constructs an Operation<[`CreateDecoderManifest`](crate::operation::CreateDecoderManifest)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateDecoderManifest,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateDecoderManifestInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateDecoderManifestInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.0",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "IoTAutobahnControlPlane.CreateDecoderManifest",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_create_decoder_manifest::ser_create_decoder_manifest_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateDecoderManifest::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateDecoderManifest",
            "iotfleetwise",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl CreateFleetInput {
    /// Consumes the builder and constructs an Operation<[`CreateFleet`](crate::operation::CreateFleet)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateFleet,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateFleetInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateFleetInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.0",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "IoTAutobahnControlPlane.CreateFleet",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_create_fleet::ser_create_fleet_input(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateFleet::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateFleet",
            "iotfleetwise",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl CreateModelManifestInput {
    /// Consumes the builder and constructs an Operation<[`CreateModelManifest`](crate::operation::CreateModelManifest)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateModelManifest,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateModelManifestInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateModelManifestInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.0",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "IoTAutobahnControlPlane.CreateModelManifest",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_create_model_manifest::ser_create_model_manifest_input(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateModelManifest::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateModelManifest",
            "iotfleetwise",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl CreateSignalCatalogInput {
    /// Consumes the builder and constructs an Operation<[`CreateSignalCatalog`](crate::operation::CreateSignalCatalog)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateSignalCatalog,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateSignalCatalogInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateSignalCatalogInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.0",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "IoTAutobahnControlPlane.CreateSignalCatalog",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_create_signal_catalog::ser_create_signal_catalog_input(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateSignalCatalog::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateSignalCatalog",
            "iotfleetwise",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl CreateVehicleInput {
    /// Consumes the builder and constructs an Operation<[`CreateVehicle`](crate::operation::CreateVehicle)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateVehicle,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateVehicleInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateVehicleInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.0",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "IoTAutobahnControlPlane.CreateVehicle",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_create_vehicle::ser_create_vehicle_input(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateVehicle::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateVehicle",
            "iotfleetwise",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DeleteCampaignInput {
    /// Consumes the builder and constructs an Operation<[`DeleteCampaign`](crate::operation::DeleteCampaign)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteCampaign,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteCampaignInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteCampaignInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.0",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "IoTAutobahnControlPlane.DeleteCampaign",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_delete_campaign::ser_delete_campaign_input(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteCampaign::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteCampaign",
            "iotfleetwise",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DeleteDecoderManifestInput {
    /// Consumes the builder and constructs an Operation<[`DeleteDecoderManifest`](crate::operation::DeleteDecoderManifest)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteDecoderManifest,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteDecoderManifestInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteDecoderManifestInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.0",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "IoTAutobahnControlPlane.DeleteDecoderManifest",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_delete_decoder_manifest::ser_delete_decoder_manifest_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteDecoderManifest::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteDecoderManifest",
            "iotfleetwise",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DeleteFleetInput {
    /// Consumes the builder and constructs an Operation<[`DeleteFleet`](crate::operation::DeleteFleet)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteFleet,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteFleetInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteFleetInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.0",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "IoTAutobahnControlPlane.DeleteFleet",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_delete_fleet::ser_delete_fleet_input(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteFleet::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteFleet",
            "iotfleetwise",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DeleteModelManifestInput {
    /// Consumes the builder and constructs an Operation<[`DeleteModelManifest`](crate::operation::DeleteModelManifest)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteModelManifest,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteModelManifestInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteModelManifestInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.0",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "IoTAutobahnControlPlane.DeleteModelManifest",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_delete_model_manifest::ser_delete_model_manifest_input(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteModelManifest::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteModelManifest",
            "iotfleetwise",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DeleteSignalCatalogInput {
    /// Consumes the builder and constructs an Operation<[`DeleteSignalCatalog`](crate::operation::DeleteSignalCatalog)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteSignalCatalog,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteSignalCatalogInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteSignalCatalogInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.0",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "IoTAutobahnControlPlane.DeleteSignalCatalog",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_delete_signal_catalog::ser_delete_signal_catalog_input(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteSignalCatalog::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteSignalCatalog",
            "iotfleetwise",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DeleteVehicleInput {
    /// Consumes the builder and constructs an Operation<[`DeleteVehicle`](crate::operation::DeleteVehicle)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteVehicle,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteVehicleInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteVehicleInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.0",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "IoTAutobahnControlPlane.DeleteVehicle",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_delete_vehicle::ser_delete_vehicle_input(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteVehicle::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteVehicle",
            "iotfleetwise",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DisassociateVehicleFleetInput {
    /// Consumes the builder and constructs an Operation<[`DisassociateVehicleFleet`](crate::operation::DisassociateVehicleFleet)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DisassociateVehicleFleet,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DisassociateVehicleFleetInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DisassociateVehicleFleetInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.0",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "IoTAutobahnControlPlane.DisassociateVehicleFleet",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_disassociate_vehicle_fleet::ser_disassociate_vehicle_fleet_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DisassociateVehicleFleet::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DisassociateVehicleFleet",
            "iotfleetwise",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetCampaignInput {
    /// Consumes the builder and constructs an Operation<[`GetCampaign`](crate::operation::GetCampaign)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetCampaign,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetCampaignInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetCampaignInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.0",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "IoTAutobahnControlPlane.GetCampaign",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_get_campaign::ser_get_campaign_input(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetCampaign::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetCampaign",
            "iotfleetwise",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetDecoderManifestInput {
    /// Consumes the builder and constructs an Operation<[`GetDecoderManifest`](crate::operation::GetDecoderManifest)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetDecoderManifest,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetDecoderManifestInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetDecoderManifestInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.0",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "IoTAutobahnControlPlane.GetDecoderManifest",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_get_decoder_manifest::ser_get_decoder_manifest_input(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetDecoderManifest::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetDecoderManifest",
            "iotfleetwise",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetFleetInput {
    /// Consumes the builder and constructs an Operation<[`GetFleet`](crate::operation::GetFleet)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetFleet,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetFleetInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetFleetInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.0",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "IoTAutobahnControlPlane.GetFleet",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_get_fleet::ser_get_fleet_input(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op =
            aws_smithy_http::operation::Operation::new(request, crate::operation::GetFleet::new())
                .with_metadata(aws_smithy_http::operation::Metadata::new(
                    "GetFleet",
                    "iotfleetwise",
                ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetLoggingOptionsInput {
    /// Consumes the builder and constructs an Operation<[`GetLoggingOptions`](crate::operation::GetLoggingOptions)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetLoggingOptions,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetLoggingOptionsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetLoggingOptionsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.0",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "IoTAutobahnControlPlane.GetLoggingOptions",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_get_logging_options::ser_get_logging_options_input(&self)?,
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetLoggingOptions::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetLoggingOptions",
            "iotfleetwise",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetModelManifestInput {
    /// Consumes the builder and constructs an Operation<[`GetModelManifest`](crate::operation::GetModelManifest)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetModelManifest,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetModelManifestInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetModelManifestInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.0",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "IoTAutobahnControlPlane.GetModelManifest",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_get_model_manifest::ser_get_model_manifest_input(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetModelManifest::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetModelManifest",
            "iotfleetwise",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetRegisterAccountStatusInput {
    /// Consumes the builder and constructs an Operation<[`GetRegisterAccountStatus`](crate::operation::GetRegisterAccountStatus)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetRegisterAccountStatus,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetRegisterAccountStatusInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetRegisterAccountStatusInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.0",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "IoTAutobahnControlPlane.GetRegisterAccountStatus",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_get_register_account_status::ser_get_register_account_status_input(&self)?
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetRegisterAccountStatus::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetRegisterAccountStatus",
            "iotfleetwise",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetSignalCatalogInput {
    /// Consumes the builder and constructs an Operation<[`GetSignalCatalog`](crate::operation::GetSignalCatalog)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetSignalCatalog,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetSignalCatalogInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetSignalCatalogInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.0",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "IoTAutobahnControlPlane.GetSignalCatalog",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_get_signal_catalog::ser_get_signal_catalog_input(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetSignalCatalog::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetSignalCatalog",
            "iotfleetwise",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetVehicleInput {
    /// Consumes the builder and constructs an Operation<[`GetVehicle`](crate::operation::GetVehicle)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetVehicle,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetVehicleInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetVehicleInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.0",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "IoTAutobahnControlPlane.GetVehicle",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_get_vehicle::ser_get_vehicle_input(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetVehicle::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetVehicle",
            "iotfleetwise",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetVehicleStatusInput {
    /// Consumes the builder and constructs an Operation<[`GetVehicleStatus`](crate::operation::GetVehicleStatus)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetVehicleStatus,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetVehicleStatusInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::GetVehicleStatusInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_1) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_1));
                    }
                }
                if let Some(inner_2) = &_input.max_results {
                    if *inner_2 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_2).encode(),
                        );
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetVehicleStatusInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.0",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "IoTAutobahnControlPlane.GetVehicleStatus",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_get_vehicle_status::ser_get_vehicle_status_input(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetVehicleStatus::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetVehicleStatus",
            "iotfleetwise",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ImportDecoderManifestInput {
    /// Consumes the builder and constructs an Operation<[`ImportDecoderManifest`](crate::operation::ImportDecoderManifest)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ImportDecoderManifest,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ImportDecoderManifestInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ImportDecoderManifestInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.0",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "IoTAutobahnControlPlane.ImportDecoderManifest",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_import_decoder_manifest::ser_import_decoder_manifest_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ImportDecoderManifest::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ImportDecoderManifest",
            "iotfleetwise",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ImportSignalCatalogInput {
    /// Consumes the builder and constructs an Operation<[`ImportSignalCatalog`](crate::operation::ImportSignalCatalog)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ImportSignalCatalog,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ImportSignalCatalogInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ImportSignalCatalogInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.0",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "IoTAutobahnControlPlane.ImportSignalCatalog",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_import_signal_catalog::ser_import_signal_catalog_input(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ImportSignalCatalog::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ImportSignalCatalog",
            "iotfleetwise",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListCampaignsInput {
    /// Consumes the builder and constructs an Operation<[`ListCampaigns`](crate::operation::ListCampaigns)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListCampaigns,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListCampaignsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListCampaignsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_3) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_3));
                    }
                }
                if let Some(inner_4) = &_input.max_results {
                    if *inner_4 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_4).encode(),
                        );
                    }
                }
                if let Some(inner_5) = &_input.status {
                    {
                        query.push_kv("status", &aws_smithy_http::query::fmt_string(&inner_5));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListCampaignsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.0",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "IoTAutobahnControlPlane.ListCampaigns",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_list_campaigns::ser_list_campaigns_input(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListCampaigns::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListCampaigns",
            "iotfleetwise",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListDecoderManifestNetworkInterfacesInput {
    /// Consumes the builder and constructs an Operation<[`ListDecoderManifestNetworkInterfaces`](crate::operation::ListDecoderManifestNetworkInterfaces)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListDecoderManifestNetworkInterfaces,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListDecoderManifestNetworkInterfacesInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListDecoderManifestNetworkInterfacesInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_6) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_6));
                    }
                }
                if let Some(inner_7) = &_input.max_results {
                    if *inner_7 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_7).encode(),
                        );
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListDecoderManifestNetworkInterfacesInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.0",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "IoTAutobahnControlPlane.ListDecoderManifestNetworkInterfaces",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_list_decoder_manifest_network_interfaces::ser_list_decoder_manifest_network_interfaces_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListDecoderManifestNetworkInterfaces::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListDecoderManifestNetworkInterfaces",
            "iotfleetwise",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListDecoderManifestsInput {
    /// Consumes the builder and constructs an Operation<[`ListDecoderManifests`](crate::operation::ListDecoderManifests)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListDecoderManifests,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListDecoderManifestsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListDecoderManifestsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_8) = &_input.model_manifest_arn {
                    {
                        query.push_kv(
                            "modelManifestArn",
                            &aws_smithy_http::query::fmt_string(&inner_8),
                        );
                    }
                }
                if let Some(inner_9) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_9));
                    }
                }
                if let Some(inner_10) = &_input.max_results {
                    if *inner_10 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_10).encode(),
                        );
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListDecoderManifestsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.0",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "IoTAutobahnControlPlane.ListDecoderManifests",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_list_decoder_manifests::ser_list_decoder_manifests_input(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListDecoderManifests::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListDecoderManifests",
            "iotfleetwise",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListDecoderManifestSignalsInput {
    /// Consumes the builder and constructs an Operation<[`ListDecoderManifestSignals`](crate::operation::ListDecoderManifestSignals)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListDecoderManifestSignals,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListDecoderManifestSignalsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListDecoderManifestSignalsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_11) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_11));
                    }
                }
                if let Some(inner_12) = &_input.max_results {
                    if *inner_12 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_12).encode(),
                        );
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListDecoderManifestSignalsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.0",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "IoTAutobahnControlPlane.ListDecoderManifestSignals",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_list_decoder_manifest_signals::ser_list_decoder_manifest_signals_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListDecoderManifestSignals::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListDecoderManifestSignals",
            "iotfleetwise",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListFleetsInput {
    /// Consumes the builder and constructs an Operation<[`ListFleets`](crate::operation::ListFleets)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListFleets,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListFleetsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListFleetsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_13) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_13));
                    }
                }
                if let Some(inner_14) = &_input.max_results {
                    if *inner_14 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_14).encode(),
                        );
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListFleetsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.0",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "IoTAutobahnControlPlane.ListFleets",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_list_fleets::ser_list_fleets_input(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListFleets::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListFleets",
            "iotfleetwise",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListFleetsForVehicleInput {
    /// Consumes the builder and constructs an Operation<[`ListFleetsForVehicle`](crate::operation::ListFleetsForVehicle)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListFleetsForVehicle,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListFleetsForVehicleInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListFleetsForVehicleInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_15) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_15));
                    }
                }
                if let Some(inner_16) = &_input.max_results {
                    if *inner_16 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_16).encode(),
                        );
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListFleetsForVehicleInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.0",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "IoTAutobahnControlPlane.ListFleetsForVehicle",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_list_fleets_for_vehicle::ser_list_fleets_for_vehicle_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListFleetsForVehicle::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListFleetsForVehicle",
            "iotfleetwise",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListModelManifestNodesInput {
    /// Consumes the builder and constructs an Operation<[`ListModelManifestNodes`](crate::operation::ListModelManifestNodes)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListModelManifestNodes,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListModelManifestNodesInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListModelManifestNodesInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_17) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_17));
                    }
                }
                if let Some(inner_18) = &_input.max_results {
                    if *inner_18 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_18).encode(),
                        );
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListModelManifestNodesInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.0",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "IoTAutobahnControlPlane.ListModelManifestNodes",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_list_model_manifest_nodes::ser_list_model_manifest_nodes_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListModelManifestNodes::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListModelManifestNodes",
            "iotfleetwise",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListModelManifestsInput {
    /// Consumes the builder and constructs an Operation<[`ListModelManifests`](crate::operation::ListModelManifests)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListModelManifests,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListModelManifestsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListModelManifestsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_19) = &_input.signal_catalog_arn {
                    {
                        query.push_kv(
                            "signalCatalogArn",
                            &aws_smithy_http::query::fmt_string(&inner_19),
                        );
                    }
                }
                if let Some(inner_20) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_20));
                    }
                }
                if let Some(inner_21) = &_input.max_results {
                    if *inner_21 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_21).encode(),
                        );
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListModelManifestsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.0",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "IoTAutobahnControlPlane.ListModelManifests",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_list_model_manifests::ser_list_model_manifests_input(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListModelManifests::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListModelManifests",
            "iotfleetwise",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListSignalCatalogNodesInput {
    /// Consumes the builder and constructs an Operation<[`ListSignalCatalogNodes`](crate::operation::ListSignalCatalogNodes)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListSignalCatalogNodes,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListSignalCatalogNodesInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListSignalCatalogNodesInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_22) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_22));
                    }
                }
                if let Some(inner_23) = &_input.max_results {
                    if *inner_23 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_23).encode(),
                        );
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListSignalCatalogNodesInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.0",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "IoTAutobahnControlPlane.ListSignalCatalogNodes",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_list_signal_catalog_nodes::ser_list_signal_catalog_nodes_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListSignalCatalogNodes::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListSignalCatalogNodes",
            "iotfleetwise",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListSignalCatalogsInput {
    /// Consumes the builder and constructs an Operation<[`ListSignalCatalogs`](crate::operation::ListSignalCatalogs)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListSignalCatalogs,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListSignalCatalogsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListSignalCatalogsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_24) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_24));
                    }
                }
                if let Some(inner_25) = &_input.max_results {
                    if *inner_25 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_25).encode(),
                        );
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListSignalCatalogsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.0",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "IoTAutobahnControlPlane.ListSignalCatalogs",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_list_signal_catalogs::ser_list_signal_catalogs_input(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListSignalCatalogs::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListSignalCatalogs",
            "iotfleetwise",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListTagsForResourceInput {
    /// Consumes the builder and constructs an Operation<[`ListTagsForResource`](crate::operation::ListTagsForResource)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListTagsForResource,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListTagsForResourceInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListTagsForResourceInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_26 = &_input.resource_arn;
                let inner_26 = inner_26.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "resource_arn",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_26.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "resource_arn",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv(
                    "resourceArn",
                    &aws_smithy_http::query::fmt_string(&inner_26),
                );
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListTagsForResourceInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.0",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "IoTAutobahnControlPlane.ListTagsForResource",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_list_tags_for_resource::ser_list_tags_for_resource_input(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListTagsForResource::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListTagsForResource",
            "iotfleetwise",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListVehiclesInput {
    /// Consumes the builder and constructs an Operation<[`ListVehicles`](crate::operation::ListVehicles)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListVehicles,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListVehiclesInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListVehiclesInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_27) = &_input.model_manifest_arn {
                    {
                        query.push_kv(
                            "modelManifestArn",
                            &aws_smithy_http::query::fmt_string(&inner_27),
                        );
                    }
                }
                if let Some(inner_28) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_28));
                    }
                }
                if let Some(inner_29) = &_input.max_results {
                    if *inner_29 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_29).encode(),
                        );
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListVehiclesInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.0",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "IoTAutobahnControlPlane.ListVehicles",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_list_vehicles::ser_list_vehicles_input(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListVehicles::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListVehicles",
            "iotfleetwise",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListVehiclesInFleetInput {
    /// Consumes the builder and constructs an Operation<[`ListVehiclesInFleet`](crate::operation::ListVehiclesInFleet)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListVehiclesInFleet,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListVehiclesInFleetInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListVehiclesInFleetInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_30) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_30));
                    }
                }
                if let Some(inner_31) = &_input.max_results {
                    if *inner_31 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_31).encode(),
                        );
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListVehiclesInFleetInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.0",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "IoTAutobahnControlPlane.ListVehiclesInFleet",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_list_vehicles_in_fleet::ser_list_vehicles_in_fleet_input(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListVehiclesInFleet::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListVehiclesInFleet",
            "iotfleetwise",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl PutLoggingOptionsInput {
    /// Consumes the builder and constructs an Operation<[`PutLoggingOptions`](crate::operation::PutLoggingOptions)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::PutLoggingOptions,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::PutLoggingOptionsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::PutLoggingOptionsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.0",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "IoTAutobahnControlPlane.PutLoggingOptions",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_put_logging_options::ser_put_logging_options_input(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::PutLoggingOptions::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "PutLoggingOptions",
            "iotfleetwise",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl RegisterAccountInput {
    /// Consumes the builder and constructs an Operation<[`RegisterAccount`](crate::operation::RegisterAccount)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::RegisterAccount,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::RegisterAccountInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::RegisterAccountInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.0",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "IoTAutobahnControlPlane.RegisterAccount",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_register_account::ser_register_account_input(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::RegisterAccount::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "RegisterAccount",
            "iotfleetwise",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl TagResourceInput {
    /// Consumes the builder and constructs an Operation<[`TagResource`](crate::operation::TagResource)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::TagResource,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::TagResourceInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::TagResourceInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_32 = &_input.resource_arn;
                let inner_32 = inner_32.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "resource_arn",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_32.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "resource_arn",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv(
                    "resourceArn",
                    &aws_smithy_http::query::fmt_string(&inner_32),
                );
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::TagResourceInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.0",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "IoTAutobahnControlPlane.TagResource",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_tag_resource::ser_tag_resource_input(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::TagResource::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "TagResource",
            "iotfleetwise",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl UntagResourceInput {
    /// Consumes the builder and constructs an Operation<[`UntagResource`](crate::operation::UntagResource)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UntagResource,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::UntagResourceInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::UntagResourceInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_33 = &_input.resource_arn;
                let inner_33 = inner_33.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "resource_arn",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_33.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "resource_arn",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv(
                    "resourceArn",
                    &aws_smithy_http::query::fmt_string(&inner_33),
                );
                let inner_34 = &_input.tag_keys;
                let inner_34 = inner_34.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "tag_keys",
                        "cannot be empty or unset",
                    )
                })?;
                for inner_35 in inner_34 {
                    query.push_kv("tagKeys", &aws_smithy_http::query::fmt_string(&inner_35));
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UntagResourceInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.0",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "IoTAutobahnControlPlane.UntagResource",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_untag_resource::ser_untag_resource_input(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UntagResource::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UntagResource",
            "iotfleetwise",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl UpdateCampaignInput {
    /// Consumes the builder and constructs an Operation<[`UpdateCampaign`](crate::operation::UpdateCampaign)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateCampaign,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateCampaignInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateCampaignInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.0",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "IoTAutobahnControlPlane.UpdateCampaign",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_update_campaign::ser_update_campaign_input(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateCampaign::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateCampaign",
            "iotfleetwise",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl UpdateDecoderManifestInput {
    /// Consumes the builder and constructs an Operation<[`UpdateDecoderManifest`](crate::operation::UpdateDecoderManifest)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateDecoderManifest,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateDecoderManifestInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateDecoderManifestInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.0",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "IoTAutobahnControlPlane.UpdateDecoderManifest",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_update_decoder_manifest::ser_update_decoder_manifest_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateDecoderManifest::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateDecoderManifest",
            "iotfleetwise",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl UpdateFleetInput {
    /// Consumes the builder and constructs an Operation<[`UpdateFleet`](crate::operation::UpdateFleet)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateFleet,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateFleetInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateFleetInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.0",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "IoTAutobahnControlPlane.UpdateFleet",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_update_fleet::ser_update_fleet_input(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateFleet::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateFleet",
            "iotfleetwise",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl UpdateModelManifestInput {
    /// Consumes the builder and constructs an Operation<[`UpdateModelManifest`](crate::operation::UpdateModelManifest)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateModelManifest,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateModelManifestInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateModelManifestInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.0",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "IoTAutobahnControlPlane.UpdateModelManifest",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_update_model_manifest::ser_update_model_manifest_input(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateModelManifest::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateModelManifest",
            "iotfleetwise",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl UpdateSignalCatalogInput {
    /// Consumes the builder and constructs an Operation<[`UpdateSignalCatalog`](crate::operation::UpdateSignalCatalog)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateSignalCatalog,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateSignalCatalogInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateSignalCatalogInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.0",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "IoTAutobahnControlPlane.UpdateSignalCatalog",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_update_signal_catalog::ser_update_signal_catalog_input(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateSignalCatalog::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateSignalCatalog",
            "iotfleetwise",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl UpdateVehicleInput {
    /// Consumes the builder and constructs an Operation<[`UpdateVehicle`](crate::operation::UpdateVehicle)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateVehicle,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateVehicleInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateVehicleInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.0",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "IoTAutobahnControlPlane.UpdateVehicle",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_update_vehicle::ser_update_vehicle_input(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateVehicle::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateVehicle",
            "iotfleetwise",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DisassociateVehicleFleetInput {
    /// <p> The unique ID of the vehicle to disassociate from the fleet.</p>
    #[doc(hidden)]
    pub vehicle_name: std::option::Option<std::string::String>,
    /// <p> The unique ID of a fleet. </p>
    #[doc(hidden)]
    pub fleet_id: std::option::Option<std::string::String>,
}
impl DisassociateVehicleFleetInput {
    /// <p> The unique ID of the vehicle to disassociate from the fleet.</p>
    pub fn vehicle_name(&self) -> std::option::Option<&str> {
        self.vehicle_name.as_deref()
    }
    /// <p> The unique ID of a fleet. </p>
    pub fn fleet_id(&self) -> std::option::Option<&str> {
        self.fleet_id.as_deref()
    }
}
impl DisassociateVehicleFleetInput {
    /// Creates a new builder-style object to manufacture [`DisassociateVehicleFleetInput`](crate::input::DisassociateVehicleFleetInput).
    pub fn builder() -> crate::input::disassociate_vehicle_fleet_input::Builder {
        crate::input::disassociate_vehicle_fleet_input::Builder::default()
    }
}

/// See [`DisassociateVehicleFleetInput`](crate::input::DisassociateVehicleFleetInput).
pub mod disassociate_vehicle_fleet_input {

    /// A builder for [`DisassociateVehicleFleetInput`](crate::input::DisassociateVehicleFleetInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) vehicle_name: std::option::Option<std::string::String>,
        pub(crate) fleet_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The unique ID of the vehicle to disassociate from the fleet.</p>
        pub fn vehicle_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.vehicle_name = Some(input.into());
            self
        }
        /// <p> The unique ID of the vehicle to disassociate from the fleet.</p>
        pub fn set_vehicle_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vehicle_name = input;
            self
        }
        /// <p> The unique ID of a fleet. </p>
        pub fn fleet_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.fleet_id = Some(input.into());
            self
        }
        /// <p> The unique ID of a fleet. </p>
        pub fn set_fleet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.fleet_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DisassociateVehicleFleetInput`](crate::input::DisassociateVehicleFleetInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::DisassociateVehicleFleetInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::DisassociateVehicleFleetInput {
                vehicle_name: self.vehicle_name,
                fleet_id: self.fleet_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AssociateVehicleFleetInput {
    /// <p> The unique ID of the vehicle to associate with the fleet. </p>
    #[doc(hidden)]
    pub vehicle_name: std::option::Option<std::string::String>,
    /// <p> The ID of a fleet. </p>
    #[doc(hidden)]
    pub fleet_id: std::option::Option<std::string::String>,
}
impl AssociateVehicleFleetInput {
    /// <p> The unique ID of the vehicle to associate with the fleet. </p>
    pub fn vehicle_name(&self) -> std::option::Option<&str> {
        self.vehicle_name.as_deref()
    }
    /// <p> The ID of a fleet. </p>
    pub fn fleet_id(&self) -> std::option::Option<&str> {
        self.fleet_id.as_deref()
    }
}
impl AssociateVehicleFleetInput {
    /// Creates a new builder-style object to manufacture [`AssociateVehicleFleetInput`](crate::input::AssociateVehicleFleetInput).
    pub fn builder() -> crate::input::associate_vehicle_fleet_input::Builder {
        crate::input::associate_vehicle_fleet_input::Builder::default()
    }
}

/// See [`AssociateVehicleFleetInput`](crate::input::AssociateVehicleFleetInput).
pub mod associate_vehicle_fleet_input {

    /// A builder for [`AssociateVehicleFleetInput`](crate::input::AssociateVehicleFleetInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) vehicle_name: std::option::Option<std::string::String>,
        pub(crate) fleet_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The unique ID of the vehicle to associate with the fleet. </p>
        pub fn vehicle_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.vehicle_name = Some(input.into());
            self
        }
        /// <p> The unique ID of the vehicle to associate with the fleet. </p>
        pub fn set_vehicle_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vehicle_name = input;
            self
        }
        /// <p> The ID of a fleet. </p>
        pub fn fleet_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.fleet_id = Some(input.into());
            self
        }
        /// <p> The ID of a fleet. </p>
        pub fn set_fleet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.fleet_id = input;
            self
        }
        /// Consumes the builder and constructs a [`AssociateVehicleFleetInput`](crate::input::AssociateVehicleFleetInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::AssociateVehicleFleetInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::AssociateVehicleFleetInput {
                vehicle_name: self.vehicle_name,
                fleet_id: self.fleet_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListVehiclesInput {
    /// <p> The Amazon Resource Name (ARN) of a vehicle model (model manifest). You can use this optional parameter to list only the vehicles created from a certain vehicle model. </p>
    #[doc(hidden)]
    pub model_manifest_arn: std::option::Option<std::string::String>,
    /// <p>A pagination token for the next set of results.</p>
    /// <p>If the results of a search are large, only a portion of the results are returned, and a <code>nextToken</code> pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value. </p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p> The maximum number of items to return, between 1 and 100, inclusive. </p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl ListVehiclesInput {
    /// <p> The Amazon Resource Name (ARN) of a vehicle model (model manifest). You can use this optional parameter to list only the vehicles created from a certain vehicle model. </p>
    pub fn model_manifest_arn(&self) -> std::option::Option<&str> {
        self.model_manifest_arn.as_deref()
    }
    /// <p>A pagination token for the next set of results.</p>
    /// <p>If the results of a search are large, only a portion of the results are returned, and a <code>nextToken</code> pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value. </p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p> The maximum number of items to return, between 1 and 100, inclusive. </p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}
impl ListVehiclesInput {
    /// Creates a new builder-style object to manufacture [`ListVehiclesInput`](crate::input::ListVehiclesInput).
    pub fn builder() -> crate::input::list_vehicles_input::Builder {
        crate::input::list_vehicles_input::Builder::default()
    }
}

/// See [`ListVehiclesInput`](crate::input::ListVehiclesInput).
pub mod list_vehicles_input {

    /// A builder for [`ListVehiclesInput`](crate::input::ListVehiclesInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) model_manifest_arn: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p> The Amazon Resource Name (ARN) of a vehicle model (model manifest). You can use this optional parameter to list only the vehicles created from a certain vehicle model. </p>
        pub fn model_manifest_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_manifest_arn = Some(input.into());
            self
        }
        /// <p> The Amazon Resource Name (ARN) of a vehicle model (model manifest). You can use this optional parameter to list only the vehicles created from a certain vehicle model. </p>
        pub fn set_model_manifest_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_manifest_arn = input;
            self
        }
        /// <p>A pagination token for the next set of results.</p>
        /// <p>If the results of a search are large, only a portion of the results are returned, and a <code>nextToken</code> pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>A pagination token for the next set of results.</p>
        /// <p>If the results of a search are large, only a portion of the results are returned, and a <code>nextToken</code> pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p> The maximum number of items to return, between 1 and 100, inclusive. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p> The maximum number of items to return, between 1 and 100, inclusive. </p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListVehiclesInput`](crate::input::ListVehiclesInput).
        pub fn build(
            self,
        ) -> Result<crate::input::ListVehiclesInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::ListVehiclesInput {
                model_manifest_arn: self.model_manifest_arn,
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateVehicleInput {
    /// <p> The unique ID of the vehicle to create. </p>
    #[doc(hidden)]
    pub vehicle_name: std::option::Option<std::string::String>,
    /// <p> The Amazon Resource Name ARN of a vehicle model. </p>
    #[doc(hidden)]
    pub model_manifest_arn: std::option::Option<std::string::String>,
    /// <p> The ARN of a decoder manifest. </p>
    #[doc(hidden)]
    pub decoder_manifest_arn: std::option::Option<std::string::String>,
    /// <p>Static information about a vehicle in a key-value pair. For example: <code>"engineType"</code> : <code>"1.3 L R2"</code> </p>
    #[doc(hidden)]
    pub attributes:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p> An option to create a new Amazon Web Services IoT thing when creating a vehicle, or to validate an existing Amazon Web Services IoT thing as a vehicle. </p>
    /// <p>Default: <code></code> </p>
    #[doc(hidden)]
    pub association_behavior: std::option::Option<crate::model::VehicleAssociationBehavior>,
    /// <p>Metadata that can be used to manage the vehicle.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl CreateVehicleInput {
    /// <p> The unique ID of the vehicle to create. </p>
    pub fn vehicle_name(&self) -> std::option::Option<&str> {
        self.vehicle_name.as_deref()
    }
    /// <p> The Amazon Resource Name ARN of a vehicle model. </p>
    pub fn model_manifest_arn(&self) -> std::option::Option<&str> {
        self.model_manifest_arn.as_deref()
    }
    /// <p> The ARN of a decoder manifest. </p>
    pub fn decoder_manifest_arn(&self) -> std::option::Option<&str> {
        self.decoder_manifest_arn.as_deref()
    }
    /// <p>Static information about a vehicle in a key-value pair. For example: <code>"engineType"</code> : <code>"1.3 L R2"</code> </p>
    pub fn attributes(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.attributes.as_ref()
    }
    /// <p> An option to create a new Amazon Web Services IoT thing when creating a vehicle, or to validate an existing Amazon Web Services IoT thing as a vehicle. </p>
    /// <p>Default: <code></code> </p>
    pub fn association_behavior(
        &self,
    ) -> std::option::Option<&crate::model::VehicleAssociationBehavior> {
        self.association_behavior.as_ref()
    }
    /// <p>Metadata that can be used to manage the vehicle.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
}
impl CreateVehicleInput {
    /// Creates a new builder-style object to manufacture [`CreateVehicleInput`](crate::input::CreateVehicleInput).
    pub fn builder() -> crate::input::create_vehicle_input::Builder {
        crate::input::create_vehicle_input::Builder::default()
    }
}

/// See [`CreateVehicleInput`](crate::input::CreateVehicleInput).
pub mod create_vehicle_input {

    /// A builder for [`CreateVehicleInput`](crate::input::CreateVehicleInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) vehicle_name: std::option::Option<std::string::String>,
        pub(crate) model_manifest_arn: std::option::Option<std::string::String>,
        pub(crate) decoder_manifest_arn: std::option::Option<std::string::String>,
        pub(crate) attributes: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) association_behavior:
            std::option::Option<crate::model::VehicleAssociationBehavior>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p> The unique ID of the vehicle to create. </p>
        pub fn vehicle_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.vehicle_name = Some(input.into());
            self
        }
        /// <p> The unique ID of the vehicle to create. </p>
        pub fn set_vehicle_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vehicle_name = input;
            self
        }
        /// <p> The Amazon Resource Name ARN of a vehicle model. </p>
        pub fn model_manifest_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_manifest_arn = Some(input.into());
            self
        }
        /// <p> The Amazon Resource Name ARN of a vehicle model. </p>
        pub fn set_model_manifest_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_manifest_arn = input;
            self
        }
        /// <p> The ARN of a decoder manifest. </p>
        pub fn decoder_manifest_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.decoder_manifest_arn = Some(input.into());
            self
        }
        /// <p> The ARN of a decoder manifest. </p>
        pub fn set_decoder_manifest_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.decoder_manifest_arn = input;
            self
        }
        /// Adds a key-value pair to `attributes`.
        ///
        /// To override the contents of this collection use [`set_attributes`](Self::set_attributes).
        ///
        /// <p>Static information about a vehicle in a key-value pair. For example: <code>"engineType"</code> : <code>"1.3 L R2"</code> </p>
        pub fn attributes(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.attributes.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.attributes = Some(hash_map);
            self
        }
        /// <p>Static information about a vehicle in a key-value pair. For example: <code>"engineType"</code> : <code>"1.3 L R2"</code> </p>
        pub fn set_attributes(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.attributes = input;
            self
        }
        /// <p> An option to create a new Amazon Web Services IoT thing when creating a vehicle, or to validate an existing Amazon Web Services IoT thing as a vehicle. </p>
        /// <p>Default: <code></code> </p>
        pub fn association_behavior(
            mut self,
            input: crate::model::VehicleAssociationBehavior,
        ) -> Self {
            self.association_behavior = Some(input);
            self
        }
        /// <p> An option to create a new Amazon Web Services IoT thing when creating a vehicle, or to validate an existing Amazon Web Services IoT thing as a vehicle. </p>
        /// <p>Default: <code></code> </p>
        pub fn set_association_behavior(
            mut self,
            input: std::option::Option<crate::model::VehicleAssociationBehavior>,
        ) -> Self {
            self.association_behavior = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Metadata that can be used to manage the vehicle.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>Metadata that can be used to manage the vehicle.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateVehicleInput`](crate::input::CreateVehicleInput).
        pub fn build(
            self,
        ) -> Result<crate::input::CreateVehicleInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::CreateVehicleInput {
                vehicle_name: self.vehicle_name,
                model_manifest_arn: self.model_manifest_arn,
                decoder_manifest_arn: self.decoder_manifest_arn,
                attributes: self.attributes,
                association_behavior: self.association_behavior,
                tags: self.tags,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteVehicleInput {
    /// <p>The ID of the vehicle to delete. </p>
    #[doc(hidden)]
    pub vehicle_name: std::option::Option<std::string::String>,
}
impl DeleteVehicleInput {
    /// <p>The ID of the vehicle to delete. </p>
    pub fn vehicle_name(&self) -> std::option::Option<&str> {
        self.vehicle_name.as_deref()
    }
}
impl DeleteVehicleInput {
    /// Creates a new builder-style object to manufacture [`DeleteVehicleInput`](crate::input::DeleteVehicleInput).
    pub fn builder() -> crate::input::delete_vehicle_input::Builder {
        crate::input::delete_vehicle_input::Builder::default()
    }
}

/// See [`DeleteVehicleInput`](crate::input::DeleteVehicleInput).
pub mod delete_vehicle_input {

    /// A builder for [`DeleteVehicleInput`](crate::input::DeleteVehicleInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) vehicle_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the vehicle to delete. </p>
        pub fn vehicle_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.vehicle_name = Some(input.into());
            self
        }
        /// <p>The ID of the vehicle to delete. </p>
        pub fn set_vehicle_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vehicle_name = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteVehicleInput`](crate::input::DeleteVehicleInput).
        pub fn build(
            self,
        ) -> Result<crate::input::DeleteVehicleInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::DeleteVehicleInput {
                vehicle_name: self.vehicle_name,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateVehicleInput {
    /// <p>The unique ID of the vehicle to update.</p>
    #[doc(hidden)]
    pub vehicle_name: std::option::Option<std::string::String>,
    /// <p>The ARN of a vehicle model (model manifest) associated with the vehicle.</p>
    #[doc(hidden)]
    pub model_manifest_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of the decoder manifest associated with this vehicle.</p>
    #[doc(hidden)]
    pub decoder_manifest_arn: std::option::Option<std::string::String>,
    /// <p>Static information about a vehicle in a key-value pair. For example:</p>
    /// <p> <code>"engineType"</code> : <code>"1.3 L R2"</code> </p>
    #[doc(hidden)]
    pub attributes:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The method the specified attributes will update the existing attributes on the vehicle. Use<code>Overwite</code> to replace the vehicle attributes with the specified attributes. Or use <code>Merge</code> to combine all attributes.</p>
    /// <p>This is required if attributes are present in the input.</p>
    #[doc(hidden)]
    pub attribute_update_mode: std::option::Option<crate::model::UpdateMode>,
}
impl UpdateVehicleInput {
    /// <p>The unique ID of the vehicle to update.</p>
    pub fn vehicle_name(&self) -> std::option::Option<&str> {
        self.vehicle_name.as_deref()
    }
    /// <p>The ARN of a vehicle model (model manifest) associated with the vehicle.</p>
    pub fn model_manifest_arn(&self) -> std::option::Option<&str> {
        self.model_manifest_arn.as_deref()
    }
    /// <p>The ARN of the decoder manifest associated with this vehicle.</p>
    pub fn decoder_manifest_arn(&self) -> std::option::Option<&str> {
        self.decoder_manifest_arn.as_deref()
    }
    /// <p>Static information about a vehicle in a key-value pair. For example:</p>
    /// <p> <code>"engineType"</code> : <code>"1.3 L R2"</code> </p>
    pub fn attributes(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.attributes.as_ref()
    }
    /// <p>The method the specified attributes will update the existing attributes on the vehicle. Use<code>Overwite</code> to replace the vehicle attributes with the specified attributes. Or use <code>Merge</code> to combine all attributes.</p>
    /// <p>This is required if attributes are present in the input.</p>
    pub fn attribute_update_mode(&self) -> std::option::Option<&crate::model::UpdateMode> {
        self.attribute_update_mode.as_ref()
    }
}
impl UpdateVehicleInput {
    /// Creates a new builder-style object to manufacture [`UpdateVehicleInput`](crate::input::UpdateVehicleInput).
    pub fn builder() -> crate::input::update_vehicle_input::Builder {
        crate::input::update_vehicle_input::Builder::default()
    }
}

/// See [`UpdateVehicleInput`](crate::input::UpdateVehicleInput).
pub mod update_vehicle_input {

    /// A builder for [`UpdateVehicleInput`](crate::input::UpdateVehicleInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) vehicle_name: std::option::Option<std::string::String>,
        pub(crate) model_manifest_arn: std::option::Option<std::string::String>,
        pub(crate) decoder_manifest_arn: std::option::Option<std::string::String>,
        pub(crate) attributes: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) attribute_update_mode: std::option::Option<crate::model::UpdateMode>,
    }
    impl Builder {
        /// <p>The unique ID of the vehicle to update.</p>
        pub fn vehicle_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.vehicle_name = Some(input.into());
            self
        }
        /// <p>The unique ID of the vehicle to update.</p>
        pub fn set_vehicle_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vehicle_name = input;
            self
        }
        /// <p>The ARN of a vehicle model (model manifest) associated with the vehicle.</p>
        pub fn model_manifest_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_manifest_arn = Some(input.into());
            self
        }
        /// <p>The ARN of a vehicle model (model manifest) associated with the vehicle.</p>
        pub fn set_model_manifest_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_manifest_arn = input;
            self
        }
        /// <p>The ARN of the decoder manifest associated with this vehicle.</p>
        pub fn decoder_manifest_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.decoder_manifest_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the decoder manifest associated with this vehicle.</p>
        pub fn set_decoder_manifest_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.decoder_manifest_arn = input;
            self
        }
        /// Adds a key-value pair to `attributes`.
        ///
        /// To override the contents of this collection use [`set_attributes`](Self::set_attributes).
        ///
        /// <p>Static information about a vehicle in a key-value pair. For example:</p>
        /// <p> <code>"engineType"</code> : <code>"1.3 L R2"</code> </p>
        pub fn attributes(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.attributes.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.attributes = Some(hash_map);
            self
        }
        /// <p>Static information about a vehicle in a key-value pair. For example:</p>
        /// <p> <code>"engineType"</code> : <code>"1.3 L R2"</code> </p>
        pub fn set_attributes(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.attributes = input;
            self
        }
        /// <p>The method the specified attributes will update the existing attributes on the vehicle. Use<code>Overwite</code> to replace the vehicle attributes with the specified attributes. Or use <code>Merge</code> to combine all attributes.</p>
        /// <p>This is required if attributes are present in the input.</p>
        pub fn attribute_update_mode(mut self, input: crate::model::UpdateMode) -> Self {
            self.attribute_update_mode = Some(input);
            self
        }
        /// <p>The method the specified attributes will update the existing attributes on the vehicle. Use<code>Overwite</code> to replace the vehicle attributes with the specified attributes. Or use <code>Merge</code> to combine all attributes.</p>
        /// <p>This is required if attributes are present in the input.</p>
        pub fn set_attribute_update_mode(
            mut self,
            input: std::option::Option<crate::model::UpdateMode>,
        ) -> Self {
            self.attribute_update_mode = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateVehicleInput`](crate::input::UpdateVehicleInput).
        pub fn build(
            self,
        ) -> Result<crate::input::UpdateVehicleInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::UpdateVehicleInput {
                vehicle_name: self.vehicle_name,
                model_manifest_arn: self.model_manifest_arn,
                decoder_manifest_arn: self.decoder_manifest_arn,
                attributes: self.attributes,
                attribute_update_mode: self.attribute_update_mode,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetVehicleInput {
    /// <p> The ID of the vehicle to retrieve information about. </p>
    #[doc(hidden)]
    pub vehicle_name: std::option::Option<std::string::String>,
}
impl GetVehicleInput {
    /// <p> The ID of the vehicle to retrieve information about. </p>
    pub fn vehicle_name(&self) -> std::option::Option<&str> {
        self.vehicle_name.as_deref()
    }
}
impl GetVehicleInput {
    /// Creates a new builder-style object to manufacture [`GetVehicleInput`](crate::input::GetVehicleInput).
    pub fn builder() -> crate::input::get_vehicle_input::Builder {
        crate::input::get_vehicle_input::Builder::default()
    }
}

/// See [`GetVehicleInput`](crate::input::GetVehicleInput).
pub mod get_vehicle_input {

    /// A builder for [`GetVehicleInput`](crate::input::GetVehicleInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) vehicle_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The ID of the vehicle to retrieve information about. </p>
        pub fn vehicle_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.vehicle_name = Some(input.into());
            self
        }
        /// <p> The ID of the vehicle to retrieve information about. </p>
        pub fn set_vehicle_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vehicle_name = input;
            self
        }
        /// Consumes the builder and constructs a [`GetVehicleInput`](crate::input::GetVehicleInput).
        pub fn build(
            self,
        ) -> Result<crate::input::GetVehicleInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::GetVehicleInput {
                vehicle_name: self.vehicle_name,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListFleetsForVehicleInput {
    /// <p> The ID of the vehicle to retrieve information about. </p>
    #[doc(hidden)]
    pub vehicle_name: std::option::Option<std::string::String>,
    /// <p>A pagination token for the next set of results.</p>
    /// <p>If the results of a search are large, only a portion of the results are returned, and a <code>nextToken</code> pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value. </p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p> The maximum number of items to return, between 1 and 100, inclusive. </p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl ListFleetsForVehicleInput {
    /// <p> The ID of the vehicle to retrieve information about. </p>
    pub fn vehicle_name(&self) -> std::option::Option<&str> {
        self.vehicle_name.as_deref()
    }
    /// <p>A pagination token for the next set of results.</p>
    /// <p>If the results of a search are large, only a portion of the results are returned, and a <code>nextToken</code> pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value. </p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p> The maximum number of items to return, between 1 and 100, inclusive. </p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}
impl ListFleetsForVehicleInput {
    /// Creates a new builder-style object to manufacture [`ListFleetsForVehicleInput`](crate::input::ListFleetsForVehicleInput).
    pub fn builder() -> crate::input::list_fleets_for_vehicle_input::Builder {
        crate::input::list_fleets_for_vehicle_input::Builder::default()
    }
}

/// See [`ListFleetsForVehicleInput`](crate::input::ListFleetsForVehicleInput).
pub mod list_fleets_for_vehicle_input {

    /// A builder for [`ListFleetsForVehicleInput`](crate::input::ListFleetsForVehicleInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) vehicle_name: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p> The ID of the vehicle to retrieve information about. </p>
        pub fn vehicle_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.vehicle_name = Some(input.into());
            self
        }
        /// <p> The ID of the vehicle to retrieve information about. </p>
        pub fn set_vehicle_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vehicle_name = input;
            self
        }
        /// <p>A pagination token for the next set of results.</p>
        /// <p>If the results of a search are large, only a portion of the results are returned, and a <code>nextToken</code> pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>A pagination token for the next set of results.</p>
        /// <p>If the results of a search are large, only a portion of the results are returned, and a <code>nextToken</code> pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p> The maximum number of items to return, between 1 and 100, inclusive. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p> The maximum number of items to return, between 1 and 100, inclusive. </p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListFleetsForVehicleInput`](crate::input::ListFleetsForVehicleInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::ListFleetsForVehicleInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::ListFleetsForVehicleInput {
                vehicle_name: self.vehicle_name,
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListSignalCatalogNodesInput {
    /// <p> The name of the signal catalog to list information about. </p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>A pagination token for the next set of results.</p>
    /// <p>If the results of a search are large, only a portion of the results are returned, and a <code>nextToken</code> pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value. </p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p> The maximum number of items to return, between 1 and 100, inclusive. </p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl ListSignalCatalogNodesInput {
    /// <p> The name of the signal catalog to list information about. </p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A pagination token for the next set of results.</p>
    /// <p>If the results of a search are large, only a portion of the results are returned, and a <code>nextToken</code> pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value. </p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p> The maximum number of items to return, between 1 and 100, inclusive. </p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}
impl ListSignalCatalogNodesInput {
    /// Creates a new builder-style object to manufacture [`ListSignalCatalogNodesInput`](crate::input::ListSignalCatalogNodesInput).
    pub fn builder() -> crate::input::list_signal_catalog_nodes_input::Builder {
        crate::input::list_signal_catalog_nodes_input::Builder::default()
    }
}

/// See [`ListSignalCatalogNodesInput`](crate::input::ListSignalCatalogNodesInput).
pub mod list_signal_catalog_nodes_input {

    /// A builder for [`ListSignalCatalogNodesInput`](crate::input::ListSignalCatalogNodesInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p> The name of the signal catalog to list information about. </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p> The name of the signal catalog to list information about. </p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A pagination token for the next set of results.</p>
        /// <p>If the results of a search are large, only a portion of the results are returned, and a <code>nextToken</code> pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>A pagination token for the next set of results.</p>
        /// <p>If the results of a search are large, only a portion of the results are returned, and a <code>nextToken</code> pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p> The maximum number of items to return, between 1 and 100, inclusive. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p> The maximum number of items to return, between 1 and 100, inclusive. </p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListSignalCatalogNodesInput`](crate::input::ListSignalCatalogNodesInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::ListSignalCatalogNodesInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::ListSignalCatalogNodesInput {
                name: self.name,
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ImportSignalCatalogInput {
    /// <p>The name of the signal catalog to import.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p> A brief description of the signal catalog. </p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The contents of the Vehicle Signal Specification (VSS) configuration. VSS is a precise language used to describe and model signals in vehicle networks.</p>
    #[doc(hidden)]
    pub vss: std::option::Option<crate::model::FormattedVss>,
    /// <p>Metadata that can be used to manage the signal catalog.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl ImportSignalCatalogInput {
    /// <p>The name of the signal catalog to import.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p> A brief description of the signal catalog. </p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The contents of the Vehicle Signal Specification (VSS) configuration. VSS is a precise language used to describe and model signals in vehicle networks.</p>
    pub fn vss(&self) -> std::option::Option<&crate::model::FormattedVss> {
        self.vss.as_ref()
    }
    /// <p>Metadata that can be used to manage the signal catalog.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
}
impl ImportSignalCatalogInput {
    /// Creates a new builder-style object to manufacture [`ImportSignalCatalogInput`](crate::input::ImportSignalCatalogInput).
    pub fn builder() -> crate::input::import_signal_catalog_input::Builder {
        crate::input::import_signal_catalog_input::Builder::default()
    }
}

/// See [`ImportSignalCatalogInput`](crate::input::ImportSignalCatalogInput).
pub mod import_signal_catalog_input {

    /// A builder for [`ImportSignalCatalogInput`](crate::input::ImportSignalCatalogInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) vss: std::option::Option<crate::model::FormattedVss>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The name of the signal catalog to import.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the signal catalog to import.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p> A brief description of the signal catalog. </p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p> A brief description of the signal catalog. </p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The contents of the Vehicle Signal Specification (VSS) configuration. VSS is a precise language used to describe and model signals in vehicle networks.</p>
        pub fn vss(mut self, input: crate::model::FormattedVss) -> Self {
            self.vss = Some(input);
            self
        }
        /// <p>The contents of the Vehicle Signal Specification (VSS) configuration. VSS is a precise language used to describe and model signals in vehicle networks.</p>
        pub fn set_vss(mut self, input: std::option::Option<crate::model::FormattedVss>) -> Self {
            self.vss = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Metadata that can be used to manage the signal catalog.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>Metadata that can be used to manage the signal catalog.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`ImportSignalCatalogInput`](crate::input::ImportSignalCatalogInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::ImportSignalCatalogInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::ImportSignalCatalogInput {
                name: self.name,
                description: self.description,
                vss: self.vss,
                tags: self.tags,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListSignalCatalogsInput {
    /// <p>A pagination token for the next set of results.</p>
    /// <p>If the results of a search are large, only a portion of the results are returned, and a <code>nextToken</code> pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value. </p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p> The maximum number of items to return, between 1 and 100, inclusive. </p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl ListSignalCatalogsInput {
    /// <p>A pagination token for the next set of results.</p>
    /// <p>If the results of a search are large, only a portion of the results are returned, and a <code>nextToken</code> pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value. </p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p> The maximum number of items to return, between 1 and 100, inclusive. </p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}
impl ListSignalCatalogsInput {
    /// Creates a new builder-style object to manufacture [`ListSignalCatalogsInput`](crate::input::ListSignalCatalogsInput).
    pub fn builder() -> crate::input::list_signal_catalogs_input::Builder {
        crate::input::list_signal_catalogs_input::Builder::default()
    }
}

/// See [`ListSignalCatalogsInput`](crate::input::ListSignalCatalogsInput).
pub mod list_signal_catalogs_input {

    /// A builder for [`ListSignalCatalogsInput`](crate::input::ListSignalCatalogsInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>A pagination token for the next set of results.</p>
        /// <p>If the results of a search are large, only a portion of the results are returned, and a <code>nextToken</code> pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>A pagination token for the next set of results.</p>
        /// <p>If the results of a search are large, only a portion of the results are returned, and a <code>nextToken</code> pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p> The maximum number of items to return, between 1 and 100, inclusive. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p> The maximum number of items to return, between 1 and 100, inclusive. </p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListSignalCatalogsInput`](crate::input::ListSignalCatalogsInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::ListSignalCatalogsInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::ListSignalCatalogsInput {
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateSignalCatalogInput {
    /// <p> The name of the signal catalog to create. </p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>A brief description of the signal catalog.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p> A list of information about nodes, which are a general abstraction of signals. For more information, see the API data type.</p>
    #[doc(hidden)]
    pub nodes: std::option::Option<std::vec::Vec<crate::model::Node>>,
    /// <p>Metadata that can be used to manage the signal catalog.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl CreateSignalCatalogInput {
    /// <p> The name of the signal catalog to create. </p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A brief description of the signal catalog.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p> A list of information about nodes, which are a general abstraction of signals. For more information, see the API data type.</p>
    pub fn nodes(&self) -> std::option::Option<&[crate::model::Node]> {
        self.nodes.as_deref()
    }
    /// <p>Metadata that can be used to manage the signal catalog.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
}
impl CreateSignalCatalogInput {
    /// Creates a new builder-style object to manufacture [`CreateSignalCatalogInput`](crate::input::CreateSignalCatalogInput).
    pub fn builder() -> crate::input::create_signal_catalog_input::Builder {
        crate::input::create_signal_catalog_input::Builder::default()
    }
}

/// See [`CreateSignalCatalogInput`](crate::input::CreateSignalCatalogInput).
pub mod create_signal_catalog_input {

    /// A builder for [`CreateSignalCatalogInput`](crate::input::CreateSignalCatalogInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) nodes: std::option::Option<std::vec::Vec<crate::model::Node>>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p> The name of the signal catalog to create. </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p> The name of the signal catalog to create. </p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A brief description of the signal catalog.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A brief description of the signal catalog.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Appends an item to `nodes`.
        ///
        /// To override the contents of this collection use [`set_nodes`](Self::set_nodes).
        ///
        /// <p> A list of information about nodes, which are a general abstraction of signals. For more information, see the API data type.</p>
        pub fn nodes(mut self, input: crate::model::Node) -> Self {
            let mut v = self.nodes.unwrap_or_default();
            v.push(input);
            self.nodes = Some(v);
            self
        }
        /// <p> A list of information about nodes, which are a general abstraction of signals. For more information, see the API data type.</p>
        pub fn set_nodes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Node>>,
        ) -> Self {
            self.nodes = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Metadata that can be used to manage the signal catalog.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>Metadata that can be used to manage the signal catalog.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateSignalCatalogInput`](crate::input::CreateSignalCatalogInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::CreateSignalCatalogInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::CreateSignalCatalogInput {
                name: self.name,
                description: self.description,
                nodes: self.nodes,
                tags: self.tags,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteSignalCatalogInput {
    /// <p> The name of the signal catalog to delete. </p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
}
impl DeleteSignalCatalogInput {
    /// <p> The name of the signal catalog to delete. </p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
}
impl DeleteSignalCatalogInput {
    /// Creates a new builder-style object to manufacture [`DeleteSignalCatalogInput`](crate::input::DeleteSignalCatalogInput).
    pub fn builder() -> crate::input::delete_signal_catalog_input::Builder {
        crate::input::delete_signal_catalog_input::Builder::default()
    }
}

/// See [`DeleteSignalCatalogInput`](crate::input::DeleteSignalCatalogInput).
pub mod delete_signal_catalog_input {

    /// A builder for [`DeleteSignalCatalogInput`](crate::input::DeleteSignalCatalogInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The name of the signal catalog to delete. </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p> The name of the signal catalog to delete. </p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteSignalCatalogInput`](crate::input::DeleteSignalCatalogInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::DeleteSignalCatalogInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::DeleteSignalCatalogInput { name: self.name })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateSignalCatalogInput {
    /// <p> The name of the signal catalog to update. </p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p> A brief description of the signal catalog to update.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p> A list of information about nodes to add to the signal catalog. </p>
    #[doc(hidden)]
    pub nodes_to_add: std::option::Option<std::vec::Vec<crate::model::Node>>,
    /// <p> A list of information about nodes to update in the signal catalog. </p>
    #[doc(hidden)]
    pub nodes_to_update: std::option::Option<std::vec::Vec<crate::model::Node>>,
    /// <p> A list of <code>fullyQualifiedName</code> of nodes to remove from the signal catalog. </p>
    #[doc(hidden)]
    pub nodes_to_remove: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl UpdateSignalCatalogInput {
    /// <p> The name of the signal catalog to update. </p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p> A brief description of the signal catalog to update.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p> A list of information about nodes to add to the signal catalog. </p>
    pub fn nodes_to_add(&self) -> std::option::Option<&[crate::model::Node]> {
        self.nodes_to_add.as_deref()
    }
    /// <p> A list of information about nodes to update in the signal catalog. </p>
    pub fn nodes_to_update(&self) -> std::option::Option<&[crate::model::Node]> {
        self.nodes_to_update.as_deref()
    }
    /// <p> A list of <code>fullyQualifiedName</code> of nodes to remove from the signal catalog. </p>
    pub fn nodes_to_remove(&self) -> std::option::Option<&[std::string::String]> {
        self.nodes_to_remove.as_deref()
    }
}
impl UpdateSignalCatalogInput {
    /// Creates a new builder-style object to manufacture [`UpdateSignalCatalogInput`](crate::input::UpdateSignalCatalogInput).
    pub fn builder() -> crate::input::update_signal_catalog_input::Builder {
        crate::input::update_signal_catalog_input::Builder::default()
    }
}

/// See [`UpdateSignalCatalogInput`](crate::input::UpdateSignalCatalogInput).
pub mod update_signal_catalog_input {

    /// A builder for [`UpdateSignalCatalogInput`](crate::input::UpdateSignalCatalogInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) nodes_to_add: std::option::Option<std::vec::Vec<crate::model::Node>>,
        pub(crate) nodes_to_update: std::option::Option<std::vec::Vec<crate::model::Node>>,
        pub(crate) nodes_to_remove: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p> The name of the signal catalog to update. </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p> The name of the signal catalog to update. </p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p> A brief description of the signal catalog to update.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p> A brief description of the signal catalog to update.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Appends an item to `nodes_to_add`.
        ///
        /// To override the contents of this collection use [`set_nodes_to_add`](Self::set_nodes_to_add).
        ///
        /// <p> A list of information about nodes to add to the signal catalog. </p>
        pub fn nodes_to_add(mut self, input: crate::model::Node) -> Self {
            let mut v = self.nodes_to_add.unwrap_or_default();
            v.push(input);
            self.nodes_to_add = Some(v);
            self
        }
        /// <p> A list of information about nodes to add to the signal catalog. </p>
        pub fn set_nodes_to_add(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Node>>,
        ) -> Self {
            self.nodes_to_add = input;
            self
        }
        /// Appends an item to `nodes_to_update`.
        ///
        /// To override the contents of this collection use [`set_nodes_to_update`](Self::set_nodes_to_update).
        ///
        /// <p> A list of information about nodes to update in the signal catalog. </p>
        pub fn nodes_to_update(mut self, input: crate::model::Node) -> Self {
            let mut v = self.nodes_to_update.unwrap_or_default();
            v.push(input);
            self.nodes_to_update = Some(v);
            self
        }
        /// <p> A list of information about nodes to update in the signal catalog. </p>
        pub fn set_nodes_to_update(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Node>>,
        ) -> Self {
            self.nodes_to_update = input;
            self
        }
        /// Appends an item to `nodes_to_remove`.
        ///
        /// To override the contents of this collection use [`set_nodes_to_remove`](Self::set_nodes_to_remove).
        ///
        /// <p> A list of <code>fullyQualifiedName</code> of nodes to remove from the signal catalog. </p>
        pub fn nodes_to_remove(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.nodes_to_remove.unwrap_or_default();
            v.push(input.into());
            self.nodes_to_remove = Some(v);
            self
        }
        /// <p> A list of <code>fullyQualifiedName</code> of nodes to remove from the signal catalog. </p>
        pub fn set_nodes_to_remove(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.nodes_to_remove = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateSignalCatalogInput`](crate::input::UpdateSignalCatalogInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::UpdateSignalCatalogInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::UpdateSignalCatalogInput {
                name: self.name,
                description: self.description,
                nodes_to_add: self.nodes_to_add,
                nodes_to_update: self.nodes_to_update,
                nodes_to_remove: self.nodes_to_remove,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetSignalCatalogInput {
    /// <p> The name of the signal catalog to retrieve information about. </p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
}
impl GetSignalCatalogInput {
    /// <p> The name of the signal catalog to retrieve information about. </p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
}
impl GetSignalCatalogInput {
    /// Creates a new builder-style object to manufacture [`GetSignalCatalogInput`](crate::input::GetSignalCatalogInput).
    pub fn builder() -> crate::input::get_signal_catalog_input::Builder {
        crate::input::get_signal_catalog_input::Builder::default()
    }
}

/// See [`GetSignalCatalogInput`](crate::input::GetSignalCatalogInput).
pub mod get_signal_catalog_input {

    /// A builder for [`GetSignalCatalogInput`](crate::input::GetSignalCatalogInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The name of the signal catalog to retrieve information about. </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p> The name of the signal catalog to retrieve information about. </p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`GetSignalCatalogInput`](crate::input::GetSignalCatalogInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::GetSignalCatalogInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::GetSignalCatalogInput { name: self.name })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListModelManifestNodesInput {
    /// <p> The name of the vehicle model to list information about. </p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>A pagination token for the next set of results.</p>
    /// <p>If the results of a search are large, only a portion of the results are returned, and a <code>nextToken</code> pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value. </p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p> The maximum number of items to return, between 1 and 100, inclusive. </p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl ListModelManifestNodesInput {
    /// <p> The name of the vehicle model to list information about. </p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A pagination token for the next set of results.</p>
    /// <p>If the results of a search are large, only a portion of the results are returned, and a <code>nextToken</code> pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value. </p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p> The maximum number of items to return, between 1 and 100, inclusive. </p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}
impl ListModelManifestNodesInput {
    /// Creates a new builder-style object to manufacture [`ListModelManifestNodesInput`](crate::input::ListModelManifestNodesInput).
    pub fn builder() -> crate::input::list_model_manifest_nodes_input::Builder {
        crate::input::list_model_manifest_nodes_input::Builder::default()
    }
}

/// See [`ListModelManifestNodesInput`](crate::input::ListModelManifestNodesInput).
pub mod list_model_manifest_nodes_input {

    /// A builder for [`ListModelManifestNodesInput`](crate::input::ListModelManifestNodesInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p> The name of the vehicle model to list information about. </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p> The name of the vehicle model to list information about. </p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A pagination token for the next set of results.</p>
        /// <p>If the results of a search are large, only a portion of the results are returned, and a <code>nextToken</code> pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>A pagination token for the next set of results.</p>
        /// <p>If the results of a search are large, only a portion of the results are returned, and a <code>nextToken</code> pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p> The maximum number of items to return, between 1 and 100, inclusive. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p> The maximum number of items to return, between 1 and 100, inclusive. </p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListModelManifestNodesInput`](crate::input::ListModelManifestNodesInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::ListModelManifestNodesInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::ListModelManifestNodesInput {
                name: self.name,
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListModelManifestsInput {
    /// <p> The ARN of a signal catalog. If you specify a signal catalog, only the vehicle models associated with it are returned.</p>
    #[doc(hidden)]
    pub signal_catalog_arn: std::option::Option<std::string::String>,
    /// <p>A pagination token for the next set of results.</p>
    /// <p>If the results of a search are large, only a portion of the results are returned, and a <code>nextToken</code> pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value. </p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p> The maximum number of items to return, between 1 and 100, inclusive. </p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl ListModelManifestsInput {
    /// <p> The ARN of a signal catalog. If you specify a signal catalog, only the vehicle models associated with it are returned.</p>
    pub fn signal_catalog_arn(&self) -> std::option::Option<&str> {
        self.signal_catalog_arn.as_deref()
    }
    /// <p>A pagination token for the next set of results.</p>
    /// <p>If the results of a search are large, only a portion of the results are returned, and a <code>nextToken</code> pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value. </p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p> The maximum number of items to return, between 1 and 100, inclusive. </p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}
impl ListModelManifestsInput {
    /// Creates a new builder-style object to manufacture [`ListModelManifestsInput`](crate::input::ListModelManifestsInput).
    pub fn builder() -> crate::input::list_model_manifests_input::Builder {
        crate::input::list_model_manifests_input::Builder::default()
    }
}

/// See [`ListModelManifestsInput`](crate::input::ListModelManifestsInput).
pub mod list_model_manifests_input {

    /// A builder for [`ListModelManifestsInput`](crate::input::ListModelManifestsInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) signal_catalog_arn: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p> The ARN of a signal catalog. If you specify a signal catalog, only the vehicle models associated with it are returned.</p>
        pub fn signal_catalog_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.signal_catalog_arn = Some(input.into());
            self
        }
        /// <p> The ARN of a signal catalog. If you specify a signal catalog, only the vehicle models associated with it are returned.</p>
        pub fn set_signal_catalog_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.signal_catalog_arn = input;
            self
        }
        /// <p>A pagination token for the next set of results.</p>
        /// <p>If the results of a search are large, only a portion of the results are returned, and a <code>nextToken</code> pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>A pagination token for the next set of results.</p>
        /// <p>If the results of a search are large, only a portion of the results are returned, and a <code>nextToken</code> pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p> The maximum number of items to return, between 1 and 100, inclusive. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p> The maximum number of items to return, between 1 and 100, inclusive. </p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListModelManifestsInput`](crate::input::ListModelManifestsInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::ListModelManifestsInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::ListModelManifestsInput {
                signal_catalog_arn: self.signal_catalog_arn,
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateModelManifestInput {
    /// <p> The name of the vehicle model to create.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p> A brief description of the vehicle model. </p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p> A list of nodes, which are a general abstraction of signals. </p>
    #[doc(hidden)]
    pub nodes: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p> The Amazon Resource Name (ARN) of a signal catalog. </p>
    #[doc(hidden)]
    pub signal_catalog_arn: std::option::Option<std::string::String>,
    /// <p>Metadata that can be used to manage the vehicle model.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl CreateModelManifestInput {
    /// <p> The name of the vehicle model to create.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p> A brief description of the vehicle model. </p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p> A list of nodes, which are a general abstraction of signals. </p>
    pub fn nodes(&self) -> std::option::Option<&[std::string::String]> {
        self.nodes.as_deref()
    }
    /// <p> The Amazon Resource Name (ARN) of a signal catalog. </p>
    pub fn signal_catalog_arn(&self) -> std::option::Option<&str> {
        self.signal_catalog_arn.as_deref()
    }
    /// <p>Metadata that can be used to manage the vehicle model.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
}
impl CreateModelManifestInput {
    /// Creates a new builder-style object to manufacture [`CreateModelManifestInput`](crate::input::CreateModelManifestInput).
    pub fn builder() -> crate::input::create_model_manifest_input::Builder {
        crate::input::create_model_manifest_input::Builder::default()
    }
}

/// See [`CreateModelManifestInput`](crate::input::CreateModelManifestInput).
pub mod create_model_manifest_input {

    /// A builder for [`CreateModelManifestInput`](crate::input::CreateModelManifestInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) nodes: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) signal_catalog_arn: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p> The name of the vehicle model to create.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p> The name of the vehicle model to create.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p> A brief description of the vehicle model. </p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p> A brief description of the vehicle model. </p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Appends an item to `nodes`.
        ///
        /// To override the contents of this collection use [`set_nodes`](Self::set_nodes).
        ///
        /// <p> A list of nodes, which are a general abstraction of signals. </p>
        pub fn nodes(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.nodes.unwrap_or_default();
            v.push(input.into());
            self.nodes = Some(v);
            self
        }
        /// <p> A list of nodes, which are a general abstraction of signals. </p>
        pub fn set_nodes(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.nodes = input;
            self
        }
        /// <p> The Amazon Resource Name (ARN) of a signal catalog. </p>
        pub fn signal_catalog_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.signal_catalog_arn = Some(input.into());
            self
        }
        /// <p> The Amazon Resource Name (ARN) of a signal catalog. </p>
        pub fn set_signal_catalog_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.signal_catalog_arn = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Metadata that can be used to manage the vehicle model.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>Metadata that can be used to manage the vehicle model.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateModelManifestInput`](crate::input::CreateModelManifestInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::CreateModelManifestInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::CreateModelManifestInput {
                name: self.name,
                description: self.description,
                nodes: self.nodes,
                signal_catalog_arn: self.signal_catalog_arn,
                tags: self.tags,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteModelManifestInput {
    /// <p> The name of the model manifest to delete. </p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
}
impl DeleteModelManifestInput {
    /// <p> The name of the model manifest to delete. </p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
}
impl DeleteModelManifestInput {
    /// Creates a new builder-style object to manufacture [`DeleteModelManifestInput`](crate::input::DeleteModelManifestInput).
    pub fn builder() -> crate::input::delete_model_manifest_input::Builder {
        crate::input::delete_model_manifest_input::Builder::default()
    }
}

/// See [`DeleteModelManifestInput`](crate::input::DeleteModelManifestInput).
pub mod delete_model_manifest_input {

    /// A builder for [`DeleteModelManifestInput`](crate::input::DeleteModelManifestInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The name of the model manifest to delete. </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p> The name of the model manifest to delete. </p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteModelManifestInput`](crate::input::DeleteModelManifestInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::DeleteModelManifestInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::DeleteModelManifestInput { name: self.name })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateModelManifestInput {
    /// <p> The name of the vehicle model to update. </p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p> A brief description of the vehicle model. </p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p> A list of <code>fullyQualifiedName</code> of nodes, which are a general abstraction of signals, to add to the vehicle model. </p>
    #[doc(hidden)]
    pub nodes_to_add: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p> A list of <code>fullyQualifiedName</code> of nodes, which are a general abstraction of signals, to remove from the vehicle model. </p>
    #[doc(hidden)]
    pub nodes_to_remove: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p> The state of the vehicle model. If the status is <code>ACTIVE</code>, the vehicle model can't be edited. If the status is <code>DRAFT</code>, you can edit the vehicle model. </p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::ManifestStatus>,
}
impl UpdateModelManifestInput {
    /// <p> The name of the vehicle model to update. </p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p> A brief description of the vehicle model. </p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p> A list of <code>fullyQualifiedName</code> of nodes, which are a general abstraction of signals, to add to the vehicle model. </p>
    pub fn nodes_to_add(&self) -> std::option::Option<&[std::string::String]> {
        self.nodes_to_add.as_deref()
    }
    /// <p> A list of <code>fullyQualifiedName</code> of nodes, which are a general abstraction of signals, to remove from the vehicle model. </p>
    pub fn nodes_to_remove(&self) -> std::option::Option<&[std::string::String]> {
        self.nodes_to_remove.as_deref()
    }
    /// <p> The state of the vehicle model. If the status is <code>ACTIVE</code>, the vehicle model can't be edited. If the status is <code>DRAFT</code>, you can edit the vehicle model. </p>
    pub fn status(&self) -> std::option::Option<&crate::model::ManifestStatus> {
        self.status.as_ref()
    }
}
impl UpdateModelManifestInput {
    /// Creates a new builder-style object to manufacture [`UpdateModelManifestInput`](crate::input::UpdateModelManifestInput).
    pub fn builder() -> crate::input::update_model_manifest_input::Builder {
        crate::input::update_model_manifest_input::Builder::default()
    }
}

/// See [`UpdateModelManifestInput`](crate::input::UpdateModelManifestInput).
pub mod update_model_manifest_input {

    /// A builder for [`UpdateModelManifestInput`](crate::input::UpdateModelManifestInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) nodes_to_add: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) nodes_to_remove: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) status: std::option::Option<crate::model::ManifestStatus>,
    }
    impl Builder {
        /// <p> The name of the vehicle model to update. </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p> The name of the vehicle model to update. </p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p> A brief description of the vehicle model. </p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p> A brief description of the vehicle model. </p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Appends an item to `nodes_to_add`.
        ///
        /// To override the contents of this collection use [`set_nodes_to_add`](Self::set_nodes_to_add).
        ///
        /// <p> A list of <code>fullyQualifiedName</code> of nodes, which are a general abstraction of signals, to add to the vehicle model. </p>
        pub fn nodes_to_add(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.nodes_to_add.unwrap_or_default();
            v.push(input.into());
            self.nodes_to_add = Some(v);
            self
        }
        /// <p> A list of <code>fullyQualifiedName</code> of nodes, which are a general abstraction of signals, to add to the vehicle model. </p>
        pub fn set_nodes_to_add(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.nodes_to_add = input;
            self
        }
        /// Appends an item to `nodes_to_remove`.
        ///
        /// To override the contents of this collection use [`set_nodes_to_remove`](Self::set_nodes_to_remove).
        ///
        /// <p> A list of <code>fullyQualifiedName</code> of nodes, which are a general abstraction of signals, to remove from the vehicle model. </p>
        pub fn nodes_to_remove(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.nodes_to_remove.unwrap_or_default();
            v.push(input.into());
            self.nodes_to_remove = Some(v);
            self
        }
        /// <p> A list of <code>fullyQualifiedName</code> of nodes, which are a general abstraction of signals, to remove from the vehicle model. </p>
        pub fn set_nodes_to_remove(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.nodes_to_remove = input;
            self
        }
        /// <p> The state of the vehicle model. If the status is <code>ACTIVE</code>, the vehicle model can't be edited. If the status is <code>DRAFT</code>, you can edit the vehicle model. </p>
        pub fn status(mut self, input: crate::model::ManifestStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p> The state of the vehicle model. If the status is <code>ACTIVE</code>, the vehicle model can't be edited. If the status is <code>DRAFT</code>, you can edit the vehicle model. </p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ManifestStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateModelManifestInput`](crate::input::UpdateModelManifestInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::UpdateModelManifestInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::UpdateModelManifestInput {
                name: self.name,
                description: self.description,
                nodes_to_add: self.nodes_to_add,
                nodes_to_remove: self.nodes_to_remove,
                status: self.status,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetModelManifestInput {
    /// <p> The name of the vehicle model to retrieve information about. </p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
}
impl GetModelManifestInput {
    /// <p> The name of the vehicle model to retrieve information about. </p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
}
impl GetModelManifestInput {
    /// Creates a new builder-style object to manufacture [`GetModelManifestInput`](crate::input::GetModelManifestInput).
    pub fn builder() -> crate::input::get_model_manifest_input::Builder {
        crate::input::get_model_manifest_input::Builder::default()
    }
}

/// See [`GetModelManifestInput`](crate::input::GetModelManifestInput).
pub mod get_model_manifest_input {

    /// A builder for [`GetModelManifestInput`](crate::input::GetModelManifestInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The name of the vehicle model to retrieve information about. </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p> The name of the vehicle model to retrieve information about. </p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`GetModelManifestInput`](crate::input::GetModelManifestInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::GetModelManifestInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::GetModelManifestInput { name: self.name })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListFleetsInput {
    /// <p>A pagination token for the next set of results.</p>
    /// <p>If the results of a search are large, only a portion of the results are returned, and a <code>nextToken</code> pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value. </p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p> The maximum number of items to return, between 1 and 100, inclusive. </p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl ListFleetsInput {
    /// <p>A pagination token for the next set of results.</p>
    /// <p>If the results of a search are large, only a portion of the results are returned, and a <code>nextToken</code> pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value. </p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p> The maximum number of items to return, between 1 and 100, inclusive. </p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}
impl ListFleetsInput {
    /// Creates a new builder-style object to manufacture [`ListFleetsInput`](crate::input::ListFleetsInput).
    pub fn builder() -> crate::input::list_fleets_input::Builder {
        crate::input::list_fleets_input::Builder::default()
    }
}

/// See [`ListFleetsInput`](crate::input::ListFleetsInput).
pub mod list_fleets_input {

    /// A builder for [`ListFleetsInput`](crate::input::ListFleetsInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>A pagination token for the next set of results.</p>
        /// <p>If the results of a search are large, only a portion of the results are returned, and a <code>nextToken</code> pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>A pagination token for the next set of results.</p>
        /// <p>If the results of a search are large, only a portion of the results are returned, and a <code>nextToken</code> pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p> The maximum number of items to return, between 1 and 100, inclusive. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p> The maximum number of items to return, between 1 and 100, inclusive. </p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListFleetsInput`](crate::input::ListFleetsInput).
        pub fn build(
            self,
        ) -> Result<crate::input::ListFleetsInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::ListFleetsInput {
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateFleetInput {
    /// <p> The unique ID of the fleet to create. </p>
    #[doc(hidden)]
    pub fleet_id: std::option::Option<std::string::String>,
    /// <p> A brief description of the fleet to create. </p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p> The Amazon Resource Name (ARN) of a signal catalog. </p>
    #[doc(hidden)]
    pub signal_catalog_arn: std::option::Option<std::string::String>,
    /// <p>Metadata that can be used to manage the fleet.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl CreateFleetInput {
    /// <p> The unique ID of the fleet to create. </p>
    pub fn fleet_id(&self) -> std::option::Option<&str> {
        self.fleet_id.as_deref()
    }
    /// <p> A brief description of the fleet to create. </p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p> The Amazon Resource Name (ARN) of a signal catalog. </p>
    pub fn signal_catalog_arn(&self) -> std::option::Option<&str> {
        self.signal_catalog_arn.as_deref()
    }
    /// <p>Metadata that can be used to manage the fleet.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
}
impl CreateFleetInput {
    /// Creates a new builder-style object to manufacture [`CreateFleetInput`](crate::input::CreateFleetInput).
    pub fn builder() -> crate::input::create_fleet_input::Builder {
        crate::input::create_fleet_input::Builder::default()
    }
}

/// See [`CreateFleetInput`](crate::input::CreateFleetInput).
pub mod create_fleet_input {

    /// A builder for [`CreateFleetInput`](crate::input::CreateFleetInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) fleet_id: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) signal_catalog_arn: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p> The unique ID of the fleet to create. </p>
        pub fn fleet_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.fleet_id = Some(input.into());
            self
        }
        /// <p> The unique ID of the fleet to create. </p>
        pub fn set_fleet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.fleet_id = input;
            self
        }
        /// <p> A brief description of the fleet to create. </p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p> A brief description of the fleet to create. </p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p> The Amazon Resource Name (ARN) of a signal catalog. </p>
        pub fn signal_catalog_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.signal_catalog_arn = Some(input.into());
            self
        }
        /// <p> The Amazon Resource Name (ARN) of a signal catalog. </p>
        pub fn set_signal_catalog_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.signal_catalog_arn = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Metadata that can be used to manage the fleet.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>Metadata that can be used to manage the fleet.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateFleetInput`](crate::input::CreateFleetInput).
        pub fn build(
            self,
        ) -> Result<crate::input::CreateFleetInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::CreateFleetInput {
                fleet_id: self.fleet_id,
                description: self.description,
                signal_catalog_arn: self.signal_catalog_arn,
                tags: self.tags,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteFleetInput {
    /// <p> The ID of the fleet to delete. </p>
    #[doc(hidden)]
    pub fleet_id: std::option::Option<std::string::String>,
}
impl DeleteFleetInput {
    /// <p> The ID of the fleet to delete. </p>
    pub fn fleet_id(&self) -> std::option::Option<&str> {
        self.fleet_id.as_deref()
    }
}
impl DeleteFleetInput {
    /// Creates a new builder-style object to manufacture [`DeleteFleetInput`](crate::input::DeleteFleetInput).
    pub fn builder() -> crate::input::delete_fleet_input::Builder {
        crate::input::delete_fleet_input::Builder::default()
    }
}

/// See [`DeleteFleetInput`](crate::input::DeleteFleetInput).
pub mod delete_fleet_input {

    /// A builder for [`DeleteFleetInput`](crate::input::DeleteFleetInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) fleet_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The ID of the fleet to delete. </p>
        pub fn fleet_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.fleet_id = Some(input.into());
            self
        }
        /// <p> The ID of the fleet to delete. </p>
        pub fn set_fleet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.fleet_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteFleetInput`](crate::input::DeleteFleetInput).
        pub fn build(
            self,
        ) -> Result<crate::input::DeleteFleetInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::DeleteFleetInput {
                fleet_id: self.fleet_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateFleetInput {
    /// <p> The ID of the fleet to update. </p>
    #[doc(hidden)]
    pub fleet_id: std::option::Option<std::string::String>,
    /// <p> An updated description of the fleet. </p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
}
impl UpdateFleetInput {
    /// <p> The ID of the fleet to update. </p>
    pub fn fleet_id(&self) -> std::option::Option<&str> {
        self.fleet_id.as_deref()
    }
    /// <p> An updated description of the fleet. </p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
}
impl UpdateFleetInput {
    /// Creates a new builder-style object to manufacture [`UpdateFleetInput`](crate::input::UpdateFleetInput).
    pub fn builder() -> crate::input::update_fleet_input::Builder {
        crate::input::update_fleet_input::Builder::default()
    }
}

/// See [`UpdateFleetInput`](crate::input::UpdateFleetInput).
pub mod update_fleet_input {

    /// A builder for [`UpdateFleetInput`](crate::input::UpdateFleetInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) fleet_id: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The ID of the fleet to update. </p>
        pub fn fleet_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.fleet_id = Some(input.into());
            self
        }
        /// <p> The ID of the fleet to update. </p>
        pub fn set_fleet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.fleet_id = input;
            self
        }
        /// <p> An updated description of the fleet. </p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p> An updated description of the fleet. </p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateFleetInput`](crate::input::UpdateFleetInput).
        pub fn build(
            self,
        ) -> Result<crate::input::UpdateFleetInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::UpdateFleetInput {
                fleet_id: self.fleet_id,
                description: self.description,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetFleetInput {
    /// <p> The ID of the fleet to retrieve information about. </p>
    #[doc(hidden)]
    pub fleet_id: std::option::Option<std::string::String>,
}
impl GetFleetInput {
    /// <p> The ID of the fleet to retrieve information about. </p>
    pub fn fleet_id(&self) -> std::option::Option<&str> {
        self.fleet_id.as_deref()
    }
}
impl GetFleetInput {
    /// Creates a new builder-style object to manufacture [`GetFleetInput`](crate::input::GetFleetInput).
    pub fn builder() -> crate::input::get_fleet_input::Builder {
        crate::input::get_fleet_input::Builder::default()
    }
}

/// See [`GetFleetInput`](crate::input::GetFleetInput).
pub mod get_fleet_input {

    /// A builder for [`GetFleetInput`](crate::input::GetFleetInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) fleet_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The ID of the fleet to retrieve information about. </p>
        pub fn fleet_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.fleet_id = Some(input.into());
            self
        }
        /// <p> The ID of the fleet to retrieve information about. </p>
        pub fn set_fleet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.fleet_id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetFleetInput`](crate::input::GetFleetInput).
        pub fn build(
            self,
        ) -> Result<crate::input::GetFleetInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::GetFleetInput {
                fleet_id: self.fleet_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListVehiclesInFleetInput {
    /// <p> The ID of a fleet. </p>
    #[doc(hidden)]
    pub fleet_id: std::option::Option<std::string::String>,
    /// <p>A pagination token for the next set of results.</p>
    /// <p>If the results of a search are large, only a portion of the results are returned, and a <code>nextToken</code> pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value. </p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p> The maximum number of items to return, between 1 and 100, inclusive. </p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl ListVehiclesInFleetInput {
    /// <p> The ID of a fleet. </p>
    pub fn fleet_id(&self) -> std::option::Option<&str> {
        self.fleet_id.as_deref()
    }
    /// <p>A pagination token for the next set of results.</p>
    /// <p>If the results of a search are large, only a portion of the results are returned, and a <code>nextToken</code> pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value. </p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p> The maximum number of items to return, between 1 and 100, inclusive. </p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}
impl ListVehiclesInFleetInput {
    /// Creates a new builder-style object to manufacture [`ListVehiclesInFleetInput`](crate::input::ListVehiclesInFleetInput).
    pub fn builder() -> crate::input::list_vehicles_in_fleet_input::Builder {
        crate::input::list_vehicles_in_fleet_input::Builder::default()
    }
}

/// See [`ListVehiclesInFleetInput`](crate::input::ListVehiclesInFleetInput).
pub mod list_vehicles_in_fleet_input {

    /// A builder for [`ListVehiclesInFleetInput`](crate::input::ListVehiclesInFleetInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) fleet_id: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p> The ID of a fleet. </p>
        pub fn fleet_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.fleet_id = Some(input.into());
            self
        }
        /// <p> The ID of a fleet. </p>
        pub fn set_fleet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.fleet_id = input;
            self
        }
        /// <p>A pagination token for the next set of results.</p>
        /// <p>If the results of a search are large, only a portion of the results are returned, and a <code>nextToken</code> pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>A pagination token for the next set of results.</p>
        /// <p>If the results of a search are large, only a portion of the results are returned, and a <code>nextToken</code> pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p> The maximum number of items to return, between 1 and 100, inclusive. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p> The maximum number of items to return, between 1 and 100, inclusive. </p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListVehiclesInFleetInput`](crate::input::ListVehiclesInFleetInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::ListVehiclesInFleetInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::ListVehiclesInFleetInput {
                fleet_id: self.fleet_id,
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListDecoderManifestSignalsInput {
    /// <p> The name of the decoder manifest to list information about. </p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>A pagination token for the next set of results.</p>
    /// <p>If the results of a search are large, only a portion of the results are returned, and a <code>nextToken</code> pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value. </p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p> The maximum number of items to return, between 1 and 100, inclusive. </p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl ListDecoderManifestSignalsInput {
    /// <p> The name of the decoder manifest to list information about. </p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A pagination token for the next set of results.</p>
    /// <p>If the results of a search are large, only a portion of the results are returned, and a <code>nextToken</code> pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value. </p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p> The maximum number of items to return, between 1 and 100, inclusive. </p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}
impl ListDecoderManifestSignalsInput {
    /// Creates a new builder-style object to manufacture [`ListDecoderManifestSignalsInput`](crate::input::ListDecoderManifestSignalsInput).
    pub fn builder() -> crate::input::list_decoder_manifest_signals_input::Builder {
        crate::input::list_decoder_manifest_signals_input::Builder::default()
    }
}

/// See [`ListDecoderManifestSignalsInput`](crate::input::ListDecoderManifestSignalsInput).
pub mod list_decoder_manifest_signals_input {

    /// A builder for [`ListDecoderManifestSignalsInput`](crate::input::ListDecoderManifestSignalsInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p> The name of the decoder manifest to list information about. </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p> The name of the decoder manifest to list information about. </p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A pagination token for the next set of results.</p>
        /// <p>If the results of a search are large, only a portion of the results are returned, and a <code>nextToken</code> pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>A pagination token for the next set of results.</p>
        /// <p>If the results of a search are large, only a portion of the results are returned, and a <code>nextToken</code> pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p> The maximum number of items to return, between 1 and 100, inclusive. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p> The maximum number of items to return, between 1 and 100, inclusive. </p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListDecoderManifestSignalsInput`](crate::input::ListDecoderManifestSignalsInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::ListDecoderManifestSignalsInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::ListDecoderManifestSignalsInput {
                name: self.name,
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListDecoderManifestNetworkInterfacesInput {
    /// <p> The name of the decoder manifest to list information about. </p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>A pagination token for the next set of results.</p>
    /// <p>If the results of a search are large, only a portion of the results are returned, and a <code>nextToken</code> pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value. </p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p> The maximum number of items to return, between 1 and 100, inclusive. </p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl ListDecoderManifestNetworkInterfacesInput {
    /// <p> The name of the decoder manifest to list information about. </p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A pagination token for the next set of results.</p>
    /// <p>If the results of a search are large, only a portion of the results are returned, and a <code>nextToken</code> pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value. </p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p> The maximum number of items to return, between 1 and 100, inclusive. </p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}
impl ListDecoderManifestNetworkInterfacesInput {
    /// Creates a new builder-style object to manufacture [`ListDecoderManifestNetworkInterfacesInput`](crate::input::ListDecoderManifestNetworkInterfacesInput).
    pub fn builder() -> crate::input::list_decoder_manifest_network_interfaces_input::Builder {
        crate::input::list_decoder_manifest_network_interfaces_input::Builder::default()
    }
}

/// See [`ListDecoderManifestNetworkInterfacesInput`](crate::input::ListDecoderManifestNetworkInterfacesInput).
pub mod list_decoder_manifest_network_interfaces_input {

    /// A builder for [`ListDecoderManifestNetworkInterfacesInput`](crate::input::ListDecoderManifestNetworkInterfacesInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p> The name of the decoder manifest to list information about. </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p> The name of the decoder manifest to list information about. </p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A pagination token for the next set of results.</p>
        /// <p>If the results of a search are large, only a portion of the results are returned, and a <code>nextToken</code> pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>A pagination token for the next set of results.</p>
        /// <p>If the results of a search are large, only a portion of the results are returned, and a <code>nextToken</code> pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p> The maximum number of items to return, between 1 and 100, inclusive. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p> The maximum number of items to return, between 1 and 100, inclusive. </p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListDecoderManifestNetworkInterfacesInput`](crate::input::ListDecoderManifestNetworkInterfacesInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::ListDecoderManifestNetworkInterfacesInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::ListDecoderManifestNetworkInterfacesInput {
                name: self.name,
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ImportDecoderManifestInput {
    /// <p> The name of the decoder manifest to import. </p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p> The file to load into an Amazon Web Services account. </p>
    #[doc(hidden)]
    pub network_file_definitions:
        std::option::Option<std::vec::Vec<crate::model::NetworkFileDefinition>>,
}
impl ImportDecoderManifestInput {
    /// <p> The name of the decoder manifest to import. </p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p> The file to load into an Amazon Web Services account. </p>
    pub fn network_file_definitions(
        &self,
    ) -> std::option::Option<&[crate::model::NetworkFileDefinition]> {
        self.network_file_definitions.as_deref()
    }
}
impl ImportDecoderManifestInput {
    /// Creates a new builder-style object to manufacture [`ImportDecoderManifestInput`](crate::input::ImportDecoderManifestInput).
    pub fn builder() -> crate::input::import_decoder_manifest_input::Builder {
        crate::input::import_decoder_manifest_input::Builder::default()
    }
}

/// See [`ImportDecoderManifestInput`](crate::input::ImportDecoderManifestInput).
pub mod import_decoder_manifest_input {

    /// A builder for [`ImportDecoderManifestInput`](crate::input::ImportDecoderManifestInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) network_file_definitions:
            std::option::Option<std::vec::Vec<crate::model::NetworkFileDefinition>>,
    }
    impl Builder {
        /// <p> The name of the decoder manifest to import. </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p> The name of the decoder manifest to import. </p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `network_file_definitions`.
        ///
        /// To override the contents of this collection use [`set_network_file_definitions`](Self::set_network_file_definitions).
        ///
        /// <p> The file to load into an Amazon Web Services account. </p>
        pub fn network_file_definitions(
            mut self,
            input: crate::model::NetworkFileDefinition,
        ) -> Self {
            let mut v = self.network_file_definitions.unwrap_or_default();
            v.push(input);
            self.network_file_definitions = Some(v);
            self
        }
        /// <p> The file to load into an Amazon Web Services account. </p>
        pub fn set_network_file_definitions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::NetworkFileDefinition>>,
        ) -> Self {
            self.network_file_definitions = input;
            self
        }
        /// Consumes the builder and constructs a [`ImportDecoderManifestInput`](crate::input::ImportDecoderManifestInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::ImportDecoderManifestInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::ImportDecoderManifestInput {
                name: self.name,
                network_file_definitions: self.network_file_definitions,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListDecoderManifestsInput {
    /// <p> The Amazon Resource Name (ARN) of a vehicle model (model manifest) associated with the decoder manifest. </p>
    #[doc(hidden)]
    pub model_manifest_arn: std::option::Option<std::string::String>,
    /// <p>A pagination token for the next set of results.</p>
    /// <p>If the results of a search are large, only a portion of the results are returned, and a <code>nextToken</code> pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value. </p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p> The maximum number of items to return, between 1 and 100, inclusive. </p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
}
impl ListDecoderManifestsInput {
    /// <p> The Amazon Resource Name (ARN) of a vehicle model (model manifest) associated with the decoder manifest. </p>
    pub fn model_manifest_arn(&self) -> std::option::Option<&str> {
        self.model_manifest_arn.as_deref()
    }
    /// <p>A pagination token for the next set of results.</p>
    /// <p>If the results of a search are large, only a portion of the results are returned, and a <code>nextToken</code> pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value. </p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p> The maximum number of items to return, between 1 and 100, inclusive. </p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
}
impl ListDecoderManifestsInput {
    /// Creates a new builder-style object to manufacture [`ListDecoderManifestsInput`](crate::input::ListDecoderManifestsInput).
    pub fn builder() -> crate::input::list_decoder_manifests_input::Builder {
        crate::input::list_decoder_manifests_input::Builder::default()
    }
}

/// See [`ListDecoderManifestsInput`](crate::input::ListDecoderManifestsInput).
pub mod list_decoder_manifests_input {

    /// A builder for [`ListDecoderManifestsInput`](crate::input::ListDecoderManifestsInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) model_manifest_arn: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
    }
    impl Builder {
        /// <p> The Amazon Resource Name (ARN) of a vehicle model (model manifest) associated with the decoder manifest. </p>
        pub fn model_manifest_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_manifest_arn = Some(input.into());
            self
        }
        /// <p> The Amazon Resource Name (ARN) of a vehicle model (model manifest) associated with the decoder manifest. </p>
        pub fn set_model_manifest_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_manifest_arn = input;
            self
        }
        /// <p>A pagination token for the next set of results.</p>
        /// <p>If the results of a search are large, only a portion of the results are returned, and a <code>nextToken</code> pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>A pagination token for the next set of results.</p>
        /// <p>If the results of a search are large, only a portion of the results are returned, and a <code>nextToken</code> pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p> The maximum number of items to return, between 1 and 100, inclusive. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p> The maximum number of items to return, between 1 and 100, inclusive. </p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// Consumes the builder and constructs a [`ListDecoderManifestsInput`](crate::input::ListDecoderManifestsInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::ListDecoderManifestsInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::ListDecoderManifestsInput {
                model_manifest_arn: self.model_manifest_arn,
                next_token: self.next_token,
                max_results: self.max_results,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateDecoderManifestInput {
    /// <p> The unique name of the decoder manifest to create.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p> A brief description of the decoder manifest. </p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p> The Amazon Resource Name (ARN) of the vehicle model (model manifest). </p>
    #[doc(hidden)]
    pub model_manifest_arn: std::option::Option<std::string::String>,
    /// <p> A list of information about signal decoders. </p>
    #[doc(hidden)]
    pub signal_decoders: std::option::Option<std::vec::Vec<crate::model::SignalDecoder>>,
    /// <p> A list of information about available network interfaces. </p>
    #[doc(hidden)]
    pub network_interfaces: std::option::Option<std::vec::Vec<crate::model::NetworkInterface>>,
    /// <p>Metadata that can be used to manage the decoder manifest.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl CreateDecoderManifestInput {
    /// <p> The unique name of the decoder manifest to create.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p> A brief description of the decoder manifest. </p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p> The Amazon Resource Name (ARN) of the vehicle model (model manifest). </p>
    pub fn model_manifest_arn(&self) -> std::option::Option<&str> {
        self.model_manifest_arn.as_deref()
    }
    /// <p> A list of information about signal decoders. </p>
    pub fn signal_decoders(&self) -> std::option::Option<&[crate::model::SignalDecoder]> {
        self.signal_decoders.as_deref()
    }
    /// <p> A list of information about available network interfaces. </p>
    pub fn network_interfaces(&self) -> std::option::Option<&[crate::model::NetworkInterface]> {
        self.network_interfaces.as_deref()
    }
    /// <p>Metadata that can be used to manage the decoder manifest.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
}
impl CreateDecoderManifestInput {
    /// Creates a new builder-style object to manufacture [`CreateDecoderManifestInput`](crate::input::CreateDecoderManifestInput).
    pub fn builder() -> crate::input::create_decoder_manifest_input::Builder {
        crate::input::create_decoder_manifest_input::Builder::default()
    }
}

/// See [`CreateDecoderManifestInput`](crate::input::CreateDecoderManifestInput).
pub mod create_decoder_manifest_input {

    /// A builder for [`CreateDecoderManifestInput`](crate::input::CreateDecoderManifestInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) model_manifest_arn: std::option::Option<std::string::String>,
        pub(crate) signal_decoders: std::option::Option<std::vec::Vec<crate::model::SignalDecoder>>,
        pub(crate) network_interfaces:
            std::option::Option<std::vec::Vec<crate::model::NetworkInterface>>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p> The unique name of the decoder manifest to create.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p> The unique name of the decoder manifest to create.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p> A brief description of the decoder manifest. </p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p> A brief description of the decoder manifest. </p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p> The Amazon Resource Name (ARN) of the vehicle model (model manifest). </p>
        pub fn model_manifest_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_manifest_arn = Some(input.into());
            self
        }
        /// <p> The Amazon Resource Name (ARN) of the vehicle model (model manifest). </p>
        pub fn set_model_manifest_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_manifest_arn = input;
            self
        }
        /// Appends an item to `signal_decoders`.
        ///
        /// To override the contents of this collection use [`set_signal_decoders`](Self::set_signal_decoders).
        ///
        /// <p> A list of information about signal decoders. </p>
        pub fn signal_decoders(mut self, input: crate::model::SignalDecoder) -> Self {
            let mut v = self.signal_decoders.unwrap_or_default();
            v.push(input);
            self.signal_decoders = Some(v);
            self
        }
        /// <p> A list of information about signal decoders. </p>
        pub fn set_signal_decoders(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SignalDecoder>>,
        ) -> Self {
            self.signal_decoders = input;
            self
        }
        /// Appends an item to `network_interfaces`.
        ///
        /// To override the contents of this collection use [`set_network_interfaces`](Self::set_network_interfaces).
        ///
        /// <p> A list of information about available network interfaces. </p>
        pub fn network_interfaces(mut self, input: crate::model::NetworkInterface) -> Self {
            let mut v = self.network_interfaces.unwrap_or_default();
            v.push(input);
            self.network_interfaces = Some(v);
            self
        }
        /// <p> A list of information about available network interfaces. </p>
        pub fn set_network_interfaces(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::NetworkInterface>>,
        ) -> Self {
            self.network_interfaces = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Metadata that can be used to manage the decoder manifest.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>Metadata that can be used to manage the decoder manifest.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateDecoderManifestInput`](crate::input::CreateDecoderManifestInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::CreateDecoderManifestInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::CreateDecoderManifestInput {
                name: self.name,
                description: self.description,
                model_manifest_arn: self.model_manifest_arn,
                signal_decoders: self.signal_decoders,
                network_interfaces: self.network_interfaces,
                tags: self.tags,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteDecoderManifestInput {
    /// <p> The name of the decoder manifest to delete. </p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
}
impl DeleteDecoderManifestInput {
    /// <p> The name of the decoder manifest to delete. </p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
}
impl DeleteDecoderManifestInput {
    /// Creates a new builder-style object to manufacture [`DeleteDecoderManifestInput`](crate::input::DeleteDecoderManifestInput).
    pub fn builder() -> crate::input::delete_decoder_manifest_input::Builder {
        crate::input::delete_decoder_manifest_input::Builder::default()
    }
}

/// See [`DeleteDecoderManifestInput`](crate::input::DeleteDecoderManifestInput).
pub mod delete_decoder_manifest_input {

    /// A builder for [`DeleteDecoderManifestInput`](crate::input::DeleteDecoderManifestInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The name of the decoder manifest to delete. </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p> The name of the decoder manifest to delete. </p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteDecoderManifestInput`](crate::input::DeleteDecoderManifestInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::DeleteDecoderManifestInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::DeleteDecoderManifestInput { name: self.name })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateDecoderManifestInput {
    /// <p> The name of the decoder manifest to update.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p> A brief description of the decoder manifest to update. </p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p> A list of information about decoding additional signals to add to the decoder manifest. </p>
    #[doc(hidden)]
    pub signal_decoders_to_add: std::option::Option<std::vec::Vec<crate::model::SignalDecoder>>,
    /// <p> A list of updated information about decoding signals to update in the decoder manifest. </p>
    #[doc(hidden)]
    pub signal_decoders_to_update: std::option::Option<std::vec::Vec<crate::model::SignalDecoder>>,
    /// <p> A list of signal decoders to remove from the decoder manifest. </p>
    #[doc(hidden)]
    pub signal_decoders_to_remove: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p> A list of information about the network interfaces to add to the decoder manifest. </p>
    #[doc(hidden)]
    pub network_interfaces_to_add:
        std::option::Option<std::vec::Vec<crate::model::NetworkInterface>>,
    /// <p> A list of information about the network interfaces to update in the decoder manifest. </p>
    #[doc(hidden)]
    pub network_interfaces_to_update:
        std::option::Option<std::vec::Vec<crate::model::NetworkInterface>>,
    /// <p> A list of network interfaces to remove from the decoder manifest.</p>
    #[doc(hidden)]
    pub network_interfaces_to_remove: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p> The state of the decoder manifest. If the status is <code>ACTIVE</code>, the decoder manifest can't be edited. If the status is <code>DRAFT</code>, you can edit the decoder manifest. </p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::ManifestStatus>,
}
impl UpdateDecoderManifestInput {
    /// <p> The name of the decoder manifest to update.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p> A brief description of the decoder manifest to update. </p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p> A list of information about decoding additional signals to add to the decoder manifest. </p>
    pub fn signal_decoders_to_add(&self) -> std::option::Option<&[crate::model::SignalDecoder]> {
        self.signal_decoders_to_add.as_deref()
    }
    /// <p> A list of updated information about decoding signals to update in the decoder manifest. </p>
    pub fn signal_decoders_to_update(&self) -> std::option::Option<&[crate::model::SignalDecoder]> {
        self.signal_decoders_to_update.as_deref()
    }
    /// <p> A list of signal decoders to remove from the decoder manifest. </p>
    pub fn signal_decoders_to_remove(&self) -> std::option::Option<&[std::string::String]> {
        self.signal_decoders_to_remove.as_deref()
    }
    /// <p> A list of information about the network interfaces to add to the decoder manifest. </p>
    pub fn network_interfaces_to_add(
        &self,
    ) -> std::option::Option<&[crate::model::NetworkInterface]> {
        self.network_interfaces_to_add.as_deref()
    }
    /// <p> A list of information about the network interfaces to update in the decoder manifest. </p>
    pub fn network_interfaces_to_update(
        &self,
    ) -> std::option::Option<&[crate::model::NetworkInterface]> {
        self.network_interfaces_to_update.as_deref()
    }
    /// <p> A list of network interfaces to remove from the decoder manifest.</p>
    pub fn network_interfaces_to_remove(&self) -> std::option::Option<&[std::string::String]> {
        self.network_interfaces_to_remove.as_deref()
    }
    /// <p> The state of the decoder manifest. If the status is <code>ACTIVE</code>, the decoder manifest can't be edited. If the status is <code>DRAFT</code>, you can edit the decoder manifest. </p>
    pub fn status(&self) -> std::option::Option<&crate::model::ManifestStatus> {
        self.status.as_ref()
    }
}
impl UpdateDecoderManifestInput {
    /// Creates a new builder-style object to manufacture [`UpdateDecoderManifestInput`](crate::input::UpdateDecoderManifestInput).
    pub fn builder() -> crate::input::update_decoder_manifest_input::Builder {
        crate::input::update_decoder_manifest_input::Builder::default()
    }
}

/// See [`UpdateDecoderManifestInput`](crate::input::UpdateDecoderManifestInput).
pub mod update_decoder_manifest_input {

    /// A builder for [`UpdateDecoderManifestInput`](crate::input::UpdateDecoderManifestInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) signal_decoders_to_add:
            std::option::Option<std::vec::Vec<crate::model::SignalDecoder>>,
        pub(crate) signal_decoders_to_update:
            std::option::Option<std::vec::Vec<crate::model::SignalDecoder>>,
        pub(crate) signal_decoders_to_remove:
            std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) network_interfaces_to_add:
            std::option::Option<std::vec::Vec<crate::model::NetworkInterface>>,
        pub(crate) network_interfaces_to_update:
            std::option::Option<std::vec::Vec<crate::model::NetworkInterface>>,
        pub(crate) network_interfaces_to_remove:
            std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) status: std::option::Option<crate::model::ManifestStatus>,
    }
    impl Builder {
        /// <p> The name of the decoder manifest to update.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p> The name of the decoder manifest to update.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p> A brief description of the decoder manifest to update. </p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p> A brief description of the decoder manifest to update. </p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Appends an item to `signal_decoders_to_add`.
        ///
        /// To override the contents of this collection use [`set_signal_decoders_to_add`](Self::set_signal_decoders_to_add).
        ///
        /// <p> A list of information about decoding additional signals to add to the decoder manifest. </p>
        pub fn signal_decoders_to_add(mut self, input: crate::model::SignalDecoder) -> Self {
            let mut v = self.signal_decoders_to_add.unwrap_or_default();
            v.push(input);
            self.signal_decoders_to_add = Some(v);
            self
        }
        /// <p> A list of information about decoding additional signals to add to the decoder manifest. </p>
        pub fn set_signal_decoders_to_add(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SignalDecoder>>,
        ) -> Self {
            self.signal_decoders_to_add = input;
            self
        }
        /// Appends an item to `signal_decoders_to_update`.
        ///
        /// To override the contents of this collection use [`set_signal_decoders_to_update`](Self::set_signal_decoders_to_update).
        ///
        /// <p> A list of updated information about decoding signals to update in the decoder manifest. </p>
        pub fn signal_decoders_to_update(mut self, input: crate::model::SignalDecoder) -> Self {
            let mut v = self.signal_decoders_to_update.unwrap_or_default();
            v.push(input);
            self.signal_decoders_to_update = Some(v);
            self
        }
        /// <p> A list of updated information about decoding signals to update in the decoder manifest. </p>
        pub fn set_signal_decoders_to_update(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SignalDecoder>>,
        ) -> Self {
            self.signal_decoders_to_update = input;
            self
        }
        /// Appends an item to `signal_decoders_to_remove`.
        ///
        /// To override the contents of this collection use [`set_signal_decoders_to_remove`](Self::set_signal_decoders_to_remove).
        ///
        /// <p> A list of signal decoders to remove from the decoder manifest. </p>
        pub fn signal_decoders_to_remove(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.signal_decoders_to_remove.unwrap_or_default();
            v.push(input.into());
            self.signal_decoders_to_remove = Some(v);
            self
        }
        /// <p> A list of signal decoders to remove from the decoder manifest. </p>
        pub fn set_signal_decoders_to_remove(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.signal_decoders_to_remove = input;
            self
        }
        /// Appends an item to `network_interfaces_to_add`.
        ///
        /// To override the contents of this collection use [`set_network_interfaces_to_add`](Self::set_network_interfaces_to_add).
        ///
        /// <p> A list of information about the network interfaces to add to the decoder manifest. </p>
        pub fn network_interfaces_to_add(mut self, input: crate::model::NetworkInterface) -> Self {
            let mut v = self.network_interfaces_to_add.unwrap_or_default();
            v.push(input);
            self.network_interfaces_to_add = Some(v);
            self
        }
        /// <p> A list of information about the network interfaces to add to the decoder manifest. </p>
        pub fn set_network_interfaces_to_add(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::NetworkInterface>>,
        ) -> Self {
            self.network_interfaces_to_add = input;
            self
        }
        /// Appends an item to `network_interfaces_to_update`.
        ///
        /// To override the contents of this collection use [`set_network_interfaces_to_update`](Self::set_network_interfaces_to_update).
        ///
        /// <p> A list of information about the network interfaces to update in the decoder manifest. </p>
        pub fn network_interfaces_to_update(
            mut self,
            input: crate::model::NetworkInterface,
        ) -> Self {
            let mut v = self.network_interfaces_to_update.unwrap_or_default();
            v.push(input);
            self.network_interfaces_to_update = Some(v);
            self
        }
        /// <p> A list of information about the network interfaces to update in the decoder manifest. </p>
        pub fn set_network_interfaces_to_update(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::NetworkInterface>>,
        ) -> Self {
            self.network_interfaces_to_update = input;
            self
        }
        /// Appends an item to `network_interfaces_to_remove`.
        ///
        /// To override the contents of this collection use [`set_network_interfaces_to_remove`](Self::set_network_interfaces_to_remove).
        ///
        /// <p> A list of network interfaces to remove from the decoder manifest.</p>
        pub fn network_interfaces_to_remove(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            let mut v = self.network_interfaces_to_remove.unwrap_or_default();
            v.push(input.into());
            self.network_interfaces_to_remove = Some(v);
            self
        }
        /// <p> A list of network interfaces to remove from the decoder manifest.</p>
        pub fn set_network_interfaces_to_remove(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.network_interfaces_to_remove = input;
            self
        }
        /// <p> The state of the decoder manifest. If the status is <code>ACTIVE</code>, the decoder manifest can't be edited. If the status is <code>DRAFT</code>, you can edit the decoder manifest. </p>
        pub fn status(mut self, input: crate::model::ManifestStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p> The state of the decoder manifest. If the status is <code>ACTIVE</code>, the decoder manifest can't be edited. If the status is <code>DRAFT</code>, you can edit the decoder manifest. </p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ManifestStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateDecoderManifestInput`](crate::input::UpdateDecoderManifestInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::UpdateDecoderManifestInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::UpdateDecoderManifestInput {
                name: self.name,
                description: self.description,
                signal_decoders_to_add: self.signal_decoders_to_add,
                signal_decoders_to_update: self.signal_decoders_to_update,
                signal_decoders_to_remove: self.signal_decoders_to_remove,
                network_interfaces_to_add: self.network_interfaces_to_add,
                network_interfaces_to_update: self.network_interfaces_to_update,
                network_interfaces_to_remove: self.network_interfaces_to_remove,
                status: self.status,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetDecoderManifestInput {
    /// <p> The name of the decoder manifest to retrieve information about. </p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
}
impl GetDecoderManifestInput {
    /// <p> The name of the decoder manifest to retrieve information about. </p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
}
impl GetDecoderManifestInput {
    /// Creates a new builder-style object to manufacture [`GetDecoderManifestInput`](crate::input::GetDecoderManifestInput).
    pub fn builder() -> crate::input::get_decoder_manifest_input::Builder {
        crate::input::get_decoder_manifest_input::Builder::default()
    }
}

/// See [`GetDecoderManifestInput`](crate::input::GetDecoderManifestInput).
pub mod get_decoder_manifest_input {

    /// A builder for [`GetDecoderManifestInput`](crate::input::GetDecoderManifestInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The name of the decoder manifest to retrieve information about. </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p> The name of the decoder manifest to retrieve information about. </p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`GetDecoderManifestInput`](crate::input::GetDecoderManifestInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::GetDecoderManifestInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::GetDecoderManifestInput { name: self.name })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListCampaignsInput {
    /// <p>A pagination token for the next set of results.</p>
    /// <p>If the results of a search are large, only a portion of the results are returned, and a <code>nextToken</code> pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value. </p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p> The maximum number of items to return, between 1 and 100, inclusive. </p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>Optional parameter to filter the results by the status of each created campaign in your account. The status can be one of: <code>CREATING</code>, <code>WAITING_FOR_APPROVAL</code>, <code>RUNNING</code>, or <code>SUSPENDED</code>.</p>
    #[doc(hidden)]
    pub status: std::option::Option<std::string::String>,
}
impl ListCampaignsInput {
    /// <p>A pagination token for the next set of results.</p>
    /// <p>If the results of a search are large, only a portion of the results are returned, and a <code>nextToken</code> pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value. </p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p> The maximum number of items to return, between 1 and 100, inclusive. </p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>Optional parameter to filter the results by the status of each created campaign in your account. The status can be one of: <code>CREATING</code>, <code>WAITING_FOR_APPROVAL</code>, <code>RUNNING</code>, or <code>SUSPENDED</code>.</p>
    pub fn status(&self) -> std::option::Option<&str> {
        self.status.as_deref()
    }
}
impl ListCampaignsInput {
    /// Creates a new builder-style object to manufacture [`ListCampaignsInput`](crate::input::ListCampaignsInput).
    pub fn builder() -> crate::input::list_campaigns_input::Builder {
        crate::input::list_campaigns_input::Builder::default()
    }
}

/// See [`ListCampaignsInput`](crate::input::ListCampaignsInput).
pub mod list_campaigns_input {

    /// A builder for [`ListCampaignsInput`](crate::input::ListCampaignsInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) status: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A pagination token for the next set of results.</p>
        /// <p>If the results of a search are large, only a portion of the results are returned, and a <code>nextToken</code> pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>A pagination token for the next set of results.</p>
        /// <p>If the results of a search are large, only a portion of the results are returned, and a <code>nextToken</code> pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p> The maximum number of items to return, between 1 and 100, inclusive. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p> The maximum number of items to return, between 1 and 100, inclusive. </p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>Optional parameter to filter the results by the status of each created campaign in your account. The status can be one of: <code>CREATING</code>, <code>WAITING_FOR_APPROVAL</code>, <code>RUNNING</code>, or <code>SUSPENDED</code>.</p>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        /// <p>Optional parameter to filter the results by the status of each created campaign in your account. The status can be one of: <code>CREATING</code>, <code>WAITING_FOR_APPROVAL</code>, <code>RUNNING</code>, or <code>SUSPENDED</code>.</p>
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`ListCampaignsInput`](crate::input::ListCampaignsInput).
        pub fn build(
            self,
        ) -> Result<crate::input::ListCampaignsInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::ListCampaignsInput {
                next_token: self.next_token,
                max_results: self.max_results,
                status: self.status,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateCampaignInput {
    /// <p> The name of the campaign to create. </p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>An optional description of the campaign to help identify its purpose.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>(Optional) The Amazon Resource Name (ARN) of the signal catalog to associate with the campaign. </p>
    #[doc(hidden)]
    pub signal_catalog_arn: std::option::Option<std::string::String>,
    /// <p> The ARN of the vehicle or fleet to deploy a campaign to. </p>
    #[doc(hidden)]
    pub target_arn: std::option::Option<std::string::String>,
    /// <p>(Optional) The time, in milliseconds, to deliver a campaign after it was approved. If it's not specified, <code>0</code> is used.</p>
    /// <p>Default: <code>0</code> </p>
    #[doc(hidden)]
    pub start_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p> (Optional) The time the campaign expires, in seconds since epoch (January 1, 1970 at midnight UTC time). Vehicle data won't be collected after the campaign expires. </p>
    /// <p>Default: 253402214400 (December 31, 9999, 00:00:00 UTC)</p>
    #[doc(hidden)]
    pub expiry_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p> (Optional) How long (in milliseconds) to collect raw data after a triggering event initiates the collection. If it's not specified, <code>0</code> is used.</p>
    /// <p>Default: <code>0</code> </p>
    #[doc(hidden)]
    pub post_trigger_collection_duration: std::option::Option<i64>,
    /// <p> (Optional) Option for a vehicle to send diagnostic trouble codes to Amazon Web Services IoT FleetWise. If you want to send diagnostic trouble codes, use <code>SEND_ACTIVE_DTCS</code>. If it's not specified, <code>OFF</code> is used.</p>
    /// <p>Default: <code>OFF</code> </p>
    #[doc(hidden)]
    pub diagnostics_mode: std::option::Option<crate::model::DiagnosticsMode>,
    /// <p>(Optional) Whether to store collected data after a vehicle lost a connection with the cloud. After a connection is re-established, the data is automatically forwarded to Amazon Web Services IoT FleetWise. If you want to store collected data when a vehicle loses connection with the cloud, use <code>TO_DISK</code>. If it's not specified, <code>OFF</code> is used.</p>
    /// <p>Default: <code>OFF</code> </p>
    #[doc(hidden)]
    pub spooling_mode: std::option::Option<crate::model::SpoolingMode>,
    /// <p> (Optional) Whether to compress signals before transmitting data to Amazon Web Services IoT FleetWise. If you don't want to compress the signals, use <code>OFF</code>. If it's not specified, <code>SNAPPY</code> is used. </p>
    /// <p>Default: <code>SNAPPY</code> </p>
    #[doc(hidden)]
    pub compression: std::option::Option<crate::model::Compression>,
    /// <p>(Optional) A number indicating the priority of one campaign over another campaign for a certain vehicle or fleet. A campaign with the lowest value is deployed to vehicles before any other campaigns. If it's not specified, <code>0</code> is used. </p>
    /// <p>Default: <code>0</code> </p>
    #[doc(hidden)]
    pub priority: std::option::Option<i32>,
    /// <p>(Optional) A list of information about signals to collect. </p>
    #[doc(hidden)]
    pub signals_to_collect: std::option::Option<std::vec::Vec<crate::model::SignalInformation>>,
    /// <p> The data collection scheme associated with the campaign. You can specify a scheme that collects data based on time or an event.</p>
    #[doc(hidden)]
    pub collection_scheme: std::option::Option<crate::model::CollectionScheme>,
    /// <p> (Optional) A list of vehicle attributes to associate with a campaign. </p>
    /// <p>Enrich the data with specified vehicle attributes. For example, add <code>make</code> and <code>model</code> to the campaign, and Amazon Web Services IoT FleetWise will associate the data with those attributes as dimensions in Amazon Timestream. You can then query the data against <code>make</code> and <code>model</code>.</p>
    /// <p>Default: An empty array</p>
    #[doc(hidden)]
    pub data_extra_dimensions: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Metadata that can be used to manage the campaign.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl CreateCampaignInput {
    /// <p> The name of the campaign to create. </p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>An optional description of the campaign to help identify its purpose.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>(Optional) The Amazon Resource Name (ARN) of the signal catalog to associate with the campaign. </p>
    pub fn signal_catalog_arn(&self) -> std::option::Option<&str> {
        self.signal_catalog_arn.as_deref()
    }
    /// <p> The ARN of the vehicle or fleet to deploy a campaign to. </p>
    pub fn target_arn(&self) -> std::option::Option<&str> {
        self.target_arn.as_deref()
    }
    /// <p>(Optional) The time, in milliseconds, to deliver a campaign after it was approved. If it's not specified, <code>0</code> is used.</p>
    /// <p>Default: <code>0</code> </p>
    pub fn start_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.start_time.as_ref()
    }
    /// <p> (Optional) The time the campaign expires, in seconds since epoch (January 1, 1970 at midnight UTC time). Vehicle data won't be collected after the campaign expires. </p>
    /// <p>Default: 253402214400 (December 31, 9999, 00:00:00 UTC)</p>
    pub fn expiry_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.expiry_time.as_ref()
    }
    /// <p> (Optional) How long (in milliseconds) to collect raw data after a triggering event initiates the collection. If it's not specified, <code>0</code> is used.</p>
    /// <p>Default: <code>0</code> </p>
    pub fn post_trigger_collection_duration(&self) -> std::option::Option<i64> {
        self.post_trigger_collection_duration
    }
    /// <p> (Optional) Option for a vehicle to send diagnostic trouble codes to Amazon Web Services IoT FleetWise. If you want to send diagnostic trouble codes, use <code>SEND_ACTIVE_DTCS</code>. If it's not specified, <code>OFF</code> is used.</p>
    /// <p>Default: <code>OFF</code> </p>
    pub fn diagnostics_mode(&self) -> std::option::Option<&crate::model::DiagnosticsMode> {
        self.diagnostics_mode.as_ref()
    }
    /// <p>(Optional) Whether to store collected data after a vehicle lost a connection with the cloud. After a connection is re-established, the data is automatically forwarded to Amazon Web Services IoT FleetWise. If you want to store collected data when a vehicle loses connection with the cloud, use <code>TO_DISK</code>. If it's not specified, <code>OFF</code> is used.</p>
    /// <p>Default: <code>OFF</code> </p>
    pub fn spooling_mode(&self) -> std::option::Option<&crate::model::SpoolingMode> {
        self.spooling_mode.as_ref()
    }
    /// <p> (Optional) Whether to compress signals before transmitting data to Amazon Web Services IoT FleetWise. If you don't want to compress the signals, use <code>OFF</code>. If it's not specified, <code>SNAPPY</code> is used. </p>
    /// <p>Default: <code>SNAPPY</code> </p>
    pub fn compression(&self) -> std::option::Option<&crate::model::Compression> {
        self.compression.as_ref()
    }
    /// <p>(Optional) A number indicating the priority of one campaign over another campaign for a certain vehicle or fleet. A campaign with the lowest value is deployed to vehicles before any other campaigns. If it's not specified, <code>0</code> is used. </p>
    /// <p>Default: <code>0</code> </p>
    pub fn priority(&self) -> std::option::Option<i32> {
        self.priority
    }
    /// <p>(Optional) A list of information about signals to collect. </p>
    pub fn signals_to_collect(&self) -> std::option::Option<&[crate::model::SignalInformation]> {
        self.signals_to_collect.as_deref()
    }
    /// <p> The data collection scheme associated with the campaign. You can specify a scheme that collects data based on time or an event.</p>
    pub fn collection_scheme(&self) -> std::option::Option<&crate::model::CollectionScheme> {
        self.collection_scheme.as_ref()
    }
    /// <p> (Optional) A list of vehicle attributes to associate with a campaign. </p>
    /// <p>Enrich the data with specified vehicle attributes. For example, add <code>make</code> and <code>model</code> to the campaign, and Amazon Web Services IoT FleetWise will associate the data with those attributes as dimensions in Amazon Timestream. You can then query the data against <code>make</code> and <code>model</code>.</p>
    /// <p>Default: An empty array</p>
    pub fn data_extra_dimensions(&self) -> std::option::Option<&[std::string::String]> {
        self.data_extra_dimensions.as_deref()
    }
    /// <p>Metadata that can be used to manage the campaign.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
}
impl CreateCampaignInput {
    /// Creates a new builder-style object to manufacture [`CreateCampaignInput`](crate::input::CreateCampaignInput).
    pub fn builder() -> crate::input::create_campaign_input::Builder {
        crate::input::create_campaign_input::Builder::default()
    }
}

/// See [`CreateCampaignInput`](crate::input::CreateCampaignInput).
pub mod create_campaign_input {

    /// A builder for [`CreateCampaignInput`](crate::input::CreateCampaignInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) signal_catalog_arn: std::option::Option<std::string::String>,
        pub(crate) target_arn: std::option::Option<std::string::String>,
        pub(crate) start_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) expiry_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) post_trigger_collection_duration: std::option::Option<i64>,
        pub(crate) diagnostics_mode: std::option::Option<crate::model::DiagnosticsMode>,
        pub(crate) spooling_mode: std::option::Option<crate::model::SpoolingMode>,
        pub(crate) compression: std::option::Option<crate::model::Compression>,
        pub(crate) priority: std::option::Option<i32>,
        pub(crate) signals_to_collect:
            std::option::Option<std::vec::Vec<crate::model::SignalInformation>>,
        pub(crate) collection_scheme: std::option::Option<crate::model::CollectionScheme>,
        pub(crate) data_extra_dimensions: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p> The name of the campaign to create. </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p> The name of the campaign to create. </p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>An optional description of the campaign to help identify its purpose.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>An optional description of the campaign to help identify its purpose.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>(Optional) The Amazon Resource Name (ARN) of the signal catalog to associate with the campaign. </p>
        pub fn signal_catalog_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.signal_catalog_arn = Some(input.into());
            self
        }
        /// <p>(Optional) The Amazon Resource Name (ARN) of the signal catalog to associate with the campaign. </p>
        pub fn set_signal_catalog_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.signal_catalog_arn = input;
            self
        }
        /// <p> The ARN of the vehicle or fleet to deploy a campaign to. </p>
        pub fn target_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.target_arn = Some(input.into());
            self
        }
        /// <p> The ARN of the vehicle or fleet to deploy a campaign to. </p>
        pub fn set_target_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.target_arn = input;
            self
        }
        /// <p>(Optional) The time, in milliseconds, to deliver a campaign after it was approved. If it's not specified, <code>0</code> is used.</p>
        /// <p>Default: <code>0</code> </p>
        pub fn start_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>(Optional) The time, in milliseconds, to deliver a campaign after it was approved. If it's not specified, <code>0</code> is used.</p>
        /// <p>Default: <code>0</code> </p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// <p> (Optional) The time the campaign expires, in seconds since epoch (January 1, 1970 at midnight UTC time). Vehicle data won't be collected after the campaign expires. </p>
        /// <p>Default: 253402214400 (December 31, 9999, 00:00:00 UTC)</p>
        pub fn expiry_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.expiry_time = Some(input);
            self
        }
        /// <p> (Optional) The time the campaign expires, in seconds since epoch (January 1, 1970 at midnight UTC time). Vehicle data won't be collected after the campaign expires. </p>
        /// <p>Default: 253402214400 (December 31, 9999, 00:00:00 UTC)</p>
        pub fn set_expiry_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.expiry_time = input;
            self
        }
        /// <p> (Optional) How long (in milliseconds) to collect raw data after a triggering event initiates the collection. If it's not specified, <code>0</code> is used.</p>
        /// <p>Default: <code>0</code> </p>
        pub fn post_trigger_collection_duration(mut self, input: i64) -> Self {
            self.post_trigger_collection_duration = Some(input);
            self
        }
        /// <p> (Optional) How long (in milliseconds) to collect raw data after a triggering event initiates the collection. If it's not specified, <code>0</code> is used.</p>
        /// <p>Default: <code>0</code> </p>
        pub fn set_post_trigger_collection_duration(
            mut self,
            input: std::option::Option<i64>,
        ) -> Self {
            self.post_trigger_collection_duration = input;
            self
        }
        /// <p> (Optional) Option for a vehicle to send diagnostic trouble codes to Amazon Web Services IoT FleetWise. If you want to send diagnostic trouble codes, use <code>SEND_ACTIVE_DTCS</code>. If it's not specified, <code>OFF</code> is used.</p>
        /// <p>Default: <code>OFF</code> </p>
        pub fn diagnostics_mode(mut self, input: crate::model::DiagnosticsMode) -> Self {
            self.diagnostics_mode = Some(input);
            self
        }
        /// <p> (Optional) Option for a vehicle to send diagnostic trouble codes to Amazon Web Services IoT FleetWise. If you want to send diagnostic trouble codes, use <code>SEND_ACTIVE_DTCS</code>. If it's not specified, <code>OFF</code> is used.</p>
        /// <p>Default: <code>OFF</code> </p>
        pub fn set_diagnostics_mode(
            mut self,
            input: std::option::Option<crate::model::DiagnosticsMode>,
        ) -> Self {
            self.diagnostics_mode = input;
            self
        }
        /// <p>(Optional) Whether to store collected data after a vehicle lost a connection with the cloud. After a connection is re-established, the data is automatically forwarded to Amazon Web Services IoT FleetWise. If you want to store collected data when a vehicle loses connection with the cloud, use <code>TO_DISK</code>. If it's not specified, <code>OFF</code> is used.</p>
        /// <p>Default: <code>OFF</code> </p>
        pub fn spooling_mode(mut self, input: crate::model::SpoolingMode) -> Self {
            self.spooling_mode = Some(input);
            self
        }
        /// <p>(Optional) Whether to store collected data after a vehicle lost a connection with the cloud. After a connection is re-established, the data is automatically forwarded to Amazon Web Services IoT FleetWise. If you want to store collected data when a vehicle loses connection with the cloud, use <code>TO_DISK</code>. If it's not specified, <code>OFF</code> is used.</p>
        /// <p>Default: <code>OFF</code> </p>
        pub fn set_spooling_mode(
            mut self,
            input: std::option::Option<crate::model::SpoolingMode>,
        ) -> Self {
            self.spooling_mode = input;
            self
        }
        /// <p> (Optional) Whether to compress signals before transmitting data to Amazon Web Services IoT FleetWise. If you don't want to compress the signals, use <code>OFF</code>. If it's not specified, <code>SNAPPY</code> is used. </p>
        /// <p>Default: <code>SNAPPY</code> </p>
        pub fn compression(mut self, input: crate::model::Compression) -> Self {
            self.compression = Some(input);
            self
        }
        /// <p> (Optional) Whether to compress signals before transmitting data to Amazon Web Services IoT FleetWise. If you don't want to compress the signals, use <code>OFF</code>. If it's not specified, <code>SNAPPY</code> is used. </p>
        /// <p>Default: <code>SNAPPY</code> </p>
        pub fn set_compression(
            mut self,
            input: std::option::Option<crate::model::Compression>,
        ) -> Self {
            self.compression = input;
            self
        }
        /// <p>(Optional) A number indicating the priority of one campaign over another campaign for a certain vehicle or fleet. A campaign with the lowest value is deployed to vehicles before any other campaigns. If it's not specified, <code>0</code> is used. </p>
        /// <p>Default: <code>0</code> </p>
        pub fn priority(mut self, input: i32) -> Self {
            self.priority = Some(input);
            self
        }
        /// <p>(Optional) A number indicating the priority of one campaign over another campaign for a certain vehicle or fleet. A campaign with the lowest value is deployed to vehicles before any other campaigns. If it's not specified, <code>0</code> is used. </p>
        /// <p>Default: <code>0</code> </p>
        pub fn set_priority(mut self, input: std::option::Option<i32>) -> Self {
            self.priority = input;
            self
        }
        /// Appends an item to `signals_to_collect`.
        ///
        /// To override the contents of this collection use [`set_signals_to_collect`](Self::set_signals_to_collect).
        ///
        /// <p>(Optional) A list of information about signals to collect. </p>
        pub fn signals_to_collect(mut self, input: crate::model::SignalInformation) -> Self {
            let mut v = self.signals_to_collect.unwrap_or_default();
            v.push(input);
            self.signals_to_collect = Some(v);
            self
        }
        /// <p>(Optional) A list of information about signals to collect. </p>
        pub fn set_signals_to_collect(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SignalInformation>>,
        ) -> Self {
            self.signals_to_collect = input;
            self
        }
        /// <p> The data collection scheme associated with the campaign. You can specify a scheme that collects data based on time or an event.</p>
        pub fn collection_scheme(mut self, input: crate::model::CollectionScheme) -> Self {
            self.collection_scheme = Some(input);
            self
        }
        /// <p> The data collection scheme associated with the campaign. You can specify a scheme that collects data based on time or an event.</p>
        pub fn set_collection_scheme(
            mut self,
            input: std::option::Option<crate::model::CollectionScheme>,
        ) -> Self {
            self.collection_scheme = input;
            self
        }
        /// Appends an item to `data_extra_dimensions`.
        ///
        /// To override the contents of this collection use [`set_data_extra_dimensions`](Self::set_data_extra_dimensions).
        ///
        /// <p> (Optional) A list of vehicle attributes to associate with a campaign. </p>
        /// <p>Enrich the data with specified vehicle attributes. For example, add <code>make</code> and <code>model</code> to the campaign, and Amazon Web Services IoT FleetWise will associate the data with those attributes as dimensions in Amazon Timestream. You can then query the data against <code>make</code> and <code>model</code>.</p>
        /// <p>Default: An empty array</p>
        pub fn data_extra_dimensions(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.data_extra_dimensions.unwrap_or_default();
            v.push(input.into());
            self.data_extra_dimensions = Some(v);
            self
        }
        /// <p> (Optional) A list of vehicle attributes to associate with a campaign. </p>
        /// <p>Enrich the data with specified vehicle attributes. For example, add <code>make</code> and <code>model</code> to the campaign, and Amazon Web Services IoT FleetWise will associate the data with those attributes as dimensions in Amazon Timestream. You can then query the data against <code>make</code> and <code>model</code>.</p>
        /// <p>Default: An empty array</p>
        pub fn set_data_extra_dimensions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.data_extra_dimensions = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Metadata that can be used to manage the campaign.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>Metadata that can be used to manage the campaign.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateCampaignInput`](crate::input::CreateCampaignInput).
        pub fn build(
            self,
        ) -> Result<crate::input::CreateCampaignInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::CreateCampaignInput {
                name: self.name,
                description: self.description,
                signal_catalog_arn: self.signal_catalog_arn,
                target_arn: self.target_arn,
                start_time: self.start_time,
                expiry_time: self.expiry_time,
                post_trigger_collection_duration: self.post_trigger_collection_duration,
                diagnostics_mode: self.diagnostics_mode,
                spooling_mode: self.spooling_mode,
                compression: self.compression,
                priority: self.priority,
                signals_to_collect: self.signals_to_collect,
                collection_scheme: self.collection_scheme,
                data_extra_dimensions: self.data_extra_dimensions,
                tags: self.tags,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteCampaignInput {
    /// <p> The name of the campaign to delete. </p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
}
impl DeleteCampaignInput {
    /// <p> The name of the campaign to delete. </p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
}
impl DeleteCampaignInput {
    /// Creates a new builder-style object to manufacture [`DeleteCampaignInput`](crate::input::DeleteCampaignInput).
    pub fn builder() -> crate::input::delete_campaign_input::Builder {
        crate::input::delete_campaign_input::Builder::default()
    }
}

/// See [`DeleteCampaignInput`](crate::input::DeleteCampaignInput).
pub mod delete_campaign_input {

    /// A builder for [`DeleteCampaignInput`](crate::input::DeleteCampaignInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The name of the campaign to delete. </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p> The name of the campaign to delete. </p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteCampaignInput`](crate::input::DeleteCampaignInput).
        pub fn build(
            self,
        ) -> Result<crate::input::DeleteCampaignInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::DeleteCampaignInput { name: self.name })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateCampaignInput {
    /// <p> The name of the campaign to update. </p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The description of the campaign.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p> A list of vehicle attributes to associate with a signal. </p>
    /// <p>Default: An empty array</p>
    #[doc(hidden)]
    pub data_extra_dimensions: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p> Specifies how to update a campaign. The action can be one of the following:</p>
    /// <ul>
    /// <li> <p> <code>APPROVE</code> - To approve delivering a data collection scheme to vehicles. </p> </li>
    /// <li> <p> <code>SUSPEND</code> - To suspend collecting signal data. </p> </li>
    /// <li> <p> <code>RESUME</code> - To resume collecting signal data. </p> </li>
    /// <li> <p> <code>UPDATE</code> - To update a campaign. </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub action: std::option::Option<crate::model::UpdateCampaignAction>,
}
impl UpdateCampaignInput {
    /// <p> The name of the campaign to update. </p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The description of the campaign.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p> A list of vehicle attributes to associate with a signal. </p>
    /// <p>Default: An empty array</p>
    pub fn data_extra_dimensions(&self) -> std::option::Option<&[std::string::String]> {
        self.data_extra_dimensions.as_deref()
    }
    /// <p> Specifies how to update a campaign. The action can be one of the following:</p>
    /// <ul>
    /// <li> <p> <code>APPROVE</code> - To approve delivering a data collection scheme to vehicles. </p> </li>
    /// <li> <p> <code>SUSPEND</code> - To suspend collecting signal data. </p> </li>
    /// <li> <p> <code>RESUME</code> - To resume collecting signal data. </p> </li>
    /// <li> <p> <code>UPDATE</code> - To update a campaign. </p> </li>
    /// </ul>
    pub fn action(&self) -> std::option::Option<&crate::model::UpdateCampaignAction> {
        self.action.as_ref()
    }
}
impl UpdateCampaignInput {
    /// Creates a new builder-style object to manufacture [`UpdateCampaignInput`](crate::input::UpdateCampaignInput).
    pub fn builder() -> crate::input::update_campaign_input::Builder {
        crate::input::update_campaign_input::Builder::default()
    }
}

/// See [`UpdateCampaignInput`](crate::input::UpdateCampaignInput).
pub mod update_campaign_input {

    /// A builder for [`UpdateCampaignInput`](crate::input::UpdateCampaignInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) data_extra_dimensions: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) action: std::option::Option<crate::model::UpdateCampaignAction>,
    }
    impl Builder {
        /// <p> The name of the campaign to update. </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p> The name of the campaign to update. </p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The description of the campaign.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the campaign.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Appends an item to `data_extra_dimensions`.
        ///
        /// To override the contents of this collection use [`set_data_extra_dimensions`](Self::set_data_extra_dimensions).
        ///
        /// <p> A list of vehicle attributes to associate with a signal. </p>
        /// <p>Default: An empty array</p>
        pub fn data_extra_dimensions(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.data_extra_dimensions.unwrap_or_default();
            v.push(input.into());
            self.data_extra_dimensions = Some(v);
            self
        }
        /// <p> A list of vehicle attributes to associate with a signal. </p>
        /// <p>Default: An empty array</p>
        pub fn set_data_extra_dimensions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.data_extra_dimensions = input;
            self
        }
        /// <p> Specifies how to update a campaign. The action can be one of the following:</p>
        /// <ul>
        /// <li> <p> <code>APPROVE</code> - To approve delivering a data collection scheme to vehicles. </p> </li>
        /// <li> <p> <code>SUSPEND</code> - To suspend collecting signal data. </p> </li>
        /// <li> <p> <code>RESUME</code> - To resume collecting signal data. </p> </li>
        /// <li> <p> <code>UPDATE</code> - To update a campaign. </p> </li>
        /// </ul>
        pub fn action(mut self, input: crate::model::UpdateCampaignAction) -> Self {
            self.action = Some(input);
            self
        }
        /// <p> Specifies how to update a campaign. The action can be one of the following:</p>
        /// <ul>
        /// <li> <p> <code>APPROVE</code> - To approve delivering a data collection scheme to vehicles. </p> </li>
        /// <li> <p> <code>SUSPEND</code> - To suspend collecting signal data. </p> </li>
        /// <li> <p> <code>RESUME</code> - To resume collecting signal data. </p> </li>
        /// <li> <p> <code>UPDATE</code> - To update a campaign. </p> </li>
        /// </ul>
        pub fn set_action(
            mut self,
            input: std::option::Option<crate::model::UpdateCampaignAction>,
        ) -> Self {
            self.action = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateCampaignInput`](crate::input::UpdateCampaignInput).
        pub fn build(
            self,
        ) -> Result<crate::input::UpdateCampaignInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::UpdateCampaignInput {
                name: self.name,
                description: self.description,
                data_extra_dimensions: self.data_extra_dimensions,
                action: self.action,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetCampaignInput {
    /// <p> The name of the campaign to retrieve information about. </p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
}
impl GetCampaignInput {
    /// <p> The name of the campaign to retrieve information about. </p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
}
impl GetCampaignInput {
    /// Creates a new builder-style object to manufacture [`GetCampaignInput`](crate::input::GetCampaignInput).
    pub fn builder() -> crate::input::get_campaign_input::Builder {
        crate::input::get_campaign_input::Builder::default()
    }
}

/// See [`GetCampaignInput`](crate::input::GetCampaignInput).
pub mod get_campaign_input {

    /// A builder for [`GetCampaignInput`](crate::input::GetCampaignInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The name of the campaign to retrieve information about. </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p> The name of the campaign to retrieve information about. </p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`GetCampaignInput`](crate::input::GetCampaignInput).
        pub fn build(
            self,
        ) -> Result<crate::input::GetCampaignInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::GetCampaignInput { name: self.name })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UntagResourceInput {
    /// <p>The ARN of the resource.</p>
    #[doc(hidden)]
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>A list of the keys of the tags to be removed from the resource.</p>
    #[doc(hidden)]
    pub tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl UntagResourceInput {
    /// <p>The ARN of the resource.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
    /// <p>A list of the keys of the tags to be removed from the resource.</p>
    pub fn tag_keys(&self) -> std::option::Option<&[std::string::String]> {
        self.tag_keys.as_deref()
    }
}
impl UntagResourceInput {
    /// Creates a new builder-style object to manufacture [`UntagResourceInput`](crate::input::UntagResourceInput).
    pub fn builder() -> crate::input::untag_resource_input::Builder {
        crate::input::untag_resource_input::Builder::default()
    }
}

/// See [`UntagResourceInput`](crate::input::UntagResourceInput).
pub mod untag_resource_input {

    /// A builder for [`UntagResourceInput`](crate::input::UntagResourceInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The ARN of the resource.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the resource.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Appends an item to `tag_keys`.
        ///
        /// To override the contents of this collection use [`set_tag_keys`](Self::set_tag_keys).
        ///
        /// <p>A list of the keys of the tags to be removed from the resource.</p>
        pub fn tag_keys(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.tag_keys.unwrap_or_default();
            v.push(input.into());
            self.tag_keys = Some(v);
            self
        }
        /// <p>A list of the keys of the tags to be removed from the resource.</p>
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.tag_keys = input;
            self
        }
        /// Consumes the builder and constructs a [`UntagResourceInput`](crate::input::UntagResourceInput).
        pub fn build(
            self,
        ) -> Result<crate::input::UntagResourceInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::UntagResourceInput {
                resource_arn: self.resource_arn,
                tag_keys: self.tag_keys,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TagResourceInput {
    /// <p>The ARN of the resource.</p>
    #[doc(hidden)]
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>The new or modified tags for the resource.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl TagResourceInput {
    /// <p>The ARN of the resource.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
    /// <p>The new or modified tags for the resource.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
}
impl TagResourceInput {
    /// Creates a new builder-style object to manufacture [`TagResourceInput`](crate::input::TagResourceInput).
    pub fn builder() -> crate::input::tag_resource_input::Builder {
        crate::input::tag_resource_input::Builder::default()
    }
}

/// See [`TagResourceInput`](crate::input::TagResourceInput).
pub mod tag_resource_input {

    /// A builder for [`TagResourceInput`](crate::input::TagResourceInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The ARN of the resource.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the resource.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The new or modified tags for the resource.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>The new or modified tags for the resource.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`TagResourceInput`](crate::input::TagResourceInput).
        pub fn build(
            self,
        ) -> Result<crate::input::TagResourceInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::TagResourceInput {
                resource_arn: self.resource_arn,
                tags: self.tags,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RegisterAccountInput {
    /// <p>The registered Amazon Timestream resources that Amazon Web Services IoT FleetWise edge agent software can transfer your vehicle data to.</p>
    #[doc(hidden)]
    pub timestream_resources: std::option::Option<crate::model::TimestreamResources>,
    /// <p>The IAM resource that allows Amazon Web Services IoT FleetWise to send data to Amazon Timestream.</p>
    #[deprecated(note = "iamResources is no longer used or needed as input")]
    #[doc(hidden)]
    pub iam_resources: std::option::Option<crate::model::IamResources>,
}
impl RegisterAccountInput {
    /// <p>The registered Amazon Timestream resources that Amazon Web Services IoT FleetWise edge agent software can transfer your vehicle data to.</p>
    pub fn timestream_resources(&self) -> std::option::Option<&crate::model::TimestreamResources> {
        self.timestream_resources.as_ref()
    }
    /// <p>The IAM resource that allows Amazon Web Services IoT FleetWise to send data to Amazon Timestream.</p>
    #[deprecated(note = "iamResources is no longer used or needed as input")]
    pub fn iam_resources(&self) -> std::option::Option<&crate::model::IamResources> {
        self.iam_resources.as_ref()
    }
}
impl RegisterAccountInput {
    /// Creates a new builder-style object to manufacture [`RegisterAccountInput`](crate::input::RegisterAccountInput).
    pub fn builder() -> crate::input::register_account_input::Builder {
        crate::input::register_account_input::Builder::default()
    }
}

/// See [`RegisterAccountInput`](crate::input::RegisterAccountInput).
pub mod register_account_input {

    /// A builder for [`RegisterAccountInput`](crate::input::RegisterAccountInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) timestream_resources: std::option::Option<crate::model::TimestreamResources>,
        pub(crate) iam_resources: std::option::Option<crate::model::IamResources>,
    }
    impl Builder {
        /// <p>The registered Amazon Timestream resources that Amazon Web Services IoT FleetWise edge agent software can transfer your vehicle data to.</p>
        pub fn timestream_resources(mut self, input: crate::model::TimestreamResources) -> Self {
            self.timestream_resources = Some(input);
            self
        }
        /// <p>The registered Amazon Timestream resources that Amazon Web Services IoT FleetWise edge agent software can transfer your vehicle data to.</p>
        pub fn set_timestream_resources(
            mut self,
            input: std::option::Option<crate::model::TimestreamResources>,
        ) -> Self {
            self.timestream_resources = input;
            self
        }
        /// <p>The IAM resource that allows Amazon Web Services IoT FleetWise to send data to Amazon Timestream.</p>
        #[deprecated(note = "iamResources is no longer used or needed as input")]
        pub fn iam_resources(mut self, input: crate::model::IamResources) -> Self {
            self.iam_resources = Some(input);
            self
        }
        /// <p>The IAM resource that allows Amazon Web Services IoT FleetWise to send data to Amazon Timestream.</p>
        #[deprecated(note = "iamResources is no longer used or needed as input")]
        pub fn set_iam_resources(
            mut self,
            input: std::option::Option<crate::model::IamResources>,
        ) -> Self {
            self.iam_resources = input;
            self
        }
        /// Consumes the builder and constructs a [`RegisterAccountInput`](crate::input::RegisterAccountInput).
        pub fn build(
            self,
        ) -> Result<crate::input::RegisterAccountInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::RegisterAccountInput {
                timestream_resources: self.timestream_resources,
                iam_resources: self.iam_resources,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PutLoggingOptionsInput {
    /// <p>Creates or updates the log delivery option to Amazon CloudWatch Logs.</p>
    #[doc(hidden)]
    pub cloud_watch_log_delivery: std::option::Option<crate::model::CloudWatchLogDeliveryOptions>,
}
impl PutLoggingOptionsInput {
    /// <p>Creates or updates the log delivery option to Amazon CloudWatch Logs.</p>
    pub fn cloud_watch_log_delivery(
        &self,
    ) -> std::option::Option<&crate::model::CloudWatchLogDeliveryOptions> {
        self.cloud_watch_log_delivery.as_ref()
    }
}
impl PutLoggingOptionsInput {
    /// Creates a new builder-style object to manufacture [`PutLoggingOptionsInput`](crate::input::PutLoggingOptionsInput).
    pub fn builder() -> crate::input::put_logging_options_input::Builder {
        crate::input::put_logging_options_input::Builder::default()
    }
}

/// See [`PutLoggingOptionsInput`](crate::input::PutLoggingOptionsInput).
pub mod put_logging_options_input {

    /// A builder for [`PutLoggingOptionsInput`](crate::input::PutLoggingOptionsInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cloud_watch_log_delivery:
            std::option::Option<crate::model::CloudWatchLogDeliveryOptions>,
    }
    impl Builder {
        /// <p>Creates or updates the log delivery option to Amazon CloudWatch Logs.</p>
        pub fn cloud_watch_log_delivery(
            mut self,
            input: crate::model::CloudWatchLogDeliveryOptions,
        ) -> Self {
            self.cloud_watch_log_delivery = Some(input);
            self
        }
        /// <p>Creates or updates the log delivery option to Amazon CloudWatch Logs.</p>
        pub fn set_cloud_watch_log_delivery(
            mut self,
            input: std::option::Option<crate::model::CloudWatchLogDeliveryOptions>,
        ) -> Self {
            self.cloud_watch_log_delivery = input;
            self
        }
        /// Consumes the builder and constructs a [`PutLoggingOptionsInput`](crate::input::PutLoggingOptionsInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::PutLoggingOptionsInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::PutLoggingOptionsInput {
                cloud_watch_log_delivery: self.cloud_watch_log_delivery,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListTagsForResourceInput {
    /// <p>The ARN of the resource.</p>
    #[doc(hidden)]
    pub resource_arn: std::option::Option<std::string::String>,
}
impl ListTagsForResourceInput {
    /// <p>The ARN of the resource.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
}
impl ListTagsForResourceInput {
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput).
    pub fn builder() -> crate::input::list_tags_for_resource_input::Builder {
        crate::input::list_tags_for_resource_input::Builder::default()
    }
}

/// See [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput).
pub mod list_tags_for_resource_input {

    /// A builder for [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the resource.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the resource.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::ListTagsForResourceInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::ListTagsForResourceInput {
                resource_arn: self.resource_arn,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetVehicleStatusInput {
    /// <p>A pagination token for the next set of results.</p>
    /// <p>If the results of a search are large, only a portion of the results are returned, and a <code>nextToken</code> pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value. </p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p> The maximum number of items to return, between 1 and 100, inclusive. </p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p> The ID of the vehicle to retrieve information about. </p>
    #[doc(hidden)]
    pub vehicle_name: std::option::Option<std::string::String>,
}
impl GetVehicleStatusInput {
    /// <p>A pagination token for the next set of results.</p>
    /// <p>If the results of a search are large, only a portion of the results are returned, and a <code>nextToken</code> pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value. </p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p> The maximum number of items to return, between 1 and 100, inclusive. </p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p> The ID of the vehicle to retrieve information about. </p>
    pub fn vehicle_name(&self) -> std::option::Option<&str> {
        self.vehicle_name.as_deref()
    }
}
impl GetVehicleStatusInput {
    /// Creates a new builder-style object to manufacture [`GetVehicleStatusInput`](crate::input::GetVehicleStatusInput).
    pub fn builder() -> crate::input::get_vehicle_status_input::Builder {
        crate::input::get_vehicle_status_input::Builder::default()
    }
}

/// See [`GetVehicleStatusInput`](crate::input::GetVehicleStatusInput).
pub mod get_vehicle_status_input {

    /// A builder for [`GetVehicleStatusInput`](crate::input::GetVehicleStatusInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) vehicle_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A pagination token for the next set of results.</p>
        /// <p>If the results of a search are large, only a portion of the results are returned, and a <code>nextToken</code> pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>A pagination token for the next set of results.</p>
        /// <p>If the results of a search are large, only a portion of the results are returned, and a <code>nextToken</code> pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p> The maximum number of items to return, between 1 and 100, inclusive. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p> The maximum number of items to return, between 1 and 100, inclusive. </p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p> The ID of the vehicle to retrieve information about. </p>
        pub fn vehicle_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.vehicle_name = Some(input.into());
            self
        }
        /// <p> The ID of the vehicle to retrieve information about. </p>
        pub fn set_vehicle_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vehicle_name = input;
            self
        }
        /// Consumes the builder and constructs a [`GetVehicleStatusInput`](crate::input::GetVehicleStatusInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::GetVehicleStatusInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::GetVehicleStatusInput {
                next_token: self.next_token,
                max_results: self.max_results,
                vehicle_name: self.vehicle_name,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetRegisterAccountStatusInput {}
impl GetRegisterAccountStatusInput {
    /// Creates a new builder-style object to manufacture [`GetRegisterAccountStatusInput`](crate::input::GetRegisterAccountStatusInput).
    pub fn builder() -> crate::input::get_register_account_status_input::Builder {
        crate::input::get_register_account_status_input::Builder::default()
    }
}

/// See [`GetRegisterAccountStatusInput`](crate::input::GetRegisterAccountStatusInput).
pub mod get_register_account_status_input {

    /// A builder for [`GetRegisterAccountStatusInput`](crate::input::GetRegisterAccountStatusInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`GetRegisterAccountStatusInput`](crate::input::GetRegisterAccountStatusInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::GetRegisterAccountStatusInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::GetRegisterAccountStatusInput {})
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetLoggingOptionsInput {}
impl GetLoggingOptionsInput {
    /// Creates a new builder-style object to manufacture [`GetLoggingOptionsInput`](crate::input::GetLoggingOptionsInput).
    pub fn builder() -> crate::input::get_logging_options_input::Builder {
        crate::input::get_logging_options_input::Builder::default()
    }
}

/// See [`GetLoggingOptionsInput`](crate::input::GetLoggingOptionsInput).
pub mod get_logging_options_input {

    /// A builder for [`GetLoggingOptionsInput`](crate::input::GetLoggingOptionsInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`GetLoggingOptionsInput`](crate::input::GetLoggingOptionsInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::GetLoggingOptionsInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::GetLoggingOptionsInput {})
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BatchUpdateVehicleInput {
    /// <p> A list of information about the vehicles to update. For more information, see the API data type.</p>
    #[doc(hidden)]
    pub vehicles: std::option::Option<std::vec::Vec<crate::model::UpdateVehicleRequestItem>>,
}
impl BatchUpdateVehicleInput {
    /// <p> A list of information about the vehicles to update. For more information, see the API data type.</p>
    pub fn vehicles(&self) -> std::option::Option<&[crate::model::UpdateVehicleRequestItem]> {
        self.vehicles.as_deref()
    }
}
impl BatchUpdateVehicleInput {
    /// Creates a new builder-style object to manufacture [`BatchUpdateVehicleInput`](crate::input::BatchUpdateVehicleInput).
    pub fn builder() -> crate::input::batch_update_vehicle_input::Builder {
        crate::input::batch_update_vehicle_input::Builder::default()
    }
}

/// See [`BatchUpdateVehicleInput`](crate::input::BatchUpdateVehicleInput).
pub mod batch_update_vehicle_input {

    /// A builder for [`BatchUpdateVehicleInput`](crate::input::BatchUpdateVehicleInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) vehicles:
            std::option::Option<std::vec::Vec<crate::model::UpdateVehicleRequestItem>>,
    }
    impl Builder {
        /// Appends an item to `vehicles`.
        ///
        /// To override the contents of this collection use [`set_vehicles`](Self::set_vehicles).
        ///
        /// <p> A list of information about the vehicles to update. For more information, see the API data type.</p>
        pub fn vehicles(mut self, input: crate::model::UpdateVehicleRequestItem) -> Self {
            let mut v = self.vehicles.unwrap_or_default();
            v.push(input);
            self.vehicles = Some(v);
            self
        }
        /// <p> A list of information about the vehicles to update. For more information, see the API data type.</p>
        pub fn set_vehicles(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::UpdateVehicleRequestItem>>,
        ) -> Self {
            self.vehicles = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchUpdateVehicleInput`](crate::input::BatchUpdateVehicleInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::BatchUpdateVehicleInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::BatchUpdateVehicleInput {
                vehicles: self.vehicles,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BatchCreateVehicleInput {
    /// <p> A list of information about each vehicle to create. For more information, see the API data type.</p>
    #[doc(hidden)]
    pub vehicles: std::option::Option<std::vec::Vec<crate::model::CreateVehicleRequestItem>>,
}
impl BatchCreateVehicleInput {
    /// <p> A list of information about each vehicle to create. For more information, see the API data type.</p>
    pub fn vehicles(&self) -> std::option::Option<&[crate::model::CreateVehicleRequestItem]> {
        self.vehicles.as_deref()
    }
}
impl BatchCreateVehicleInput {
    /// Creates a new builder-style object to manufacture [`BatchCreateVehicleInput`](crate::input::BatchCreateVehicleInput).
    pub fn builder() -> crate::input::batch_create_vehicle_input::Builder {
        crate::input::batch_create_vehicle_input::Builder::default()
    }
}

/// See [`BatchCreateVehicleInput`](crate::input::BatchCreateVehicleInput).
pub mod batch_create_vehicle_input {

    /// A builder for [`BatchCreateVehicleInput`](crate::input::BatchCreateVehicleInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) vehicles:
            std::option::Option<std::vec::Vec<crate::model::CreateVehicleRequestItem>>,
    }
    impl Builder {
        /// Appends an item to `vehicles`.
        ///
        /// To override the contents of this collection use [`set_vehicles`](Self::set_vehicles).
        ///
        /// <p> A list of information about each vehicle to create. For more information, see the API data type.</p>
        pub fn vehicles(mut self, input: crate::model::CreateVehicleRequestItem) -> Self {
            let mut v = self.vehicles.unwrap_or_default();
            v.push(input);
            self.vehicles = Some(v);
            self
        }
        /// <p> A list of information about each vehicle to create. For more information, see the API data type.</p>
        pub fn set_vehicles(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CreateVehicleRequestItem>>,
        ) -> Self {
            self.vehicles = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchCreateVehicleInput`](crate::input::BatchCreateVehicleInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::BatchCreateVehicleInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::BatchCreateVehicleInput {
                vehicles: self.vehicles,
            })
        }
    }
}
