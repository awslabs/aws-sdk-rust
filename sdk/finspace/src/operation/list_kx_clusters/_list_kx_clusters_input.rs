// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct ListKxClustersInput {
    /// <p>A unique identifier for the kdb environment.</p>
    pub environment_id: ::std::option::Option<::std::string::String>,
    /// <p>Specifies the type of KDB database that is being created. The following types are available: </p>
    /// <ul>
    /// <li> <p>HDB – A Historical Database. The data is only accessible with read-only permissions from one of the FinSpace managed kdb databases mounted to the cluster.</p> </li>
    /// <li> <p>RDB – A Realtime Database. This type of database captures all the data from a ticker plant and stores it in memory until the end of day, after which it writes all of its data to a disk and reloads the HDB. This cluster type requires local storage for temporary storage of data during the savedown process. If you specify this field in your request, you must provide the <code>savedownStorageConfiguration</code> parameter.</p> </li>
    /// <li> <p>GATEWAY – A gateway cluster allows you to access data across processes in kdb systems. It allows you to create your own routing logic using the initialization scripts and custom code. This type of cluster does not require a writable local storage.</p> </li>
    /// </ul>
    pub cluster_type: ::std::option::Option<crate::types::KxClusterType>,
    /// <p>The maximum number of results to return in this request.</p>
    pub max_results: ::std::option::Option<i32>,
    /// <p>A token that indicates where a results page should begin.</p>
    pub next_token: ::std::option::Option<::std::string::String>,
}
impl ListKxClustersInput {
    /// <p>A unique identifier for the kdb environment.</p>
    pub fn environment_id(&self) -> ::std::option::Option<&str> {
        self.environment_id.as_deref()
    }
    /// <p>Specifies the type of KDB database that is being created. The following types are available: </p>
    /// <ul>
    /// <li> <p>HDB – A Historical Database. The data is only accessible with read-only permissions from one of the FinSpace managed kdb databases mounted to the cluster.</p> </li>
    /// <li> <p>RDB – A Realtime Database. This type of database captures all the data from a ticker plant and stores it in memory until the end of day, after which it writes all of its data to a disk and reloads the HDB. This cluster type requires local storage for temporary storage of data during the savedown process. If you specify this field in your request, you must provide the <code>savedownStorageConfiguration</code> parameter.</p> </li>
    /// <li> <p>GATEWAY – A gateway cluster allows you to access data across processes in kdb systems. It allows you to create your own routing logic using the initialization scripts and custom code. This type of cluster does not require a writable local storage.</p> </li>
    /// </ul>
    pub fn cluster_type(&self) -> ::std::option::Option<&crate::types::KxClusterType> {
        self.cluster_type.as_ref()
    }
    /// <p>The maximum number of results to return in this request.</p>
    pub fn max_results(&self) -> ::std::option::Option<i32> {
        self.max_results
    }
    /// <p>A token that indicates where a results page should begin.</p>
    pub fn next_token(&self) -> ::std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl ListKxClustersInput {
    /// Creates a new builder-style object to manufacture [`ListKxClustersInput`](crate::operation::list_kx_clusters::ListKxClustersInput).
    pub fn builder() -> crate::operation::list_kx_clusters::builders::ListKxClustersInputBuilder {
        crate::operation::list_kx_clusters::builders::ListKxClustersInputBuilder::default()
    }
}

/// A builder for [`ListKxClustersInput`](crate::operation::list_kx_clusters::ListKxClustersInput).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct ListKxClustersInputBuilder {
    pub(crate) environment_id: ::std::option::Option<::std::string::String>,
    pub(crate) cluster_type: ::std::option::Option<crate::types::KxClusterType>,
    pub(crate) max_results: ::std::option::Option<i32>,
    pub(crate) next_token: ::std::option::Option<::std::string::String>,
}
impl ListKxClustersInputBuilder {
    /// <p>A unique identifier for the kdb environment.</p>
    /// This field is required.
    pub fn environment_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.environment_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>A unique identifier for the kdb environment.</p>
    pub fn set_environment_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.environment_id = input;
        self
    }
    /// <p>A unique identifier for the kdb environment.</p>
    pub fn get_environment_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.environment_id
    }
    /// <p>Specifies the type of KDB database that is being created. The following types are available: </p>
    /// <ul>
    /// <li> <p>HDB – A Historical Database. The data is only accessible with read-only permissions from one of the FinSpace managed kdb databases mounted to the cluster.</p> </li>
    /// <li> <p>RDB – A Realtime Database. This type of database captures all the data from a ticker plant and stores it in memory until the end of day, after which it writes all of its data to a disk and reloads the HDB. This cluster type requires local storage for temporary storage of data during the savedown process. If you specify this field in your request, you must provide the <code>savedownStorageConfiguration</code> parameter.</p> </li>
    /// <li> <p>GATEWAY – A gateway cluster allows you to access data across processes in kdb systems. It allows you to create your own routing logic using the initialization scripts and custom code. This type of cluster does not require a writable local storage.</p> </li>
    /// </ul>
    pub fn cluster_type(mut self, input: crate::types::KxClusterType) -> Self {
        self.cluster_type = ::std::option::Option::Some(input);
        self
    }
    /// <p>Specifies the type of KDB database that is being created. The following types are available: </p>
    /// <ul>
    /// <li> <p>HDB – A Historical Database. The data is only accessible with read-only permissions from one of the FinSpace managed kdb databases mounted to the cluster.</p> </li>
    /// <li> <p>RDB – A Realtime Database. This type of database captures all the data from a ticker plant and stores it in memory until the end of day, after which it writes all of its data to a disk and reloads the HDB. This cluster type requires local storage for temporary storage of data during the savedown process. If you specify this field in your request, you must provide the <code>savedownStorageConfiguration</code> parameter.</p> </li>
    /// <li> <p>GATEWAY – A gateway cluster allows you to access data across processes in kdb systems. It allows you to create your own routing logic using the initialization scripts and custom code. This type of cluster does not require a writable local storage.</p> </li>
    /// </ul>
    pub fn set_cluster_type(mut self, input: ::std::option::Option<crate::types::KxClusterType>) -> Self {
        self.cluster_type = input;
        self
    }
    /// <p>Specifies the type of KDB database that is being created. The following types are available: </p>
    /// <ul>
    /// <li> <p>HDB – A Historical Database. The data is only accessible with read-only permissions from one of the FinSpace managed kdb databases mounted to the cluster.</p> </li>
    /// <li> <p>RDB – A Realtime Database. This type of database captures all the data from a ticker plant and stores it in memory until the end of day, after which it writes all of its data to a disk and reloads the HDB. This cluster type requires local storage for temporary storage of data during the savedown process. If you specify this field in your request, you must provide the <code>savedownStorageConfiguration</code> parameter.</p> </li>
    /// <li> <p>GATEWAY – A gateway cluster allows you to access data across processes in kdb systems. It allows you to create your own routing logic using the initialization scripts and custom code. This type of cluster does not require a writable local storage.</p> </li>
    /// </ul>
    pub fn get_cluster_type(&self) -> &::std::option::Option<crate::types::KxClusterType> {
        &self.cluster_type
    }
    /// <p>The maximum number of results to return in this request.</p>
    pub fn max_results(mut self, input: i32) -> Self {
        self.max_results = ::std::option::Option::Some(input);
        self
    }
    /// <p>The maximum number of results to return in this request.</p>
    pub fn set_max_results(mut self, input: ::std::option::Option<i32>) -> Self {
        self.max_results = input;
        self
    }
    /// <p>The maximum number of results to return in this request.</p>
    pub fn get_max_results(&self) -> &::std::option::Option<i32> {
        &self.max_results
    }
    /// <p>A token that indicates where a results page should begin.</p>
    pub fn next_token(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.next_token = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>A token that indicates where a results page should begin.</p>
    pub fn set_next_token(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.next_token = input;
        self
    }
    /// <p>A token that indicates where a results page should begin.</p>
    pub fn get_next_token(&self) -> &::std::option::Option<::std::string::String> {
        &self.next_token
    }
    /// Consumes the builder and constructs a [`ListKxClustersInput`](crate::operation::list_kx_clusters::ListKxClustersInput).
    pub fn build(
        self,
    ) -> ::std::result::Result<crate::operation::list_kx_clusters::ListKxClustersInput, ::aws_smithy_types::error::operation::BuildError> {
        ::std::result::Result::Ok(crate::operation::list_kx_clusters::ListKxClustersInput {
            environment_id: self.environment_id,
            cluster_type: self.cluster_type,
            max_results: self.max_results,
            next_token: self.next_token,
        })
    }
}
