// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>Creates a cache policy.</p>
/// <p>After you create a cache policy, you can attach it to one or more cache behaviors. When it’s
/// attached to a cache behavior, the cache policy determines the following:</p>
/// <ul>
/// <li>
/// <p>The values that CloudFront includes in the <i>cache key</i>. These values can
/// include HTTP headers, cookies, and URL query strings. CloudFront uses the cache key to
/// find an object in its cache that it can return to the viewer.</p>
/// </li>
/// <li>
/// <p>The default, minimum, and maximum time to live (TTL) values that you want objects to stay
/// in the CloudFront cache.</p>
/// </li>
/// </ul>
/// <p>The headers, cookies, and query strings that are included in the cache key are automatically
/// included in requests that CloudFront sends to the origin. CloudFront sends a request when it can’t
/// find an object in its cache that matches the request’s cache key. If you want to send
/// values to the origin but <i>not</i> include them in the cache key, use
/// <code>OriginRequestPolicy</code>.</p>
/// <p>For more information about cache policies, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html">Controlling the cache key</a> in the
/// <i>Amazon CloudFront Developer Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateCachePolicy {
    _private: (),
}
impl CreateCachePolicy {
    /// Creates a new builder-style object to manufacture [`CreateCachePolicyInput`](crate::input::CreateCachePolicyInput)
    pub fn builder() -> crate::input::create_cache_policy_input::Builder {
        crate::input::create_cache_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateCachePolicy {
    type Output = std::result::Result<
        crate::output::CreateCachePolicyOutput,
        crate::error::CreateCachePolicyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 201 {
            crate::operation_deser::parse_create_cache_policy_error(response)
        } else {
            crate::operation_deser::parse_create_cache_policy_response(response)
        }
    }
}

/// <p>Creates a new origin access identity. If you're using Amazon S3 for your origin, you can
/// use an origin access identity to require users to access your content using a CloudFront URL instead
/// of the Amazon S3 URL. For more information about how to use origin access identities, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html">Serving Private Content through CloudFront</a> in the
/// <i>Amazon CloudFront Developer Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateCloudFrontOriginAccessIdentity {
    _private: (),
}
impl CreateCloudFrontOriginAccessIdentity {
    /// Creates a new builder-style object to manufacture [`CreateCloudFrontOriginAccessIdentityInput`](crate::input::CreateCloudFrontOriginAccessIdentityInput)
    pub fn builder() -> crate::input::create_cloud_front_origin_access_identity_input::Builder {
        crate::input::create_cloud_front_origin_access_identity_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateCloudFrontOriginAccessIdentity {
    type Output = std::result::Result<
        crate::output::CreateCloudFrontOriginAccessIdentityOutput,
        crate::error::CreateCloudFrontOriginAccessIdentityError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 201 {
            crate::operation_deser::parse_create_cloud_front_origin_access_identity_error(response)
        } else {
            crate::operation_deser::parse_create_cloud_front_origin_access_identity_response(
                response,
            )
        }
    }
}

/// <p>Creates a new web distribution. You create a CloudFront distribution to tell CloudFront where you
/// want content to be delivered from, and the details about how to track and manage content delivery. Send a <code>POST</code> request to the
/// <code>/<i>CloudFront API version</i>/distribution</code>/<code>distribution ID</code> resource.</p>
/// <important>
/// <p>When you update a distribution, there are more required fields than when you create a distribution.
/// When you update your distribution by using
/// <a href="https://docs.aws.amazon.com/cloudfront/latest/APIReference/API_UpdateDistribution.html">UpdateDistribution</a>,
/// follow the steps included
/// in the documentation to get the current configuration
/// and then make your updates. This helps to make sure that you include all of the required fields. To view a summary,
/// see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-overview-required-fields.html">Required
/// Fields for Create Distribution and Update Distribution</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
/// </important>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateDistribution {
    _private: (),
}
impl CreateDistribution {
    /// Creates a new builder-style object to manufacture [`CreateDistributionInput`](crate::input::CreateDistributionInput)
    pub fn builder() -> crate::input::create_distribution_input::Builder {
        crate::input::create_distribution_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateDistribution {
    type Output = std::result::Result<
        crate::output::CreateDistributionOutput,
        crate::error::CreateDistributionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 201 {
            crate::operation_deser::parse_create_distribution_error(response)
        } else {
            crate::operation_deser::parse_create_distribution_response(response)
        }
    }
}

/// <p>Create a new distribution with tags.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateDistributionWithTags {
    _private: (),
}
impl CreateDistributionWithTags {
    /// Creates a new builder-style object to manufacture [`CreateDistributionWithTagsInput`](crate::input::CreateDistributionWithTagsInput)
    pub fn builder() -> crate::input::create_distribution_with_tags_input::Builder {
        crate::input::create_distribution_with_tags_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateDistributionWithTags {
    type Output = std::result::Result<
        crate::output::CreateDistributionWithTagsOutput,
        crate::error::CreateDistributionWithTagsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 201 {
            crate::operation_deser::parse_create_distribution_with_tags_error(response)
        } else {
            crate::operation_deser::parse_create_distribution_with_tags_response(response)
        }
    }
}

/// <p>Create a new field-level encryption configuration.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateFieldLevelEncryptionConfig {
    _private: (),
}
impl CreateFieldLevelEncryptionConfig {
    /// Creates a new builder-style object to manufacture [`CreateFieldLevelEncryptionConfigInput`](crate::input::CreateFieldLevelEncryptionConfigInput)
    pub fn builder() -> crate::input::create_field_level_encryption_config_input::Builder {
        crate::input::create_field_level_encryption_config_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateFieldLevelEncryptionConfig {
    type Output = std::result::Result<
        crate::output::CreateFieldLevelEncryptionConfigOutput,
        crate::error::CreateFieldLevelEncryptionConfigError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 201 {
            crate::operation_deser::parse_create_field_level_encryption_config_error(response)
        } else {
            crate::operation_deser::parse_create_field_level_encryption_config_response(response)
        }
    }
}

/// <p>Create a field-level encryption profile.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateFieldLevelEncryptionProfile {
    _private: (),
}
impl CreateFieldLevelEncryptionProfile {
    /// Creates a new builder-style object to manufacture [`CreateFieldLevelEncryptionProfileInput`](crate::input::CreateFieldLevelEncryptionProfileInput)
    pub fn builder() -> crate::input::create_field_level_encryption_profile_input::Builder {
        crate::input::create_field_level_encryption_profile_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateFieldLevelEncryptionProfile {
    type Output = std::result::Result<
        crate::output::CreateFieldLevelEncryptionProfileOutput,
        crate::error::CreateFieldLevelEncryptionProfileError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 201 {
            crate::operation_deser::parse_create_field_level_encryption_profile_error(response)
        } else {
            crate::operation_deser::parse_create_field_level_encryption_profile_response(response)
        }
    }
}

/// <p>Creates a CloudFront function.</p>
/// <p>To create a function, you provide the function code and some configuration information
/// about the function. The response contains an Amazon Resource Name (ARN) that uniquely
/// identifies the function.</p>
/// <p>When you create a function, it’s in the <code>DEVELOPMENT</code> stage. In this stage, you
/// can test the function with <code>TestFunction</code>, and update it with
/// <code>UpdateFunction</code>.</p>
/// <p>When you’re ready to use your function with a CloudFront distribution, use
/// <code>PublishFunction</code> to copy the function from the <code>DEVELOPMENT</code>
/// stage to <code>LIVE</code>. When it’s live, you can attach the function to a
/// distribution’s cache behavior, using the function’s ARN.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateFunction {
    _private: (),
}
impl CreateFunction {
    /// Creates a new builder-style object to manufacture [`CreateFunctionInput`](crate::input::CreateFunctionInput)
    pub fn builder() -> crate::input::create_function_input::Builder {
        crate::input::create_function_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateFunction {
    type Output =
        std::result::Result<crate::output::CreateFunctionOutput, crate::error::CreateFunctionError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 201 {
            crate::operation_deser::parse_create_function_error(response)
        } else {
            crate::operation_deser::parse_create_function_response(response)
        }
    }
}

/// <p>Create a new invalidation. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateInvalidation {
    _private: (),
}
impl CreateInvalidation {
    /// Creates a new builder-style object to manufacture [`CreateInvalidationInput`](crate::input::CreateInvalidationInput)
    pub fn builder() -> crate::input::create_invalidation_input::Builder {
        crate::input::create_invalidation_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateInvalidation {
    type Output = std::result::Result<
        crate::output::CreateInvalidationOutput,
        crate::error::CreateInvalidationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 201 {
            crate::operation_deser::parse_create_invalidation_error(response)
        } else {
            crate::operation_deser::parse_create_invalidation_response(response)
        }
    }
}

/// <p>Creates a key group that you can use with <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html">CloudFront signed URLs and signed cookies</a>.</p>
/// <p>To create a key group, you must specify at least one public key for the key group. After you
/// create a key group, you can reference it from one or more cache behaviors. When you
/// reference a key group in a cache behavior, CloudFront requires signed URLs or signed cookies
/// for all requests that match the cache behavior. The URLs or cookies must be signed with
/// a private key whose corresponding public key is in the key group. The signed URL or
/// cookie contains information about which public key CloudFront should use to verify the
/// signature. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html">Serving private content</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateKeyGroup {
    _private: (),
}
impl CreateKeyGroup {
    /// Creates a new builder-style object to manufacture [`CreateKeyGroupInput`](crate::input::CreateKeyGroupInput)
    pub fn builder() -> crate::input::create_key_group_input::Builder {
        crate::input::create_key_group_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateKeyGroup {
    type Output =
        std::result::Result<crate::output::CreateKeyGroupOutput, crate::error::CreateKeyGroupError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 201 {
            crate::operation_deser::parse_create_key_group_error(response)
        } else {
            crate::operation_deser::parse_create_key_group_response(response)
        }
    }
}

/// <p>Enables additional CloudWatch metrics for the specified CloudFront distribution. The
/// additional metrics incur an additional cost.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/viewing-cloudfront-metrics.html#monitoring-console.distributions-additional">Viewing additional CloudFront distribution metrics</a> in the
/// <i>Amazon CloudFront Developer Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateMonitoringSubscription {
    _private: (),
}
impl CreateMonitoringSubscription {
    /// Creates a new builder-style object to manufacture [`CreateMonitoringSubscriptionInput`](crate::input::CreateMonitoringSubscriptionInput)
    pub fn builder() -> crate::input::create_monitoring_subscription_input::Builder {
        crate::input::create_monitoring_subscription_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateMonitoringSubscription {
    type Output = std::result::Result<
        crate::output::CreateMonitoringSubscriptionOutput,
        crate::error::CreateMonitoringSubscriptionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_monitoring_subscription_error(response)
        } else {
            crate::operation_deser::parse_create_monitoring_subscription_response(response)
        }
    }
}

/// <p>Creates an origin request policy.</p>
/// <p>After you create an origin request policy, you can attach it to one or more cache behaviors.
/// When it’s attached to a cache behavior, the origin request policy determines the values
/// that CloudFront includes in requests that it sends to the origin. Each request that CloudFront sends
/// to the origin includes the following:</p>
/// <ul>
/// <li>
/// <p>The request body and the URL path (without the domain name) from the viewer
/// request.</p>
/// </li>
/// <li>
/// <p>The headers that CloudFront automatically includes in every origin request, including
/// <code>Host</code>, <code>User-Agent</code>, and <code>X-Amz-Cf-Id</code>.</p>
/// </li>
/// <li>
/// <p>All HTTP headers, cookies, and URL query strings that are specified in the cache policy or
/// the origin request policy. These can include items from the viewer request and,
/// in the case of headers, additional ones that are added by CloudFront.</p>
/// </li>
/// </ul>
/// <p>CloudFront sends a request when it can’t find a valid object in its cache that matches the
/// request. If you want to send values to the origin and also include them in the cache
/// key, use <code>CachePolicy</code>.</p>
/// <p>For more information about origin request policies, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html">Controlling origin requests</a> in the
/// <i>Amazon CloudFront Developer Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateOriginRequestPolicy {
    _private: (),
}
impl CreateOriginRequestPolicy {
    /// Creates a new builder-style object to manufacture [`CreateOriginRequestPolicyInput`](crate::input::CreateOriginRequestPolicyInput)
    pub fn builder() -> crate::input::create_origin_request_policy_input::Builder {
        crate::input::create_origin_request_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateOriginRequestPolicy {
    type Output = std::result::Result<
        crate::output::CreateOriginRequestPolicyOutput,
        crate::error::CreateOriginRequestPolicyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 201 {
            crate::operation_deser::parse_create_origin_request_policy_error(response)
        } else {
            crate::operation_deser::parse_create_origin_request_policy_response(response)
        }
    }
}

/// <p>Uploads a public key to CloudFront that you can use with <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html">signed URLs and signed cookies</a>, or with <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/field-level-encryption.html">field-level encryption</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreatePublicKey {
    _private: (),
}
impl CreatePublicKey {
    /// Creates a new builder-style object to manufacture [`CreatePublicKeyInput`](crate::input::CreatePublicKeyInput)
    pub fn builder() -> crate::input::create_public_key_input::Builder {
        crate::input::create_public_key_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreatePublicKey {
    type Output = std::result::Result<
        crate::output::CreatePublicKeyOutput,
        crate::error::CreatePublicKeyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 201 {
            crate::operation_deser::parse_create_public_key_error(response)
        } else {
            crate::operation_deser::parse_create_public_key_response(response)
        }
    }
}

/// <p>Creates a real-time log configuration.</p>
/// <p>After you create a real-time log configuration, you can attach it to one or more cache
/// behaviors to send real-time log data to the specified Amazon Kinesis data stream.</p>
/// <p>For more information about real-time log configurations, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/real-time-logs.html">Real-time logs</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateRealtimeLogConfig {
    _private: (),
}
impl CreateRealtimeLogConfig {
    /// Creates a new builder-style object to manufacture [`CreateRealtimeLogConfigInput`](crate::input::CreateRealtimeLogConfigInput)
    pub fn builder() -> crate::input::create_realtime_log_config_input::Builder {
        crate::input::create_realtime_log_config_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateRealtimeLogConfig {
    type Output = std::result::Result<
        crate::output::CreateRealtimeLogConfigOutput,
        crate::error::CreateRealtimeLogConfigError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 201 {
            crate::operation_deser::parse_create_realtime_log_config_error(response)
        } else {
            crate::operation_deser::parse_create_realtime_log_config_response(response)
        }
    }
}

/// <p>This API is deprecated.
/// Amazon CloudFront is deprecating real-time messaging protocol (RTMP) distributions on December 31, 2020.
/// For more information, <a href="http://forums.aws.amazon.com/ann.jspa?annID=7356">read the announcement</a> on the Amazon CloudFront discussion forum.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateStreamingDistribution {
    _private: (),
}
impl CreateStreamingDistribution {
    /// Creates a new builder-style object to manufacture [`CreateStreamingDistributionInput`](crate::input::CreateStreamingDistributionInput)
    pub fn builder() -> crate::input::create_streaming_distribution_input::Builder {
        crate::input::create_streaming_distribution_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateStreamingDistribution {
    type Output = std::result::Result<
        crate::output::CreateStreamingDistributionOutput,
        crate::error::CreateStreamingDistributionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 201 {
            crate::operation_deser::parse_create_streaming_distribution_error(response)
        } else {
            crate::operation_deser::parse_create_streaming_distribution_response(response)
        }
    }
}

/// <p>This API is deprecated.
/// Amazon CloudFront is deprecating real-time messaging protocol (RTMP) distributions on December 31, 2020.
/// For more information, <a href="http://forums.aws.amazon.com/ann.jspa?annID=7356">read the announcement</a> on the Amazon CloudFront discussion forum.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateStreamingDistributionWithTags {
    _private: (),
}
impl CreateStreamingDistributionWithTags {
    /// Creates a new builder-style object to manufacture [`CreateStreamingDistributionWithTagsInput`](crate::input::CreateStreamingDistributionWithTagsInput)
    pub fn builder() -> crate::input::create_streaming_distribution_with_tags_input::Builder {
        crate::input::create_streaming_distribution_with_tags_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateStreamingDistributionWithTags {
    type Output = std::result::Result<
        crate::output::CreateStreamingDistributionWithTagsOutput,
        crate::error::CreateStreamingDistributionWithTagsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 201 {
            crate::operation_deser::parse_create_streaming_distribution_with_tags_error(response)
        } else {
            crate::operation_deser::parse_create_streaming_distribution_with_tags_response(response)
        }
    }
}

/// <p>Deletes a cache policy.</p>
/// <p>You cannot delete a cache policy if it’s attached to a cache behavior. First update your
/// distributions to remove the cache policy from all cache behaviors, then delete the cache
/// policy.</p>
/// <p>To delete a cache policy, you must provide the policy’s identifier and version. To get these
/// values, you can use <code>ListCachePolicies</code> or
/// <code>GetCachePolicy</code>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteCachePolicy {
    _private: (),
}
impl DeleteCachePolicy {
    /// Creates a new builder-style object to manufacture [`DeleteCachePolicyInput`](crate::input::DeleteCachePolicyInput)
    pub fn builder() -> crate::input::delete_cache_policy_input::Builder {
        crate::input::delete_cache_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteCachePolicy {
    type Output = std::result::Result<
        crate::output::DeleteCachePolicyOutput,
        crate::error::DeleteCachePolicyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 204 {
            crate::operation_deser::parse_delete_cache_policy_error(response)
        } else {
            crate::operation_deser::parse_delete_cache_policy_response(response)
        }
    }
}

/// <p>Delete an origin access identity. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteCloudFrontOriginAccessIdentity {
    _private: (),
}
impl DeleteCloudFrontOriginAccessIdentity {
    /// Creates a new builder-style object to manufacture [`DeleteCloudFrontOriginAccessIdentityInput`](crate::input::DeleteCloudFrontOriginAccessIdentityInput)
    pub fn builder() -> crate::input::delete_cloud_front_origin_access_identity_input::Builder {
        crate::input::delete_cloud_front_origin_access_identity_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteCloudFrontOriginAccessIdentity {
    type Output = std::result::Result<
        crate::output::DeleteCloudFrontOriginAccessIdentityOutput,
        crate::error::DeleteCloudFrontOriginAccessIdentityError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 204 {
            crate::operation_deser::parse_delete_cloud_front_origin_access_identity_error(response)
        } else {
            crate::operation_deser::parse_delete_cloud_front_origin_access_identity_response(
                response,
            )
        }
    }
}

/// <p>Delete a distribution. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteDistribution {
    _private: (),
}
impl DeleteDistribution {
    /// Creates a new builder-style object to manufacture [`DeleteDistributionInput`](crate::input::DeleteDistributionInput)
    pub fn builder() -> crate::input::delete_distribution_input::Builder {
        crate::input::delete_distribution_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteDistribution {
    type Output = std::result::Result<
        crate::output::DeleteDistributionOutput,
        crate::error::DeleteDistributionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 204 {
            crate::operation_deser::parse_delete_distribution_error(response)
        } else {
            crate::operation_deser::parse_delete_distribution_response(response)
        }
    }
}

/// <p>Remove a field-level encryption configuration.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteFieldLevelEncryptionConfig {
    _private: (),
}
impl DeleteFieldLevelEncryptionConfig {
    /// Creates a new builder-style object to manufacture [`DeleteFieldLevelEncryptionConfigInput`](crate::input::DeleteFieldLevelEncryptionConfigInput)
    pub fn builder() -> crate::input::delete_field_level_encryption_config_input::Builder {
        crate::input::delete_field_level_encryption_config_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteFieldLevelEncryptionConfig {
    type Output = std::result::Result<
        crate::output::DeleteFieldLevelEncryptionConfigOutput,
        crate::error::DeleteFieldLevelEncryptionConfigError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 204 {
            crate::operation_deser::parse_delete_field_level_encryption_config_error(response)
        } else {
            crate::operation_deser::parse_delete_field_level_encryption_config_response(response)
        }
    }
}

/// <p>Remove a field-level encryption profile.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteFieldLevelEncryptionProfile {
    _private: (),
}
impl DeleteFieldLevelEncryptionProfile {
    /// Creates a new builder-style object to manufacture [`DeleteFieldLevelEncryptionProfileInput`](crate::input::DeleteFieldLevelEncryptionProfileInput)
    pub fn builder() -> crate::input::delete_field_level_encryption_profile_input::Builder {
        crate::input::delete_field_level_encryption_profile_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteFieldLevelEncryptionProfile {
    type Output = std::result::Result<
        crate::output::DeleteFieldLevelEncryptionProfileOutput,
        crate::error::DeleteFieldLevelEncryptionProfileError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 204 {
            crate::operation_deser::parse_delete_field_level_encryption_profile_error(response)
        } else {
            crate::operation_deser::parse_delete_field_level_encryption_profile_response(response)
        }
    }
}

/// <p>Deletes a CloudFront function.</p>
/// <p>You cannot delete a function if it’s associated with a cache behavior. First, update your
/// distributions to remove the function association from all cache behaviors, then delete
/// the function.</p>
/// <p>To delete a function, you must provide the function’s name and version
/// (<code>ETag</code> value). To get these values, you can use <code>ListFunctions</code>
/// and <code>DescribeFunction</code>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteFunction {
    _private: (),
}
impl DeleteFunction {
    /// Creates a new builder-style object to manufacture [`DeleteFunctionInput`](crate::input::DeleteFunctionInput)
    pub fn builder() -> crate::input::delete_function_input::Builder {
        crate::input::delete_function_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteFunction {
    type Output =
        std::result::Result<crate::output::DeleteFunctionOutput, crate::error::DeleteFunctionError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 204 {
            crate::operation_deser::parse_delete_function_error(response)
        } else {
            crate::operation_deser::parse_delete_function_response(response)
        }
    }
}

/// <p>Deletes a key group.</p>
/// <p>You cannot delete a key group that is referenced in a cache behavior. First update
/// your distributions to remove the key group from all cache behaviors, then delete the key
/// group.</p>
/// <p>To delete a key group, you must provide the key group’s identifier and version. To get
/// these values, use <code>ListKeyGroups</code> followed by <code>GetKeyGroup</code> or
/// <code>GetKeyGroupConfig</code>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteKeyGroup {
    _private: (),
}
impl DeleteKeyGroup {
    /// Creates a new builder-style object to manufacture [`DeleteKeyGroupInput`](crate::input::DeleteKeyGroupInput)
    pub fn builder() -> crate::input::delete_key_group_input::Builder {
        crate::input::delete_key_group_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteKeyGroup {
    type Output =
        std::result::Result<crate::output::DeleteKeyGroupOutput, crate::error::DeleteKeyGroupError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 204 {
            crate::operation_deser::parse_delete_key_group_error(response)
        } else {
            crate::operation_deser::parse_delete_key_group_response(response)
        }
    }
}

/// <p>Disables additional CloudWatch metrics for the specified CloudFront distribution.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteMonitoringSubscription {
    _private: (),
}
impl DeleteMonitoringSubscription {
    /// Creates a new builder-style object to manufacture [`DeleteMonitoringSubscriptionInput`](crate::input::DeleteMonitoringSubscriptionInput)
    pub fn builder() -> crate::input::delete_monitoring_subscription_input::Builder {
        crate::input::delete_monitoring_subscription_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteMonitoringSubscription {
    type Output = std::result::Result<
        crate::output::DeleteMonitoringSubscriptionOutput,
        crate::error::DeleteMonitoringSubscriptionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_monitoring_subscription_error(response)
        } else {
            crate::operation_deser::parse_delete_monitoring_subscription_response(response)
        }
    }
}

/// <p>Deletes an origin request policy.</p>
/// <p>You cannot delete an origin request policy if it’s attached to any cache behaviors. First
/// update your distributions to remove the origin request policy from all cache behaviors,
/// then delete the origin request policy.</p>
/// <p>To delete an origin request policy, you must provide the policy’s identifier and version. To
/// get the identifier, you can use <code>ListOriginRequestPolicies</code> or
/// <code>GetOriginRequestPolicy</code>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteOriginRequestPolicy {
    _private: (),
}
impl DeleteOriginRequestPolicy {
    /// Creates a new builder-style object to manufacture [`DeleteOriginRequestPolicyInput`](crate::input::DeleteOriginRequestPolicyInput)
    pub fn builder() -> crate::input::delete_origin_request_policy_input::Builder {
        crate::input::delete_origin_request_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteOriginRequestPolicy {
    type Output = std::result::Result<
        crate::output::DeleteOriginRequestPolicyOutput,
        crate::error::DeleteOriginRequestPolicyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 204 {
            crate::operation_deser::parse_delete_origin_request_policy_error(response)
        } else {
            crate::operation_deser::parse_delete_origin_request_policy_response(response)
        }
    }
}

/// <p>Remove a public key you previously added to CloudFront.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeletePublicKey {
    _private: (),
}
impl DeletePublicKey {
    /// Creates a new builder-style object to manufacture [`DeletePublicKeyInput`](crate::input::DeletePublicKeyInput)
    pub fn builder() -> crate::input::delete_public_key_input::Builder {
        crate::input::delete_public_key_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeletePublicKey {
    type Output = std::result::Result<
        crate::output::DeletePublicKeyOutput,
        crate::error::DeletePublicKeyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 204 {
            crate::operation_deser::parse_delete_public_key_error(response)
        } else {
            crate::operation_deser::parse_delete_public_key_response(response)
        }
    }
}

/// <p>Deletes a real-time log configuration.</p>
/// <p>You cannot delete a real-time log configuration if it’s attached to a cache behavior.
/// First update your distributions to remove the real-time log configuration from all cache
/// behaviors, then delete the real-time log configuration.</p>
/// <p>To delete a real-time log configuration, you can provide the configuration’s name or its
/// Amazon Resource Name (ARN). You must provide at least one. If you provide both, CloudFront
/// uses the name to identify the real-time log configuration to delete.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteRealtimeLogConfig {
    _private: (),
}
impl DeleteRealtimeLogConfig {
    /// Creates a new builder-style object to manufacture [`DeleteRealtimeLogConfigInput`](crate::input::DeleteRealtimeLogConfigInput)
    pub fn builder() -> crate::input::delete_realtime_log_config_input::Builder {
        crate::input::delete_realtime_log_config_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteRealtimeLogConfig {
    type Output = std::result::Result<
        crate::output::DeleteRealtimeLogConfigOutput,
        crate::error::DeleteRealtimeLogConfigError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 204 {
            crate::operation_deser::parse_delete_realtime_log_config_error(response)
        } else {
            crate::operation_deser::parse_delete_realtime_log_config_response(response)
        }
    }
}

/// <p>Delete a streaming distribution. To delete an RTMP distribution using the CloudFront API,
/// perform the following steps.</p>
/// <p>
/// <b>To delete an RTMP distribution using the CloudFront
/// API</b>:</p>
/// <ol>
/// <li>
/// <p>Disable the RTMP distribution.</p>
/// </li>
/// <li>
/// <p>Submit a <code>GET Streaming Distribution Config</code> request to get the current
/// configuration and the <code>Etag</code> header for the distribution. </p>
/// </li>
/// <li>
/// <p>Update the XML document that was returned in the response to your <code>GET
/// Streaming Distribution Config</code> request to change the value of <code>Enabled</code>
/// to <code>false</code>.</p>
/// </li>
/// <li>
/// <p>Submit a <code>PUT Streaming Distribution Config</code> request to update the
/// configuration for your distribution. In the request body, include the XML document that
/// you updated in Step 3. Then set the value of the HTTP <code>If-Match</code> header to the
/// value of the <code>ETag</code> header that CloudFront returned when you submitted the <code>GET
/// Streaming Distribution Config</code> request in Step 2.</p>
/// </li>
/// <li>
/// <p>Review the response to the <code>PUT Streaming Distribution Config</code> request
/// to confirm that the distribution was successfully disabled.</p>
/// </li>
/// <li>
/// <p>Submit a <code>GET Streaming Distribution Config</code> request to confirm that
/// your changes have propagated. When propagation is complete, the value of
/// <code>Status</code> is <code>Deployed</code>.</p>
/// </li>
/// <li>
/// <p>Submit a <code>DELETE Streaming Distribution</code> request. Set the value of the
/// HTTP <code>If-Match</code> header to the value of the <code>ETag</code> header that CloudFront
/// returned when you submitted the <code>GET Streaming Distribution Config</code> request in
/// Step 2.</p>
/// </li>
/// <li>
/// <p>Review the response to your <code>DELETE Streaming Distribution</code> request to
/// confirm that the distribution was successfully deleted.</p>
/// </li>
/// </ol>
/// <p>For information about deleting a distribution using the CloudFront console, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/HowToDeleteDistribution.html">Deleting a Distribution</a> in the
/// <i>Amazon CloudFront Developer Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteStreamingDistribution {
    _private: (),
}
impl DeleteStreamingDistribution {
    /// Creates a new builder-style object to manufacture [`DeleteStreamingDistributionInput`](crate::input::DeleteStreamingDistributionInput)
    pub fn builder() -> crate::input::delete_streaming_distribution_input::Builder {
        crate::input::delete_streaming_distribution_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteStreamingDistribution {
    type Output = std::result::Result<
        crate::output::DeleteStreamingDistributionOutput,
        crate::error::DeleteStreamingDistributionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 204 {
            crate::operation_deser::parse_delete_streaming_distribution_error(response)
        } else {
            crate::operation_deser::parse_delete_streaming_distribution_response(response)
        }
    }
}

/// <p>Gets configuration information and metadata about a CloudFront function, but not the function’s
/// code. To get a function’s code, use <code>GetFunction</code>.</p>
/// <p>To get configuration information and metadata about a function, you must provide the
/// function’s name and stage. To get these values, you can use
/// <code>ListFunctions</code>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeFunction {
    _private: (),
}
impl DescribeFunction {
    /// Creates a new builder-style object to manufacture [`DescribeFunctionInput`](crate::input::DescribeFunctionInput)
    pub fn builder() -> crate::input::describe_function_input::Builder {
        crate::input::describe_function_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeFunction {
    type Output = std::result::Result<
        crate::output::DescribeFunctionOutput,
        crate::error::DescribeFunctionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_function_error(response)
        } else {
            crate::operation_deser::parse_describe_function_response(response)
        }
    }
}

/// <p>Gets a cache policy, including the following metadata:</p>
/// <ul>
/// <li>
/// <p>The policy’s identifier.</p>
/// </li>
/// <li>
/// <p>The date and time when the policy was last modified.</p>
/// </li>
/// </ul>
/// <p>To get a cache policy, you must provide the policy’s identifier. If the cache policy is
/// attached to a distribution’s cache behavior, you can get the policy’s identifier using
/// <code>ListDistributions</code> or <code>GetDistribution</code>. If the cache policy is
/// not attached to a cache behavior, you can get the identifier using
/// <code>ListCachePolicies</code>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetCachePolicy {
    _private: (),
}
impl GetCachePolicy {
    /// Creates a new builder-style object to manufacture [`GetCachePolicyInput`](crate::input::GetCachePolicyInput)
    pub fn builder() -> crate::input::get_cache_policy_input::Builder {
        crate::input::get_cache_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetCachePolicy {
    type Output =
        std::result::Result<crate::output::GetCachePolicyOutput, crate::error::GetCachePolicyError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_cache_policy_error(response)
        } else {
            crate::operation_deser::parse_get_cache_policy_response(response)
        }
    }
}

/// <p>Gets a cache policy configuration.</p>
/// <p>To get a cache policy configuration, you must provide the policy’s identifier. If the cache
/// policy is attached to a distribution’s cache behavior, you can get the policy’s
/// identifier using <code>ListDistributions</code> or <code>GetDistribution</code>. If the
/// cache policy is not attached to a cache behavior, you can get the identifier using
/// <code>ListCachePolicies</code>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetCachePolicyConfig {
    _private: (),
}
impl GetCachePolicyConfig {
    /// Creates a new builder-style object to manufacture [`GetCachePolicyConfigInput`](crate::input::GetCachePolicyConfigInput)
    pub fn builder() -> crate::input::get_cache_policy_config_input::Builder {
        crate::input::get_cache_policy_config_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetCachePolicyConfig {
    type Output = std::result::Result<
        crate::output::GetCachePolicyConfigOutput,
        crate::error::GetCachePolicyConfigError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_cache_policy_config_error(response)
        } else {
            crate::operation_deser::parse_get_cache_policy_config_response(response)
        }
    }
}

/// <p>Get the information about an origin access identity. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetCloudFrontOriginAccessIdentity {
    _private: (),
}
impl GetCloudFrontOriginAccessIdentity {
    /// Creates a new builder-style object to manufacture [`GetCloudFrontOriginAccessIdentityInput`](crate::input::GetCloudFrontOriginAccessIdentityInput)
    pub fn builder() -> crate::input::get_cloud_front_origin_access_identity_input::Builder {
        crate::input::get_cloud_front_origin_access_identity_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetCloudFrontOriginAccessIdentity {
    type Output = std::result::Result<
        crate::output::GetCloudFrontOriginAccessIdentityOutput,
        crate::error::GetCloudFrontOriginAccessIdentityError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_cloud_front_origin_access_identity_error(response)
        } else {
            crate::operation_deser::parse_get_cloud_front_origin_access_identity_response(response)
        }
    }
}

/// <p>Get the configuration information about an origin access identity. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetCloudFrontOriginAccessIdentityConfig {
    _private: (),
}
impl GetCloudFrontOriginAccessIdentityConfig {
    /// Creates a new builder-style object to manufacture [`GetCloudFrontOriginAccessIdentityConfigInput`](crate::input::GetCloudFrontOriginAccessIdentityConfigInput)
    pub fn builder() -> crate::input::get_cloud_front_origin_access_identity_config_input::Builder {
        crate::input::get_cloud_front_origin_access_identity_config_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetCloudFrontOriginAccessIdentityConfig {
    type Output = std::result::Result<
        crate::output::GetCloudFrontOriginAccessIdentityConfigOutput,
        crate::error::GetCloudFrontOriginAccessIdentityConfigError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_cloud_front_origin_access_identity_config_error(
                response,
            )
        } else {
            crate::operation_deser::parse_get_cloud_front_origin_access_identity_config_response(
                response,
            )
        }
    }
}

/// <p>Get the information about a distribution.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetDistribution {
    _private: (),
}
impl GetDistribution {
    /// Creates a new builder-style object to manufacture [`GetDistributionInput`](crate::input::GetDistributionInput)
    pub fn builder() -> crate::input::get_distribution_input::Builder {
        crate::input::get_distribution_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetDistribution {
    type Output = std::result::Result<
        crate::output::GetDistributionOutput,
        crate::error::GetDistributionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_distribution_error(response)
        } else {
            crate::operation_deser::parse_get_distribution_response(response)
        }
    }
}

/// <p>Get the configuration information about a distribution. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetDistributionConfig {
    _private: (),
}
impl GetDistributionConfig {
    /// Creates a new builder-style object to manufacture [`GetDistributionConfigInput`](crate::input::GetDistributionConfigInput)
    pub fn builder() -> crate::input::get_distribution_config_input::Builder {
        crate::input::get_distribution_config_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetDistributionConfig {
    type Output = std::result::Result<
        crate::output::GetDistributionConfigOutput,
        crate::error::GetDistributionConfigError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_distribution_config_error(response)
        } else {
            crate::operation_deser::parse_get_distribution_config_response(response)
        }
    }
}

/// <p>Get the field-level encryption configuration information.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetFieldLevelEncryption {
    _private: (),
}
impl GetFieldLevelEncryption {
    /// Creates a new builder-style object to manufacture [`GetFieldLevelEncryptionInput`](crate::input::GetFieldLevelEncryptionInput)
    pub fn builder() -> crate::input::get_field_level_encryption_input::Builder {
        crate::input::get_field_level_encryption_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetFieldLevelEncryption {
    type Output = std::result::Result<
        crate::output::GetFieldLevelEncryptionOutput,
        crate::error::GetFieldLevelEncryptionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_field_level_encryption_error(response)
        } else {
            crate::operation_deser::parse_get_field_level_encryption_response(response)
        }
    }
}

/// <p>Get the field-level encryption configuration information.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetFieldLevelEncryptionConfig {
    _private: (),
}
impl GetFieldLevelEncryptionConfig {
    /// Creates a new builder-style object to manufacture [`GetFieldLevelEncryptionConfigInput`](crate::input::GetFieldLevelEncryptionConfigInput)
    pub fn builder() -> crate::input::get_field_level_encryption_config_input::Builder {
        crate::input::get_field_level_encryption_config_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetFieldLevelEncryptionConfig {
    type Output = std::result::Result<
        crate::output::GetFieldLevelEncryptionConfigOutput,
        crate::error::GetFieldLevelEncryptionConfigError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_field_level_encryption_config_error(response)
        } else {
            crate::operation_deser::parse_get_field_level_encryption_config_response(response)
        }
    }
}

/// <p>Get the field-level encryption profile information.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetFieldLevelEncryptionProfile {
    _private: (),
}
impl GetFieldLevelEncryptionProfile {
    /// Creates a new builder-style object to manufacture [`GetFieldLevelEncryptionProfileInput`](crate::input::GetFieldLevelEncryptionProfileInput)
    pub fn builder() -> crate::input::get_field_level_encryption_profile_input::Builder {
        crate::input::get_field_level_encryption_profile_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetFieldLevelEncryptionProfile {
    type Output = std::result::Result<
        crate::output::GetFieldLevelEncryptionProfileOutput,
        crate::error::GetFieldLevelEncryptionProfileError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_field_level_encryption_profile_error(response)
        } else {
            crate::operation_deser::parse_get_field_level_encryption_profile_response(response)
        }
    }
}

/// <p>Get the field-level encryption profile configuration information.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetFieldLevelEncryptionProfileConfig {
    _private: (),
}
impl GetFieldLevelEncryptionProfileConfig {
    /// Creates a new builder-style object to manufacture [`GetFieldLevelEncryptionProfileConfigInput`](crate::input::GetFieldLevelEncryptionProfileConfigInput)
    pub fn builder() -> crate::input::get_field_level_encryption_profile_config_input::Builder {
        crate::input::get_field_level_encryption_profile_config_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetFieldLevelEncryptionProfileConfig {
    type Output = std::result::Result<
        crate::output::GetFieldLevelEncryptionProfileConfigOutput,
        crate::error::GetFieldLevelEncryptionProfileConfigError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_field_level_encryption_profile_config_error(response)
        } else {
            crate::operation_deser::parse_get_field_level_encryption_profile_config_response(
                response,
            )
        }
    }
}

/// <p>Gets the code of a CloudFront function. To get configuration information and metadata about
/// a function, use <code>DescribeFunction</code>.</p>
/// <p>To get a function’s code, you must provide the function’s name and stage. To get these
/// values, you can use <code>ListFunctions</code>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetFunction {
    _private: (),
}
impl GetFunction {
    /// Creates a new builder-style object to manufacture [`GetFunctionInput`](crate::input::GetFunctionInput)
    pub fn builder() -> crate::input::get_function_input::Builder {
        crate::input::get_function_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetFunction {
    type Output =
        std::result::Result<crate::output::GetFunctionOutput, crate::error::GetFunctionError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_function_error(response)
        } else {
            crate::operation_deser::parse_get_function_response(response)
        }
    }
}

/// <p>Get the information about an invalidation. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetInvalidation {
    _private: (),
}
impl GetInvalidation {
    /// Creates a new builder-style object to manufacture [`GetInvalidationInput`](crate::input::GetInvalidationInput)
    pub fn builder() -> crate::input::get_invalidation_input::Builder {
        crate::input::get_invalidation_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetInvalidation {
    type Output = std::result::Result<
        crate::output::GetInvalidationOutput,
        crate::error::GetInvalidationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_invalidation_error(response)
        } else {
            crate::operation_deser::parse_get_invalidation_response(response)
        }
    }
}

/// <p>Gets a key group, including the date and time when the key group was last modified.</p>
/// <p>To get a key group, you must provide the key group’s identifier. If the key group is
/// referenced in a distribution’s cache behavior, you can get the key group’s identifier
/// using <code>ListDistributions</code> or <code>GetDistribution</code>. If the key group
/// is not referenced in a cache behavior, you can get the identifier using
/// <code>ListKeyGroups</code>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetKeyGroup {
    _private: (),
}
impl GetKeyGroup {
    /// Creates a new builder-style object to manufacture [`GetKeyGroupInput`](crate::input::GetKeyGroupInput)
    pub fn builder() -> crate::input::get_key_group_input::Builder {
        crate::input::get_key_group_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetKeyGroup {
    type Output =
        std::result::Result<crate::output::GetKeyGroupOutput, crate::error::GetKeyGroupError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_key_group_error(response)
        } else {
            crate::operation_deser::parse_get_key_group_response(response)
        }
    }
}

/// <p>Gets a key group configuration.</p>
/// <p>To get a key group configuration, you must provide the key group’s identifier. If the
/// key group is referenced in a distribution’s cache behavior, you can get the key group’s
/// identifier using <code>ListDistributions</code> or <code>GetDistribution</code>. If the
/// key group is not referenced in a cache behavior, you can get the identifier using
/// <code>ListKeyGroups</code>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetKeyGroupConfig {
    _private: (),
}
impl GetKeyGroupConfig {
    /// Creates a new builder-style object to manufacture [`GetKeyGroupConfigInput`](crate::input::GetKeyGroupConfigInput)
    pub fn builder() -> crate::input::get_key_group_config_input::Builder {
        crate::input::get_key_group_config_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetKeyGroupConfig {
    type Output = std::result::Result<
        crate::output::GetKeyGroupConfigOutput,
        crate::error::GetKeyGroupConfigError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_key_group_config_error(response)
        } else {
            crate::operation_deser::parse_get_key_group_config_response(response)
        }
    }
}

/// <p>Gets information about whether additional CloudWatch metrics are enabled for the specified
/// CloudFront distribution.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetMonitoringSubscription {
    _private: (),
}
impl GetMonitoringSubscription {
    /// Creates a new builder-style object to manufacture [`GetMonitoringSubscriptionInput`](crate::input::GetMonitoringSubscriptionInput)
    pub fn builder() -> crate::input::get_monitoring_subscription_input::Builder {
        crate::input::get_monitoring_subscription_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetMonitoringSubscription {
    type Output = std::result::Result<
        crate::output::GetMonitoringSubscriptionOutput,
        crate::error::GetMonitoringSubscriptionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_monitoring_subscription_error(response)
        } else {
            crate::operation_deser::parse_get_monitoring_subscription_response(response)
        }
    }
}

/// <p>Gets an origin request policy, including the following metadata:</p>
/// <ul>
/// <li>
/// <p>The policy’s identifier.</p>
/// </li>
/// <li>
/// <p>The date and time when the policy was last modified.</p>
/// </li>
/// </ul>
/// <p>To get an origin request policy, you must provide the policy’s identifier. If the origin
/// request policy is attached to a distribution’s cache behavior, you can get the policy’s
/// identifier using <code>ListDistributions</code> or <code>GetDistribution</code>. If the
/// origin request policy is not attached to a cache behavior, you can get the identifier
/// using <code>ListOriginRequestPolicies</code>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetOriginRequestPolicy {
    _private: (),
}
impl GetOriginRequestPolicy {
    /// Creates a new builder-style object to manufacture [`GetOriginRequestPolicyInput`](crate::input::GetOriginRequestPolicyInput)
    pub fn builder() -> crate::input::get_origin_request_policy_input::Builder {
        crate::input::get_origin_request_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetOriginRequestPolicy {
    type Output = std::result::Result<
        crate::output::GetOriginRequestPolicyOutput,
        crate::error::GetOriginRequestPolicyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_origin_request_policy_error(response)
        } else {
            crate::operation_deser::parse_get_origin_request_policy_response(response)
        }
    }
}

/// <p>Gets an origin request policy configuration.</p>
/// <p>To get an origin request policy configuration, you must provide the policy’s identifier. If
/// the origin request policy is attached to a distribution’s cache behavior, you can get
/// the policy’s identifier using <code>ListDistributions</code> or
/// <code>GetDistribution</code>. If the origin request policy is not attached to a cache
/// behavior, you can get the identifier using
/// <code>ListOriginRequestPolicies</code>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetOriginRequestPolicyConfig {
    _private: (),
}
impl GetOriginRequestPolicyConfig {
    /// Creates a new builder-style object to manufacture [`GetOriginRequestPolicyConfigInput`](crate::input::GetOriginRequestPolicyConfigInput)
    pub fn builder() -> crate::input::get_origin_request_policy_config_input::Builder {
        crate::input::get_origin_request_policy_config_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetOriginRequestPolicyConfig {
    type Output = std::result::Result<
        crate::output::GetOriginRequestPolicyConfigOutput,
        crate::error::GetOriginRequestPolicyConfigError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_origin_request_policy_config_error(response)
        } else {
            crate::operation_deser::parse_get_origin_request_policy_config_response(response)
        }
    }
}

/// <p>Gets a public key.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetPublicKey {
    _private: (),
}
impl GetPublicKey {
    /// Creates a new builder-style object to manufacture [`GetPublicKeyInput`](crate::input::GetPublicKeyInput)
    pub fn builder() -> crate::input::get_public_key_input::Builder {
        crate::input::get_public_key_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetPublicKey {
    type Output =
        std::result::Result<crate::output::GetPublicKeyOutput, crate::error::GetPublicKeyError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_public_key_error(response)
        } else {
            crate::operation_deser::parse_get_public_key_response(response)
        }
    }
}

/// <p>Gets a public key configuration.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetPublicKeyConfig {
    _private: (),
}
impl GetPublicKeyConfig {
    /// Creates a new builder-style object to manufacture [`GetPublicKeyConfigInput`](crate::input::GetPublicKeyConfigInput)
    pub fn builder() -> crate::input::get_public_key_config_input::Builder {
        crate::input::get_public_key_config_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetPublicKeyConfig {
    type Output = std::result::Result<
        crate::output::GetPublicKeyConfigOutput,
        crate::error::GetPublicKeyConfigError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_public_key_config_error(response)
        } else {
            crate::operation_deser::parse_get_public_key_config_response(response)
        }
    }
}

/// <p>Gets a real-time log configuration.</p>
/// <p>To get a real-time log configuration, you can provide the configuration’s name or its Amazon
/// Resource Name (ARN). You must provide at least one. If you provide both, CloudFront uses the
/// name to identify the real-time log configuration to get.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetRealtimeLogConfig {
    _private: (),
}
impl GetRealtimeLogConfig {
    /// Creates a new builder-style object to manufacture [`GetRealtimeLogConfigInput`](crate::input::GetRealtimeLogConfigInput)
    pub fn builder() -> crate::input::get_realtime_log_config_input::Builder {
        crate::input::get_realtime_log_config_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetRealtimeLogConfig {
    type Output = std::result::Result<
        crate::output::GetRealtimeLogConfigOutput,
        crate::error::GetRealtimeLogConfigError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_realtime_log_config_error(response)
        } else {
            crate::operation_deser::parse_get_realtime_log_config_response(response)
        }
    }
}

/// <p>Gets information about a specified RTMP distribution, including the distribution configuration.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetStreamingDistribution {
    _private: (),
}
impl GetStreamingDistribution {
    /// Creates a new builder-style object to manufacture [`GetStreamingDistributionInput`](crate::input::GetStreamingDistributionInput)
    pub fn builder() -> crate::input::get_streaming_distribution_input::Builder {
        crate::input::get_streaming_distribution_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetStreamingDistribution {
    type Output = std::result::Result<
        crate::output::GetStreamingDistributionOutput,
        crate::error::GetStreamingDistributionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_streaming_distribution_error(response)
        } else {
            crate::operation_deser::parse_get_streaming_distribution_response(response)
        }
    }
}

/// <p>Get the configuration information about a streaming distribution. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetStreamingDistributionConfig {
    _private: (),
}
impl GetStreamingDistributionConfig {
    /// Creates a new builder-style object to manufacture [`GetStreamingDistributionConfigInput`](crate::input::GetStreamingDistributionConfigInput)
    pub fn builder() -> crate::input::get_streaming_distribution_config_input::Builder {
        crate::input::get_streaming_distribution_config_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetStreamingDistributionConfig {
    type Output = std::result::Result<
        crate::output::GetStreamingDistributionConfigOutput,
        crate::error::GetStreamingDistributionConfigError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_streaming_distribution_config_error(response)
        } else {
            crate::operation_deser::parse_get_streaming_distribution_config_response(response)
        }
    }
}

/// <p>Gets a list of cache policies.</p>
/// <p>You can optionally apply a filter to return only the managed policies created by AWS, or
/// only the custom policies created in your AWS account.</p>
/// <p>You can optionally specify the maximum number of items to receive in the response. If
/// the total number of items in the list exceeds the maximum that you specify, or the
/// default maximum, the response is paginated. To get the next page of items, send a
/// subsequent request that specifies the <code>NextMarker</code> value from the current
/// response as the <code>Marker</code> value in the subsequent request.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListCachePolicies {
    _private: (),
}
impl ListCachePolicies {
    /// Creates a new builder-style object to manufacture [`ListCachePoliciesInput`](crate::input::ListCachePoliciesInput)
    pub fn builder() -> crate::input::list_cache_policies_input::Builder {
        crate::input::list_cache_policies_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListCachePolicies {
    type Output = std::result::Result<
        crate::output::ListCachePoliciesOutput,
        crate::error::ListCachePoliciesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_cache_policies_error(response)
        } else {
            crate::operation_deser::parse_list_cache_policies_response(response)
        }
    }
}

/// <p>Lists origin access identities.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListCloudFrontOriginAccessIdentities {
    _private: (),
}
impl ListCloudFrontOriginAccessIdentities {
    /// Creates a new builder-style object to manufacture [`ListCloudFrontOriginAccessIdentitiesInput`](crate::input::ListCloudFrontOriginAccessIdentitiesInput)
    pub fn builder() -> crate::input::list_cloud_front_origin_access_identities_input::Builder {
        crate::input::list_cloud_front_origin_access_identities_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListCloudFrontOriginAccessIdentities {
    type Output = std::result::Result<
        crate::output::ListCloudFrontOriginAccessIdentitiesOutput,
        crate::error::ListCloudFrontOriginAccessIdentitiesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_cloud_front_origin_access_identities_error(response)
        } else {
            crate::operation_deser::parse_list_cloud_front_origin_access_identities_response(
                response,
            )
        }
    }
}

/// <p>List CloudFront distributions.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListDistributions {
    _private: (),
}
impl ListDistributions {
    /// Creates a new builder-style object to manufacture [`ListDistributionsInput`](crate::input::ListDistributionsInput)
    pub fn builder() -> crate::input::list_distributions_input::Builder {
        crate::input::list_distributions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListDistributions {
    type Output = std::result::Result<
        crate::output::ListDistributionsOutput,
        crate::error::ListDistributionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_distributions_error(response)
        } else {
            crate::operation_deser::parse_list_distributions_response(response)
        }
    }
}

/// <p>Gets a list of distribution IDs for distributions that have a cache behavior that’s
/// associated with the specified cache policy.</p>
/// <p>You can optionally specify the maximum number of items to receive in the response. If
/// the total number of items in the list exceeds the maximum that you specify, or the
/// default maximum, the response is paginated. To get the next page of items, send a
/// subsequent request that specifies the <code>NextMarker</code> value from the current
/// response as the <code>Marker</code> value in the subsequent request.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListDistributionsByCachePolicyId {
    _private: (),
}
impl ListDistributionsByCachePolicyId {
    /// Creates a new builder-style object to manufacture [`ListDistributionsByCachePolicyIdInput`](crate::input::ListDistributionsByCachePolicyIdInput)
    pub fn builder() -> crate::input::list_distributions_by_cache_policy_id_input::Builder {
        crate::input::list_distributions_by_cache_policy_id_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListDistributionsByCachePolicyId {
    type Output = std::result::Result<
        crate::output::ListDistributionsByCachePolicyIdOutput,
        crate::error::ListDistributionsByCachePolicyIdError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_distributions_by_cache_policy_id_error(response)
        } else {
            crate::operation_deser::parse_list_distributions_by_cache_policy_id_response(response)
        }
    }
}

/// <p>Gets a list of distribution IDs for distributions that have a cache behavior that references
/// the specified key group.</p>
/// <p>You can optionally specify the maximum number of items to receive in the response. If
/// the total number of items in the list exceeds the maximum that you specify, or the
/// default maximum, the response is paginated. To get the next page of items, send a
/// subsequent request that specifies the <code>NextMarker</code> value from the current
/// response as the <code>Marker</code> value in the subsequent request.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListDistributionsByKeyGroup {
    _private: (),
}
impl ListDistributionsByKeyGroup {
    /// Creates a new builder-style object to manufacture [`ListDistributionsByKeyGroupInput`](crate::input::ListDistributionsByKeyGroupInput)
    pub fn builder() -> crate::input::list_distributions_by_key_group_input::Builder {
        crate::input::list_distributions_by_key_group_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListDistributionsByKeyGroup {
    type Output = std::result::Result<
        crate::output::ListDistributionsByKeyGroupOutput,
        crate::error::ListDistributionsByKeyGroupError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_distributions_by_key_group_error(response)
        } else {
            crate::operation_deser::parse_list_distributions_by_key_group_response(response)
        }
    }
}

/// <p>Gets a list of distribution IDs for distributions that have a cache behavior that’s
/// associated with the specified origin request policy.</p>
/// <p>You can optionally specify the maximum number of items to receive in the response. If
/// the total number of items in the list exceeds the maximum that you specify, or the
/// default maximum, the response is paginated. To get the next page of items, send a
/// subsequent request that specifies the <code>NextMarker</code> value from the current
/// response as the <code>Marker</code> value in the subsequent request.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListDistributionsByOriginRequestPolicyId {
    _private: (),
}
impl ListDistributionsByOriginRequestPolicyId {
    /// Creates a new builder-style object to manufacture [`ListDistributionsByOriginRequestPolicyIdInput`](crate::input::ListDistributionsByOriginRequestPolicyIdInput)
    pub fn builder() -> crate::input::list_distributions_by_origin_request_policy_id_input::Builder
    {
        crate::input::list_distributions_by_origin_request_policy_id_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListDistributionsByOriginRequestPolicyId {
    type Output = std::result::Result<
        crate::output::ListDistributionsByOriginRequestPolicyIdOutput,
        crate::error::ListDistributionsByOriginRequestPolicyIdError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_distributions_by_origin_request_policy_id_error(
                response,
            )
        } else {
            crate::operation_deser::parse_list_distributions_by_origin_request_policy_id_response(
                response,
            )
        }
    }
}

/// <p>Gets a list of distributions that have a cache behavior that’s associated with the specified
/// real-time log configuration.</p>
/// <p>You can specify the real-time log configuration by its name or its Amazon Resource Name
/// (ARN). You must provide at least one. If you provide both, CloudFront uses the name to
/// identify the real-time log configuration to list distributions for.</p>
/// <p>You can optionally specify the maximum number of items to receive in the response. If
/// the total number of items in the list exceeds the maximum that you specify, or the
/// default maximum, the response is paginated. To get the next page of items, send a
/// subsequent request that specifies the <code>NextMarker</code> value from the current
/// response as the <code>Marker</code> value in the subsequent request. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListDistributionsByRealtimeLogConfig {
    _private: (),
}
impl ListDistributionsByRealtimeLogConfig {
    /// Creates a new builder-style object to manufacture [`ListDistributionsByRealtimeLogConfigInput`](crate::input::ListDistributionsByRealtimeLogConfigInput)
    pub fn builder() -> crate::input::list_distributions_by_realtime_log_config_input::Builder {
        crate::input::list_distributions_by_realtime_log_config_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListDistributionsByRealtimeLogConfig {
    type Output = std::result::Result<
        crate::output::ListDistributionsByRealtimeLogConfigOutput,
        crate::error::ListDistributionsByRealtimeLogConfigError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_distributions_by_realtime_log_config_error(response)
        } else {
            crate::operation_deser::parse_list_distributions_by_realtime_log_config_response(
                response,
            )
        }
    }
}

/// <p>List the distributions that are associated with a specified AWS WAF web ACL. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListDistributionsByWebACLId {
    _private: (),
}
impl ListDistributionsByWebACLId {
    /// Creates a new builder-style object to manufacture [`ListDistributionsByWebAclIdInput`](crate::input::ListDistributionsByWebAclIdInput)
    pub fn builder() -> crate::input::list_distributions_by_web_acl_id_input::Builder {
        crate::input::list_distributions_by_web_acl_id_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListDistributionsByWebACLId {
    type Output = std::result::Result<
        crate::output::ListDistributionsByWebAclIdOutput,
        crate::error::ListDistributionsByWebACLIdError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_distributions_by_web_acl_id_error(response)
        } else {
            crate::operation_deser::parse_list_distributions_by_web_acl_id_response(response)
        }
    }
}

/// <p>List all field-level encryption configurations that have been created in CloudFront for this account.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListFieldLevelEncryptionConfigs {
    _private: (),
}
impl ListFieldLevelEncryptionConfigs {
    /// Creates a new builder-style object to manufacture [`ListFieldLevelEncryptionConfigsInput`](crate::input::ListFieldLevelEncryptionConfigsInput)
    pub fn builder() -> crate::input::list_field_level_encryption_configs_input::Builder {
        crate::input::list_field_level_encryption_configs_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListFieldLevelEncryptionConfigs {
    type Output = std::result::Result<
        crate::output::ListFieldLevelEncryptionConfigsOutput,
        crate::error::ListFieldLevelEncryptionConfigsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_field_level_encryption_configs_error(response)
        } else {
            crate::operation_deser::parse_list_field_level_encryption_configs_response(response)
        }
    }
}

/// <p>Request a list of field-level encryption profiles that have been created in CloudFront for this account.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListFieldLevelEncryptionProfiles {
    _private: (),
}
impl ListFieldLevelEncryptionProfiles {
    /// Creates a new builder-style object to manufacture [`ListFieldLevelEncryptionProfilesInput`](crate::input::ListFieldLevelEncryptionProfilesInput)
    pub fn builder() -> crate::input::list_field_level_encryption_profiles_input::Builder {
        crate::input::list_field_level_encryption_profiles_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListFieldLevelEncryptionProfiles {
    type Output = std::result::Result<
        crate::output::ListFieldLevelEncryptionProfilesOutput,
        crate::error::ListFieldLevelEncryptionProfilesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_field_level_encryption_profiles_error(response)
        } else {
            crate::operation_deser::parse_list_field_level_encryption_profiles_response(response)
        }
    }
}

/// <p>Gets a list of all CloudFront functions in your AWS account.</p>
/// <p>You can optionally apply a filter to return only the functions that are in the
/// specified stage, either <code>DEVELOPMENT</code> or <code>LIVE</code>.</p>
/// <p>You can optionally specify the maximum number of items to receive in the response. If
/// the total number of items in the list exceeds the maximum that you specify, or the
/// default maximum, the response is paginated. To get the next page of items, send a
/// subsequent request that specifies the <code>NextMarker</code> value from the current
/// response as the <code>Marker</code> value in the subsequent request.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListFunctions {
    _private: (),
}
impl ListFunctions {
    /// Creates a new builder-style object to manufacture [`ListFunctionsInput`](crate::input::ListFunctionsInput)
    pub fn builder() -> crate::input::list_functions_input::Builder {
        crate::input::list_functions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListFunctions {
    type Output =
        std::result::Result<crate::output::ListFunctionsOutput, crate::error::ListFunctionsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_functions_error(response)
        } else {
            crate::operation_deser::parse_list_functions_response(response)
        }
    }
}

/// <p>Lists invalidation batches. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListInvalidations {
    _private: (),
}
impl ListInvalidations {
    /// Creates a new builder-style object to manufacture [`ListInvalidationsInput`](crate::input::ListInvalidationsInput)
    pub fn builder() -> crate::input::list_invalidations_input::Builder {
        crate::input::list_invalidations_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListInvalidations {
    type Output = std::result::Result<
        crate::output::ListInvalidationsOutput,
        crate::error::ListInvalidationsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_invalidations_error(response)
        } else {
            crate::operation_deser::parse_list_invalidations_response(response)
        }
    }
}

/// <p>Gets a list of key groups.</p>
/// <p>You can optionally specify the maximum number of items to receive in the response. If
/// the total number of items in the list exceeds the maximum that you specify, or the
/// default maximum, the response is paginated. To get the next page of items, send a
/// subsequent request that specifies the <code>NextMarker</code> value from the current
/// response as the <code>Marker</code> value in the subsequent request.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListKeyGroups {
    _private: (),
}
impl ListKeyGroups {
    /// Creates a new builder-style object to manufacture [`ListKeyGroupsInput`](crate::input::ListKeyGroupsInput)
    pub fn builder() -> crate::input::list_key_groups_input::Builder {
        crate::input::list_key_groups_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListKeyGroups {
    type Output =
        std::result::Result<crate::output::ListKeyGroupsOutput, crate::error::ListKeyGroupsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_key_groups_error(response)
        } else {
            crate::operation_deser::parse_list_key_groups_response(response)
        }
    }
}

/// <p>Gets a list of origin request policies.</p>
/// <p>You can optionally apply a filter to return only the managed policies created by AWS, or
/// only the custom policies created in your AWS account.</p>
/// <p>You can optionally specify the maximum number of items to receive in the response. If
/// the total number of items in the list exceeds the maximum that you specify, or the
/// default maximum, the response is paginated. To get the next page of items, send a
/// subsequent request that specifies the <code>NextMarker</code> value from the current
/// response as the <code>Marker</code> value in the subsequent request.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListOriginRequestPolicies {
    _private: (),
}
impl ListOriginRequestPolicies {
    /// Creates a new builder-style object to manufacture [`ListOriginRequestPoliciesInput`](crate::input::ListOriginRequestPoliciesInput)
    pub fn builder() -> crate::input::list_origin_request_policies_input::Builder {
        crate::input::list_origin_request_policies_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListOriginRequestPolicies {
    type Output = std::result::Result<
        crate::output::ListOriginRequestPoliciesOutput,
        crate::error::ListOriginRequestPoliciesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_origin_request_policies_error(response)
        } else {
            crate::operation_deser::parse_list_origin_request_policies_response(response)
        }
    }
}

/// <p>List all public keys that have been added to CloudFront for this account.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListPublicKeys {
    _private: (),
}
impl ListPublicKeys {
    /// Creates a new builder-style object to manufacture [`ListPublicKeysInput`](crate::input::ListPublicKeysInput)
    pub fn builder() -> crate::input::list_public_keys_input::Builder {
        crate::input::list_public_keys_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListPublicKeys {
    type Output =
        std::result::Result<crate::output::ListPublicKeysOutput, crate::error::ListPublicKeysError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_public_keys_error(response)
        } else {
            crate::operation_deser::parse_list_public_keys_response(response)
        }
    }
}

/// <p>Gets a list of real-time log configurations.</p>
/// <p>You can optionally specify the maximum number of items to receive in the response. If
/// the total number of items in the list exceeds the maximum that you specify, or the
/// default maximum, the response is paginated. To get the next page of items, send a
/// subsequent request that specifies the <code>NextMarker</code> value from the current
/// response as the <code>Marker</code> value in the subsequent request. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListRealtimeLogConfigs {
    _private: (),
}
impl ListRealtimeLogConfigs {
    /// Creates a new builder-style object to manufacture [`ListRealtimeLogConfigsInput`](crate::input::ListRealtimeLogConfigsInput)
    pub fn builder() -> crate::input::list_realtime_log_configs_input::Builder {
        crate::input::list_realtime_log_configs_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListRealtimeLogConfigs {
    type Output = std::result::Result<
        crate::output::ListRealtimeLogConfigsOutput,
        crate::error::ListRealtimeLogConfigsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_realtime_log_configs_error(response)
        } else {
            crate::operation_deser::parse_list_realtime_log_configs_response(response)
        }
    }
}

/// <p>List streaming distributions. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListStreamingDistributions {
    _private: (),
}
impl ListStreamingDistributions {
    /// Creates a new builder-style object to manufacture [`ListStreamingDistributionsInput`](crate::input::ListStreamingDistributionsInput)
    pub fn builder() -> crate::input::list_streaming_distributions_input::Builder {
        crate::input::list_streaming_distributions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListStreamingDistributions {
    type Output = std::result::Result<
        crate::output::ListStreamingDistributionsOutput,
        crate::error::ListStreamingDistributionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_streaming_distributions_error(response)
        } else {
            crate::operation_deser::parse_list_streaming_distributions_response(response)
        }
    }
}

/// <p>List tags for a CloudFront resource.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTagsForResource {
    _private: (),
}
impl ListTagsForResource {
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
    pub fn builder() -> crate::input::list_tags_for_resource_input::Builder {
        crate::input::list_tags_for_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTagsForResource {
    type Output = std::result::Result<
        crate::output::ListTagsForResourceOutput,
        crate::error::ListTagsForResourceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_tags_for_resource_error(response)
        } else {
            crate::operation_deser::parse_list_tags_for_resource_response(response)
        }
    }
}

/// <p>Publishes a CloudFront function by copying the function code from the <code>DEVELOPMENT</code>
/// stage to <code>LIVE</code>. This automatically updates all cache behaviors that are
/// using this function to use the newly published copy in the <code>LIVE</code>
/// stage.</p>
/// <p>When a function is published to the <code>LIVE</code> stage, you can attach the function to
/// a distribution’s cache behavior, using the function’s Amazon Resource Name (ARN).</p>
/// <p>To publish a function, you must provide the function’s name and version (<code>ETag</code>
/// value). To get these values, you can use <code>ListFunctions</code> and
/// <code>DescribeFunction</code>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PublishFunction {
    _private: (),
}
impl PublishFunction {
    /// Creates a new builder-style object to manufacture [`PublishFunctionInput`](crate::input::PublishFunctionInput)
    pub fn builder() -> crate::input::publish_function_input::Builder {
        crate::input::publish_function_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PublishFunction {
    type Output = std::result::Result<
        crate::output::PublishFunctionOutput,
        crate::error::PublishFunctionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_publish_function_error(response)
        } else {
            crate::operation_deser::parse_publish_function_response(response)
        }
    }
}

/// <p>Add tags to a CloudFront resource.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct TagResource {
    _private: (),
}
impl TagResource {
    /// Creates a new builder-style object to manufacture [`TagResourceInput`](crate::input::TagResourceInput)
    pub fn builder() -> crate::input::tag_resource_input::Builder {
        crate::input::tag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for TagResource {
    type Output =
        std::result::Result<crate::output::TagResourceOutput, crate::error::TagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 204 {
            crate::operation_deser::parse_tag_resource_error(response)
        } else {
            crate::operation_deser::parse_tag_resource_response(response)
        }
    }
}

/// <p>Tests a CloudFront function.</p>
/// <p>To test a function, you provide an <i>event object</i> that represents an HTTP
/// request or response that your CloudFront distribution could receive in production. CloudFront runs
/// the function, passing it the event object that you provided, and returns the function’s
/// result (the modified event object) in the response. The response also contains function
/// logs and error messages, if any exist. For more information about testing functions, see
/// <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/managing-functions.html#test-function">Testing functions</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
/// <p>To test a function, you provide the function’s name and version (<code>ETag</code> value)
/// along with the event object. To get the function’s name and version, you can use
/// <code>ListFunctions</code> and <code>DescribeFunction</code>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct TestFunction {
    _private: (),
}
impl TestFunction {
    /// Creates a new builder-style object to manufacture [`TestFunctionInput`](crate::input::TestFunctionInput)
    pub fn builder() -> crate::input::test_function_input::Builder {
        crate::input::test_function_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for TestFunction {
    type Output =
        std::result::Result<crate::output::TestFunctionOutput, crate::error::TestFunctionError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_test_function_error(response)
        } else {
            crate::operation_deser::parse_test_function_response(response)
        }
    }
}

/// <p>Remove tags from a CloudFront resource.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UntagResource {
    _private: (),
}
impl UntagResource {
    /// Creates a new builder-style object to manufacture [`UntagResourceInput`](crate::input::UntagResourceInput)
    pub fn builder() -> crate::input::untag_resource_input::Builder {
        crate::input::untag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UntagResource {
    type Output =
        std::result::Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 204 {
            crate::operation_deser::parse_untag_resource_error(response)
        } else {
            crate::operation_deser::parse_untag_resource_response(response)
        }
    }
}

/// <p>Updates a cache policy configuration.</p>
/// <p>When you update a cache policy configuration, all the fields are updated with the
/// values provided in the request. You cannot update some fields independent of others. To
/// update a cache policy configuration:</p>
/// <ol>
/// <li>
/// <p>Use <code>GetCachePolicyConfig</code> to get the current configuration.</p>
/// </li>
/// <li>
/// <p>Locally modify the fields in the cache policy configuration that you want to
/// update.</p>
/// </li>
/// <li>
/// <p>Call <code>UpdateCachePolicy</code> by providing the entire cache policy
/// configuration, including the fields that you modified and those that you
/// didn’t.</p>
/// </li>
/// </ol>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateCachePolicy {
    _private: (),
}
impl UpdateCachePolicy {
    /// Creates a new builder-style object to manufacture [`UpdateCachePolicyInput`](crate::input::UpdateCachePolicyInput)
    pub fn builder() -> crate::input::update_cache_policy_input::Builder {
        crate::input::update_cache_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateCachePolicy {
    type Output = std::result::Result<
        crate::output::UpdateCachePolicyOutput,
        crate::error::UpdateCachePolicyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_cache_policy_error(response)
        } else {
            crate::operation_deser::parse_update_cache_policy_response(response)
        }
    }
}

/// <p>Update an origin access identity. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateCloudFrontOriginAccessIdentity {
    _private: (),
}
impl UpdateCloudFrontOriginAccessIdentity {
    /// Creates a new builder-style object to manufacture [`UpdateCloudFrontOriginAccessIdentityInput`](crate::input::UpdateCloudFrontOriginAccessIdentityInput)
    pub fn builder() -> crate::input::update_cloud_front_origin_access_identity_input::Builder {
        crate::input::update_cloud_front_origin_access_identity_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateCloudFrontOriginAccessIdentity {
    type Output = std::result::Result<
        crate::output::UpdateCloudFrontOriginAccessIdentityOutput,
        crate::error::UpdateCloudFrontOriginAccessIdentityError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_cloud_front_origin_access_identity_error(response)
        } else {
            crate::operation_deser::parse_update_cloud_front_origin_access_identity_response(
                response,
            )
        }
    }
}

/// <p>Updates the configuration for a web distribution. </p>
/// <important>
/// <p>When you update a distribution, there are more required fields than when you create a distribution.
/// When you update your distribution by using this API action, follow the steps here to get the current configuration
/// and then make your updates, to make sure that you include all of the required fields. To view a summary,
/// see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-overview-required-fields.html">Required
/// Fields for Create Distribution and Update Distribution</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
/// </important>
/// <p>The update process includes getting the current distribution configuration, updating the XML document that is
/// returned to make your changes, and then submitting an <code>UpdateDistribution</code> request to make the updates.</p>
/// <p>For information about updating a distribution using the CloudFront console instead, see  
/// <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-creating-console.html">Creating a
/// Distribution</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
/// <p>
/// <b>To update a web distribution using the CloudFront API</b>
/// </p>
/// <ol>
/// <li>
/// <p>Submit a
/// <a href="https://docs.aws.amazon.com/cloudfront/latest/APIReference/API_GetDistributionConfig.html">GetDistributionConfig</a>
/// request to get the current configuration and an <code>Etag</code> header  
/// for the distribution.</p>
/// <note>
/// <p>If you update the distribution again, you must get a new <code>Etag</code> header.</p>
/// </note>
/// </li>
/// <li>
/// <p>Update the XML document that was returned in the response to your <code>GetDistributionConfig</code> request to include
/// your changes. </p>
/// <important>
/// <p>When you edit the XML file, be aware of the following:</p>
/// <ul>
/// <li>
/// <p>You must strip out the ETag parameter that is returned.</p>
/// </li>
/// <li>
/// <p>Additional fields are required when you update a distribution. There may be fields included in the
/// XML file for features that you haven't configured for your distribution. This is expected and required to
/// successfully update the distribution.</p>
/// </li>
/// <li>
/// <p>You can't change the value of <code>CallerReference</code>. If you try to change this value, CloudFront returns an  
/// <code>IllegalUpdate</code> error. </p>
/// </li>
/// <li>
/// <p>The new configuration replaces the existing configuration; the values that you specify in an
/// <code>UpdateDistribution</code> request are not merged into your existing configuration. When you add, delete, or
/// replace values in an element that allows multiple values (for example, <code>CNAME</code>), you must specify all of the
/// values that you want to appear in the updated distribution. In addition,  
/// you must update the corresponding <code>Quantity</code> element.</p>
/// </li>
/// </ul>
/// </important>
/// </li>
/// <li>
/// <p>Submit an <code>UpdateDistribution</code> request to update the configuration for your distribution:</p>
/// <ul>
/// <li>
/// <p>In the request body, include the XML document that you updated in Step 2. The request body must include an  
/// XML document with a <code>DistributionConfig</code> element.</p>
/// </li>
/// <li>
/// <p>Set the value of the HTTP <code>If-Match</code> header to the value of the <code>ETag</code> header that CloudFront returned  
/// when you submitted the <code>GetDistributionConfig</code> request in Step 1.</p>
/// </li>
/// </ul>
/// </li>
/// <li>
/// <p>Review the response to the <code>UpdateDistribution</code> request to confirm that the configuration was  
/// successfully updated.</p>
/// </li>
/// <li>
/// <p>Optional: Submit a
/// <a href="https://docs.aws.amazon.com/cloudfront/latest/APIReference/API_GetDistribution.html">GetDistribution</a>
/// request to confirm that your changes have propagated.  
/// When propagation is complete, the value of <code>Status</code> is <code>Deployed</code>.</p>
/// </li>
/// </ol>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateDistribution {
    _private: (),
}
impl UpdateDistribution {
    /// Creates a new builder-style object to manufacture [`UpdateDistributionInput`](crate::input::UpdateDistributionInput)
    pub fn builder() -> crate::input::update_distribution_input::Builder {
        crate::input::update_distribution_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateDistribution {
    type Output = std::result::Result<
        crate::output::UpdateDistributionOutput,
        crate::error::UpdateDistributionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_distribution_error(response)
        } else {
            crate::operation_deser::parse_update_distribution_response(response)
        }
    }
}

/// <p>Update a field-level encryption configuration. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateFieldLevelEncryptionConfig {
    _private: (),
}
impl UpdateFieldLevelEncryptionConfig {
    /// Creates a new builder-style object to manufacture [`UpdateFieldLevelEncryptionConfigInput`](crate::input::UpdateFieldLevelEncryptionConfigInput)
    pub fn builder() -> crate::input::update_field_level_encryption_config_input::Builder {
        crate::input::update_field_level_encryption_config_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateFieldLevelEncryptionConfig {
    type Output = std::result::Result<
        crate::output::UpdateFieldLevelEncryptionConfigOutput,
        crate::error::UpdateFieldLevelEncryptionConfigError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_field_level_encryption_config_error(response)
        } else {
            crate::operation_deser::parse_update_field_level_encryption_config_response(response)
        }
    }
}

/// <p>Update a field-level encryption profile. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateFieldLevelEncryptionProfile {
    _private: (),
}
impl UpdateFieldLevelEncryptionProfile {
    /// Creates a new builder-style object to manufacture [`UpdateFieldLevelEncryptionProfileInput`](crate::input::UpdateFieldLevelEncryptionProfileInput)
    pub fn builder() -> crate::input::update_field_level_encryption_profile_input::Builder {
        crate::input::update_field_level_encryption_profile_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateFieldLevelEncryptionProfile {
    type Output = std::result::Result<
        crate::output::UpdateFieldLevelEncryptionProfileOutput,
        crate::error::UpdateFieldLevelEncryptionProfileError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_field_level_encryption_profile_error(response)
        } else {
            crate::operation_deser::parse_update_field_level_encryption_profile_response(response)
        }
    }
}

/// <p>Updates a CloudFront function.</p>
/// <p>You can update a function’s code or the comment that describes the function. You
/// cannot update a function’s name.</p>
/// <p>To update a function, you provide the function’s name and version (<code>ETag</code> value)
/// along with the updated function code. To get the name and version, you can use
/// <code>ListFunctions</code> and <code>DescribeFunction</code>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateFunction {
    _private: (),
}
impl UpdateFunction {
    /// Creates a new builder-style object to manufacture [`UpdateFunctionInput`](crate::input::UpdateFunctionInput)
    pub fn builder() -> crate::input::update_function_input::Builder {
        crate::input::update_function_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateFunction {
    type Output =
        std::result::Result<crate::output::UpdateFunctionOutput, crate::error::UpdateFunctionError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_function_error(response)
        } else {
            crate::operation_deser::parse_update_function_response(response)
        }
    }
}

/// <p>Updates a key group.</p>
/// <p>When you update a key group, all the fields are updated with the values provided in
/// the request. You cannot update some fields independent of others. To update a key
/// group:</p>
/// <ol>
/// <li>
/// <p>Get the current key group with <code>GetKeyGroup</code> or
/// <code>GetKeyGroupConfig</code>.</p>
/// </li>
/// <li>
/// <p>Locally modify the fields in the key group that you want to update. For
/// example, add or remove public key IDs.</p>
/// </li>
/// <li>
/// <p>Call <code>UpdateKeyGroup</code> with the entire key group object, including
/// the fields that you modified and those that you didn’t.</p>
/// </li>
/// </ol>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateKeyGroup {
    _private: (),
}
impl UpdateKeyGroup {
    /// Creates a new builder-style object to manufacture [`UpdateKeyGroupInput`](crate::input::UpdateKeyGroupInput)
    pub fn builder() -> crate::input::update_key_group_input::Builder {
        crate::input::update_key_group_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateKeyGroup {
    type Output =
        std::result::Result<crate::output::UpdateKeyGroupOutput, crate::error::UpdateKeyGroupError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_key_group_error(response)
        } else {
            crate::operation_deser::parse_update_key_group_response(response)
        }
    }
}

/// <p>Updates an origin request policy configuration.</p>
/// <p>When you update an origin request policy configuration, all the fields are updated
/// with the values provided in the request. You cannot update some fields independent of
/// others. To update an origin request policy configuration:</p>
/// <ol>
/// <li>
/// <p>Use <code>GetOriginRequestPolicyConfig</code> to get the current configuration.</p>
/// </li>
/// <li>
/// <p>Locally modify the fields in the origin request policy configuration that you
/// want to update.</p>
/// </li>
/// <li>
/// <p>Call <code>UpdateOriginRequestPolicy</code> by providing the entire origin
/// request policy configuration, including the fields that you modified and those
/// that you didn’t.</p>
/// </li>
/// </ol>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateOriginRequestPolicy {
    _private: (),
}
impl UpdateOriginRequestPolicy {
    /// Creates a new builder-style object to manufacture [`UpdateOriginRequestPolicyInput`](crate::input::UpdateOriginRequestPolicyInput)
    pub fn builder() -> crate::input::update_origin_request_policy_input::Builder {
        crate::input::update_origin_request_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateOriginRequestPolicy {
    type Output = std::result::Result<
        crate::output::UpdateOriginRequestPolicyOutput,
        crate::error::UpdateOriginRequestPolicyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_origin_request_policy_error(response)
        } else {
            crate::operation_deser::parse_update_origin_request_policy_response(response)
        }
    }
}

/// <p>Update public key information. Note that the only value you can change is the comment.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdatePublicKey {
    _private: (),
}
impl UpdatePublicKey {
    /// Creates a new builder-style object to manufacture [`UpdatePublicKeyInput`](crate::input::UpdatePublicKeyInput)
    pub fn builder() -> crate::input::update_public_key_input::Builder {
        crate::input::update_public_key_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdatePublicKey {
    type Output = std::result::Result<
        crate::output::UpdatePublicKeyOutput,
        crate::error::UpdatePublicKeyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_public_key_error(response)
        } else {
            crate::operation_deser::parse_update_public_key_response(response)
        }
    }
}

/// <p>Updates a real-time log configuration.</p>
/// <p>When you update a real-time log configuration, all the parameters are updated with the
/// values provided in the request. You cannot update some parameters independent of others.
/// To update a real-time log configuration:</p>
/// <ol>
/// <li>
/// <p>Call <code>GetRealtimeLogConfig</code> to get the current real-time log
/// configuration.</p>
/// </li>
/// <li>
/// <p>Locally modify the parameters in the real-time log configuration that you want
/// to update.</p>
/// </li>
/// <li>
/// <p>Call this API (<code>UpdateRealtimeLogConfig</code>) by providing the entire
/// real-time log configuration, including the parameters that you modified and
/// those that you didn’t.</p>
/// </li>
/// </ol>
/// <p>You cannot update a real-time log configuration’s <code>Name</code> or
/// <code>ARN</code>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateRealtimeLogConfig {
    _private: (),
}
impl UpdateRealtimeLogConfig {
    /// Creates a new builder-style object to manufacture [`UpdateRealtimeLogConfigInput`](crate::input::UpdateRealtimeLogConfigInput)
    pub fn builder() -> crate::input::update_realtime_log_config_input::Builder {
        crate::input::update_realtime_log_config_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateRealtimeLogConfig {
    type Output = std::result::Result<
        crate::output::UpdateRealtimeLogConfigOutput,
        crate::error::UpdateRealtimeLogConfigError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_realtime_log_config_error(response)
        } else {
            crate::operation_deser::parse_update_realtime_log_config_response(response)
        }
    }
}

/// <p>Update a streaming distribution. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateStreamingDistribution {
    _private: (),
}
impl UpdateStreamingDistribution {
    /// Creates a new builder-style object to manufacture [`UpdateStreamingDistributionInput`](crate::input::UpdateStreamingDistributionInput)
    pub fn builder() -> crate::input::update_streaming_distribution_input::Builder {
        crate::input::update_streaming_distribution_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateStreamingDistribution {
    type Output = std::result::Result<
        crate::output::UpdateStreamingDistributionOutput,
        crate::error::UpdateStreamingDistributionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_streaming_distribution_error(response)
        } else {
            crate::operation_deser::parse_update_streaming_distribution_response(response)
        }
    }
}
